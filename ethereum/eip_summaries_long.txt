=== EIP-7612 ===
TITLE: Verkle state transition via an overlay tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-01-25
REQUIRES: 4, 7, 6, 2, ,,  , 6, 8, 0, 0, ,,  , 7, 5, 4, 5

SUMMARY:
This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT “laid over” the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants | Parameter | value | Description | | ----------- | ----- | -------------------------------------------- | | `FORK_TIME` | `TBD` | Time at which the overlay tree is activated. | ### Helper functions ```python3 # Determine if `block` is the fork activation block def is_fork_block(block): return block.parent.timestamp < FORK_TIME && block.timestamp >= FORK_TIME # Write an account in the verkle tree def verkle_set_account(tree: VerkleTree,

MOTIVATION:
The Ethereum state is growing, and VKTs offer a good mitigation strategy to stem this growth and enable weak statelessness. Owing to the difficulty of translating contracts with large storage while they are being accessed, proposals for migrating the current MPT state are complex and will require client teams to undergo a long process of refactoring their code to handle this conversion. The bigger the state, the longer any conversion process will take. This has an impact both while the conversion is happening, as well as when full-syncing the chain if the conversion is part of consensus. Fullsync

RATIONALE:
This approach doesn't convert the state, which is left to a subsequent EIP. This is meant as a stopgap in case we decide to push the conversion itself to a later time. It has the advantage of simplicity, which means that the Verge fork could happen at the same time as other, simpler EIPs. It also requires no change at the consensus layer.


=== EIP-3026 ===
TITLE: BW6-761 curve operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-05
REQUIRES: 2539

SUMMARY:
This precompile adds operations for the BW6-761 curve (from the EY/Inria **Optimized and secure pairing-friendly elliptic curves suitable for one layer proof composition** research paper) as a precompile in a set necessary to *efficiently* perform verification of one-layer composed zkSNARKs proofs. If `block.number >= X` we introduce *seven* separate precompiles to perform the following operations (addresses to be determined): - BW6_G1_ADD - to perform point addition on a curve defined over a prime field - BW6_G1_MUL - to perform point multiplication on a curve defined over a prime field - BW6_G1_MULTIEXP - to perform multiexponentiation on a curve

SPECIFICATION:
Curve parameters: The BW6-761 `y^2=x^3-1` curve is fully defined by the following set of parameters: ``` Base field modulus = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008b A coefficient = 0x0 B coefficient = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008a Main subgroup order = 0x1ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001 Extension tower: Fp3 construction: (Fp3 = Fp[u]/u^3+4) Fp cubic non-residue = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d000000000087 Twist parameters: Twist type: M twist curve A coefficient c0 = 0x0 c1 = 0x0 twist curve B coefficient c0 = 0x4 c1 = 0x0 Generators: G1: X = 0x1075b020ea190c8b277ce98a477beaee6a0cfb7551b27f0ee05c54b85f56fc779017ffac15520ac11dbfcd294c2e746a17a54ce47729b905bd71fa0c9ea097103758f9a280ca27f6750dd0356133e82055928aca6af603f4088f3af66e5b43d Y = 0x58b84e0a6fc574e6fd637b45cc2a420f952589884c9ec61a7348d2a2e573a3265909f1af7e0dbac5b8fa1771b5b806cc685d31717a4c55be3fb90b6fc2cdd49f9df141b3053253b2b08119cad0fb93ad1cb2be0b20d2a1bafc8f2db4e95363 G2: X = 0x110133241d9b816c852a82e69d660f9d61053aac5a7115f4c06201013890f6d26b41c5dab3da268734ec3f1f09feb58c5bbcae9ac70e7c7963317a300e1b6bace6948cb3cd208d700e96efbc2ad54b06410cf4fe1bf995ba830c194cd025f1c Y = 0x17c3357761369f8179eb10e4b6d2dc26b7cf9acec2181c81a78e2753ffe3160a1d86c80b95a59c94c97eb733293fef64f293dbd2c712b88906c170ffa823003ea96fcd504affc758aa2d3a3c5a02a591ec0594f9eac689eb70a16728c73b61 Pairing parameters: e(P,Q)=(ML1(P,Q)*ML2(P,Q)^q)^FE |loop_count_1| (first miller loop ML1 count) = 0x8508c00000000002 |loop_count_2|

MOTIVATION:
This EIP is based on and tends to replace matter-labs' proposal for significant performance reasons. In most applications, BW6-761 is used as an outer curve to BLS12-377 considered in [EIP-2539](./eip-2539.md). The motivation of this precompile is to allow efficient one-layer composition of SNARK proofs. Currently this is done by Zexe using the BLS12-377/CP6-782 pair of curves. This precompile proposes a replacement of CP6-782 by BW6-761, which allows much faster operations. For example, it was shown that verifying a Groth16 proof with BW6-761 is 30 times faster than with CP6-782. ### Proposed addresses table | Precompile | Address |

RATIONALE:
Gas costs are based on [EIP-1962](./eip-1962.md) estimation strategy (but do not fully include yet parsing of ABI, decoding and encoding of the result as a byte array). ### Gas estimation strategy Gas cost is derived by taking the average timing of the same operations over different implementations and assuming a constant `30 MGas/second`. Since the execution time is machine-specific, this constant is determined based on execution times of *ECRECOVER* and *BNPAIR* precompiles on my machine and their proposed gas price (`43.5 MGas/s` for ECRECOVER and `16.5 MGas/s` for BNPAIR). Following are the proposed methods to time the precompile


=== EIP-7873 ===
TITLE: EOF - TXCREATE and InitcodeTransaction type
TYPE: Standards Track Core
STATUS: Review
CREATED: 2025-01-31
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 3, 8, 6, 0, ,,  , 7, 6, 2, 0

SUMMARY:
EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an empty `to` field), `CREATE` or `CREATE2` instructions. We introduce a new instruction: `TXCREATE`, as well as a new transaction type (`InitcodeTransaction`), to provide a way to create contracts using EOF containers in transaction data.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Parameters | Constant | Value | |-----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | `INITCODE_TX_TYPE` | `Bytes1(0x06)` | | `MAX_INITCODE_COUNT` | `256` | | `TX_CREATE_COST` | Defined as `32000` in the [Ethereum Execution Layer Specs](https://github.com/ethereum/execution-specs/blob/0f9e4345b60d36c23fffaa69f70cf9cdb975f4ba/src/ethereum/shanghai/fork_types.py#L42) | | `STACK_DEPTH_LIMIT` | Defined as `1024` in the [Ethereum Execution Layer Specs](https://github.com/ethereum/execution-specs/blob/0f9e4345b60d36c23fffaa69f70cf9cdb975f4ba/src/ethereum/shanghai/vm/interpreter.py#L60) | | `GAS_CODE_DEPOSIT` | Defined as `200` in the [Ethereum Execution Layer Specs](https://github.com/ethereum/execution-specs/blob/0f9e4345b60d36c23fffaa69f70cf9cdb975f4ba/src/ethereum/shanghai/vm/gas.py#L44) | | `TX_DATA_COST_PER_ZERO` | Defined as `4` in

MOTIVATION:
This EIP uses terminology from the [EIP-3540](./eip-3540.md) which introduces the EOF format. Creation transaction and creation instructions `CREATE` and `CREATE2` are means provided by legacy EVM to deploy new code, but per requirement of removing code observability, they are not allowed to deploy EOF code. To allow Externally Owned Accounts (EOAs) to deploy EOF contracts, there must be a way to create EOF contracts using bytecode delivered in transaction data. Additionally, the new instruction and transaction type introduced in this EIP enable contracts to create other contracts using initcode from the transaction data, which in legacy EVM is

RATIONALE:
### `TXCREATE` failure modes `TXCREATE` has two "light" failure modes in case the initcontainer is not present and in case the EOF validation is unsuccessful. An alternative design where both cases led to a "hard" failure (consuming the entire gas available) was considered. We decided to have the more granular and forgiving failure modes in order to align the gas costs incurred to the actual work the EVM performs. ### Allowing `TXCREATE` in legacy EVM EOF contract creation requires an exceptional possibility of calling an EOF opcode in legacy code - `TXCREATE`, because otherwise neither legacy contracts nor


=== EIP-7840 ===
TITLE: Add blob schedule to EL config files
TYPE: Informational 
STATUS: Final
CREATED: 2024-12-12
REQUIRES: 

SUMMARY:
Add a new object to client configuration files `blobSchedule` which lists the target blob count per block and max blob count per block for each fork.

SPECIFICATION:
Extend client configuration files with the object `blobSchedule`, which has the following shape: ```json "blobSchedule": { "cancun": { "target": 3, "max": 6, "baseFeeUpdateFraction": 3338477 }, "prague": { "target": 6, "max": 9, "baseFeeUpdateFraction": 5007716 } } ``` Clients must configure the target, max and baseFeeUpdateFraction per-fork. The behavior when the configuration is missing or incomplete for a fork is undefined. Clients are free to choose how to handle this situation.

MOTIVATION:
- ensure there is a way to dynamically adjust the target and max blob counts per block - ensure there is a way to dynamically adjust the blob base fee update fraction - avoid complex handshake over engine API

RATIONALE:
Although maintaining the target and max blob only in the consensus client is desirable, we acknowledge the reality that execution clients need these values for various activities. For example, the `eth_feeHistory` RPC method returns a field `blobGasUsedRatio` that does require the max, even though the core protocol doesn't specifically need such value. Passing this value over the engine API every block seem overkill so we believe a configuration value is a good middle ground. Additionally, the `baseFeeUpdateFraction` parameter was added to adjust the responsiveness of blob gas pricing per fork.


=== EIP-6189 ===
TITLE: Alias Contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2, 9, 2, 9, ,,  , 6, 1, 8, 8

SUMMARY:
This EIP allows contracts to be turned into "alias contracts" using a magic nonce. Alias contracts automatically forward calls to other contracts.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions A contract is an alias contract if its nonce is `2^64-1`, and its contract code is equal to `0x1`. ### Prerequisites [EIP-6188](./eip-6188.md) MUST be used to protect the magic nonce value of `2^64-1`. ### Opcode Changes #### `CALL`, `CALLCODE`, `DELEGATECALL`, `STATICCALL`, `PAY`, and EOA Transactions The "callee" refers to the account that is being called or being paid. If the nonce of the callee

MOTIVATION:
This EIP is not terribly useful on its own, as it adds additional computation and gas costs without any useful side effects. However, in conjunction with [EIP-6190](./eip-6190.md), it can be used to make SELFDESTRUCT compatible with Verkle trees.

RATIONALE:
The additional gas cost of `25` represents the cost of fetching the nonce and comparing it to the given value. `eth_getStorageAt` was modified to throw an error because of alias contracts' special behavior. The nonce of `2^64-1` was chosen since it is the nonce protected by [EIP-6188](./eip-6188.md). The contract code of `0x1` was chosen arbitrarily. A nonzero code was chosen just in case a non-alias contract with nonce `2^64-1` somehow had its code set to `0x0`, or an EOA had its nonce set to `2^64-1`.


=== EIP-3085 ===
TITLE: wallet_addEthereumChain RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-11-01
REQUIRES: 155

SUMMARY:
This EIP adds a wallet-namespaced RPC method: `wallet_addEtherereumChain`, providing a standard interface for adding chains to Ethereum wallets.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal defines a new RPC method, `wallet_addEthereumChain`. ### `wallet_addEthereumChain` The `wallet_addEthereumChain` method is used to suggest to the wallet that a new chain be added to the wallet's list of chains. It takes a single parameter and returns `null` if the chain was added successfully, or an error if the chain was not added. #### `wallet_addEthereumChain` Parameters The `wallet_addEthereumChain` method takes a single parameter, an `EthereumChainAddRequest` object, which

RATIONALE:
The design of `wallet_addEthereumChain` is deliberately ignorant of what it means to "add" a chain to a wallet. The meaning of "adding" a chain to a wallet depends on the wallet implementation. When calling the method, specifying the `chainId` will always be necessary, since in the universe of Ethereum chains, the [EIP-155](./eip-155.md) chain ID is effectively the chain GUID. The remaining parameters amount to what, in the estimation of the authors, a wallet will minimally require in order to effectively support a chain and represent it to the user. The network ID (per the `net_version` RPC method) is


=== EIP-7503 ===
TITLE: Zero-Knowledge Wormholes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-08-14
REQUIRES: 2, 7, 1, 8, ,,  , 4, 8, 4, 4, ,,  , 7, 7, 0, 8

SUMMARY:
While researching on privacy solutions and applications of ZKP, we discovered a technique, by which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, and later build a ZK proof showing that some amount of tokens reside in an account that are unspendable, without revealing the account. The EIP proposes to add a minting functionality to Ethereum, so that people can re-mint Ethers they have purposefully burnt. The mentioned privacy solution will bring strong levels of ***plausible deniability*** for the sender, since there is no way one can prove that the sender

SPECIFICATION:
### Parameters * `MAGIC_ADDRESS`: `0xfe` (one byte) * `MAGIC_NULLIFIER`: `0x01` (one byte) * `MAGIC_POW`: `0x02` (one byte) * `MAGIC_CHANGE`: `0x0404040404040404040404040404040404040404040404040404040404040404` * `POW_LOG_DIFFICULTY`: `24` * `MAX_DEPOSIT`: `32 * 10**18` wei * `WormholeTxType`: `TBD` * `WORMHOLE_NULLIFIER_ADDRESS`: `TBD` * `RECEIPT_PREFIX`: `TBD` (datatype `List[bool]`) - - - We define a new [EIP-2718](./eip-2718.md) transaction type, where `TransactionType` is `WormholeTxType` and the `TransactionPayload` format is as follows: `[chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, data, access_list, root_beacon_block_number, proof]` Verifying this type of transaction requires confirming that: 1. The proof is a zero-knowledge proof: * Private inputs: `secret`, `main_index`, `main_branch`, `privacy_pool_index`, `privacy_pool_branch`, `deposit_value`, `deposit_sender`, `change_value_salt`, `change_value`


=== EIP-3044 ===
TITLE: Adds `baseFee` to `eth_getBlockByNumber`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getBlockByNumber` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getBlockByNumber` #### Description Returns information about a block specified by number. Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork block **MUST** include a `baseFee` field. #### Parameters Parameters remain unchanged. #### Returns For the full specification of `eth_getBlockByNumber` see [EIP-1474](./eip-1474.md). Add a new JSON field to the `result` object for block headers containing a base fee (post [EIP-1559](./eip-1559.md) fork block). - {[`Quantity`](./eip-1474.md#quantity)} `baseFee` - base fee for this

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-6913 ===
TITLE: SETCODE instruction
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2023-04-20
REQUIRES: 

SUMMARY:
Introduce the `SETCODE` (`0xfc`) instruction, which replaces the code of the executing account from memory.

SPECIFICATION:
When within a read-only execution scope like the recursive kind created by `STATICCALL`, `SETCODE` causes an exceptional abort. When the currently executing code does not equal the code of the executing account, such as can happen inside of `DELEGATECALL` or `CREATE`, `SETCODE` causes an exceptional abort. Otherwise, `SETCODE` consumes two words from the stack: offset and length. These specify a range of memory containing the new code. Any validations that would be performed on the result of `CREATE` or `CREATE2` occur immediately, potentially causing failure with exceptional abort. The operations `EXTCODESIZE` and `EXTCODECOPY` now query the updated code,

MOTIVATION:
Many contracts are upgradeable in order to facilitate improvement or defer decisions without migrating to a new address. Contracts presently do this in several ways: The oldest method uses `CALL`. The limitation of this method is that internal state must be modifiable by all future implementations. Second, `DELEGATECALL` can proxy the implementation. Some proxies are minimal while others branch to many separate implementation accounts. This method can also bypass account code size limits. A third method uses `SELFDESTRUCT` and `CREATE2` to replace code in-place. This method improves upon the prior methods by removing the need to call into

RATIONALE:
The behavior of `CODECOPY`, `CODESIZE`, `EXTCODESIZE`, and `EXTCODECOPY` match the behavior of `DELEGATECALL` and `CREATE`, where it is also possible for executing code to differ from the code of the executing account. The gas cost of `SETCODE` is comparable to `CREATE` but excludes `Gcreate` because no execution context is created, nor any new account. Other account modification costs are accounted for outside of execution gas. Unlike `SELFDESTRUCT`, execution proceeds normally after `SETCODE` in order to allow validation and return data. Post-update validation can undo a `SETCODE` operation with `REVERT`, or with a recursive `SETCODE`, but `REVERT` uses less


=== EIP-7886 ===
TITLE: Delayed execution
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-02-18
REQUIRES: 1, 5, 5, 9, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4, ,,  , 7, 6, 2, 3, ,,  , 7, 7, 0, 2

SUMMARY:
This proposal introduces a mechanism to make execution blocks statically verifiable through minimal checks that only require the previous state, without requiring execution of the block's transactions. This enables validators to attest to a block's validity without completing its execution.

SPECIFICATION:
### Header Changes The block header structure is extended to support delayed execution: ```python @dataclass class Header: # Existing fields parent_hash: Hash32 ommers_hash: Hash32 coinbase: Address # Pre-execution state root - this is the state root before executing transactions pre_state_root: Root # Deferred execution outputs from parent block parent_transactions_root: Root # Transaction root from parent block parent_receipt_root: Root # Receipt root from parent block parent_bloom: Bloom # Logs bloom from parent block parent_requests_hash: Hash32 # Hash of requests from the parent block parent_execution_reverted: bool # Indicates if parent block's execution was reverted # Other existing fields difficulty: Uint

MOTIVATION:
The primary advantage of this proposal is **asynchronous block validation**. In the current Ethereum protocol, blocks must be fully executed before validators can attest to them. This requirement creates a bottleneck in the consensus process, as attestors must wait for execution results before committing their votes, limiting the network's throughput potential. By introducing a mechanism where execution payloads can be reverted rather than invalidating the entire block, execution is no longer an immediate requirement for validation. Instead, a block's validity can be determined based on its structural correctness and the upfront payment of transaction fees by senders. This

RATIONALE:
### Deferred Execution Outputs The core innovation of deferring execution outputs to the next block enables static and stateful validation without requiring immediate execution. The `pre_state_root` provides a cryptographically verifiable starting point for validation, while parent execution outputs create a chain of deferred execution results that maintains the integrity of the blockchain state. This approach eliminates the execution bottleneck in the validation pipeline by allowing validators to attest to a block's validity based on its structure and the pre-charged transaction fees, without waiting for execution results. ### Pre-Charging Mechanism Pre-charging senders with the maximum possible fees before execution


=== EIP-747 ===
TITLE: wallet_watchAsset RPC Method
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2018-08-13
REQUIRES: 2, 0, ,,  , 1, 0, 4, 6, ,,  , 1, 1, 9, 3

SUMMARY:
This EIP standardizes a new wallet-scoped RPC method, `wallet_watchAsset`, to allow a client to suggest a token for the user's wallet to track.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A new RPC method, `wallet_watchAsset` is added. `wallet_watchAsset` requests that a specified asset be listed to the user's wallet. It MUST immediately (i.e. before prompting the user) return `true` if the request was valid, or error if it was not. The meaning of "listed to the user's wallet" is dependent on the wallet implementation. A successful call to `wallet_watchAsset` MUST indicate that the wallet

MOTIVATION:
Today, one of the major uses of Ethereum wallets is to track users' assets. Without this EIP, each wallet either needs to pre-load a list of approved assets, or users must manually add assets to their wallet. In the first case, wallets are burdened with both the security of managing this list, as well as the bandwidth of mass polling for known assets on their wallet. In the second case, the user experience is terrible.

RATIONALE:
Displaying a user's assets is a basic feature that every modern DApp user expects. Most wallets currently either manage their own asset lists, which they store client-side, or they query a centralized API for balances, which reduces decentralization and allows correlating account holders with IP addresses. Additionally, refreshing/polling an asset list from the network can be costly, especially on bandwidth-constrained devices. Also, maintaining an asset list becomes a political act, provoking harassment and inducing pressure to list obscure assets. Automatically listing assets makes assets into a sort of spam mail: Users suddenly see new assets that they don't


=== EIP-6190 ===
TITLE: Verkle-compatible SELFDESTRUCT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2, 9, 2, 9, ,,  , 6, 1, 8, 8, ,,  , 6, 1, 8, 9

SUMMARY:
Changes `SELFDESTRUCT` to only cause a finite number of state changes.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Prerequisites [EIP-6188](./eip-6188.md) and [EIP-6189](./eip-6189.md) must be used for this EIP to function correctly. ### `SELFDESTRUCT` Behaviour Instead of destroying the contract at the end of the transaction, instead, the following will occur at the end of the transaction in which it is invoked: 1. The contract's code is set to `0x1`, and its nonce is set to `2^64-1`. 2. The contract's `0`th storage slot is

MOTIVATION:
The `SELFDESTRUCT` instruction has a fixed price, but is unbounded in storage/account changes (it needs to delete all keys). This has been an outstanding concern for some time. Furthermore, with *Verkle trees* accounts will be organised differently. Account properties, including storage, would have individual keys. It would not be possible to traverse and find all used keys. This makes `SELFDESTRUCT` very challenging to support in Verkle trees. This EIP is a step towards supporting `SELFDESTRUCT` in Verkle trees.

RATIONALE:
This EIP is designed to be a step towards supporting `SELFDESTRUCT` in Verkle trees while making the minimum amount of changes. The `5000` base gas cost and additional alias contracts represents the cost of setting the account nonce and first storage slot. The [EIP-2929](./eip-2929.md) gas cost increase is preserved for the reasons mentioned in said EIP's Rationale. The nonce of `2^64-1` was chosen since it is the nonce protected by [EIP-6188](./eip-6188.md). The account code of `0x1` was chosen since it was the code specified in [EIP-6189](./eip-6189.md). The address being the same as the one created by `CREATE` is


=== EIP-234 ===
TITLE: Add `blockHash` to JSON-RPC filter options.
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-03-24
REQUIRES: 1474

SUMMARY:
This addition would allow clients to fetch logs for specific blocks, whether those blocks were in the current main chain or not. This resolves some issues that make it difficult/expensive to author robust clients due to the nature of chain reorgs, unreliable network connections and the result set not containing enough details in the empty case.

SPECIFICATION:
The filter options used by `eth_newFilter` would have an additional optional parameter named `blockHash` whose value is a single block hash. The Ethereum node responding to the request would either send back an error if the block hash was not found or it would return the results matching the filter (per normal operation) constrained to the block provided. Internally, this would function (presumably) similar to the `fromBlock` and `toBlock` filter options.

RATIONALE:
A client (dApp) who needs reliable notification of both log additions (on new blocks) and log removals (on chain reorgs) cannot achieve this while relying solely on subscriptions and filters. This is because a combination of a network or remote node failure during a reorg can result in the client getting out of sync with reality. An example of where this can happen with Websockets is when the client opens a web socket connection, sets up a log filter subscription, gets notified of some new logs, then loses the web socket connection, then (while disconnected) a re-org occurs,


=== EIP-6968 ===
TITLE: Contract Secured Revenue on an EVM based L2
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-05-01
REQUIRES: 


=== EIP-658 ===
TITLE: Embedding transaction status code in receipts
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-06-30
REQUIRES: 140

SUMMARY:
This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.

SPECIFICATION:
For blocks where block.number >= BYZANTIUM_FORK_BLKNUM, the intermediate state root is replaced by a status code, 0 indicating failure (due to any operation that can cause the transaction or top-level call to revert) and 1 indicating success.

MOTIVATION:
With the introduction of the REVERT opcode in EIP140, it is no longer possible for users to assume that a transaction failed iff it consumed all gas. As a result, there is no clear mechanism for callers to determine whether a transaction succeeded and the state changes contained in it were applied. Full nodes can provide RPCs to get a transaction return status and value by replaying the transaction, but fast nodes can only do this for nodes after their pivot point, and light nodes cannot do this at all, making a non-consensus solution impractical. Instead, we propose

RATIONALE:
This constitutes a minimal possible change that permits fetching the success/failure state of transactions, preserving existing capabilities with minimum disruption or additional work for Metropolis.


=== EIP-606 ===
TITLE: Hardfork Meta: Homestead
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 2, ,,  , 7, ,,  , 8

SUMMARY:
This specifies the changes included in the hard fork named Homestead.

SPECIFICATION:
- Codename: Homestead - Activation: - Block >= 1,150,000 on Mainnet - Block >= 494,000 on Morden - Block >= 0 on future testnets - Included EIPs: - [EIP-2](./eip-2.md) (Homestead Hard-fork Changes) - [EIP-7](./eip-7.md) (DELEGATECALL) - [EIP-8](./eip-8.md) (Networking layer: devp2p Forward Compatibility Requirements for Homestead)


=== EIP-1057 ===
TITLE: ProgPoW, a Programmatic Proof-of-Work
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
ProgPoW is a proof-of-work algorithm designed to close the efficiency gap available to specialized ASICs. It utilizes almost all parts of commodity hardware (GPUs), and comes pre-tuned for the most common hardware utilized in the Ethereum network. This document presents an overview of the algorithm and examines what it means to be “ASIC-resistant.” Next, we compare existing PoW designs by analyzing how each algorithm executes in hardware. Finally, we present the detailed implementation by walking through the code.

SPECIFICATION:
ProgPoW can be tuned using the following parameters. The proposed settings have been tuned for a range of existing, commodity GPUs: * `PROGPOW_PERIOD`: Number of blocks before changing the random program * `PROGPOW_LANES`: The number of parallel lanes that coordinate to calculate a single hash instance * `PROGPOW_REGS`: The register file usage size * `PROGPOW_DAG_LOADS`: Number of uint32 loads from the DAG per lane * `PROGPOW_CACHE_BYTES`: The size of the cache * `PROGPOW_CNT_DAG`: The number of DAG accesses, defined as the outer loop of the algorithm (64 is the same as Ethash) * `PROGPOW_CNT_CACHE`: The number of cache

MOTIVATION:
Ever since the first bitcoin mining ASIC was released, many new Proof of Work algorithms have been created with the intention of being “ASIC-resistant”. The goal of “ASIC-resistance” is to resist the centralization of PoW mining power such that these coins couldn’t be so easily manipulated by a few players. Ethereum's approach is to incentivize a geographically-distributed community of miners with a low barrier to entry on commodity hardware. As stated in the [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf): > 11.5. Mining Proof-of-Work. The mining proof-ofwork (PoW) exists as a cryptographically secure nonce that proves beyond reasonable doubt that a particular amount


=== EIP-5283 ===
TITLE: Semaphore for Reentrancy Protection
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-07-17
REQUIRES: 2, 0, ,,  , 1, 2, 8, 3, ,,  , 1, 3, 5, 2

SUMMARY:
This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage, and therefore it enables contracts to be forward-compatible with all designs that provide fine-grained (i.e. cell level) parallelization for the multi-threaded execution of EVM transactions.

SPECIFICATION:
Starting from an activation block (TBD) a new precompiled contract `Semaphore` is created at address `0x0A`. When `Semaphore` is called, if the caller address is present more than once in the call stack, the contract behaves as if the first instruction had been a `REVERT`, therefore the CALL returns 0. Otherwise, it executes no code and returns 1. The gas cost of the contract execution is set to 100, which is consumed independently of the call result.

MOTIVATION:
The typical smart contract RPG uses a contract storage cell. The algorithm is simple: the code checks that a storage cell is 0 (or any other predefined constant) on entry, aborting if not, and then sets it to 1. After executing the required code, it resets the cell back to 0 before exiting. This is the algorithm implemented in OpenZeppelin's ReentrancyGuard. The algorithm results in a read-write pattern on the RPG's storage cell. This pattern prevents the parallelization of the execution of the smart contract for all known designs that try to provide fine-grained parallelization (detecting conflicts at

RATIONALE:
The address `0x0A` is the next one available within the range defined by [EIP-1352](./eip-1352). ### Sample usage ```solidity pragma solidity ^0.8.0; abstract contract ReentrancyGuard2 { uint8 constant SemaphoreAddress = 0x0A; /** * @dev Prevents a contract from calling itself, directly or indirectly. * Calling a `nonReentrant` function from another `nonReentrant` * function is supported. */ modifier nonReentrant() { _nonReentrantBefore(); _; } function _nonReentrantBefore() private { assembly { if iszero(staticcall(1000,SemaphoreAddress, 0, 0, 0, 0)) { revert(0, 0) } } } } ``` ### Parallelizable storage-based RPGs The only way to parallelize preexistent contracts that are using the storage RPG


=== EIP-7547 ===
TITLE: Inclusion lists
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-24
REQUIRES: 

SUMMARY:
Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.

SPECIFICATION:
### Constants | Name | Value | | - | - | | `MAX_TRANSACTIONS_PER_INCLUSION_LIST` | `2**4 = 16` | | `MAX_GAS_PER_INCLUSION_LIST` | `2**21` | | `MIN_SLOTS_FOR_INCLUSION_LIST_REQUEST` | `1` | #### Reference Objects ``` class InclusionListSummaryEntry(Container): address: ExecutionAddress gas_limit: uint64 ``` ``` class InclusionListSummary(Container) slot: Slot proposer_index: ValidatorIndex summary: List[InclusionListSummaryEntry, MAX_TRANSACTIONS_PER_INCLUSION_LIST] ``` ``` class SignedInclusionListSummary(Container): message: InclusionListSummary signature: BLSSignature ``` ``` class InclusionList(Container) summary: SignedInclusionListSummary transactions: List[Transaction, MAX_TRANSACTIONS_PER_INCLUSION_LIST] ``` ``` class ExecutionPayload(Container): ... inclusion_list_summary: List[InclusionListSummaryEntry, MAX_TRANSACTIONS_PER_INCLUSION_LIST] inclusion_list_exclusions: List[uint64, MAX_TRANSACTIONS_PER_INCLUSION_LIST] ``` ``` class ExecutionPayloadHeader(Container): ... inclusion_list_summary_root: Root inclusion_list_exclusions_root: Root ``` ``` class BeaconBlockBody(Container): ... inclusion_list_summary: SignedInclusionListSummary ``` ### Consensus layer

MOTIVATION:
Since the merge, validators have started outsourcing almost all block production to a specialized set of builders who compete to extract the most MEV (this is commonly referred to as Proposer-Builder Separation). As of October 2023, nearly 95% of blocks are built by builders rather than the proposer. While it is great that all proposers have access to competitive blocks through the `mev-boost` ecosystem, a major downside of externally built blocks is the fact that the builders ultimately decide what transactions to include or exclude. Without any forced transaction inclusion mechanism, the proposer is faced with a difficult

RATIONALE:
We consider a few design decisions present in this EIP. 1. `ReducedSummary` versus `Summary` - The original proposal tries to improve data efficiency by using a `ReducedSummary` and a `Rebuilder`. This allows the full summary to be reconstructed. - This adds a lot of complexity to the spec, so in this initial version, we should consider just using the regular `Summary` and including that in the subsequent block. 3. Gas limit vs no limit. - One consideration is whether the inclusion list should have a gas limit or use the block’s gas limit. - Having a separate gas


=== EIP-2997 ===
TITLE: IMPERSONATECALL Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-24
REQUIRES: 

SUMMARY:
Add a new opcode, `IMPERSONATECALL` at `0xf6`, which is similar in idea to `CALL (0xF1)`, except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.

SPECIFICATION:
`IMPERSONATECALL`: `0xf6`, takes 7 operands: - `gas`: the amount of gas the code may use in order to execute; - `to`: the destination address whose code is to be executed; - `in_offset`: the offset into memory of the input; - `in_size`: the size of the input in bytes; - `ret_offset`: the offset into memory of the output; - `ret_size`: the size of the scratch pad for the output. - `salt` is a `32` bytes value (a stack item). ### Computation of impersonated sender The impersonated sender address is computed as `keccak256( 0xff ++ address ++ salt ++ zeros32)[12:]`.

MOTIVATION:
This proposal enables native multi-user wallets (wallets that serve multiple users) that can be commanded by EIP-712 based messages and therefore enable meta-transactions. Multi-user wallets also enable the aggregation of transfer operations in batches similar to rollups, but maintaining the same address space as normal onchain transactions, so the sender's wallet does not need to be upgraded to support sinding ether or tokens to a user of a multi-user wallet. Additionally, many times a sponsor company wants to deploy non-custodial smart wallets for all its users. The sponsor does not want to pay the deployment cost of each

RATIONALE:
Even if `IMPERSONATECALL` requires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn't not compensate increasing the complexity of the implementation. We use the zeros32 field to base address derivation in a pre-image of similar size than CREATE2 and reuse the existing address derivation functions. We also avoid worrying about address collisions between EOA derivation (65 bytes pre-image), CREATE derivation (from 23 to 27 bytes pre-image, for a 32bit nonce) and CREATE2 derivation (85 bytes pre-image). An option is to omit the zeros32 field: the resulting length of


=== EIP-7957 ===
TITLE: EVM64 - EOF support
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-26
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 7, 9, 3, 7

SUMMARY:
This EIP defines EOF support for EVM64 with its additional code validation rules and `RJUMPI`, `RJUMPV` opcodes.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. We define the following gas cost constant: | Name | Gas | |------|-----| | `G_RJUMPIV64` | `3` | At EOF contract creation time as defined in [EIP-3670](./eip-3670.md), if the opcode `C0` is encountered and it is not part of PUSH opcode's data, then the interpreter MUST validate that: * The next opcode exists. * The next opcode is `RJUMPI64`, `RJUMPV64`, or one of the

MOTIVATION:
EOF defines a stricter code validation rule to improve efficiency. Due to EVM64 using multibyte opcode (the mode opcode `C0`), a small adaptation is needed. This EIP also additionally defines a 64-bit mode `RJUMPI` and `RJUMPV` to be 64-bit.

RATIONALE:
For detailed rationale discussion, please see the core EVM64 definition [EIP-7937](./eip-7937.md).


=== EIP-1895 ===
TITLE: Support for an Elliptic Curve Cycle
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-03-31
REQUIRES: 

SUMMARY:
Adds supports for the following operations through precompiles: * `ecadd` on MNT4 * `ecmul` on MNT4 * `ecpairing` on MNT4

SPECIFICATION:
### The curve The proposed cycle has been introduced in [Scalable Zero Knowledge via Cycles of Elliptic Curves](https://eprint.iacr.org/2014/595.pdf). ### MNT4 definition The groups `G_1` and `G_2` are cyclic groups of prime order : ```. q = 475922286169261325753349249653048451545124878552823515553267735739164647307408490559963137 ``` `G_1` is defined over the field `F_p` of prime order : ```. p = 475922286169261325753349249653048451545124879242694725395555128576210262817955800483758081 ``` with generator P: ```. P = ( 60760244141852568949126569781626075788424196370144486719385562369396875346601926534016838, 363732850702582978263902770815145784459747722357071843971107674179038674942891694705904306 ) ``` Both p and q can be written in 298 bits. The group G_1 is defined on the curve defined by the equation `Y² = X³ + aX + b` where: ```. a =

MOTIVATION:
Elliptic curve is the basic block of recursive SNARKs (ie: verifying a SNARK inside a SNARK) and this addresses the issue of scalable zero-knowledge. More generally this addresses partly the scalability issue as SNARKs verification are constant time in the size of the circuit being verified. More concretely, today if the EVM has to deal with 1000s of SNARK verification it would take around 1.5 billion gas and would be impractical for Ethereum. Recursive SNARKs for instance make it possible to aggregate multiple proofs into a single one that can be verified like any other SNARK. It results

RATIONALE:
The curve has 80 bits of security (whereas MNT6 has 120 bits) which might not be considered enough for critical security level, (for instance transferring several billions), but enough for others. If it turns out this is not enough security for adoption, there is another option : another cycle is being used by Coda but is defined over a 753 bits sized field which might also be prohibitively low (no reference to this curve from Coda's publications found). Independently of the cycle chosen, the groups and field elements are represented with integers larger than 256 bits (even for


=== EIP-7980 ===
TITLE: Ed25519 transaction support
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2025-06-25
REQUIRES: 7932

SUMMARY:
This EIP adds a new [EIP-7932](./eip-7932.md) algorithm of type `0x0` for supporting Ed25519 signatures.

SPECIFICATION:
This EIP defines a new [EIP-7932](../../EIPS/eip-7932.md) algorithmic type with the following parameters: | Constant | Value | | - | - | | `ALG_TYPE` | `Bytes1(0x0)` | | `GAS_PENALTY`| `1000` | | `MAX_SIZE` | `96` | ```python def verify(signature_info: bytes, payload_hash: Hash32) -> ExecutionAddress: assert(len(signature_info) == 96) signature = signature_info[:64] public_key = signature_info[64:] # This is the `Verify` function described in [RFC 8032 Section 5.1.7](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.7), # This MUST be processed as raw `Ed25519` and not `Ed25519ctx` or `Ed25519ph` assert(ed25519_verify(signature, public_key, payload_hash)) return keccak256(public_key)[-20:] ```

MOTIVATION:
Ed25519 is one of the most widely used forms of Elliptic Curve Cryptography and is one of the defaults for SSH keys, this makes it a good contender to be able to sign transactions with. It also provides an algorithm to write test cases against during the implementation phase of [EIP-7932](./eip-7932.md).

RATIONALE:
### Additional 1000 gas penalty The gas penalty discourages people from attempting to migrate off current secp256k1 accounts, and also covers the additional overhead (in regards to hashing) that the ed25519 curve applies. ### Why Ed25519? Ed25519 has significant tooling backing it, this makes it a good candidate for using as a "dummy" algorithm. This allows it to be an algorithm for client teams to easily test [EIP-7932](./eip-7932.md). It may also be useful for signing in Hardware security modules in server environments designed for serving as [ERC-4337](./eip-4337.md) bundlers. It may also improve interoperability with other components such as


=== EIP-158 ===
TITLE: State clearing
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-16
REQUIRES: 


=== EIP-2025 ===
TITLE: Block Rewards Proposal for funding Eth1.x
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-04-20
REQUIRES: 1890

SUMMARY:
This EIP extends the mechanism established in EIP-1890 to add `0.0055 ETH` to the block reward for a specific distribution period of `3,100,000 BLOCKS`(≈ 18 months). The `RECIPIENT_ADDRESS` is set to a smart contract with hardcoded denominations that distributes incoming ETH to a set of addresses for the purpose of Eth1.X development. The emission schedule would start at the hard fork block number and continue for `3,100,000 BLOCKS` (≈ 18 months) at which point the address and amount would again return to 0. Any further distribution would require a future hard fork.

SPECIFICATION:
Two constants will be introduced: - `REWARD_DURATION_IN_BLOCKS`, which specifies the number of blocks after `ISTANBUL_BLOCK_HEIGHT` when the reward collection will terminate (i.e., at block `ISTANBUL_BLOCK_HEIGHT + REWARD_DURATION_IN_BLOCKS`) - `BENEFICIARY_ADDRESSES`, a list of tuples containing the address and the amount to be transferred to this address per block. These amounts will be determined as the loan is collected from participating organizations and the addresses for repayment will be specified by them. The total of the amounts will sum to 0.0055. At the end of `REWARD_DURATION_IN_BLOCKS` the loan will be completely repaid. ``` REWARD_DURATION_IN_BLOCKS = 3100000 DEVFUND_BLOCK_REWARD = 0.0055 BENEFICIARY_ADDRESSES

MOTIVATION:
The context for this proposal came from attending the [Core Dev Eth1.X Meeting](https://www.youtube.com/watch?v=Au1Qll-86v0) in Berlin. Development is needed to move Eth1.X forward, and I observed that a lack of funding is the primary barrier to this work. This work can only be effectively conducted by working groups forming around these issues, and these working groups need funding in order to pay dedicated contractors and project managers. This proposal is a plan for funding these groups and supporting their operation.

RATIONALE:
There has been great public debate concerning EIP-1890, and one of the primary concerns is that it is difficult to evaluate the proposal without more complete information on how funds would be raised, how they would be administered, and how they would be used. There is a need for funding Eth1.x development and it is currently unclear where those funds will come from. This proposal is intended to give a more comprehensive proposal for its funding. In the case that ETH1.x is fully funded before the Istanbul upgrade I will withdraw this EIP. Until that point I intend


=== EIP-7801 ===
TITLE: etha - Sharded Blocks Subprotocol
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2024-10-30
REQUIRES: 7642

SUMMARY:
This EIP proposes the creation of a new subprotocol, `etha`, enabling Ethereum nodes to communicate available block spans via a bitmask. Each bit represents a 106_496-block span within each 1_064_960 block range of chain history. Nodes use this bitmask to signal stored spans and commit to storing future spans as they are created. This allows peers to make informed decisions about data availability without first connecting and querying for it. The bitmask repeats every 1_064_960 blocks for straightforward reasoning about data availability probabilities. The `etha` subprotocol has the same functionality to serve historical data using message types copied

SPECIFICATION:
### Subprotocol Handshake - Introduce a new subprotocol named `etha`. - Define the handshake message for the `etha` subprotocol as follows: - Handshake packet: `[version: P, networkid: P, blockhash: B_32, genesis: B_32, forkid, blockBitmask]` - `blockBitmask` is a 10-bit bitmask, with each bit representing a 106_496-block range per 1_064_960 blocks of history. - the rest of the elements are as defined in eth/69 ### Supported Messages The `etha` subprotocol **MUST** include support for the following messages from the `eth/69` protocol to facilitate historical data serving: - **GetBlockBodies (0x05):** Request block bodies. - **BlockBodies (0x06):** Response to `GetBlockBodies`. -

MOTIVATION:
With [EIP-4444](./eip-4444.md), nodes may prune historical data while others continue serving it. Determining data availability by connecting and requesting blocks is inefficient consuming unnexessary bandwidth. This EIP addresses this inefficiency by enabling nodes to shard chain history into 106_496 block segments and signal availability via a bitmask. By introducing a separate subprotocol, `etha`, nodes can exchange this information seamlessly and retain the ability to serve historical data without impacting existing `eth` protocol versions.

RATIONALE:
The bitmask approach provides a flexible means to represent and retain block data while committing to future spans. This mechanism aligns with the pruning proposed in EIP-4444, while ensuring that historical and future data spans remain available across the network. A similar bitlist approach is already used in the Consensus Layer for attestation subnets, making it a familiar and efficient method for representing data spans. Additionally, committing to future spans ensures better predictability and stability for data locality. The `etha` subprotocol separates this functionality from `eth` ensuring nodes dont hammer other nodes with requests on historical ranges that


=== EIP-2474 ===
TITLE: Coinbase calls
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-01-19
REQUIRES: 

SUMMARY:
_In proof-of-work blockchains, validators are known as miners._ The validator might want to execute functions directly, without having to sign a transaction. Some examples might be presenting a proof in a contract for a change which also benefits the validator. A notable example would be when a validator want to act as an [EIP-1077](./eip-1077.md) Gas Relayer, incentivized to pick up fees from meta transactions. Without this change, they can do so by signing from any address a `gasPrice = 0` transaction with the gas relayed call. However this brings an overhead of a signed transaction by validator that

SPECIFICATION:
The calls to be executed by `block.coinbase` would be included first at block, and would consume normally the gas of block, however they won't pay/cost gas, instead the call logic would pay the validator in other form. Would be valid to execute any calls without a transaction by the block coinbase, except when the validator call tries to read `msg.sender`, which would throw an invalid jump. Calls included by the validator would have `tx.origin = block.coinbase` and `gas.price = 0` for the rest of call stack, the rest follows as normal calls.

MOTIVATION:
In order to reduce the overhead of calls that don't use `msg.sender` and are being called by validator with `tx.gasPrice = 0`.

RATIONALE:
TBD


=== EIP-3416 ===
TITLE: Median Gas Premium
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-18
REQUIRES: 

SUMMARY:
There is a base fee per gas in protocol, which can move up or down by a maximum of 1/8 in each block. The base fee per gas is adjusted by the protocol to target an average gas usage per block instead of an absolute gas usage per block. The base fee is increased when blocks are over the gas limit target and decreases when blocks are under the gas limit target. Transaction senders specify their fees by providing *only one value*: * The fee cap which represents the maximum total (base fee + gas premium) that the

SPECIFICATION:
### Definitions This is a classic fork without a long migration time. * `FORK_BLOCK_NUMBER`: TBD. Block number at or after which EIP-3416 transactions are valid. * `GAS_TARGET_MAX_CHANGE`: `1 // 1024`. * `BLOCK_GAS_USED`: total gas consumed by transaction included in the block. * `PARENT_GAS_USED`: same as `BLOCK_GAS_USED` for parent block. * `CURRENT_BLOCK`: The current block that is being worked with (either being validated, or being produced). * `BASE_FEE`: 16th item in the block header. Represents the amount of attoeth burned for every unit of gas a transaction uses. * `PARENT_BASE_FEE`: same as `BASE_FEE` for parent block. * `BASE_FEE_MAX_CHANGE`: `1

MOTIVATION:
We target the following goals: * Gas prices spikes are mathematically smoothed out. EIP1559 does not seems to really tackle gas premium volatility and UX. * Maintain gas price preference, i.e. transaction senders willing to pay extra in fees will be rewarded with early preferential inclusion in the blocks, because the miners want to maximize their profits and include transactions with higher fee caps first to maximize the median. * Final gas price paid by the sender is, most of the time, smaller than the maximum gas price specified by sender. * Gas pricing is more robust to


=== EIP-609 ===
TITLE: Hardfork Meta: Byzantium
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 0, 0, ,,  , 1, 4, 0, ,,  , 1, 9, 6, ,,  , 1, 9, 7, ,,  , 1, 9, 8, ,,  , 2, 1, 1, ,,  , 2, 1, 4, ,,  , 6, 0, 7, ,,  , 6, 4, 9, ,,  , 6, 5, 8

SUMMARY:
This specifies the changes included in the hard fork named Byzantium.

SPECIFICATION:
- Codename: Byzantium - Aliases: Metropolis/Byzantium, Metropolis part 1 - Activation: - Block >= 4,370,000 on Mainnet - Block >= 1,700,000 on Ropsten testnet - Included EIPs: - [EIP-100](./eip-100.md) (Change difficulty adjustment to target mean block time including uncles) - [EIP-140](./eip-140.md) (REVERT instruction in the Ethereum Virtual Machine) - [EIP-196](./eip-196.md) (Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128) - [EIP-197](./eip-197.md) (Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128) - [EIP-198](./eip-198.md) (Precompiled contract for bigint modular exponentiation) - [EIP-211](./eip-211.md) (New opcodes: RETURNDATASIZE and RETURNDATACOPY) - [EIP-214](./eip-214.md) (New opcode STATICCALL) - [EIP-649](./eip-649.md)


=== EIP-7807 ===
TITLE: SSZ execution blocks
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-28
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 4, 9, 5, ,,  , 7, 7, 0, 6, ,,  , 7, 7, 9, 9

SUMMARY:
This EIP defines a migration process of execution blocks to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Gas amounts The different kinds of gas amounts are combined into a single structure, mirroring the [EIP-6404 gas fees](./eip-6404.md#gas-fees). | Name | SSZ equivalent | | - | - | | [`GasAmount`](./eip-6404.md#normalized-transactions) | `uint64` | ```python class GasAmounts(ProgressiveContainer((active_fields=[1, 1]))): regular: GasAmount blob: GasAmount ``` ### Requests hash computation `requests_hash` is changed to `ExecutionRequests.hash_tree_root()` using the same structure as in the Consensus Layer `BeaconBlockBody`.

MOTIVATION:
With [EIP-6404](./eip-6404.md) SSZ transactions, [EIP-6466](./eip-6466.md) SSZ receipts, and [EIP-6465](./eip-6465.md) SSZ withdrawals, all Merkle-Patricia Tries (MPT) besides the state trie are converted to SSZ. This enables the surrounding data structure, the execution block itself, to also convert to SSZ, achieving a unified block representation across both Consensus Layer and Execution Layer. 1. **Normalized block hash:** The Consensus Layer can compute the block hash autonomously, enabling it to process all consistency checks that currently require asynchronous communication with the Execution Layer ([`verify_and_notify_new_payload`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/electra/beacon-chain.md#modified-verify_and_notify_new_payload)). This allows early rejection of inconsistent blocks and dropping the requirement to wait for engine API interactions while

RATIONALE:
This completes the transition to SSZ for everything except the execution state trie. ### Future - With SSZ `Log`, the withdrawals mechanism and validator requests could be redefined to be based on logs (similar to deposits, originally, but without the delay), possibly removing the need for `withdrawals_root` and `requests_hash`. - The CL would insert the extra logs for minting ([EIP-7799](./eip-7799.md)) and could fetch the ones relevant for withdrawing (deposits, requests, consolidations). That mechanism would be more generic than [EIP-7685](./eip-7685.md) and would drop requiring the EL to special case requests, including `compute_requests_hash`. - For client applications and smart contracts,


=== EIP-7266 ===
TITLE: Remove BLAKE2 compression precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-03
REQUIRES: 

SUMMARY:
This EIP removes the [`blake2f`](./eip-152.md) (`0x09`) precompile by changing the precompile behaviour to result in an exceptional abort.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All `CALL`, `CALLCODE`, `DELEGATECALL`, and `STATICCALL` invocations to the `blake2f` precompile address `0x09` MUST result in an exceptional abort.

MOTIVATION:
[EIP-152](./eip-152.md) has never capitalised on a real-world use case. This fact is clearly reflected in the number of times the address `0x09` has been invoked (numbers from the date this EIP was created): - The most recent call took place on 6 October 2022. - Since its gone live as part of the Istanbul network upgrade on December 7 2019 (block number 9,069,000), `0x09` has been called only 22,131 times. One of the reasons why [EIP-152](./eip-152.md) has failed is that the envisioned use cases were not validated before inclusion.

RATIONALE:
The EVM should be optimised for simplicity and future-proofness. The original Yellow Paper states: _these are so-called 'precompiled' contracts, meant as a preliminary piece of architecture that may later become native extensions_. Considering that no use cases have been realised in the last 3.5 years, we can conclude that the precompile `blake2f` (`0x09`) will never transition into a native opcode. In that sense, the precompile `blake2f` (`0x09`) is an obsolete carry-along with no real-world traction and thus should be removed. This removal will simplify the EVM to the extent that it only consists of clear instructions with real-world


=== EIP-4803 ===
TITLE: Limit transaction gas to a maximum of 2^63-1
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-02
REQUIRES: 

SUMMARY:
Limit transaction gas to be between `0` and `2^63-1`.

SPECIFICATION:
Introduce one new restriction retroactively from genesis: any transaction is invalid and not includeable in a block, where the gas limit exceeds `2^63-1`.

MOTIVATION:
The gas limit field in the transaction is specified to be an arbitrary long unsigned integer, but various clients put limits on this value. This EIP brings a reasonable limit into consensus.

RATIONALE:
### `2^63-1` vs `2^64-1` `2^63-1` is chosen because it allows representing the gas value as a signed integer, and so the out of gas check can be done as a simple "less than zero" check after subtraction. ### Consider `2^31-1` An alternative is considering a lower limit, because this can be handled easily in Javascript, since it handles numbers as floating point (the actual upper bound is `2^53-1`). ### Current limit Due to the nature of RLP encoding, there is no fixed upper bound for the value, but most implementations limit it to 256-bits. Furthermore, most client implementations


=== EIP-7954 ===
TITLE: Increase Maximum Contract Size
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-06-09
REQUIRES: 1, 7, 0, ,,  , 3, 8, 6, 0

SUMMARY:
This EIP proposes to raise the maximum allowed size for contract code deployed on Ethereum from 24,576 bytes to 32,768 bytes.

SPECIFICATION:
1. Update the [EIP-170](./eip-170.md) contract code size limit of 24KiB (`0x6000` bytes) to 32KiB (`0x8000` bytes). 2. Update the [EIP-3860](./eip-3860.md) initcode size limit of 48KiB (`0xC000` bytes) to 64KiB (`0x10000` bytes).

MOTIVATION:
The current 24KiB contract size limit can be restrictive for complex contracts and applications. Increasing the limit to 32KiB allows for more feature-rich contracts while maintaining reasonable constraints on block and state growth.

RATIONALE:
- **Developer Flexibility:** Enables more complex contracts and features. - **Backward Compatibility:** Existing contracts are unaffected. - **Simplicity:** Only the size limit is changed, with no other protocol modifications.


=== EIP-4396 ===
TITLE: Time-Aware Base Fee Calculation
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-10-28
REQUIRES: 

SUMMARY:
This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle, be applied to either a Proof-of-Work or a Proof-of-Stake chain, however the security implications for the Proof-of-Work case remain unexplored.

SPECIFICATION:
Using the pseudocode language of [EIP-1559](./eip-1559.md), the updated base fee calculation becomes: ```python ... BASE_FEE_MAX_CHANGE_DENOMINATOR = 8 BLOCK_TIME_TARGET = 12 MAX_GAS_TARGET_PERCENT = 95 class World(ABC): def validate_block(self, block: Block) -> None: parent_gas_limit = self.parent(block).gas_limit parent_block_time = self.parent(block).timestamp - self.parent(self.parent(block)).timestamp parent_base_gas_target = parent_gas_limit // ELASTICITY_MULTIPLIER parent_adjusted_gas_target = min(parent_base_gas_target * parent_block_time // BLOCK_TIME_TARGET, parent_gas_limit * MAX_GAS_TARGET_PERCENT // 100) parent_base_fee_per_gas = self.parent(block).base_fee_per_gas parent_gas_used = self.parent(block).gas_used ... if parent_gas_used == parent_adjusted_gas_target: expected_base_fee_per_gas = parent_base_fee_per_gas elif parent_gas_used > parent_adjusted_gas_target: gas_used_delta = parent_gas_used - parent_adjusted_gas_target base_fee_per_gas_delta = max(parent_base_fee_per_gas * gas_used_delta // parent_base_gas_target // BASE_FEE_MAX_CHANGE_DENOMINATOR, 1) expected_base_fee_per_gas = parent_base_fee_per_gas + base_fee_per_gas_delta else: gas_used_delta = parent_adjusted_gas_target

MOTIVATION:
The current base fee calculation chooses the gas usage of a block as the signal to determine whether demand for block space is too low (indicating that the base fee should be lowered) or too high (indicating that the base fee should be increased). While simple, this choice of signal has drawbacks: it does not take the block time into account. Assuming a relatively constant demand, a proposer constructing a block after 20 seconds will have transactions available with twice the gas of a proposer constructing a block after 10 seconds. Using the same gas target for both

RATIONALE:
### Mechanism The proposed new base fee calculation only adjusts the block gas target by scaling it with the block time, capped at a maximum percent of the overall block gas limit: #### Current Base Fee Calculation ![](../assets/eip-4396/old_formula.png) #### Proposed Base Fee Calculation ![](../assets/eip-4396/new_formula.png) This new calculation thus targets a stable throughput per time instead of per block. ### Limitations Under PoS, block time increases always come in multiples of full blocks (e.g. a single missed slot = 24s instead of 12s block time). Accounting for this already requires doubling the block gas target, even for a single


=== EIP-211 ===
TITLE: New opcodes: RETURNDATASIZE and RETURNDATACOPY
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
Please see summary.

SPECIFICATION:
If `block.number >= BYZANTIUM_FORK_BLKNUM`, add two new opcodes and amend the semantics of any opcode that creates a new call frame (like `CALL`, `CREATE`, `DELEGATECALL`, ...) called call-like opcodes in the following. It is assumed that the EVM (to be more specific: an EVM call frame) has a new internal buffer of variable size, called the return data buffer. This buffer is created empty for each new call frame. Upon executing any call-like opcode, the buffer is cleared (its size is set to zero). After executing a call-like opcode, the complete return data (or failure data, see [EIP-140](./eip-140.md))

MOTIVATION:
In some situations, it is vital for a function to be able to return data whose length cannot be anticipated before the call. In principle, this can be solved without alterations to the EVM, for example by splitting the call into two calls where the first is used to compute only the size. All of these mechanisms, though, are very expensive in at least some situations. A very useful example of such a worst-case situation is a generic forwarding contract; a contract that takes call data, potentially makes some checks and then forwards it as is to another

RATIONALE:
Other solutions that would allow returning dynamic data were considered, but they all had to deduct the gas from the call opcode and thus were both complicated to implement and specify ([5/8](https://github.com/ethereum/EIPs/issues/8)). Since this proposal is very similar to the way calldata is handled, it fits nicely into the concept. Furthermore, the eWASM architecture already handles return data in exactly the same way. Note that the EVM implementation needs to keep the return data until the next call or the return from the current call. Since this resource was already paid for as part of the memory of


=== EIP-6953 ===
TITLE: Network Upgrade Activation Triggers
TYPE: Informational 
STATUS: Final
CREATED: 2023-04-28
REQUIRES: 2, 9, 8, 2, ,,  , 3, 6, 7, 5, ,,  , 6, 1, 2, 2

SUMMARY:
This EIP outlines the various network upgrade activation triggers used on Ethereum over time, from the proof-of-work era to the first post-merge network upgrade, Shanghai/Capella, across both the execution and consensus layers.

SPECIFICATION:
### Proof-of-Work Network Upgrades During the proof-of-work era, network upgrades on Ethereum were triggered based on specific block numbers. The following upgrades followed this pattern: | Upgrade Name | Activation Block Number | |--------------------|-------------------------| | Frontier | `1` | | Frontier Thawing | `200000` | | Homestead | `1150000` | | DAO Fork | `1920000` | | Tangerine Whistle | `2463000` | | Spurious Dragon | `2675000` | | Byzantium | `4370000` | | Constantinople | `7280000` | | Petersburg | `7280000` | | Istanbul | `9069000` | | Muir Glacier | `9200000` | | Berlin | `12244000`

MOTIVATION:
This EIP aims to provide users and developers with a single source of truth for understanding the various upgrade activation patterns used throughout Ethereum's history. It does not aim to be a comprehensive, ongoing record, of upgrades and their activations mechanism. Readers should assume that future upgrades use the mechanism described in the [Post Merge Upgrades](#post-merge-upgrades) section, unless this EIP is superseded by another one.

RATIONALE:
### Blocks and Epochs Blocks and epochs serve as natural trigger points for upgrades, as they represent the levels at which state transitions occur on Ethereum. ### Terminal Total Difficulty For the Terminal Total Difficulty mechanism, the rationale can be found in [EIP-3675](./eip-3675.md). ### Timestamps Due to the possibility of missed slots on the Beacon Chain, the execution layer cannot rely solely on block numbers to trigger upgrades in sync with the consensus layer. Timestamps are guaranteed to map to a specific epoch, and in their Unix representation, timestamps will always be greater than the block numbers previously


=== EIP-7619 ===
TITLE: Precompile Falcon512 generic verifier
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-07-03
REQUIRES: 

SUMMARY:
Include a precompiled signature verification function using Falcon-512. Falcon-512 is a candidate for standardization by the National Institute of Standards and Technology (NIST) and is quantum resistant with security level I.

SPECIFICATION:
A clean implementation for Falcon-512 algorithm was brought from the PQClean project. The precompiled signature verification function runs at address `0x65`. The required inputs are: - `public key` - Falcon Public key of 897 bytes - `signature` - 666 bytes (max size) - `message` - an arbitrary number of bytes representing the message that was signed Those inputs are encoded according to: ``` [pubkey:897 bytes][signature:666 bytes][message: remainder] ``` Output is: - `result` - A successful signature verification returns `0000000000000000000000000000000000000000000000000000000000000001`, otherwise `0000000000000000000000000000000000000000000000000000000000000000` indicating all other failure cases where sufficient gas has been provided. The precompile will only revert in

MOTIVATION:
The advent of quantum computing threatens blockchain protocols and networks because they utilize non-quantum resistant cryptographic algorithms. When quantum computers become robust enough to run Shor’s algorithm (a quantum algorithm to find the prime factors of an integer) on a large scale, the most used asymmetric algorithms, utilized for digital signatures and message encryption, such as RSA, (EC)DSA, and (EC)DH, will be no longer secure. Quantum computers will be able to break them within a short period of time. Today, there are hundreds of billions of dollars denominated in cryptocurrencies and other digital assets that rely on blockchain

RATIONALE:
Falcon-512 is a good candidate for a new signature implementation. Key sizes in Falcon-512 are relatively small compared to other post-quantum signature algorithms. The following table shows a summary of the typical values for keys and the approximate amount of time taken per second to execute signature verifications as specified by the authors of Falcon algorithm: | **variant** | **verify/s** | **pub size(bytes)** | **sig size(bytes)** | | ----------- | ------------ | ------------------- | ------------------- | | Falcon512 | 27933.0 | 897 | 666 | Falcon uses shake256 under the hood, an implementation made in solidity showed it


=== EIP-7937 ===
TITLE: EVM64 - 64-bit mode EVM opcodes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-04-23
REQUIRES: 

SUMMARY:
This EIP introduces multibyte opcodes prefixed by `C0` for 64-bit arithmetic (`C001`-`C00B`), comparison (`C010`-`C015`), bitwise (`C016`-`C019`) and flow (`C056` and `C057`) operations.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Prefix opcode behavior This EIP uses the prefix opcode `C0`, and it only occupies this single EVM opcode space. Upon the interpreter encountering opcode `C0`, it MUST continue to seek the next byte in code. It then executes things in "64-bit mode", based on the second byte, described below. If the execution is successful, then the interpreter MUST increase `PC` by 2 (instead

MOTIVATION:
Not all computations in EVM can utilize the full 256-bit integer width. It can therefore be beneficial to have a "64-bit mode" to avoid unnecessary cycles. This EIP uses a "prefix" opcode `C0`, essentially forming multibyte opcodes to avoid polluting the EVM opcode space too much.

RATIONALE:
When a smart contract uses the 64-bit mode, it's expected that once entered, it will want to stay in 64-bit mode, and only exit to non-64-bit mode when the computationally intensive function is finished. This EIP is designed particularly with this fact in mind. All 64-bit opcodes only operates on the 64-bit value. It totally discards the rest 192 bits. The interpreter only needs to ensure that when it exits into non-64-bit mode and next time when a value result is read, that value has the first 192 bits reset to zero. The EVM interpreter can therefore use


=== EIP-5022 ===
TITLE: Increase price of SSTORE from zero to non-zero to 40k gas
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-20
REQUIRES: 

SUMMARY:
Increase the price of the SSTORE opcode from `20_000` gas to `40_000` gas when the original slot is zero and the resultant slot is non-zero. ### Motivation The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage slot has not increased. All resources are merged into the same pricing mechanism. If the price for creating new storage slots is fixed, then it needs to be manually changed. One of the main reasons for not increasing gas limit is the increase of state. In that regard, because

SPECIFICATION:
| Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `NEW_STORAGE_PRICE` | `40_000` For blocks where `block.number >= FORK_BLOCK`, a new gas schedule applies. Make `SSTORE_SET_GAS`, the price when a slot is set from zero to non-zero, equal `NEW_STORAGE_PRICE`. All other costs remain the same. ### Backwards compatibility Contracts that depend on hardcoded gas costs will break if they create state. It is a gas schedule change, so transactions from an epoch before FORK_BLOCK should be treated with previous gas costs.

MOTIVATION:
The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage slot has not increased. All resources are merged into the same pricing mechanism. If the price for creating new storage slots is fixed, then it needs to be manually changed. One of the main reasons for not increasing gas limit is the increase of state. In that regard, because the cost of creating storage is higher than its price, all the users of all the other opcodes are subsidizing the creation of state. If state creation

RATIONALE:
### Why not also raise the cost of non-zero to non-zero? Rewriting storage does not affect state growth, which is the main issue this EIP is addressing. Rewriting storage may also be underpriced. Increasing the price of state growth will, at least, incentivize developers to reuse storage instead. ### Why not also increase the gas refund from setting non-zero to zero? More discussion is needed on this. ### Why not a better state solution? Whereas solutions like state rent, or state expiry have been researched for a long time, they will not be ready on the short to


=== EIP-7872 ===
TITLE: Max blob flag for local builders
TYPE: Meta 
STATUS: Review
CREATED: 2025-01-30
REQUIRES: 

SUMMARY:
This EIP adds a flag to the block builder in order to allow them to include a client configured maximum amount of blobs.

SPECIFICATION:
- Create a parameter in block builder's configuration called `USER_CONFIGURED_MAX_BLOBS_PER_BLOCK` - Take the minimum out of the `MAX_BLOB_GAS_PER_BLOCK` and the `USER_CONFIGURED_MAX_BLOBS_PER_BLOCK` - If the minimum is zero, set the minimum to one. - Use the minimum to decide how many blobs to include in the block Note: By default `USER_CONFIGURED_MAX_BLOBS_PER_BLOCK` may be set to the maximum in the current fork.

MOTIVATION:
Currently a builder will include all blobs in their local mempool, up to the maximum amount that the protocol requires. If a builder has low bandwidth, they may include too many blobs and subsequently end up not being able to convince the network that the blobs are available.

RATIONALE:
By adding a flag for the local block builder, they are able to specify how many blobs they can include in a block.


=== EIP-7761 ===
TITLE: EXTCODETYPE instruction
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-09-01
REQUIRES: 3, 5, 4, 0, ,,  , 7, 6, 9, 2

SUMMARY:
Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing an `EXTCODETYPE` instruction.

SPECIFICATION:
### Parameters | Constant | Value | |---------------------------|--------------------------------------------------------------------| | `FORK_BLKNUM` | tbd | | `GAS_COLD_ACCOUNT_ACCESS` | Defined as `2600` in the [Ethereum Execution Layer Spec Constants] | | `GAS_WARM_ACCESS` | Defined as `100` in the [Ethereum Execution Layer Spec Constants] | | `TYPE_NONE` | 0 | | `TYPE_LEGACY_CONTRACT` | 1 | | `TYPE_EOF_CONTRACT` | 2 | We introduce a new EOFv1 instruction on the block number `FORK_BLKNUM`: `EXTCODETYPE` (`0xe9`) EOF code which contains this instruction before `FORK_BLKNUM` is considered invalid. Beginning with block `FORK_BLKNUM` `0xe9` is added to the set of valid EOFv1 instructions. ### Execution Semantics ####

MOTIVATION:
EOFv1 as scoped in [EIP-7692] removes code introspection capabilities from the EVM, including the `EXTCODESIZE` instruction (in [EIP-3540]). This makes it hard for [ERC-721] and [ERC-1155] standard contracts to be implemented, as they rely on discovering whether a token's `safeTransfer` call target was an EOA or a contract account: - `safeTransfers` to EOAs succeed - `safeTransfers` to contract accounts call an `onERC721Received` (`onERC1155Received`) on them and expect to get a special magic return value, otherwise the transfer reverts (on the assumption that such a recipient may not be able to interact with the token) Application and library developers

RATIONALE:
### Alternative solutions There have been other solutions proposed to alleviate the problems related to lack of code introspection required for ERC-721 and ERC-1155 standards: 1. Extra status code for `EXT*CALL` instruction - allowing to discriminate a result coming from calling an EOA 2. Extra argument for `EXT*CALL` (a "fail if EOA" flag) 3. Two return values from `EXT*CALL` (status code + whether it was EOA) 4. `EXT*CALL` setting a new `callstatus` register (+ a new `CALLSTATUS` instruction) 5. Re-enable `EXTCODESIZE` in EOF, keeping its behavior same as in legacy `EXTCODETYPE` has been chosen as the most elegant


=== EIP-3143 ===
TITLE: Increase block rewards to 5 ETH
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-12-01
REQUIRES: 

SUMMARY:
Starting with `FORK_BLKNUM` block rewards will be increased to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Adjust Block, Uncle, and Nephew rewards Adjust the block reward to `new_block_reward`, where new_block_reward = 5_000_000_000_000_000_000 if block.number >= FORK_BLKNUM else block.reward (5E18 wei, or 5,000,000,000,000,000,000 wei, or 5 ETH). Analogue, if an uncle is included in a block for `block.number >= FORK_BLKNUM` such that `block.number - uncle.number = k`, the uncle reward is new_uncle_reward = (8 - k) * new_block_reward / 8 This is the existing formula for uncle rewards, simply adjusted with `new_block_reward`. The nephew reward for `block.number >= FORK_BLKNUM` is new_nephew_reward = new_block_reward / 32 This is the existing formula for nephew rewards, simply

MOTIVATION:
Currently, the transaction fees (tx fees) portion of the mining rewards makes up a significant portion of the total rewards per block, at times almost exceeded the block reward of 2 ETH. This have resulted in situations where at times of low tx fees, POW miners decide to point their rigs away from ETH as they will always prefer to mine coins that are the most profitable at any point in time, reducing the security of the ETH network till transaction activity picks up again. By increasing the block rewards back to the original 5 ETH when the

RATIONALE:
A 5 ETH base reward was chosen as a middle ground between wanting to prevent too high of an inflation rate (10.4% per annum for the first year at 5 ETH per block) and converting as many POW miners as possible into POS validators by making it easier to amass the required ETH needed through POW mining.


=== EIP-2015 ===
TITLE: wallet_updateEthereumChain RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-05-12
REQUIRES: 155

SUMMARY:
This EIP adds a wallet-namespaced RPC endpoint, `wallet_updateEthereumChain`, providing a standard interface for switching chains. The method takes the minimal parameters of `chainId`, `chainName`, `rpcUrl`, `nativeCurrency` and `blockExplorerUrl`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal adds a method to a wallet's web3 provider API: `wallet_updateEthereumChain`. ### `wallet_updateEthereumChain` The `wallet_updateEthereumChain` method is used to switch to a network, and registering it with the wallet if it isn't already recognized. The `wallet_updateEthereumChain` method takes one parameter, an `EthereumChainSwitchRequest` object, defined below: ```typescript interface NativeCurrencyData { name: string; symbol: string; decimals: number; } interface EthereumChainSwitchRequest { chainId: string; chainName?: string; rpcUrls?: string[]; nativeCurrency?: NativeCurrencyData; blockExplorerUrl?:

RATIONALE:
The `wallet_updateEthereumChain` method is designed to be as simple as possible, while still providing the necessary information for a wallet to switch to a new chain. The `chainId` is the only required parameter, as it is the only parameter that is guaranteed to be unique. The `chainName` is included to provide a human-readable name for the chain, and the `rpcUrls` array is included to provide a list of RPC endpoints for the chain. The `nativeCurrency` object is included to provide a suggestion for how the native currency should be displayed. Finally, the `blockExplorerUrl` is included to provide a


=== EIP-7950 ===
TITLE: Encode chain id with transaction hash
TYPE: Standards Track Interface
STATUS: Review
CREATED: 2025-05-22
REQUIRES: 155

SUMMARY:
This standard proposes a way to encode the combination of a chain ID and a transaction hash into one string.

SPECIFICATION:
The encoded string has three components: - A chain ID, denoted as `chainId`. The used chain id MUST be based on [EIP-155](./eip-155) and the chain ID repository stated in that EIP. - A transaction hash, denoted as `txHash`. The hash MUST include the `0x` prefix. - A static string `tx`, acting as a type identifier. The syntax is: `chainId:txHash:tx`. An example for a transaction with hash `0xc55e2b90168af6972193c1f86fa4d7d7b31a29c156665d15b9cd48618b5177ef` that was issued on chain ID `1` is: `1:0xc55e2b90168af6972193c1f86fa4d7d7b31a29c156665d15b9cd48618b5177ef:tx`. All of the characters are case-insensitive.

MOTIVATION:
Looking up a transaction by its hash always requires the context of the chain - a transaction hash alone is not enough to identify the used chain. If the chain information is included in the string itself, finding the right chain for the transaction is easy. Such strings can then be used, for example, in a forwarder service that forwards to the correct blockchain explorer. The chain id is included in some object formats, such as the transaction object inside the blockchain itself, but that object has a lot of unneeded data for our purposes.

RATIONALE:
The chain ID is the most important detail when routing queries based on this standard and is therefore the first element in the string. The transaction hash is the second most important element. The suffix `tx` is used to differentiate from, for example, addresses. Without the `tx` it would remain unclear whether an encoded string refers to an address, a transaction hash or something else.


=== EIP-3068 ===
TITLE: Precompile for BN256 HashToCurve Algorithms
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-23
REQUIRES: 1, 9, 8, ,,  , 1, 1, 0, 8

SUMMARY:
There is currently no inexpensive way to perform BLS signature verification for arbitrary messages. This stems from the fact that there is no precompiled contract in the EVM for a hash-to-curve algorithm for the BN256 elliptic curve. The gas cost of calling a deterministic hash-to-curve algorithm written in Solidity is approximately that of one pairing check, although the latter requires an order of magnitude more computation. This EIP remedies this by implementing a hash-to-curve algorithm for the BN256 G1 curve, which would reduce the cost of signature verification to essentially that of the pairing check precompiled contract. We

SPECIFICATION:
Here is the pseudocode for the `HashToG1` function: ``` function HashToG1(msg) fieldElement0 = HashToBase(msg, 0x00, 0x01) fieldElement1 = HashToBase(msg, 0x02, 0x03) curveElement0 = BaseToG1(fieldElement0) curveElement1 = BaseToG1(fieldElement1) g1Element = ECAdd(curveElement0, curveElement1) return g1Element end function ``` Here is the pseudocode for `HashToBase`; `msg` is the byte slice to be hashed while `dsp1` and `dsp2` are domain separation parameters. `fieldPrime` is the prime of the underlying field. ``` function HashToBase(msg, dsp1, dsp2) hashResult0 = uint256(Keccak256(dsp1||msg)) hashResult1 = uint256(Keccak256(dsp2||msg)) constant = 2^256 mod fieldPrime fieldElement0 = hashResult0*constant mod fieldPrime fieldElement1 = hashResult1 mod fieldPrime fieldElement = fieldElement0 + fieldElement1 mod

MOTIVATION:
The precompiled contracts in [EIP-198](./eip-198.md) and [EIP-1108](./eip-1108.md) increased usage of cryptographic operations in the EVM by reducing the gas costs. In particular, the cost reduction from [EIP-1108](./eip-1108.md) helps increase the use of SNARKs in Ethereum via an elliptic curve pairing check; however, a hash-to-curve algorithm enabling arbitrary BLS signature verification on BN256 in the EVM was noticeably missing. There is interest in having a precompiled contract which would allow for signature verification, as noted [here](https://ethereum-magicians.org/t/pre-compile-for-bls/3973). At this time, we are able to perform addition, scalar multiplication, and pairing checks in BN256. Reducing these costs in [EIP-1108](./eip-1108.md) made [ETHDKG](https://github.com/PhilippSchindler/ethdkg),

RATIONALE:
The BaseToG1 algorithm is based on the original Fouque and Tibouchi [paper](../assets/eip-3068/latincrypt12.pdf) with modifications based on Wahby and Boneh's [paper](../assets/eip-3068/2019-403_BLS12_H2C.pdf). There is freedom in choosing the HashToBase function and this could easily be changed. Within HashToBase, the particular hashing algorithm (Keccak256 in our case) could also be modified. It may be desired to change the call to `sign0` at the end of BaseToG1 and BaseToTwist with `is_square`, as this would result in the same deterministic map to curve from the Fouque and Tibouchi [paper](../assets/eip-3068/latincrypt12.pdf) and ensure HashToG1 is indifferentiable from a random oracle; they proved this result in


=== EIP-3455 ===
TITLE: SUDO Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-01
REQUIRES: 

SUMMARY:
A new opcode, `SUDO`, is introduced with the same parameters as `CALL`, plus another parameter to specify the sender address.

SPECIFICATION:
Adds a new opcode (`SUDO`) at `0xf8`. `SUDO` pops 8 parameters from the stack. Besides the sender parameter, the parameters shall match `CALL`. 1. Gas: Integer; Maximum gas allowance for message call, safely using current gas counter if the counter is lower 2. Sender: Address, truncated to lower 40 bytes; Sets `CALLER` inside the call frame 3. To: Address, truncated to lower 40 bytes; sets `ADDRESS` 4. Value: Integer, raises exception amount specified is less than the value in Sender account; transferred with call to recipient balance, sets `CALLVALUE` 5. InStart: Integer; beginning of memory to use for

MOTIVATION:
There are many use cases for being able to set the sender. Many tokens are stuck irretrievably because nobody has the key for the owner address. In particular, at address zero there is approximately 17 billion USD in tokens and ether, according to etherscan. With `SUDO`, anyone could free that value, leading to an economic boom that would end poverty and world hunger. Instead it is sitting there idle like the gold in Fort Knox. `SUDO` fixes this. It is a common mistake to send [ERC-20](./eip-20.md) tokens to the token address instead of the intended recipient. This happens

RATIONALE:
The `GAS` parameter is first so that callers can tediously compute how much of their remaining gas to send at the last possible moment. The remaining parameters inherited from `CALL` are in the same order, with sender inserted between.


=== EIP-2124 ===
TITLE: Fork identifier for chain compatibility checks
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2019-05-03
REQUIRES: 

SUMMARY:
There are many public and private Ethereum networks, but the discovery protocol doesn't differentiate between them. The only way to check if a peer is good or bad (same chain or not), is to establish a TCP/IP connection, wrap it with RLPx cryptography, then execute an `eth` handshake. This is an extreme cost to bear if it turns out that the remote peer is on a different network and it's not even precise enough to differentiate Ethereum and Ethereum Classic. This cost is magnified for small networks, where a lot more trial and errors are needed to find

SPECIFICATION:
Each node maintains the following values: - **`FORK_HASH`**: IEEE CRC32 checksum (`[4]byte`) of the genesis hash and fork blocks numbers that already passed. - The fork block numbers are fed into the CRC32 checksum in ascending order. - If multiple forks are applied at the same block, the block number is checksummed only once. - Block numbers are regarded as `uint64` integers, encoded in big endian format when checksumming. - If a chain is configured to start with a non-Frontier ruleset already in its genesis, that is NOT considered a fork. - **`FORK_NEXT`**: Block number (`uint64`) of the

MOTIVATION:
Peer-to-peer networking is messy and hard due to firewalls and network address translation (NAT). Generally only a small fraction of nodes have publicly routed addresses and P2P networks rely mainly on these for forwarding data for everyone else. The best way to maximize the utility of the public nodes is to ensure their resources aren't wasted on tasks that are worthless to the network. By aggressively cutting off incompatible nodes from each other we can extract a lot more value from the public nodes, making the entire P2P network much more robust and reliable. Supporting this network partitioning

RATIONALE:
##### Why flatten `FORK_HASH` into 4 bytes? Why not share the entire genesis and fork list? Whilst the `eth` devp2p protocol permits arbitrarily much data to be transmitted, the discovery protocol's total space allowance for all ENR entries is 300 bytes. Reducing the `FORK_HASH` into a 4 bytes checksum ensures that we leave ample room in the ENR for future extensions; and 4 bytes is more than enough for arbitrarily many Ethereum networks from a (practical) collision perspective. ##### Why use IEEE CRC32 as the checksum instead of Keccak256? We need a mechanism that can flatten arbitrary data


=== EIP-1470 ===
TITLE: Smart Contract Weakness Classification (SWC)
TYPE: Informational 
STATUS: Stagnant
CREATED: 2018-09-18
REQUIRES: 

SUMMARY:
The SWC is a smart contract specific software weakness classification scheme for developers, tool vendors and security practitioners. The SWC is loosely aligned to the terminologies and structure used in the [Common Weakness Enumeration - CWE](https://cwe.mitre.org) scheme while overlaying a wide range of weakness variants that are specific to smart contracts. The goals of the SWC scheme are as follows: - Provide a straightforward way to classify weaknesses in smart contract systems. - Provide a straightforward way to identify the weakness(es) that lead to a vulnerability in a smart contract system. - Define a common language for describing

SPECIFICATION:
Before discussing the SWC specification it is important to describe the terminology used: - Weakness: A software error or mistake that in the right conditions can by itself or coupled with other weaknesses lead to a vulnerability. - Vulnerability: A weakness or multiple weaknesses which directly or indirectly lead to an undesirable state in a smart contract system. - Variant: A specific weakness that is described in a very low detail specific to Ethereum smart contracts. Each variant is assigned a unique SWC ID. - Relationships: CWE has a wide range of _Base_ and _Class_ types that group

MOTIVATION:
In the software security industry, it is a widely accepted practice to use a common terminology and to classify security related bugs and errors with a standardized scheme. While this has not stopped vulnerabilities from appearing in software, it has helped communities focusing on web applications, network protocols, IOT devices and various other fields to educate users and developers to understand the nature of security related issues in their software. It has also allowed the security community to quickly understand vulnerabilities that occur in production systems to perform root cause analysis or triage findings from various security analysis


=== EIP-7797 ===
TITLE: Double speed for hash_tree_root
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-10-23
REQUIRES: 

SUMMARY:
This EIP explains how to customize [`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md#merkleization) to double its performance.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### SHA-256 preprocessing Before SHA-256 hash computation begins, the input message is preprocessed. A single `1` bit is appended to the input message, followed by a varying number of `0` bits, and finally a big endian `uint64` indicating the input message bit length. The number of `0` bits is chosen so that the message size is the smallest possible multiple of 512 bits. In

MOTIVATION:
Hashing is a dominant performance bottleneck for Consensus Layer implementations. To support large validator counts, it is critical to optimize hashing performance. Consensus Layer hashes are based on [`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md#merkleization), a mechanism that splits up the data into chunks and then forms a tree by recursively combining two adjacent chunks and hashing them into a single parent chunk until only a single root chunk remains. For hashing, Secure Hash Algorithm 2 with a digest size of 256 bits is used (SHA-256). This algorithm produces _exactly_ 256 bits of output for a variable-length input message. However, as `hash_tree_root` pads all

RATIONALE:
Doubling the throughput of the underlying hash algorithm allows scaling to more validators on the same hardware, or allows using the freed CPU time for other tasks. Even when caching rarely-changed intermediate hashes across computations such as the `validators` list of a `BeaconState`, and employing hardware-accelerated SHA-256 implementations that are further optimized for the tree structure using libraries such as `prysmaticlabs/hashtree`, the state root validation step of the Consensus Layer state transition function can still consume ~25% of CPU time (Holesky test network, ~1.7m validators), mostly dominated by frequently changing per-validator structures such as the `EpochParticipationFlags` lists. If


=== EIP-7591 ===
TITLE: BLS signed transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-01-10
REQUIRES: 

SUMMARY:
This EIP introduces a new [EIP-2718](./eip-2718.md) transaction type that is signed with BLS signatures.

SPECIFICATION:
BLS_TX_TYPE = Bytes1(0x04) ### Transaction Type The transaction type will have the following format: ``` [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, sender, signature] ``` with `sender` being the BLS public key of an account with address `address = [0:20](keccak256(sender))`. The signature value `signature` is calculated by constructing a BLS signature over the following digest: `tx_hash = keccak256(BLS_TX_TYPE || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, sender]))`. ### Header changes The block header will be amended with the `aggregated_sig` field, containing an aggregated signature of all BLS transactions in the block. The resulting RLP

MOTIVATION:
The BLS signature scheme allows for easy aggregation and verification of aggregated signatures. If a substantial number of transactions on mainnet were BLS signed transactions, we can aggregate signatures in a block and batch-verify them. This will reduce growth of the chain history.

RATIONALE:
Removing the ECDSA signature from a transaction saves 65 bytes. The BLS public key is 48 bytes, the aggregated signature is 96 bytes. Thus we save `-96 + (65-48)* #transactions` bytes per block. With ~7000 blocks per day, 1.000.000 transactions per day, the average block contains roughly 150 transactions. Thus we would save 2454 bytes or 2.4KB per block. This would equate to ~1.5% saving given an average block size of 160KB. In addition to the (admittedly meager) size savings for full nodes, the ability to add a new transaction type to utilize a different signature scheme does


=== EIP-2733 ===
TITLE: Transaction Package
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-06-16
REQUIRES: 2718

SUMMARY:
Introduce a new transaction type which includes a list of transactions that must be executed serially by clients. Execution information (e.g. success, gas_used, etc.) will be propagated forward to the next transaction.

SPECIFICATION:
Introduce a new [EIP-2718](./eip-2718.md) transaction type where `id = 2`. #### Structure ``` struct TransactionPackage { chain_id: u256, children: [ChildPackage], nonce: u64, gas_price: u256, v: u256, r: u256, s: u256 } ``` ##### Hash `keccak256(rlp([2, chain_id, children, nonce, gas_price, v, r, s])` ##### Signature Hash `keccak256(rlp([2, chain_id, children, nonce, gas_price])` ##### Receipt Each `ChildTransaction` transaction will generate a `ChildReceipt` after execution. Each of these receipts will be aggregated into a `Receipt`. ``` type Receipt = [ChildReceipt] ``` ``` struct ChildReceipt { status: u256, cumulative_gas_used: u256, logs_bloom: [u8; 256], logs: [u8] } ``` #### Child Transaction Let `ChildPackage` be

MOTIVATION:
Onboarding new users to Ethereum has been notoriously difficult due to the need for new users to acquire enough ether to pay for their transactions. This hurdle has seen a significant allocation of resources over the years to solve. Today, that solution is meta-transactions. This is, unfortunately, a brittle solution that requires signatures to be recovered within a smart contract to authenticate the message. This EIP aims to provide a flexible framework for relayers to "sponsor" many transactions at once, trustlessly. Meta-transactions often use relay contracts to maintain nonces and allow users to pay for gas using alternative

RATIONALE:
### Each `Child` has its own signature For simplicity, the author has chosen to require each child package to specify its own signature, even if the signer is the same as the package signer. This choice is made to allow for maximum flexibility, with minimal client changes. This transaction can still be used by a single user at the cost of only one additional signature recovery. ### `ChildPackage` specifies `max_gas_price` instead of `gas_price` Allowing child packages to specify a range of acceptable gas prices is strictly more versatile than a static price. It gives relayers more flexibility in


=== EIP-7676 ===
TITLE: EOF - Prepare for Address Space Extension
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-03
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 7, 0, 6, 9

SUMMARY:
Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This EIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve bytes need to be zero or an exceptional halt is raised.

SPECIFICATION:
We introduce one new instruction: - `EXTBALANCE` (`tbd`) with arguments `(target_address)`, returning `balance` `EXTBALANCE` will pop one stack item off of the stack, the address of another account or contract. The balance of that account or contract will be pushed onto the stack. If `EXTBALANCE` is invoked with any of the high 12 bytes in `target_address` set to a non-zero value the operation will cause an exceptional halt. All gas in the current frame will be consumed on failure, no gas schedule change is needed. The gas cost of `EXTBALANCE` will be costed according to the gas schedule

MOTIVATION:
There have been proposals to extend Ethereum Addresses from 160 bits to 256, such as one that would use the extra bits for state expiry (such as the ethereum magicians forum topic "Increasing the address size from 20 to 32 bytes"). One issue ground the work to a halt: EVM opcodes that accept addresses trim all but the lowest 20 bytes out from the operand before processing. EVM Reference tests verify this behavior in the 'stBadOpcode/invalidAddr.json' tests. The EVM Object Format presents an opportunity to remove this address masking in a backwards compatible way, by baking it into

RATIONALE:
### New Opcode There is no need to ban the `BALANCE` opcode as it does not cause any problems that would require banning it within an EOF container. Adding a new opcode also allows the existing opcode to behave the same in EOF and legacy code, reducing potential friction points for end user confusion and bugs. ### Revert on invalid address There are two alternative ways to handle accounts with high bits set. The specification calls for an exceptional halt, but the alternative was to treat the account as empty. The reason the "empty account" approach was rejected


=== EIP-7921 ===
TITLE: Skip `JUMPDEST` immediate argument check
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-26
REQUIRES: 

SUMMARY:
Allow `JUMP` and `JUMPI` to arrive at any byte matching `JUMPDEST` (`0x5b`), even if that byte is an immediate argument.

SPECIFICATION:
When activated, all `0x5b` bytes are valid `JUMPDEST` for `JUMPI` and `JUMP` opcodes.

MOTIVATION:
Immediate arguments are opcode parameters supplied within the code rather than the stack. Currently determining the validity of a `JUMPDEST` requires determining which bytes are immediate arguments to other opcodes, such as `PUSH1`. This presents several problems: 1. Codesize is a linear DoS vector because code must be preprocessed to determine `JUMPDEST` validity. 2. New opcodes with immediate arguments cannot be safely adopted. 3. `CODECOPY` data spans can invalidate subsequent `JUMPDEST`. The rationale for this `JUMPDEST` validity check is to prevent unintended code execution. However, almost all `JUMP` and `JUMPI` target constant destinations. Removing this check allows larger

RATIONALE:
Removing the check solves several problems while reducing EVM complexity.


=== EIP-1559 ===
TITLE: Fee market change for ETH 1.0 chain
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-04-13
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new [EIP-2718](./eip-2718.md) transaction type, with the format `0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`. There is a base fee per gas in protocol, which can move up or down each block according to a formula which is a function of gas used in parent block and gas target (block gas limit divided by elasticity multiplier) of parent block. The algorithm results in the base fee per gas increasing when blocks are above the gas target, and decreasing when blocks are below the gas target. The base fee per

SPECIFICATION:
Block validity is defined in the reference implementation below. The `GASPRICE` (`0x3a`) opcode **MUST** return the `effective_gas_price` as defined in the reference implementation below. As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` 2. The intrinsic cost of the new transaction is inherited from [EIP-2930](./eip-2930.md), specifically `21000 + 16 * non-zero calldata bytes + 4 * zero calldata bytes + 1900 * access list storage key count + 2400 * access list address count`. The [EIP-2718](./eip-2718.md) `TransactionPayload` for this transaction is `rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`. The `signature_y_parity, signature_r,

MOTIVATION:
Ethereum historically priced transaction fees using a simple auction mechanism, where users send transactions with bids ("gasprices") and miners choose transactions with the highest bids, and transactions that get included pay the bid that they specify. This leads to several large sources of inefficiency: * **Mismatch between volatility of transaction fee levels and social cost of transactions**: bids to include transactions on mature public blockchains, that have enough usage so that blocks are full, tend to be extremely volatile. It's absurd to suggest that the cost incurred by the network from accepting one more transaction into a block


=== EIP-2515 ===
TITLE: Implement Difficulty Freeze
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-10
REQUIRES: 

SUMMARY:
The difficulty Freeze is a mechanism that is easy to predict and model, and the pressures of missing it are more readily felt by the core developers and client maintainers. The client maintainers are also positioned as the group that is most able to respond to an incoming Difficulty Freeze. This combined with the predictability is more likely to lead to the timely diffusual of the bomb.

SPECIFICATION:
Add variable `DIFFICULTY_FREEZE_HEIGHT` The logic of the Difficulty Freeze is defined as follows: ``` if (BLOCK_HEIGHT <= DIFFICULTY_FREEZE_HEIGHT): block_diff = parent_diff + parent_diff // 2048 * max( 1 - (block_timestamp - parent_timestamp) // 10, -99) else: block_diff = parent_diff + parent_diff * 0.01 ``` **Optional Implementation** Add the variable `DIFFICULTY_FREEZE_DIFFERENCE` and use the `LAST_FORK_HEIGHT` to calculate when the Difficulty Freeze would occur. For example we can set the `DFD = 1,800,000 blocks` or approximately 9 months. The Difficulty Calculation would then be. ``` if (BLOCK_HEIGHT <= LAST_FORK_HEIGHT + DIFFICULTY_FREEZE_DIFFERENCE) : block_diff = parent_diff + parent_diff // 2048 *

MOTIVATION:
The current difficulty bombs' effect on the Block Time Targeting mechanism is rather complex to model, and it has both appeared when it was not expected (Muir Glacier) and negatively affected miners when they are not the target (in the case of delaying forks due to technical difficulties). Miners are affected by a reduction in block rewards due to the increase in block time. Users are affected as a function of the usability of the chain is affected by increased block times. Both of these groups are unable on their own to address the difficulty bomb. In the

RATIONALE:
Block height is very easy to predict and evaluate within the system. This removes the effect of the Difficulty Bomb on block time, simplifying the block time targeting mechanism. The addition of an increase in the difficulty was added after feedback that the game theory of the mechanism did not reliably result in . https://twitter.com/quentinc137/status/1227110578235330562


=== EIP-3267 ===
TITLE: Giving Ethereum fees to Future Salaries
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-02-13
REQUIRES: 

SUMMARY:
Transfer a part (exact fractions - TBD) of mining/transfer fees + (probably: TBD) some minted ETH to the `DonateETH` contract configured to transfer to `SalaryWithDAO` contract.

SPECIFICATION:
(TBD) `SalaryWithDAO` = `TBD` (`address`) `DefaultDAOInterface` = `TBD` (`address`) `MintPerPeriod` = `TBD` (`uint256`) `TransferFraction` = `TBD` (0..1) `MineFraction` = `TBD` (0..1) [The contract's source](../assets/eip-3267/contracts/README.md) Prior to `FORK_BLOCK_NUMBER`, `SalaryWithDAO` and `DefaultDAOInterface` contracts will be deployed to the network and exist at the above specified addresses. Change the Ethereum clients to transfer at every ETH transfer and every ETH mine a fixed fraction `TransferFraction` of the transferred ETH and `MineFraction` of the mined ETH to a fixed account (decide the account number, it can be for example `0x00000000000000000000000000000000000000001` or even `0x00000000000000000000000000000000000000000` or a random account). Change the Ethereum clients to

MOTIVATION:
This proposal solves two problems at once: 1. It provides a big amount of "money" to common good producers. That obviously personally benefits common good producers, allowing them to live better human lives, it increases peoples' and organizations' both abilities and incentives to produce common goods. That benefits the humanity as a whole and the Ethereum ecosystem in particular. See more in the discussion why it's crucial. 2. This would effectively decrease circulating ETH supply. The necessity to decrease the (circulating) ETH supply (by locking ETH in Future Salaries system for a long time) is a well-known important

RATIONALE:
The Future Salaries is the _only_ known system of distributing significant funds to common good producers. (Quadratic funding aimed to do a similar thing, but in practice as we see on GitCoin it favors a few developers, ignores project of highly advanced scientific research that is hard to explain to an average developer, and encourages colluding, and it just highly random due to small number of donors. Also quadratic funding simply does not gather enough funds to cover common good needs). So this EIP is the only known way to recover the economy. The economical model of Future


=== EIP-7610 ===
TITLE: Revert creation in case of non-empty storage
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-02-02
REQUIRES: 

SUMMARY:
This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. If a contract creation is attempted due to a creation transaction, the `CREATE` opcode, the `CREATE2` opcode, or any other reason, and the destination address already has either a nonzero nonce, a nonzero code length, or non-empty storage, then the creation MUST throw as if the first byte in the init code were an invalid opcode. This change MUST apply retroactively for all existing

RATIONALE:
EIP-684 defines two conditions for contract deployment: the destination address must have zero nonce and zero code length. Unfortunately, this is not sufficient. Before [EIP-161](./eip-161.md) was applied, the nonce of a newly deployed contract remained set to zero. Therefore, it was entirely possible to create a contract with a zero nonce and zero code length but with non-empty storage, if slots were set in the constructor. There exists 28 such contracts on Ethereum mainnet at this time. As one of the core tenets of smart contracts is that its code will not change, even if the code is


=== EIP-7650 ===
TITLE: Programmable access lists
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-10
REQUIRES: 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new precompiled contract named `prefetch`, which accepts an `accessList`. The `accessList` specifies a list of addresses and local storage keys; these addresses and local storage keys are added into the `accessed_addresses` and `accessed_storage_keys` global sets (introduced in [EIP-2929](./eip-2929.md)). Similar to [EIP-2930](./eip-2930.md), prefetching data through this precompile incurs a gas charge, albeit at a reduced rate compared to accesses made outside of this list.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Parameters | Constant | Value | | ----------------------------- | ----- | | `FORK_BLOCK_NUMBER` | `TBD` | | `PREFETCH_PRECOMPILE_ADDRESS` | `TBD` | | `CONCURRENCY` | `TBD` | As of `FORK_BLOCK_NUMBER`, a new precompile is deployed at `PREFETCH_PRECOMPILE_ADDRESS`. The encoding of the precompile input is the following: ```text [32 bytes for local storage key length n][n * 32 bytes local storage keys][32 bytes for address length m][m * 32 bytes addresses]

MOTIVATION:
The primary goal of this EIP is to enhance EIP-2930 by enabling contracts to add access lists programmatically. The advantage of implementing this precompile within a contract is the sustained reduction in gas costs for data access operations, leveraging the concurrent computing and IOs that most nodes have.

RATIONALE:
### Charging less for accesses in the access list Similar to EIP-2930, we encourage contract developers to use the `prefetch` precompile as much as possible, especially assuming the nodes have some decent concurrent capabilities (e.g., some cores and IO bandwidth). ### Allowing duplicates Similar to EIP-2930, we allow duplicates in the list to maximize simplicity. ### No storage keys for external contract Unlike EIP-2930, the `prefetch` precompile only accepts local storage keys and addresses. Prefetching the data of the storage keys of external contracts assumes that the contract knows the storage layout of an external contract, which may


=== EIP-7569 ===
TITLE: Hardfork Meta - Dencun
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-01
REQUIRES: 1, 1, 5, 3, ,,  , 4, 7, 8, 8, ,,  , 4, 8, 4, 4, ,,  , 5, 6, 5, 6, ,,  , 6, 7, 8, 0, ,,  , 7, 0, 4, 4, ,,  , 7, 0, 4, 5, ,,  , 7, 5, 1, 4, ,,  , 7, 5, 1, 6, ,,  , 7, 5, 6, 8

SUMMARY:
This Meta EIP lists the EIPs included in the Dencun network upgrade across both Ethereum's execution and consensus layers.

SPECIFICATION:
### Included EIPs * [EIP-1153](./eip-1153.md): Transient storage opcodes * [EIP-4788](./eip-4788.md): Beacon block root in the EVM * [EIP-4844](./eip-4844.md): Shard Blob Transactions * [EIP-5656](./eip-5656.md): MCOPY - Memory copying instruction * [EIP-6780](./eip-6780.md): SELFDESTRUCT only in same transaction * [EIP-7044](./eip-7044.md): Perpetually Valid Signed Voluntary Exits * [EIP-7045](./eip-7045.md): Increase Max Attestation Inclusion Slot * [EIP-7514](./eip-7514.md): Add Max Epoch Churn Limit * [EIP-7516](./eip-7516.md): BLOBBASEFEE opcode ### Full Specifications #### Consensus Layer EIPs 4788, 4844, 7044, 7045 and 7514 require changes to Ethereum's consensus layer. These are specified in the `deneb` folder of the `ethereum/consensus-specs` repository. #### Execution Layer EIPs 1153, 4788, 4844, 5656,

RATIONALE:
This Meta EIP provides a global view of all changes included in the Dencun network upgrade, as well as links to full specification.


=== EIP-8015 ===
TITLE: Remove `deposit` and `eth1data` fields
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-22
REQUIRES: 6, 1, 1, 0, ,,  , 7, 7, 3, 2

SUMMARY:
This EIP removes the legacy `deposits` and `eth1_data` fields from the `BeaconBlockBody` structure after [EIP-6110](./eip-6110.md) has been fully finalized. These fields become obsolete once all validators have transitioned to the new in-protocol deposit processing mechanism introduced in EIP-6110.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### Consensus Layer #### Activation Conditions This EIP SHALL only be activated when both of the following conditions are met: 1. EIP-6110 has been fully finalized: `state.eth1_deposit_index == state.deposit_requests_start_index` 2. EIP-7732 is in effect #### BeaconBlockBody Modifications The `BeaconBlockBody` container is modified to remove the following fields: **Removed fields:** - `deposits: List[Deposit, MAX_DEPOSITS]` - `eth1_data: Eth1Data` The updated `BeaconBlockBody` structure becomes: ```python class BeaconBlockBody(Container):

MOTIVATION:
EIP-6110 introduced in-protocol deposit processing by moving validator deposits to the execution layer as part of the EIP-7685 request framework. This change eliminated the need for the consensus layer's proposer voting mechanism for deposits. However, during the transition period, both the legacy deposit mechanism (using `deposits` and `eth1_data` fields) and the new mechanism coexist to ensure smooth migration. Once EIP-6110 has been fully finalized and the transition period is complete (when `state.eth1_deposit_index == state.deposit_requests_start_index`), the legacy deposit fields become permanently unused and can be safely removed. This cleanup provides several benefits: - **Simplified validation**: Removes deprecated validation logic

RATIONALE:
### Timing of Removal The fields are removed after EIP-6110 finalization to ensure: - All pending deposits from the legacy system have been processed - No validator can be affected by the removal - The transition is complete and irreversible - State consistency is maintained across all honest nodes ### Dependency on EIP-7732 This EIP requires EIP-7732 because: - EIP-7732 already modified the `BeaconBlockBody` structure significantly - It provides the architectural foundation for simplified block bodies - The timing aligns with the broader consensus layer improvements


=== EIP-2035 ===
TITLE: Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-16
REQUIRES: 

SUMMARY:
It is part of the State Rent roadmap. This particular change prepares Ethereum for introduction of the block proofs (current understanding is that they can be introuced without a hard fork). The introduction of the block proofs allows any Ethereum node that wishes to receive them, to process transactions in the blocks without needing to access the Ethereum state. All necessary information for the execution (and the proof of validity) is continued in the block proofs. In most Ethereum nodes, it will speed up the block processing and reduce the memory footprint of such processing. For mining nodes,

SPECIFICATION:
Not very formal at the moment, but will be formalised with more research and prototyping. Gas of operations `SLOAD` and `SSTORE` increases by `X` gas when the storage slots accessed (read by `SLOAD` or written by `SSTORE`) were not previously accessed (by another `SLOAD` or `SSTORE`) during the same transaction. Future variant (will be possible after the implementation of the *Gross contract size acccounting*) is researched, where the increase is varied depending on the size of the contract storage, i.e. `SLOAD` and `SSTORE` for smaller contracts will be cheaper.

MOTIVATION:
There is [empirical analysis](https://github.com/holiman/vmstats/blob/master/README.md) showing that `SLOAD` opcode is currently underpriced in terms of execution latency it adds to the block processing. The hypothesis is that it is due to the latency of the database accesses. In the same analysis, `SSTORE` is not considered, because its effect on the database accesses can be (and are in many implementations) delayed until the end of the block. Stateless clients approach to the contract storage will largely negate that latency because no database accesses will be required. Instead, bandwidth consumption goes up. There is emprical analysis (unpublished, but will be) suggesting

RATIONALE:
[EIP-1884](./eip-1884.md) seeks to increase the gas cost of `SLOAD` but using a different justification (latency of the execution as described in the Motivation). This EIP is likely to increase the cost of `SLOAD` by a larger amount, therefore partially (because EIP-1884 also proposed other increases) supersedes EIP-1884. [EIP-2028](./eip-2028.md) describes the model that can be used for deciding the gas cost of data transmission. It is relevant because in the stateless client regime `SSTORE` and `SLOAD` operations add more data to be transmitted (as well as computation to verify the proofs). The main alternate design is the rent proportional


=== EIP-7819 ===
TITLE: SETDELEGATE instruction
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-18
REQUIRES: 7702

SUMMARY:
Introduce a new instruction that allows smart contracts to create (and update) delegation accounts that match [EIP-7702](./eip-7702.md)'s design. These accounts can be used similarly to [ERC-1167](./eip-1167.md) clones, with significant advantages.

SPECIFICATION:
A new instruction (`SETDELEGATE`) is added at `0xf6`. ### Behavior Executing this instruction does the following: 1. deduct `EMPTY_ACCOUNT_COST` gas 2. halt if the current frame is in `static-mode` 3. pop `salt`, `target` from the operand stack 4. calculate `location` as `keccak256(MAGIC ++ address ++ salt)[12:]` 5. add `location` to `accessed_addresses`, as defined in [EIP-2929](./eip-2929.md) 6. halt if the code at `location` is not empty and does not start with `0xEF0100` (no empty and not a delegation indicator) 7. add `EMPTY_ACCOUNT_COST - BASE_COST` gas to the global refund counter if `location` exists in the trie. 8. set the

MOTIVATION:
Many on-chain applications involve creating multiple instances of the same code at different locations. These applications often rely on clones, or proxies, to reduce deployment costs. Clones, such as the one described in ERC-1167 are minimal pieces of code that contain the target address directly in the code. That makes them extremely light but prevents any form of reconfiguration (upgradability). Upgradeable proxies differ from clones in that they read the implementation's address from storage. This makes them more versatile but also more expensive to use. In both cases delegating the received calls to an implementation using EVM code

RATIONALE:
### Gas cost The execution of the `SETDELEGATE` instruction involves fewer moving pieces than what EIP-7702 gas costs account for: - there is no signature recovery - there is no dedicated calldata that must be accounted for that is not already paid for at the transaction level - there is no nonce update Therefore, the cost of executing this instruction could be lower than EIP-7702. Numbers from EIP-7702 are reused for simplicity. They are lower than `CREATE` or `CREATE2` operations, making the use of this instruction competitive for the intended use-cases.


=== EIP-1571 ===
TITLE: EthereumStratum/2.0.0
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-11-09
REQUIRES: 

SUMMARY:
This draft contains the guidelines to define a new standard for the Stratum protocol used by Ethereum miners to communicate with mining pool servers. ### Conventions The key words `MUST`, `MUST NOT`, `REQUIRED`, `SHALL`, `SHALL NOT`, `SHOULD`, `SHOULD NOT`, `RECOMMENDED`, `MAY`, and `OPTIONAL` in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119). The definition `mining pool server`, and it's plural form, is to be interpreted as `work provider` and later in this document can be shortened as `pool` or `server`. The definition `miner(s)`, and it's plural form, is to be interpreted as `work receiver/processor` and

SPECIFICATION:
The Stratum protocol is an instance of [JSON-RPC-2.0](https://www.jsonrpc.org/specification). The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of a `session`. A session starts at the moment a client opens a TCP connection to the server till the moment either party do voluntary close the very same connection or it gets broken. Servers **MAY** support session resuming if this is initially negotiated (on first session handshaking) between the client and the server. During a session all messages exchanged among server and client are line-based which means all messages are

RATIONALE:
Ethereum does not have an official Stratum implementation yet. It officially supports only getWork which requires miners to constantly pool the work provider. Only recently go-ethereum have implemented a [push mechanism](https://github.com/ethereum/go-ethereum/pull/17347) to notify clients for mining work, but whereas the vast majority of miners do not run a node, it's main purpose is to facilitate mining pools rather than miners. The Stratum protocol on the other hand relies on a standard stateful TCP connection which allows two-way exchange of line-based messages. Each line contains the string representation of a JSON object following the rules of either [JSON-RPC 1.0](https://www.jsonrpc.org/specification_v1)


=== EIP-7686 ===
TITLE: Linear EVM memory limits
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-15
REQUIRES: 

SUMMARY:
Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of memory.

SPECIFICATION:
Change `memory_cost` from: ```python memory_size_word = (memory_byte_size + 31) / 32 memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word) ``` To: ```python memory_size_word = (memory_byte_size + 31) / 32 memory_cost = 3 * memory_size_word ``` Additionally, if a memory expansion would lead to `memory_byte_size` strictly exceeding the current call's initial gas limit, revert with an error. When making any type of call, change the maximum gas limit from the current [EIP-150](eip-150.md) definition: ```python def max_call_gas(gas): return gas - (gas // 64) ``` To: ```python def max_call_gas(gas, memory_byte_size): return gas - max(gas // 64, memory_byte_size) ```

MOTIVATION:
Today, memory pricing rules are complicated: we have the quadratic cost for expanding memory as well as the 63/64 rule for how much gas can go into a child call. This also makes it extremely hard to calculate a maximum possible amount of memory required to process a given EVM execution. The rules in this post simplify these rules, and add a new hard limit: an EVM execution with N gas can require at most N total bytes of memory to process. This limit is tight: there are easy ways for an N-gas call to use `N -

RATIONALE:
With this EIP, there is a simple EVM implementation that can process an N-gas call using an N-byte bytearray as memory: allocate all bytes to the current context, when doing a child call use the remaining memory starting from the position `memory_byte_size` for the child call's memory, and so on recursively. Having this clean invariant is useful for EVM implementations, especially EVM implementations in constrained environments (eg. ZK-SNARK provers). The 3 gas per word memory expansion cost is retained because it is equivalent to MCOPY, and so the operation of clearing memory at the end of a child


=== EIP-858 ===
TITLE: Reduce block reward and delay difficulty bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-01-29
REQUIRES: 

SUMMARY:
The current public Ethereum network has a hashrate that corresponds to a tremendous level of energy consumption. As this energy consumption has a correlated environmental cost the network participants have an ethical obligation to ensure this cost is not higher than necessary. At this time, the most direct way to reduce this cost is to lower the block reward in order to limit the appeal of ETH mining. Unchecked growth in hashrate is also counterproductive from a security standpoint. Recent research developments also now time the switch to POS as sometime in 2019 and as a result there

SPECIFICATION:
Delay difficulty bomb by 2,000,000 blocks Adjust block, uncle, and nephew rewards to reflect a new block reward of 1 ETH.

MOTIVATION:
The current public Ethereum network has a hashrate of 296 TH/s. This hashrate corresponds to a power usage of roughly [1 TW](../assets/eip-858/calculations.md) and yearly energy consumption of 8.8 TWh (roughly 0.04% of [total](https://en.wikipedia.org/wiki/List_of_countries_by_electricity_consumption) global electricity consumption). A future switch to full Proof of Stake will solve this issue entirely. Yet that switch remains enough in the future that action should be taken in the interim to limit excess harmful side affects of the present network.

RATIONALE:
This will delay the difficulty bomb by roughly a year. The difficulty bomb remains a community supported mechanism to aid a future transition to POS. The network hashrate provides security by reducing the likelihood that an adversary could mount a 51% attack. A static block reward means that factors (price) may be such that participation in mining grows unchecked. This growth may be counterproductive and work to also grow and potential pool of adversaries. The means we have to arrest this growth is to reduce the appeal of mining and the most direct way to do that is


=== EIP-7514 ===
TITLE: Add Max Epoch Churn Limit
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-09-07
REQUIRES: 

SUMMARY:
Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.

SPECIFICATION:
### Constants | Name | Value | | ---- | ----- | | `MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT` | 8 | ### Execution layer This requires no changes to the Execution Layer. ### Consensus layer - Add `get_validator_activation_churn_limit` with upper bound `MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT` - Modify `process_registry_updates` to use bounded activation churn limit The full specification of the proposed change can be found in [`/specs/deneb/beacon-chain.md`](https://github.com/ethereum/consensus-specs/blob/69d34dc4ee3d026ca437d1b6875b218e8aaf3a5c/specs/deneb/beacon-chain.md).

MOTIVATION:
This proposal aims to mitigate the negative externalities of very high level of total ETH supply staked before a proper solution is implemented. In other words, this proposal accepts the complexities of changing the rewards curve and is meant only to slow down growth. In the event that the deposit queue stays 100% full, the share of ETH supply staked will reach 50% by May 2024, 75% by September 2024, and 100% by December 2024. While rewards decrease as the validator set size increases, at 100% of ETH supply staked, yearly consensus rewards alone (excluding MEV/transaction fees) for

RATIONALE:
### `MAX_PER_EPOCH_CHURN_LIMIT` value Depending on the specific constant selection the churn can _decrease_ at the activation fork epoch. The Beacon chain spec can handle this without issues. During 2023 Q4 (projected Dencun activation) the churn value will range 14-16. The table below compares the projected validator set assuming a continuous full deposit queue. #### `MAX_PER_EPOCH_CHURN_LIMIT` activation date: Dec 01, 2023 | Max Churn Limit | 50% ETH staked | 75% ETH staked | 100% ETH staked | |------------------:|:-----------------|:-----------------|:------------------| | inf | May 28, 2024 | Sep 25, 2024 | Dec 18, 2024 | | 16 | Jul 23,


=== EIP-7742 ===
TITLE: Uncouple blob count between CL and EL
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-07-12
REQUIRES: 4844

SUMMARY:
Update blob maximum and target verification from [EIP-4844](./eip-4844.md). The execution layer no longer verifies the blob maximum and receives the target dynamically from the consensus layer.

SPECIFICATION:
### Block structure and validity Upon activation of this EIP, execution clients **MUST** extend the header schema with an additional 64-bit field: the `target_blobs_per_block`. This value is set to the current target blob count. The Engine API is modified along with this EIP to provide the `target_blobs_per_block` with each payload and implementations can use this value to correctly set the block header field. Validity of the `target_blobs_per_block` is guaranteed from the consensus layer, much like how withdrawals are handled. When verifying a block, execution clients **MUST** ensure the target blob count in the block header matches the one

MOTIVATION:
Following EIP-4844, the execution layer (EL) maintains a hard-coded blob target value and blob maximum value. Given the relationship of the EL and the consensus layer (CL) node software, the verification of the blob maximum is redundant so it can be removed entirely without any change in security. The blob maximum is still provided during block construction via the Engine API. This EIP also changes how the EL sources the current blob target value for two reasons: 1) Gain more flexibility over the value, rather than the static `TARGET == MAX // 2` relation in EIP-4844. 2) Uncouple

RATIONALE:
### Why not have the CL also compute the blob base fee and remove any notion of blob counts from EL processing? Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack. The CL maintains a maximum value to address e.g. DoS risks, and the EL maintains knowledge of the target value to address fee accounting. Putting the target computation in the CL violates the respective responsibilities of each layer.


=== EIP-3045 ===
TITLE: Adds `baseFee` to `eth_getUncleByBlockHashAndIndex`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getUncleByBlockHashAndIndex` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getUncleByBlockHashAndIndex` #### Description Returns information about an uncle specified by block hash and uncle index position Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork block **MUST** include a `baseFee` field. #### Parameters Parameters remain unchanged. #### Returns For the full specification of `eth_getUncleByBlockHashAndIndex` see [EIP-1474](./eip-1474.md). Add a new JSON field to the `result` object for block headers containing a base fee (post [EIP-1559](./eip-1559.md) fork block). - {[`Quantity`](./eip-1474.md#quantity)} `baseFee`

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-4488 ===
TITLE: Transaction calldata gas cost reduction with total calldata limit
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-11-23
REQUIRES: 

SUMMARY:
Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.

SPECIFICATION:
| Parameter | Value | | - | - | | `NEW_CALLDATA_GAS_COST` | `3` | | `BASE_MAX_CALLDATA_PER_BLOCK` | `1,048,576` | | `CALLDATA_PER_TX_STIPEND` | `300` | Reduce the gas cost of transaction calldata to `NEW_CALLDATA_GAS_COST` per byte, regardless of whether the byte is zero or nonzero. Add a rule that a block is only valid if `sum(len(tx.calldata) for tx in block.txs) <= BASE_MAX_CALLDATA_PER_BLOCK + len(block.txs) * CALLDATA_PER_TX_STIPEND`.

MOTIVATION:
Rollups are in the short and medium term, and possibly the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups are significantly reducing fees for many Ethereum users: Optimism and Arbitrum frequently provide fees that are ~3-8x lower than the Ethereum base layer itself, and ZK rollups, which have better data compression and can avoid including signatures, have fees ~40-100x lower than the base layer. However, even these fees are

RATIONALE:
A natural alternative proposal is to decrease `NEW_CALLDATA_GAS_COST` without adding a limit. However, this presents a security concern: today, the average block size [is 60-90 kB](https://etherscan.io/chart/blocksize), but the _maximum_ block size is `30M / 16 = 1,875,000` bytes (plus about a kilobyte of block and tx overhead). Simply decreasing the calldata gas cost from 16 to 3 would increase the maximum block size to 10M bytes. This would push the Ethereum p2p networking layer to unprecedented levels of strain and risk breaking the network; some previous live tests of ~500 kB blocks a few years ago had already


=== EIP-7762 ===
TITLE: Increase MIN_BASE_FEE_PER_BLOB_GAS
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-08-31
REQUIRES: 4844

SUMMARY:
This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob base fee spike.

SPECIFICATION:
### `MIN_BASE_FEE_PER_BLOB_GAS` Increase The main specification change introduced by this EIP is setting MIN_BASE_FEE_PER_BLOB_GAS to 2**25: ```diff + MIN_BASE_FEE_PER_BLOB_GAS = 2**25 - MIN_BASE_FEE_PER_BLOB_GAS = 1 ``` ### `excess_blob_gas` Reset To avoid a blob base fee spike, the `calc_excess_blob_gas` is modified to reset `excess_blob_gas` to 0 at the fork. To detect the fork height, the block timestamp needs to be passed into `calc_excess_blob_gas`. ```python def calc_excess_blob_gas(parent: Header, block_timestamp: int) -> int: # at the fork, set excess_blob_gas to 0 if parent.timestamp < FORK_TIMESTAMP and block_timestamp >= FORK_TIMESTAMP: return 0 # otherwise, calculate normally ... ``` `validate_block` needs to be

MOTIVATION:
When scoping 4844, the thinking was that blobs would only enter price discovery once, relatively quickly after the blob rollout; however, this has not been the case. In fact, blobs have entered price discovery several times, and the frequency of price discovery events is likely to increase in the short term as we approach saturation of capacity. Moreover, the roadmap calls for further increases in blob capacity in subsequent hardforks, which may lead to price discovery events happening around those changes in the future. Increasing the MIN_BASE_FEE_PER_BLOB_GAS will speed up price discovery on blob space.

RATIONALE:
The current MIN_BASE_FEE_PER_BLOB_GAS is 1 wei. This is many orders of magnitude lower than the prevailing price of blobs when blobs enter price discovery. Whenever demand for blobs exceeds supply, blobs enter price discovery, but traversing the 8 orders of magnitude between 1 wei and the point where elasticity of demand starts to decrease takes a long time. The blob base fee can at most double every $\log_{1.125}(10) = 5.885$ blocks when blocks use all available blob space. When blobs enter price discovery, they must climb many factors of 2 to reach the prevailing price. To set the


=== EIP-4573 ===
TITLE: Procedures for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-12-16
REQUIRES: 2, 3, 1, 5, ,,  , 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 3, 7, 7, 9, ,,  , 4, 2, 0, 0

SUMMARY:
Five EVM instructions are introduced to define, call, and return from named EVM _procedures_ and access their _call frames_ in memory - `ENTERPROC`, `LEAVEPROC`, `CALLPROC`, `RETURNPROC`, and `FRAMEADDRESS`.

SPECIFICATION:
### Instructions #### ENTERPROC (0x??) dest_section: uint8, dest_offset: uint8, n_inputs: uint16, n_outputs: uint16, n_locals: uint16 ``` frame_stack.push(FP) FP -= n_locals * 32 PC +- <length of immediates> ``` Marks the entry point to a procedure * at offset `dest_offset` from the beginning of the `dest_section`. * taking `n_inputs` arguments from the data stack, * returning `n_outputs` values on the `data stack`, and * reserving `n_locals` words of data in memory on the `frame stack`. Procedures can only be entered via a `CALLPROC` to their entry point. #### LEAVEPROC (0x??) ``` FP = frame_stack.pop() asm RETURNSUB ``` > Pop

MOTIVATION:
Currently, Ethereum bytecode has no syntactic structure, and _subroutines_ have no defined interfaces. We propose to add _procedures_ -- delimited blocks of code that can be entered only by calling into them via defined interfaces. Also, the EVM currently has no automatic management of memory for _procedures_. So we also propose to automatically reserve call frames on an in-memory stack. Constraints on the use of _procedures_ must be validated at contract initialization time to maintain the safety properties of [EIP-3779](./eip-3779.md): Valid programs will not halt with an exception unless they run out of gas or recursively overflow stack.

RATIONALE:
There is actually not much new here. It amounts to [EIP-615](./eip-615.md), refined and refactored into bite-sized pieces, along lines common to other machines. This proposal uses the [EIP-2315](./eip-2315.md) return stack to manage calls and returns, and steals ideas from [EIP-615](./eip-615.md), [EIP-3336](./eip-3336.md), and [EIP-4200](./eip-4200.md). `ENTERPROC` corresponds to `BEGINSUB` from EIP-615. Like EIP-615 it uses a frame stack to track call-frame addresses with `FP` as _procedures_ are entered and left, but like EIP-3336 and EIP-3337 it moves call frames from the data stack to memory. Aliasing call frames with ordinary memory supports addressing call-frame data with ordinary stores and loads.


=== EIP-7788 ===
TITLE: Dynamic target blob count
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2024-10-15
REQUIRES: 7742

SUMMARY:
This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.

SPECIFICATION:
### Parameters | Parameter | Value | | - | - | | `FORK_TIMESTAMP` | TBD | | `TARGET_BLOB_COUNT_CHANGE_RATE` | `1` | | `MIN_TARGET_BLOB_COUNT` | `1` | | `MAX_TARGET_BLOB_COUNT` | `3` | | `BLOB_COST_CHANGE_MARGIN` | `2^48` | | `TARGET_BLOB_COST` | `2^49` | ### Dynamic targeting The target blob count changes each epoch based on the mean blob cost over the previous epoch. If the average cost exceeds the desired amount beyond some margin then the target is increased; likewise if it is below the desired amount by some margin the target will decrease. The target can increase up

MOTIVATION:
Ethereum currently uses a target of 50% capacity for blob count, with [EIP-1559](./eip-1559.md) smoothing out short term spikes and pushing average throughput towards the target. A dynamic target is orthogonal to EIP-1559, tweaking the target itself over a longer timescale to aim for some desired blob cost. With static targeting the target may be higher than the actual demand, causing the protocol to undercharge for blobspace. This decreases the amount of fees burned, negatively affecting the price of ETH and total network security. As an example, consider what would happen if there was a large increase in max

RATIONALE:
### Constant blob cost target A constant blob cost target can keep L2 transaction costs affordable for end users. Volatility in the price of ETH would affect affordability, but is unlikely to be significant compared to normal fluctuations in blob gas costs due to spikes in activity. In future the costs could be adjusted in the case of changes in the order of magnitude of ETH price. An alternative approach would be to track a target blob cost in fiat. However, choosing a specific fiat currency is not credibly neutral, and introducing exchange rate oracles into the protocol


=== EIP-2936 ===
TITLE: EXTCLEAR Opcode For SELFDESTRUCTed contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-03
REQUIRES: 

SUMMARY:
Changes `SELFDESTRUCT` (`0xff`) to not clear any storage and adds a new `EXTCLEAR` (`0x5c`) opcode that will clear a specific storage slot for a contract that has previously been self destructed.

SPECIFICATION:
After `FORK_BLOCK_NUM`, a new opcode, `EXTCLEAR`, is enabled at `0x5C` to clear storage for `SELFDESTRUCT`ed contracts. `EXTCLEAR`: * does not push any words onto the stack * pops two words off the stack: the destroyed contract address and a storage address * if the contract exists, charge the same gas cost as `EXTCODEHASH` (`0x3F`) * otherwise, if the storage is zero, charge the same gas as `EXTCODEHASH` plus `SLOAD` * otherwise, the destroyed contract's slot is reset to 0, charging the same gas as `EXTCODEHASH` and `SSTORE` when resetting storage, while also refunding the amount specified in `SSTORE`.

MOTIVATION:
`SELFDESTRUCT` (`0xFF`) is unnecessarily complex because it clears an unbounded amount of contract storage. It is computationally expensive for nodes to track all of the storage used in every contract in case the contract `SELFDESTRUCT`s. Further, contracts can be re-initialized using `CREATE2` (`0xF5`), and then `SLOAD` (`0x54`) prior storage. Therefore, several ethereum clients do not clear storage at all, and just check if the contract was initiated since `SSTORE` (`0x55`) during `SLOAD`. `CREATE2` was not intended to complicate `SLOAD`, and this change reverts that complexity. Also, bugs in this implementation could split the network. Instead this defers the

RATIONALE:
`0x5C` is available in the same range as `SSTORE` and `SLOAD`.


=== EIP-2657 ===
TITLE: Ephemeral Testnet Yolo
TYPE: Meta 
STATUS: Stagnant
CREATED: 2020-04-19
REQUIRES: 

SUMMARY:
The specification for Ephemeral Testnet Yolo. Clients who wish to sync need to implement the following features into their client. It is for testing basic infrastructure and will be nuked.


=== EIP-3675 ===
TITLE: Upgrade consensus to Proof-of-Stake
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-22
REQUIRES: 2124

SUMMARY:
This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented in [EIP-2982](./eip-2982.md). Full specification of the beacon chain can be found in the `ethereum/consensus-specs` repository. This document specifies the set of changes to the block structure, block processing, fork choice rule and network interface introduced by the consensus upgrade.

SPECIFICATION:
### Definitions * **PoW block**: Block that is built and verified by the existing proof-of-work mechanism. In other words, a block of the Ethereum network before the consensus upgrade. * **PoS block**: Block that is built and verified by the new proof-of-stake mechanism. * **Terminal PoW block**: A PoW block that satisfies the following conditions -- `pow_block.total_difficulty >= TERMINAL_TOTAL_DIFFICULTY` *and* `pow_block.parent_block.total_difficulty < TERMINAL_TOTAL_DIFFICULTY`. There can be more than one terminal PoW block in the network, e.g. multiple children of the same pre-terminal block. * **`TERMINAL_TOTAL_DIFFICULTY`** The amount of total difficulty reached by the network that triggers the consensus

MOTIVATION:
The beacon chain network has been up and running since December 2020. Neither safety nor liveness failures were detected during this period of time. This long period of running without failure demonstrates the sustainability of the beacon chain system and its readiness to become a security provider for the Ethereum Mainnet. To understand the motivation of introducing the Proof-of-Stake consensus see the Motivation section of [EIP-2982](./eip-2982.md#motivation).

RATIONALE:
The changes specified in this EIP target a minimal requisite set of consensus and client software modifications to safely replace the existing proof-of-work consensus algorithm with the new proof-of-stake consensus represented by the already in-production beacon chain. This EIP was designed to minimize the complexity of hot-swapping the live consensus of the Ethereum network. Both the safety of the operation and time to production were taken into consideration. Additionally, a minimal changeset helps ensure that *most* smart contracts and services will continue to function as intended during and after the transition with little to no required intervention. ###


=== EIP-2565 ===
TITLE: ModExp Gas Cost
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-03-20
REQUIRES: 198

SUMMARY:
To accurately reflect the real world operational cost of the `ModExp` precompile, this EIP specifies an algorithm for calculating the gas cost. This algorithm approximates the multiplication complexity cost and multiplies that by an approximation of the iterations required to execute the exponentiation.

SPECIFICATION:
As of `FORK_BLOCK_NUMBER`, the gas cost of calling the precompile at address `0x0000000000000000000000000000000000000005` will be calculated as follows: ``` def calculate_multiplication_complexity(base_length, modulus_length): max_length = max(base_length, modulus_length) words = math.ceil(max_length / 8) return words**2 def calculate_iteration_count(exponent_length, exponent): iteration_count = 0 if exponent_length <= 32 and exponent == 0: iteration_count = 0 elif exponent_length <= 32: iteration_count = exponent.bit_length() - 1 elif exponent_length > 32: iteration_count = (8 * (exponent_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1) return max(iteration_count, 1) def calculate_gas_cost(base_length, modulus_length, exponent_length, exponent): multiplication_complexity = calculate_multiplication_complexity(base_length, modulus_length) iteration_count = calculate_iteration_count(exponent_length, exponent) return max(200, math.floor(multiplication_complexity *

MOTIVATION:
Modular exponentiation is a foundational arithmetic operation for many cryptographic functions including signatures, VDFs, SNARKs, accumulators, and more. Unfortunately, the ModExp precompile is currently over-priced, making these operations inefficient and expensive. By reducing the cost of this precompile, these cryptographic functions become more practical, enabling improved security, stronger randomness (VDFs), and more.

RATIONALE:
After benchmarking the ModExp precompile, we discovered that it is ‘overpriced’ relative to other precompiles. We also discovered that the current gas pricing formula could be improved to better estimate the computational complexity of various ModExp input variables. The following changes improve the accuracy of the `ModExp` pricing: ### 1. Modify ‘computational complexity’ formula to better reflect the computational complexity The complexity function defined in [EIP-198](./eip-198.md) is as follow: ``` def mult_complexity(x): if x <= 64: return x ** 2 elif x <= 1024: return x ** 2 // 4 + 96 * x - 3072 else: return


=== EIP-6873 ===
TITLE: Preimage retention
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-14
REQUIRES: 

SUMMARY:
Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Let `T_p` be the timestamp of the fork preceding the verge, and `T_v` the timestamp of the verge. * EL clients MUST save the preimage of each address and slot hashes they produce during the execution of all blocks produced between `T_p` and `T_v` * EL clients MAY start storing preimages outside of this time range as well * Given a hash produced between

RATIONALE:
Switching to verkle trees require a complete rehashing of all tree keys. Most execution clients store all keys hashed, without their preimages, which as the time of print take up 70GB on mainnet. In order to make these preimages available to everyone, the following course of action are available to each user: * Restart a full-sync with preimage retention enabled * Download the preimages as a file The second option is the only acceptable option in practice, as a full-sync requires the syncing machine to be offline for several days, and therefore should not be simultaneously imposed to


=== EIP-160 ===
TITLE: EXP cost increase
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-20
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, increase the gas cost of EXP from 10 + 10 per byte in the exponent to 10 + 50 per byte in the exponent. ### Rationale Benchmarks suggest that EXP is currently underpriced by a factor of about 4–8. ### References 1. EIP-160 issue and discussion: https://github.com/ethereum/EIPs/issues/160

RATIONALE:
Benchmarks suggest that EXP is currently underpriced by a factor of about 4–8. ### References 1. EIP-160 issue and discussion: https://github.com/ethereum/EIPs/issues/160


=== EIP-7791 ===
TITLE: GAS2ETH opcode
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-08-13
REQUIRES: 2929

SUMMARY:
This EIP introduces a new `GAS2ETH` opcode that enables the direct conversion of gas into ether (ETH).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A new quantity is added to the calling and transaction context, the `gas2eth` limit. It is analogous to the gas counter, but is transaction-global and is maintained separately from the gas limit. At the beginning of the transaction, it is initialized to the same value as the transaction gas limit. A new opcode is introduced, `GAS2ETH` (`0xFC`), which: - Pops two values from the

MOTIVATION:
This EIP is based on the premise that smart contract authors, compiler teams and public goods projects in general should be compensated for their contributions. Moreover, their compensation should scale with the usage of their contracts. A widely used and popular contract offers significant value to its users through its functionality and to the network by driving demand for blockspace — Ethereum's _raison d'être_. This increased demand also benefits miners and validators, who are rewarded for executing these contracts. Monetizing smart contracts in a scalable manner remains challenging at the time of this writing. This difficulty is evident

RATIONALE:
- `GAS2ETH` vs. pro-rata: The pro-rata model incentivizes inflating contract gas usage to artificially increase fees. In contrast, this proposal allows contract authors to charge their desired amount directly, eliminating the need for unnecessary gas consumption. - Target address vs. simply increasing balance of the currently executing contract: Using a target address is more flexible, enabling contract authors to write more modular code and separate the concerns of fee collection from contract functionality. For instance, the contract may want to designate a specific recipient for fees without necessarily granting them direct withdrawal access. - Charging gas instead of


=== EIP-7864 ===
TITLE: Ethereum state using a unified binary tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-01-20
REQUIRES: 

SUMMARY:
Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which are grouped by 256 in order to provide some locality. Note: The hash function used in the current draft is not final. The current implementation uses BLAKE3 to reduce friction for EL clients experimenting with this EIP, but the final decision remains TBD. Other potential candidates include Keccak and Poseidon2. For Poseidon2, there's an ongoing Ethereum Foundation cryptography initiative

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Notable changes from the hexary structure - The account and storage tries are merged into a single trie. - RLP is no longer used. - The account's code is chunked and included in the tree. - Account data (e.g., balance, nonce, first storage slots, first code-chunks) is co-located in the tree to reduce branch openings. ### Tree structure The proposed Binary Tree stores key-value

MOTIVATION:
Ethereum's long-term goal is to allow blocks to be proved with validity proof so that chain verification is as simple and fast as possible. One of the most challenging parts of achieving that goal is proving the state of the tree, which is required for EVM execution. The current Merkle-Patricia Trie (MPT) design isn't friendly to validity proofs for many reasons, such as using RLP for node encoding, Keccak as a hashing function, being a "tree of trees", and not including accounts code as part of the state. Apart from requiring a state tree design that is friendly

RATIONALE:
This EIP defines a new Binary Tree that starts empty. Only new state changes are stored in the tree. The MPT continues to exist but is frozen. This sets the stage for a future hard fork that migrates the MPT data to this Binary Tree ([EIP-7748](./eip-7748.md)). ### Single tree design The proposal uses a single-layer tree structure with 32-byte keys and values for several reasons: - **Simplicity**: working with the abstraction of a key/value store makes it easier to write code dealing with the tree (e.g. database reading/writing, caching, syncing, proof creation, and verification) and upgrade it to


=== EIP-7716 ===
TITLE: Anti-correlation attestation penalties
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-25
REQUIRES: 

SUMMARY:
The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with high correlations in their setup face more severe ones.

SPECIFICATION:
| Parameter | Value | | - | - | | `PENALTY_ADJUSTMENT_FACTOR` | `4096` | | `MAX_PENALTY_FACTOR` | `4` | Add a variable `NET_EXCESS_PENALTIES` to the beacon state. Let `penalty_factor` be determined through ``` min( (non_attesting_balance * PENALTY_ADJUSTMENT_FACTOR) // (NET_EXCESS_PENALTIES * total_active_balance + 1), MAX_PENALTY_FACTOR ) ``` Let `NET_EXCESS_PENALTIES` be `max(1, NET_EXCESS_PENALTIES + penalty_factor) - 1`

MOTIVATION:
As of now, during times of usual network operation, there are no economic incentives to diversify node operations through using multiple different nodes, geographical locations, clients, ISP providers, etc., except for reducing the risk of penalties affecting all validators simultaneously, thereby limiting the impact to only a fraction of them. Attestation penalties are currently agnostic to other participation actions. This proposal scales attestation penalties as a function of other participants' actions. The goal is to decrease the profitability of participants that exhibit correlated behavior.

RATIONALE:
### PENALTY_ADJUSTMENT_FACTOR This variable impacts the sensitivity of the `NET_EXCESS_PENALTIES`. Given stable participation, the `penalty_factor` is one. If participation decreases, the `penalty_factor` will temporarily increase above one until `net_excess_penalties` catches up. If participation increases, the `penalty_factor` will temporarily be zero until `net_excess_penalties` catches up. The `PENALTY_ADJUSTMENT_FACTOR` regulates how fast `net_excess_penalties` catches up. In other words, the `PENALTY_ADJUSTMENT_FACTOR` determines the frequency that the penalty_factor is not one. A high `PENALTY_ADJUSTMENT_FACTOR` causes the `net_excess_penalties` to adjust slower. A low `PENALTY_ADJUSTMENT_FACTOR` causes the `net_excess_penalties` to react more sensitively to changes in participation. ### `MAX_PENALTY_FACTOR` The `MAX_PENALTY_FACTOR` puts a ceiling onto the


=== EIP-1588 ===
TITLE: Hardfork Meta: Ethereum ProgPoW
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-11-16
REQUIRES: 1057

SUMMARY:
This meta-EIP specifies the changes included in the alternative Ethereum hardfork named Ethereum ProgPoW.

SPECIFICATION:
- Codename: Ethereum ProgPoW - Aliases: N/A - Activation: - `Block >= 7280000` on the Ethereum mainnet - Included EIPs: - [EIP-1057](./eip-1057.md): ProgPoW, a Programmatic Proof-of-Work


=== EIP-152 ===
TITLE: Add BLAKE2 compression function `F` precompile
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-04
REQUIRES: 

SUMMARY:
This EIP introduces a new precompiled contract which implements the compression function `F` used in the BLAKE2 cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and Zcash, as well as introducing more flexible cryptographic hash primitives to the EVM.

SPECIFICATION:
We propose adding a precompiled contract at address `0x09` wrapping the [BLAKE2 `F` compression function](https://tools.ietf.org/html/rfc7693#section-3.2). The precompile requires 6 inputs tightly encoded, taking exactly 213 bytes, as explained below. The encoded inputs are corresponding to the ones specified in the [BLAKE2 RFC Section 3.2](https://tools.ietf.org/html/rfc7693#section-3.2): - `rounds` - the number of rounds - 32-bit unsigned big-endian word - `h` - the state vector - 8 unsigned 64-bit little-endian words - `m` - the message block vector - 16 unsigned 64-bit little-endian words - `t_0, t_1` - offset counters - 2 unsigned 64-bit little-endian words - `f` - the final

MOTIVATION:
Besides being a useful cryptographic hash function and SHA3 finalist, BLAKE2 allows for efficient verification of the Equihash PoW used in Zcash, making a BTC Relay - style SPV client possible on Ethereum. A single verification of an Equihash PoW verification requires 512 iterations of the hash function, making verification of Zcash block headers prohibitively expensive if a Solidity implementation of BLAKE2 is used. BLAKE2b, the common 64-bit BLAKE2 variant, is highly optimized and faster than MD5 on modern processors. Interoperability with Zcash could enable contracts like trustless atomic swaps between the chains, which could provide a much

RATIONALE:
BLAKE2 is an excellent candidate for precompilation. BLAKE2 is heavily optimized for modern 64-bit CPUs, specifically utilizing 24 and 63-bit rotations to allow parallelism through SIMD instructions and little-endian arithmetic. These characteristics provide exceptional speed on native CPUs: 3.08 cycles per byte, or 1 gibibyte per second on an Intel i5. In contrast, the big-endian 32 byte semantics of the EVM are not conducive to efficient implementation of BLAKE2, and thus the gas cost associated with computing the hash on the EVM is disproportionate to the true cost of computing the function natively. An obvious implementation would be


=== EIP-969 ===
TITLE: Modifications to ethash to invalidate existing dedicated hardware implementations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-03
REQUIRES: 

SUMMARY:
There are companies who currently have dedicated hardware based ethereum miners in production, and may be actively mining. This EIP aims to "poison the well" by modifying the block mining algorithm in a low risk manner that may *"break"* these miners if they are in-fact built as traditional ASICs.

SPECIFICATION:
If `block.number >= ASIC_MITIGATION_FORK_BLKNUM`, require that the ethash solution sealing the block has been mined using `ethashV2`.

MOTIVATION:
ASIC-based miners will have lower operational costs than GPU-based miners, which will result in GPU-based mining quickly becoming unprofitable. Given that production of ASIC-based miners has a high barrier to entry and few market players, this will cause a trend towards centralization of mining power. Risks include market dominance by a single manufacturer that may utilize production stock to mine themselves, introduce backdoors in their hardware, or facilitate a 51% attack that would otherwise be infeasible. This trend towards centralization has a negative effect on network security, putting significant control of the network in the hands of only

RATIONALE:
This EIP is aimed at breaking existing ASIC-based miners via small changes to the existing ethash algorithm. We hope to accomplish the following: 1. Break existing ASIC-based miners. 2. Demonstrate a willingness to fork in the event of future ASIC miner production. Goal #1 is something that we can only do probabilistically without detailed knowledge of existing ASIC miner design. The known released miner is available for purchase [here](https://shop.bitmain.com/product/detail?pid=00020180403174908564M8dMJKtz06B7), with delivery slated for mid-summer 2018. Our approach should balance the inherent security risks involved with changing the mining algorithm with the risk that the change we make does


=== EIP-3521 ===
TITLE: Reduce access list cost
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-15
REQUIRES: 2, 0, 2, 8, ,,  , 2, 9, 3, 0

SPECIFICATION:
Treat the first occurrence of `tx.to` in an access list as `calldata` for gas accounting purposes. Do not charge `ACCESS_LIST_ADDRESS_COST` for it. Storage keys underneath the address are unaffected. If `tx.to == nil`, `tx.to` is defined be the derived contract address created by the transaction.

MOTIVATION:
Currently, a transaction must read at least 25 distinct storage slots in `tx.to` before it's more expensive to forego an access list. ``` ACCESS_LIST_ADDRESS_COST + (ACCESS_LIST_STORAGE_KEY_COST + WARM_STORAGE_READ_COST) * x = COLD_SLOAD_COST * x x = 24 ``` EIP-2930 requires the address under which the storage keys reside be declared explicitly, since it must be added to the EIP-2929 `accessed_addresses` list. However, `tx.to` is a special case that is added by default, so paying `ACCESS_LIST_ADDRESS_COST` for `tx.to` is essentially paying twice for the same address. Avoiding overpayment here will reduce the differential to just 5 unique reads before


=== EIP-8011 ===
TITLE: Multidimensional Gas Metering
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-22
REQUIRES: 

SUMMARY:
This proposal introduces multidimensional gas metering, changing the way we account for gas used at the block level. This enables Ethereum to increase throughput and better control excessive resource usage, with minimal changes to the protocol and the UX. During transaction execution, gas is metered for each resource dimension, such as compute and state. At the transaction level, everything remains unchanged. A transaction still pays fees according to the sum of gas used across all resources and still has a single gas limit imposed on this same sum. However, at the block level, only the gas used in

SPECIFICATION:
### Operation gas costs Under the multidimensional metering model, EVM operations are assigned a cost vector whose components correspond to their gas cost on each resource dimension. Each cost has 6 dimensions: `gas_cost_vector = (compute_cost, access_cost, size_cost, memory_cost, state_cost, history_cost)`. #### Pure compute operations The operations listed in [compute_ops](../assets/eip-8011/compute_ops.md) are assigned a `gas_cost_vector` equal to `(gas_cost, 0, 0, 0, 0, 0)`, where `gas_cost` is the operation's gas cost. #### Compute and memory operations The operations listed in [compute_mem_ops](../assets/eip-8011/compute_mem_ops.md) are assigned a `gas_cost_vector` equal to `(compute_cost, 0, 0, memory_cost, 0, 0)`, where `memory_cost` is the operation's memory expansion cost

MOTIVATION:
This proposal separates *transaction pricing* (i.e., the way of measuring consumption of resources by transactions) from *block metering* (i.e., the way of controlling resource limits and ensure that blocks do not overload the network). More concretely, it introduces a multidimensional metering scheme that accounts for the different EVM resources while keeping the pricing model unchanged. There are four main benefits of the proposal: 1. Throughput gains: By decoupling resource limits, blocks can carry transactions that stress distinct resources simultaneously, improving packing efficiency. 2. Finer-grained control over excessive resource usage: metering gas costs independently for each resource allows us

RATIONALE:
### Why are we choosing this resource split? Ethereum’s slot-based structure introduces a strict temporal constraint: all attestations must be processed, aggregated, and propagated within a single slot. This fact makes time a fundamental resource. To maintain network health, validators must execute blocks, validate them, and gossip attestations quickly enough to avoid missed slots and penalties. Each type of resource contributes differently to this bottleneck: - Execution time affects how quickly validators can process blocks and produce attestations. - Data size influences how long it takes to propagate blocks and blobs across the peer-to-peer network. - Memory usage


=== EIP-7883 ===
TITLE: ModExp Gas Cost Increase
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-02-11
REQUIRES: 2565

SUMMARY:
This EIP is modifying the `ModExp` precompile pricing algorithm introduced in [EIP-2565](./eip-2565.md).

SPECIFICATION:
Upon activation of this EIP, the gas cost of calling the precompile at address `0x0000000000000000000000000000000000000005` will be calculated as follows: ``` def calculate_multiplication_complexity(base_length, modulus_length): max_length = max(base_length, modulus_length) words = math.ceil(max_length / 8) multiplication_complexity = 16 if max_length > 32: multiplication_complexity = 2 * words**2 return multiplication_complexity def calculate_iteration_count(exponent_length, exponent): iteration_count = 0 if exponent_length <= 32 and exponent == 0: iteration_count = 0 elif exponent_length <= 32: iteration_count = exponent.bit_length() - 1 elif exponent_length > 32: iteration_count = (16 * (exponent_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1) return max(iteration_count, 1) def calculate_gas_cost(base_length, modulus_length,

MOTIVATION:
Currently the `ModExp` precompile is underpriced in certain scenarios relative to its resource consumption. By adjusting the pricing formula, this EIP aims to address these discrepancies, making `ModExp` sufficiently efficient to enable potential increases in the block gas limit.

RATIONALE:
Benchmarking the `ModExp` precompile revealed several scenarios where its gas cost was significantly underestimated. Pricing adjustments are designed to rectify underpriced edge cases by modifying the existing `ModExp` pricing formula parameters. Specifically, the minimum cost for `ModExp` will rise from 200 to 500 (a 150% increase), the general cost will triple (a 200% increase), a minimum base/modulus length of 32 bytes will be assumed and the cost will scale more aggressively when the base, modulus, or exponent exceed 32 bytes. These modifications aim to ensure that the `ModExp` precompile's performance, even in its most resource-intensive edge cases across


=== EIP-7851 ===
TITLE: Deactivate/Reactivate a Delegated EOA's Key
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-12-27
REQUIRES: 7702

SUMMARY:
This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts via [EIP-7702](./eip-7702) to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through mechanisms such as social recovery.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Parameters | Constant | Value | |-----------------------------------|----------------------| | `PRECOMPILE_ADDRESS` | `0xTBD` | | `PRECOMPILE_GAS_COST` | `13000` | ### Definitions * `||` is the byte/byte-array concatenation operator. ### Delegated Code Encoding The deactivation status is encoded by appending or removing the `0x00` byte at the end of the delegated code. The transitions between two states are as follows: * Active state: `0xef0100 || address`.

MOTIVATION:
[EIP-7702](./eip-7702) enables EOAs to gain smart contract capabilities, but the private key of the EOA still retains full control over the account. With this EIP, EOAs can fully migrate to smart contract wallets, while retaining private key recovery options with reactivation. The flexible deactivate and reactivate design also paves the way for native account abstraction. e.g., [EIP-7701](./eip-7701).

RATIONALE:
### Cost of Precompiled Contract The `PRECOMPILE_GAS_COST` represents the gas required to validate and potentially update an account's code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node: * Reading the code of the address: `2600`. * Changing the code hash (from non-zero to non-zero): `5000`. * Deploying at most `24` bytes of code: `200 * 24 = 4800`. The primary operation consumes a total of `12400` gas. To account for additional overhead, such as context switching during state transitions, as well as code prefix and length validations, the


=== EIP-7706 ===
TITLE: Separate gas type for calldata
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-13
REQUIRES: 1, 5, 5, 9, ,,  , 4, 8, 4, 4

SUMMARY:
Add a new type of gas for transaction calldata. Add a new transaction type that provides `max_basefee` and `priority_fee` as a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters * `FORK_BLKNUM` = `TBD` * `NEW_TX_TYPE` = `TBD` * `CALLDATA_GAS_PER_TOKEN` = `4` * `TOKENS_PER_NONZERO_BYTE` = `4` * `CALLDATA_GAS_LIMIT_RATIO` = `4` * `LIMIT_TARGET_RATIOS = [2, 2, 4]` * `MIN_BASE_FEE_PER_GAS = 1` # Rename of EIP-4844 MIN_BASE_FEE_PER_BLOB_GAS * `BASE_FEE_UPDATE_FRACTION = 8` # Roughly matches EIP-4844 parameters ### New transaction type As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` = `TX_TYPE(NEW_TX_TYPE)`. The [EIP-2718](./eip-2718.md) `TransactionPayload` for this transaction is

MOTIVATION:
A major argument against raising the Ethereum gas limit, making calldata cheaper, or increasing the [EIP-4844](./eip-4844.md) blob count before technologies like PeerDAS become available, is that the theoretical maximum size of an Ethereum block is already too large, and we cannot afford to increase it further. However, there is an inefficiency here: the current average size of a block (not including blobs) is ~100 kB, and the theoretical max is `30,000,000 / 16 = 1,875,000` bytes (one could make larger blocks using zero bytes, but in practice zero-byte-heavy blocks would be compressed to less than 1.87 million bytes

RATIONALE:
### Conversion of all gas-related mechanics into vectors This allows the same logic that is used for handling gas to handle all three types of gas. As a result, it's arguably a net simplification of protocol gas handling logic, despite the fact that the total number of gas types increases from 2 to 3 ### Target ratios The target ratios for execution gas and blobs are set to 2; the target ratio for calldata is set to 4. This greatly decreases the number of scenarios in which calldata actually hits the limit, which mitigates economic impact of the


=== EIP-3238 ===
TITLE: Difficulty Bomb Delay to Q2/2022
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-01-25
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting eleven million blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 11_000_000) if block.number >= FORK_BLOCK_NUMBER else block.number

MOTIVATION:
Even after the Ethereum 2.0 mainnet launch, Ethash proof-of-work mining on the legacy chain should be feasible. It should allow miners sealing new blocks every 13~15 seconds on average for another ten months and allow both Ethereum 1.x and Ethereum 2.0 developers to conclude the merge.

RATIONALE:
This will delay the ice age by another ~26 million seconds (approximately ~9.89 months), so the chain would be back at ~30 second block times in Q2/2022. Hopefully, by then the Eth1-to-Eth2 merge will be concluded and the ice age fulfilled its task.


=== EIP-2027 ===
TITLE: State Rent C - Net contract size accounting
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-14
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces initial, net accounting of the number of the contract storage slots. Though not very useful on its own, it makes it possible to introduce gross accounting of the number of storage slots, which is useful for number of things: 1. Gas cost of operations suchs as `SLOAD` and `SSTORE` will need to be increased to compensate for extra bandwidth consumed by the block proofs. Although in the beginning the cost would be fixed, it will later be automatically calibrated depending on the size of the contract

SPECIFICATION:
Each contract (account with `codeHash` field not equal to 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, which the hash of the empty code) gets a new uint64 field, called `storagesize`. On and after block `C`, the semantics of the operation `SSTORE` (`location`, `value`) changes as follows: - If previous value of the [`location`] is 0, and value is not 0, *increment* `storagesize` (semantics of *increment* described below) - If previous value of the [`location`] is not 0, and value is 0, *decrement* `storagesize` (semantics of *decrement* described below) - As with other state changes, changes of `storagesize` get reverted when the execution frame reverts,

MOTIVATION:
Ethereum currently does not track the number of contract storage slots at all, and producing such number given the downloaded state cannot be done in constant *O(1)* time.

RATIONALE:
A mechanism for estimation of contract storage size has been proposed [here](https://medium.com/@akhounov/estimation-approximate-of-the-size-of-contracst-in-ethereum-4642fe92d6fe). But it does have a big drawback of introducing a lot of complexity into the consensus (in the form of estimation algorithm, which has quite a few edge cases to cater for different sizes of the storage).


=== EIP-3779 ===
TITLE: Safer Control Flow for the EVM
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-08-30
REQUIRES: 

SUMMARY:
We define a safe EVM contract as one that cannot encounter an exceptional halting state. In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset. This EIP specifies validity rules to ensure that: > Valid contracts will not halt with an exception unless they either > * throw `out of gas` or > * recursively overflow stack. This EIP does not introduce any new opcodes. Rather, it restricts the use of existing and proposed control-flow instructions. The restrictions must be validated at contract initialization time – not at runtime – by the

SPECIFICATION:
### Validity > In theory, theory and practice are the same. In practice, they're not. -- Albert Einstein We define a _safe_ EVM contract as one that cannot encounter an exceptional halting state. We validate _safety_ at initialization time to the extent practical. #### *Exceptional Halting States* The *execution* of each instruction is defined in the Yellow Paper as a change to the EVM state that preserves the invariants of EVM state. At runtime, if the execution of an instruction would violate an invariant the EVM is in an exceptional halting state. The Yellow Paper defined five such

MOTIVATION:
### Safety For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state. From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain. Unsafe code can attempt to overflow stack, underflow stack, execute invalid instructions, and jump to invalid locations. Unsafe contracts are exploits waiting to happen. Validating contract safety requires traversing the contract code. So in order to prevent denial of service attacks all jumps, including the existing `JUMP` and `JUMPI`, and also the other proposed jumps -- `RJUMP`, `RJUMPI`, `RJUMPSUB` and

RATIONALE:
Demanding *static* destinations for all jumps means that all jump destinations can be validated at initialization time, not runtime. Bounding the stack pointers catches all `data stack` and non-recursive`return stack` overflows. Requiring a consistently aligned`data stack` prevents stack underflow. It can also catch such errors as misaligned stacks due to irreducible control flows and calls to subroutines with the wrong number of arguments.


=== EIP-7199 ===
TITLE: Linter Scope
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2023-06-20
REQUIRES: 

SUMMARY:
Currently in practice EIP linter tools (EIPW, for example) will block a Pull Request for lint errors even if that lint errors was not introduced in that Pull Request. This EIP make it explicit that lint errors for untouched lines shall be considered ignorable except for status change.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. In an update to an EIP, A Pull Request SHOULD NOT be required to fix linter errors in untouched lines unless it's changing the Status of the EIP.

RATIONALE:
This policy allows micro contributions for anyone who just want to fix a typo or change a section of a section in a large EIP.


=== EIP-4747 ===
TITLE: Simplify EIP-161
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-02
REQUIRES: 161

SUMMARY:
Simplify the definition of [EIP-161](./eip-161.md), removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Retroactively replace EIP-161, starting from its introduction in block 2675000, with the following rules: a. When creating an account, set it's nonce to `1` prior to executing initcode. b. When performing EVM execution treat all empty accounts as if they do not exist. Any operation that would create an empty account instead leaves it non-existent. c. If one of the following events happens to an empty account `X`, it

MOTIVATION:
EIP-161 is overly complex and has a number of edge cases that are poorly documented and tested. This EIP takes advantage of the complete removal of all remaining empty accounts in block 14049881 (tx `0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d`) to clarify it, and allows implementors to not implement various edge cases that never occurred and are not possible in the future. In particular, this EIP permits implementors who do not wish to support historical blocks to not implement state clearing at all.

RATIONALE:
EIP-161 provides that empty accounts (accounts that have zero nonce, zero balance and no code, but that might have storage) can no longer be created and provides mechanism to remove old empty accounts. The last empty accounts were removed in block 14049881 (tx `0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d`). The complete removal of all empty accounts ensures that certain edgecases of EIP-161 can never occur on Ethereum Mainnet. Continuing to define and test those cases as part of the Ethereum Specification burdens future client implementors with unnecessary technical debt. This EIP declares those cases undefined and leaves clients free to assume they will


=== EIP-7623 ===
TITLE: Increase calldata cost
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-02-13
REQUIRES: 

SUMMARY:
The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB. This EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users. This is achieved by increasing calldata costs for transactions that predominantly post data.

SPECIFICATION:
| Parameter | Value | | ---------------------------- | ----- | | `STANDARD_TOKEN_COST` | `4` | | `TOTAL_COST_FLOOR_PER_TOKEN` | `10` | Let `tokens_in_calldata = zero_bytes_in_calldata + nonzero_bytes_in_calldata * 4`. Let `isContractCreation` be a boolean indicating the respective event. Let `execution_gas_used` be the gas used for EVM execution with the gas refund subtracted. Let `INITCODE_WORD_COST` be 2 as defined in [EIP-3860](./eip-3860.md). The current formula for determining the total gas used per transaction (`tx.gasUsed`) is equivalent to: ```python tx.gasUsed = ( 21000 + STANDARD_TOKEN_COST * tokens_in_calldata + execution_gas_used + isContractCreation * (32000 + INITCODE_WORD_COST * words(calldata)) ) ``` The formula for

MOTIVATION:
The block gas limit has not been increased since [EIP-1559](./eip-1559.md), while the average size of blocks has continuously increased due to the growing number of rollups posting data to Ethereum. Moreover, calldata costs have remained unchanged since [EIP-2028](./eip-2028). [EIP-4844](./eip-4844.md) introduces blobs as a preferred method for data availability (DA). This transition demands a reevaluation of calldata pricing, especially in order to address the disparity between average and maximum block sizes. By introducing a floor cost dependent on the ratio of gas spent on EVM operations to calldata, this proposal aims to reduce the maximum block size to make

RATIONALE:
The current maximum EL payload size is approximately 1.79 MB (`30_000_000/16`). It is possible to create payloads filled with zero bytes that expand to 7.15 MB. However, since blocks are typically compressed with Snappy at the P2P layer, zero-byte-heavy EL payloads generally compress to under 1.79 MB. The implementation of [EIP-4844](./eip-4844.md) increased the maximum possible compressed block size to approximately 2.54 MB. This proposal aims to increase the cost of calldata to 10/40 gas for transactions that do not exceed a certain threshold of gas spent on EVM operations relative to gas spent on calldata. This change will


=== EIP-3978 ===
TITLE: Gas refunds on reverts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-09-16
REQUIRES: 2929

SUMMARY:
For reverted state modification operations, keep access cost, but refund modification cost.

SPECIFICATION:
For each callframe, track `revert_gas_refund`, initially 0. The set of operations that modify `revert_gas_refund` are: - SSTORE - LOG0, LOG1, LOG2, LOG3, LOG4 - CALL - CREATE, CREATE2 - SELFDESTRUCT They increase `revert_gas_refund` as follows: ```javascript call.revert_gas_refund += operation.gas - WARM_STORAGE_READ_COST ``` And in case of revert let's use this value instead of just erasing `gas_refund`: ```javascript if (call.reverted) { // existing behavior tx.gas_refund -= call.gas_refund; // New behavior added to existing according to the EIP-3978 tx.gas_refund += call.revert_gas_refund; } ```

MOTIVATION:
Reverting a transaction, or any of its sub-calls, drops any state modifications that happened inside. But now, users are being charged for the dropped modifications as if they persisted. Since [EIP-3298](./eip-3298.md), the gas refund mechanism works for storage restores only inside the same transaction. But on revert, the gas refund is not increased; it is completely erased. It can even be cheaper to transfer tokens back at the end of a transaction instead of reverting, to keep the existing gas refund. This should be changed. - Reverted SSTORE deserves to be repriced to SLOAD gas (100 gas) -

RATIONALE:
Gas should reflect the cost of use. The revert cost reflects the cost of access during execution, but not the cost of modification.


=== EIP-5792 ===
TITLE: Wallet Call API
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-10-17
REQUIRES: 1193

SUMMARY:
Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls. Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, novel wallet RPC is defined to enable apps to query the wallet for those capabilities.

SPECIFICATION:
Four new JSON-RPC methods are added: three are for handling batches of onchain calls, and one is for querying support for wallet capabilities, such as to make better use of the three batching methods. Apps may begin using these first three methods immediately, falling back to `eth_sendTransaction` and `eth_getTransactionReceipt` when they are not available. ### `wallet_sendCalls` Requests that a wallet submits a batch of calls. `from` and `chainId` are identified by [EIP-155](./eip-155.md) integers expressed in hexadecimal notation, with `0x` prefix and no leading zeroes for the `chainId` value. The items in the `calls` field are simple `{to, data,

MOTIVATION:
The current methods used to send transactions from the user wallet and check their status are `eth_sendTransaction` and `eth_getTransactionReceipt`. The current methods used to send transactions from the user wallet and check their status do not meet modern developer demands and cannot accommodate new transaction formats. Even the name–- `eth_sendTransaction`-– is an artifact of a time when nodes served as wallets. Today, developers want to send multiple calls batched together in a single RPC call, which many smart accounts can, in turn, execute atomically in a single transaction. Developers also want to make use of features afforded by

RATIONALE:
### On Naming We considered modifying `eth_sendTransaction` to add support for these new capabilities, but the method is ultimately an artifact of when nodes were used to sign transactions. We decided it is better to move forward with `wallet_`-namespaced methods that better describe what they are used for. We also debated whether the methods should be called `wallet_sendTransaction`, `wallet_sendCalls`, or something else. We ultimately landed on `wallet_sendCalls` because in the case of EOA wallets the `wallet_send*` method might send more than one transaction. Similarly, we decided against `wallet_sendTransactions` because in the case of other wallet implementations (e.g. [ERC-4337](./eip-4337.md))


=== EIP-6810 ===
TITLE: Ex Post Facto Cascading Revert
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-01
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 2, 9

SUMMARY:
A new transaction type reverts one of a sender's prior transactions, and other transactions dependent on that state, recursively.

SPECIFICATION:
### Parameters A new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` `0x5a`. The [EIP-2718](./eip-2718.md) `TransactionPayload` for this transaction is `rlp([chainId, nonce, revertNonce, budget, signatureYParity, signatureR, signatureS])`. The `signatureYParity, signatureR, signatureS` elements of this transaction represent a secp256k1 signature over `keccak256(0x5a || rlp([chainId, nonce, revertNonce, budget]))`. The [EIP-2718](./eip-2718.md) `ReceiptPayload` for this transaction is `rlp([status, budgetUsed, removedLogsBloom, [newReceiptPayloads]])`, where `newReceiptPayloads` is a sequential array of the updated receipts of all reverted transactions. ### Block gas limit A transaction of type `0x5a` shall be the only transaction in its block. ### Cascading revert operation A transaction fee budget is initialized to the

MOTIVATION:
While Ethereum has the capability of reversible transactions through smart contracts, instant settlement is the default. But sometimes users make mistakes. Most mistakes are discovered quickly. However, once the transaction is confirmed, it is settled. There are many use cases for reverting settled transactions. Some of the most-common mistakes are listed below. - Wrong recipient - Unintended consequences - Got scammed This feature addresses these issues and more, ending all regret.

RATIONALE:
The transaction must fill the entire block to prevent MEV attacks. While some cascading reverts are highly consequential, others are considerably simpler. The budget ensures the full network cost of the operation is paid. For example, reversing a token transfer to the wrong recipient would be relatively cheap. On the other hand, it would be prohibitively expensive to revert all deposits to a custodial exchange. Transaction fees must be refunded from this budget rather than the prior block reward in order to protect the security of the consensus protocol. Snap sync should be safe because if the state


=== EIP-3529 ===
TITLE: Reduction in refunds
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-04-22
REQUIRES: 2, 2, 0, 0, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `MAX_REFUND_QUOTIENT` | 5 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. 1. Remove the `SELFDESTRUCT` refund. 2. Replace `SSTORE_CLEARS_SCHEDULE` (as defined in [EIP-2200](./eip-2200.md)) with `SSTORE_RESET_GAS + ACCESS_LIST_STORAGE_KEY_COST` (4,800 gas as of [EIP-2929](./eip-2929.md) + [EIP-2930](./eip-2930.md)) 3. Reduce the max gas refunded after a transaction to `gas_used // MAX_REFUND_QUOTIENT` Remark: Previously _max gas refunded_ was defined as `gas_used // 2`. Here we name the constant `2` as `MAX_REFUND_QUOTIENT` and change its value to `5`.

MOTIVATION:
Gas refunds for `SSTORE` and `SELFDESTRUCT` were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, the benefits of this technique have proven to be far lower than anticipated, and gas refunds have had multiple unexpected harmful consequences: * Refunds give rise to GasToken. GasToken has benefits in moving gas space from low-fee periods to high-fee periods, but it also has downsides to the network, particularly in exacerbating state size (as state slots are effectively used as a "battery" to save up

RATIONALE:
In [EIP-2200](./eip-2200.md#specification), three cases for refunds were introduced: 1. If the original value is nonzero, and the new value is zero, add `SSTORE_CLEARS_SCHEDULE` (currently 15,000) gas to the refund counter 2. If the original value is zero, the current value is nonzero, and the new value is zero, add `SSTORE_SET_GAS - SLOAD_GAS` (currently 19,900) gas to the refund counter 3. If the original value is nonzero, the current value is a different nonzero value, and the new value equals the original value, add `SSTORE_RESET_GAS - SLOAD_GAS` (currently 4,900) gas to the refund counter Of these three, only (1)


=== EIP-6811 ===
TITLE: To The Moon—10 Minute Blocks
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-01
REQUIRES: 

SUMMARY:
This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth's solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. * The time between blocks MUST be changed from 12 seconds to 600 seconds (10 minutes). * The per-block validator reward MUST be multiplied by 50 * The number of blocks per epoch MUST be reduced from 4 to 2

MOTIVATION:
It is impossible for today's Ethereum to literally "go to the moon" due to a limitation in the protocol: the block length. Should validators attempt to validate on the surface of the moon, they would find that the ~1.25 second communication delay (caused by the speed of light) might cause issues with synchronization, considering the 12-second timer between blocks. The validators would eventually be ejected on the terrestrial chain after leaking. If however a substantial number of validators are displaced (think 1/3), they might follow their own fork and would eventually eject the terrestrial to finalize their own

RATIONALE:
* The block gas limit is multiplied by fifty to compensate for the time between blocks being multiplied by fifty. * The per-block validator reward is also multiplied by fifty to compensate for the time between blocks being multiplied by fifty. * Epochs are changed to be 2 blocks long so that finality can be reached in a reasonable amount of time.


=== EIP-2711 ===
TITLE: Sponsored, expiring and batch transactions.
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-06-11
REQUIRES: 2718

SUMMARY:
An EIP-2718 transaction with the type number `2` is a new type of transaction that includes support for: 1. **Sponsored Transactions**: an optional additional signature from which the account that will pay for gas (`GAS_PAYER`) can be recovered 2. **Batch Transactions**: multiple transactions from the same sender that will be executed in sequence 3. **Expiring Transactions**: an optional `validUntil` field that makes the transaction invalid after a certain point in time

SPECIFICATION:
### Definitions **`TransactionType`** 2. See [EIP-2718](./eip-2718.md) **`TransactionSubtype`** is either 1, 2, 3, or 4. **`ChainId`** The transaction is valid if this value is `0` or it is included in a block on a chain whose ID is equal to this value. **`ValidUntil`** The transaction is valid if this value is `0` or it is included in a block whose `timestamp` is less than or equal to this value. **`YParity`** The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature. **`ChildTransaction`** A nested transaction consisting of `[to, value, data]`. **`SenderPayload`** Defined based on the

MOTIVATION:
### Sponsored Transactions With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account. Some users don't want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets. Unfortunately, since gas **MUST** be paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees. This EIP proposes a mechanism

RATIONALE:
### One Monolithic EIP This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type. Alternatively, each of the subtypes could be a unique TransactionType. The reason we chose to go with a single EIP with subtypes is because these 4 transactions all have a *lot* in common and each separate EIP would be almost identical to the previous. We felt that in this case, splitting into multiple EIPs wasn't worth the duplication of EIP content. ### ChainID not encoded with `v` While we could save one byte in


=== EIP-2014 ===
TITLE: Extended State Oracle
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-10
REQUIRES: 140

SUMMARY:
Introduce a new system contract with an extensible interface following the [Contract ABI Encoding] to access extended data sets, such as chain identifiers, block hashes, etc. This allows Ethereum contract languages to interact with this contract as if it were a regular contract and not needing any language support.

SPECIFICATION:
A new system contract ("precompile") is introduced at address `0x0000000000000000000000000000000000000009` called ESO (Extended State Oracle). It can be queried using `CALL` or `STATICCALL` and follows the [Contract ABI Encoding] for the inputs and outputs. Using elementary types in the ABI encoding is encouraged to keep complexity low. In the future it could be possible to extend ESO to have a state and accept transactions from a system address to store the passed data -- similarly to what [EIP-210] proposed. Proposals wanting to introduce more data to the state, which is not part of blocks or transactions, should aim

MOTIVATION:
Over the past couple of years several proposals were made to extend the EVM with more data. Some examples include extended access to block hashes ([EIP-210]) and chain identifiers ([EIP-1344]). Adding them as EVM opcodes seems to be using the scarce opcode space for relatively less frequently used features, while adding them as precompiles is perceived as more complicated due to an interface needs to be defined and agreed on for every case. This proposal tries to solve both issues with defining an extensible standard interface.

RATIONALE:
TBA


=== EIP-2046 ===
TITLE: Reduced gas cost for static calls made to precompiles
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-17
REQUIRES: 2, 1, 4, ,,  , 1, 3, 5, 2

SUMMARY:
Reduce the base gas cost of calling precompiles using `STATICCALL` from 700 to 40. This should allow more efficient use of precompiles as well as precompiles with a total cost below 700.

SPECIFICATION:
After block `HF` the `STATICCALL` (`0xfa`) instruction charges different basic gas cost (G<sub>call</sub> in [Yellow Paper]'s notation) depending on the destination address provided: - for precompiles (address range as per [EIP-1352]) the cost is `40` - for every other address the cost remains unchanged (`700`)

MOTIVATION:
The Spurious Dragon hard fork increased the cost of calls significantly to account for loading contract code from the state without making an exception for precompiles, whose "code" is always loaded. This made use of certain precompiles impractical. FIXME: extend this with recent reasoning about ECC repricings.

RATIONALE:
Only the `STATICCALL` instruction was changed to reduce the impact of the change. This should not be a limiting factor, given precompiles (currently) do not have a state and cannot change the state. However, contracts created and deployed before Byzantium likely will not use `STATICCALL` and as a result this change will not reduce their costs. Contrary to EIP-1109 gas reduction to `0` is not proposed. The cost `40` is kept as a cost representing the context switching needed.


=== EIP-7709 ===
TITLE: Read BLOCKHASH from storage and update cost
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-18
REQUIRES: 2935

SUMMARY:
Update the `BLOCKHASH (0x40)` opcode to read and serve from the system contract storage and charge the **additional** (cold or warm) storage costs.

SPECIFICATION:
| Parameter | Value | | ------------------------- | ------ | | `FORK_TIMESTAMP` | TBD | | `HISTORY_STORAGE_ADDRESS` | `0x0000F90827F1C53a10cb7A02335B175320002935` | | `BLOCKHASH_SERVE_WINDOW` | `256` | The `BLOCKHASH` opcode semantics remains the same as before. From the `fork_block` (defined as `fork_block.timestamp >= FORK_TIMESTAMP and fork_block.parent.timestamp < FORK_TIMESTAMP`), the `BLOCKHASH` instruction should be updated to resolve block hash in the following manner: ```python def resolve_blockhash(block: Block, state: State, arg: uint64): # note that outside the BLOCKHASH_SERVE_WINDOW we continue to return 0 # despite the 2935 history contract being able to serve more hashes if arg >= block.number or (arg +

MOTIVATION:
The `BLOCKHASH (0x40)` opcode currently assumes that the client has knowledge of the previous blocks, which in Verkle [EIP-6800](./eip-6800.md) would prevent stateless execution. However with [EIP-2935](./eip-2935.md) blockhashes can be retrieved and served from its system contract storage which allows Verkle blocks to include a storage access witness for stateless execution.

RATIONALE:
* The reason behind the updated gas cost is to match the real operation, which is equivalent to an `SLOAD`. * The [EIP-2935](./eip-2935.md) system contract execution charges (and accesses) are not applied to keep the gas low and to keep things simple for clients which choose to resolve `BLOCKHASH` in other ways (directly or though memory/maintained history) Note that `BLOCKHASH` opcode only serves a limited `BLOCKHASH_SERVE_WINDOW` to be backward compatible (and to not extend the above exemptions). For deeper accesses one will need to directly call [EIP-2935](./eip-2935.md) system contract which will lead to a normal contract execution (as


=== EIP-2045 ===
TITLE: Particle gas costs for EVM opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-17
REQUIRES: 

SUMMARY:
According to recent benchmarks, EVM opcodes for computation (`ADD`, `SUB`, `MUL`, etc.) are generally overpriced relative to opcodes for storage I/O (`SLOAD`, `SSTORE`, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5, or 8), so the range in possible cost reduction is limited. A new minimum unit of gas, called a "particle", which is a fraction of 1 gas, would expand the range of gas costs and thus enable reductions below the current minimum.

SPECIFICATION:
A new gas counter `particlesUsed` is added to the EVM, in addition to the existing gas counter `gasUsed`. The unit 1 gas is equal to 10000 particles (`PARTICLES_PER_GAS`). The `particlesUsed` counter is only increased for opcodes priced in particles (i.e. opcodes that cost less than 1 gas). If increasing `particlesUsed` results in an excess of 1 gas, then 1 gas is added to `gasUsed` (and deducted from `particlesUsed`). Where the current gas logic looks like this: ```python def vm_execute(ext, msg, code): # Initialize stack, memory, program counter, etc compustate = Compustate(gas=msg.gas) codelen = len(code) while compustate.pc < codelen:

MOTIVATION:
The transaction capacity of an Ethereum block is determined by the gas cost of transactions relative to the block gas limit. One way to boost the transaction capacity is to raise the block gas limit. Unfortunately, raising the block gas limit would also increase the rate of state growth, unless the costs of state-expanding storage opcodes (`SSTORE`, `CREATE`, etc.) are simultaneously increased to the same proportion. Increasing the cost of storage opcodes may have adverse side effects, such as shifting the economic assumptions around gas fees of deployed contracts, or possibly breaking invariants in current contract executions (as

RATIONALE:
Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept of `particles` need not be exposed to Ethereum users nor most contract authors, but only to EVM implementers and contract developers concerned with optimized gas usage. Furthermore, only the EVM logic for charging gas per opcode executed should be affected by this change. All other contexts dealing with gas and gas limits, such as block headers and transaction formats, should be unaffected. ### Ewasm The term "particles"


=== EIP-161 ===
TITLE: State trie clearing (invariant-preserving alternative)
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-24
REQUIRES: 

SPECIFICATION:
a. Account creation transactions and the `CREATE` operation SHALL, prior to the execution of the initialisation code, **increment** the **nonce** over and above its normal starting value by **one** (for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different). b. Whereas `CALL` and `SUICIDE` would charge 25,000 gas when the destination is non-existent, now the charge SHALL **only** be levied if the operation transfers **more than zero value** and the destination account is _dead_. c. No account may _change state_ from non-existent to existent-but-_empty_. If an operation would do this,

RATIONALE:
Same as #158 except that several edge cases are avoided since we do not break invariants: - ~~that an account can go from having code and storage to not having code or storage mid-way through the execution of a transaction;~~ [corrected] - that a newly created account cannot be deleted prior to being deployed. `CREATE` avoids zero in the nonce to avoid any suggestion of the oddity of `CREATE`d accounts being reaped half-way through their creation. ### Addendum (2017-08-15) On 2016-11-24, a consensus bug occurred due to two implementations having different behavior in the case of state reverts.[3]


=== EIP-8 ===
TITLE: devp2p Forward Compatibility Requirements for Homestead
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2015-12-18
REQUIRES: 

SUMMARY:
This EIP introduces new forward-compatibility requirements for implementations of the devp2p Wire Protocol, the RLPx Discovery Protocol and the RLPx TCP Transport Protocol. Clients which implement EIP-8 behave according to Postel's Law: > Be conservative in what you do, be liberal in what you accept from others. ### Specification Implementations of **the devp2p Wire Protocol** should ignore the version number of hello packets. When sending the hello packet, the version element should be set to the highest devp2p version supported. Implementations should also ignore any additional list elements at the end of the hello packet. Similarly, implementations of

SPECIFICATION:
Implementations of **the devp2p Wire Protocol** should ignore the version number of hello packets. When sending the hello packet, the version element should be set to the highest devp2p version supported. Implementations should also ignore any additional list elements at the end of the hello packet. Similarly, implementations of **the RLPx Discovery Protocol** should not validate the version number of the ping packet, ignore any additional list elements in any packet, and ignore any data after the first RLP value in any packet. Discovery packets with unknown packet type should be discarded silently. The maximum size of any

MOTIVATION:
Changes to the devp2p protocols are hard to deploy because clients running an older version will refuse communication if the version number or structure of the hello (discovery ping, RLPx handshake) packet does not match local expectations. Introducing forward-compatibility requirements as part of the Homestead consensus upgrade will ensure that all client software in use on the Ethereum network can cope with future network protocol upgrades (as long as backwards-compatibility is maintained). ### Rationale The proposed changes address forward compatibility by applying Postel's Law (also known as the Robustness Principle) throughout the protocol stack. The merit and applicability

RATIONALE:
The proposed changes address forward compatibility by applying Postel's Law (also known as the Robustness Principle) throughout the protocol stack. The merit and applicability of this approach has been studied repeatedly since its original application in RFC 761. For a recent perspective, see ["The Robustness Principle Reconsidered" (Eric Allman, 2011)](https://queue.acm.org/detail.cfm?id=1999945). #### Changes to the devp2p Wire Protocol All clients currently contain statements such as the following: ```python # pydevp2p/p2p_protocol.py if data['version'] != proto.version: log.debug('incompatible network protocols', peer=proto.peer, expected=proto.version, received=data['version']) return proto.send_disconnect(reason=reasons.incompatible_p2p_version) ``` These checks make it impossible to change the version or structure of the hello packet. Dropping


=== EIP-7377 ===
TITLE: Migration Transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-21
REQUIRES: 1, 7, 0, ,,  , 1, 5, 5, 9, ,,  , 2, 2, 0, 0, ,,  , 2, 7, 1, 8

SUMMARY:
Introduce a new [EIP-2718](./eip-2718.md) transaction type with the format `0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])` which sets the sending account's `code` field in the state trie to the `code` value at `codeAddr` and applies the storage tuples to the sender's storage trie.

SPECIFICATION:
At the fork block `X`, introduce the migration transaction type. ### Migration Transaction #### Definition | field | type | |------------------------|-----------| | `chainId` | `uint256` | | `nonce` | `uint64` | | `maxFeePerGas` | `uint256` | | `maxPriorityFeePerGas` | `uint256` | | `gasLimit` | `uint64` | | `codeAddr` | `address` | | `storage` | `List[Tuple[uint256, uint256]]` | | `data` | `bytes` | | `value` | `uint256` | | `accessList` | `List[Tuple[address, List[uint256]]]` | | `yParity` | `uint8` | | `r` | `uint256` | | `s` | `uint256` | The EIP-2718 `TransactionType` is `0x04` and the `TransactionPayload` is `rlp([chainId,

MOTIVATION:
Smart contract wallets have long been touted as the solution to Ethereum's user experience woes. As early as 2015, there were proposals for allowing smart contracts to originate transactions in hopes that new users would flock to smart contract wallets to store their assets. So far, only a fraction of users have elected to do so. Today, account abstraction is still an important goal in Ethereum and there are many efforts attempting to realize it. We're getting closer to succeeding at this, but unfortunately the years of failure have caused many users to simply rely on EOA. After

RATIONALE:
### No `to` address field This transaction is only good for one-time use to migrate an EOA to a smart contract. It is designed to immediately call the deployed contract, which is at the sender's address, after deployment to allow the sender to do any kind of further processing. ### Code pointer for deployment Naively, one could design the migration transaction to have a field `code` of type `bytes`. However, there would be substantial duplication of code calldata, since many users will want to deploy the exact same thing (often a wallet). Using a pointer instead acknowledges this


=== EIP-4 ===
TITLE: EIP Classification
TYPE: Meta 
STATUS: Final
CREATED: 2015-11-17
REQUIRES: 


=== EIP-1295 ===
TITLE: Modify Ethereum PoW Incentive Structure and Delay Difficulty Bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-05
REQUIRES: 

SUMMARY:
Starting with CNSTNTNPL_FORK_BLKNUM the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 6 million blocks later than previously specified with the Homestead fork. Furthermore, Uncle rewards will be adjusted and Nephew rewards will be removed to eliminate excess ancillary ETH issuance. The current ETH block reward of 3 ETH will remain constant.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 6_000_000) if block.number >= CNSTNTNPL_FORK_BLKNUM else block.number #### Adjust Uncle and Nephew rewards If an uncle is included in a block for `block.number >= CNSTNTNPL_FORK_BLKNUM` such that `block.number - uncle.number = k`, the uncle reward is new_uncle_reward = (3 - k) * new_block_reward / 8 This is the existing pre-Constantinople formula for uncle rewards, adjusted to reward 2 levels of Uncles at a reduced

MOTIVATION:
Network scalability and security are at the forefront of risks to the Ethereum protocol. With great strides being made towards on and off chain scalability, the existence of an artificial throughput limiting device in the protocol is not warranted. Removing the risk of reducing throughput through the initialization of the Difficulty Bomb is "low-hanging-fruit" to ensure continued operation at a minimum of current throughput through the next major hard fork (scheduled for late 2019). The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the security of the growing ecosystem are

RATIONALE:
The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the growing ecosystem’s security are paramount. At the same time, the ancillary issuance benefits of the Ethereum protocol can be adjusted to reduce the overall issuance profile. Aggressively adjusting Uncle and removing Nephew rewards will reduce the inflationary aspect of ETH issuance, while keeping the current block reward constant at 3 ETH will ensure top line incentives stay in place. The Difficulty Bomb was instituted as a type of planned obsolescence to force the implementation of network upgrades with regular frequency.


=== EIP-2700 ===
TITLE: JavaScript Provider Event Emitter
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2020-06-05
REQUIRES: 

SUMMARY:
This standard provides the description of an object that is made available to JavaScript applications which they can use to receive notifications from an Ethereum Provider. This standard only describes the notification mechanism, it does not specify the payloads that are valid nor does it specify how the client or the provider will discover or agree on payload content. How/where this Ethereum Provider object is exposed is left to future standards.

SPECIFICATION:
### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Interface ```ts interface EthereumProvider { on(eventName: string, listener: (...params: unknown[]) => void): void removeListener(eventName: string, listener: (...params: unknown[]) => void): void } ``` The specific events that can be listened to and the shape of their listener callback functions is left to be defined in separate standards. If `on` is called with an `eventName` that the provider is familiar with then the provider **MUST** call the provided

MOTIVATION:
When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime. Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or scripts running within that runtime in order to provide notifications of blockchain state changes. In order to achieve maximum compatibility between the provider and the client, a standard is necessary for what the shape of that object is.

RATIONALE:
This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn't a lot of room for improving things such as by using a discriminated union object for listener parameters or having a tighter definition of `on`. The specific events are intentionally left out of this specification as that set will be an ever-evolving collection and having the first few listed here doesn't add value to this specification (especially if, over time, the first few end up deprecated or unused).


=== EIP-706 ===
TITLE: DEVp2p snappy compression
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-09-07
REQUIRES: 

SUMMARY:
The base networking protocol (DEVp2p) used by Ethereum currently does not employ any form of compression. This results in a massive amount of bandwidth wasted in the entire network, making both initial sync as well as normal operation slower and laggier. This EIP proposes a tiny extension to the DEVp2p protocol to enable [Snappy compression](https://en.wikipedia.org/wiki/Snappy_(compression)) on all message payloads after the initial handshake. After extensive benchmarks, results show that data traffic is decreased by 60-80% for initial sync. You can find exact numbers below.

SPECIFICATION:
Bump the advertised DEVp2p version number from `4` to `5`. If during handshake, the remote side advertises support only for version `4`, run the exact same protocol as until now. If the remote side advertises a DEVp2p version `>= 5`, inject a Snappy compression step right before encrypting the DEVp2p message during sending: * A message consists of `{Code, Size, Payload}` * Compress the original payload with Snappy and store it in the same field. * Update the message size to the length of the compressed payload. * Encrypt and send the message as before, oblivious to compression.

MOTIVATION:
Synchronizing the Ethereum main network (block 4,248,000) in Geth using fast sync currently consumes 1.01GB upload and 33.59GB download bandwidth. On the Rinkeby test network (block 852,000) it's 55.89MB upload and 2.51GB download. However, most of this data (blocks, transactions) are heavily compressible. By enabling compression at the message payload level, we can reduce the previous numbers to 1.01GB upload / 13.46GB download on the main network, and 46.21MB upload / 463.65MB download on the test network. The motivation behind doing this at the DEVp2p level (opposed to eth for example) is that it would enable compression for


=== EIP-7784 ===
TITLE: GETCONTRACT opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-10-07
REQUIRES: 

SUMMARY:
This is a proposal to add a new opcode, `GETCONTRACT`. The `GETCONTRACT` opcode would return the address containing the bytecode by its hash.

SPECIFICATION:
### Opcode Definition * **Mnemonic:** `GETCONTRACT` * **Opcode Value:** `0x4f` * **Input:** * `codehash`: A single 32-byte code hash from the stack. * **Output:** * `address`: If the `codehash` exists in the state, pushes the corresponding contract address onto the stack. Otherwise, pushes 0. * **Gas Cost:** 150 * **Stack Effects:** Pops 1 item, pushes 1 item. * **Error Handling:** If the `codehash` is invalid or the bytecode retrieval encounters an error, the instruction will revert. Every contract stored in EVM MUST be added to the state trie with the key being the keccak256 hash of the contract's

MOTIVATION:
Content addressing by hash is a common pattern in database design. It allows to store and retrieve data by its unique footprint in the storage. This pattern is widely used in the industry and it allows abstracting the actual storage location and allows reusing the same bytecode in multiple contracts. Today, existing contract discovery relies on addresses, which are non-deterministic and can be obfuscated through proxies. Indexing by bytecode hash provides a deterministic and tamper-proof way to identify and verify contract code, enhancing security and trust in the Ethereum ecosystem. Consider a security auditor who wants to attest

RATIONALE:
**Bytecode over Addresses**: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable. **Do not re-index**: There is small, yet non-zero probability of hash collision attack. Disallowing updates to indexed location of bytecode coupes with this. **Gas cost**: This operation is more complex than simple data retrieval, however lookup in the database by hash generally is simpler in complexity.


=== EIP-7705 ===
TITLE: NONREENTRANT and REENTRANT opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-09
REQUIRES: 

SUMMARY:
Add two opcodes, `NONREENTRANT` and `REENTRANT`, which set and clear a contract's reentrancy status. After invoking `NONREENTRANT`, a contract cannot be `CALL`ed (or `STATICCALL`ed, or `DELEGATECALL`ed) until `REENTRANT` is invoked.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Two new opcodes are introduced, `NONREENTRANT` (0xF6) and `REENTRANT` (0xF7), which set and clear a contract's nonreentrancy flag. The effect of invoking `NONREENTRANT` is that a contract can no longer have execution context transferred to it (via any of the `*CALL` opcodes), until `REENTRANT` is invoked. `CALL`ing a contract which has the nonreentrancy flag set is equivalent to executing a single `REVERT` opcode. Both

MOTIVATION:
Reentrancy attacks account for a substantial portion of user funds stolen on EVM chains, including the famous "DAO hack". However, due to the cost of preventing against reentrancy attacks in application code, developers often opt-out of reentrancy protection. This cost has come down with the advent of transient storage ([EIP-1153](./eip-1153.md)), but it is still not cheap enough where it is a "no-brainer" to use it by default. This EIP proposes opcodes which make it cheaper to protect against reentrancy in application code.

RATIONALE:
The computational cost of pushing the current value to the call stack (for handling reverts) is accounted for in the overhead cost of the `*CALL` opcodes. An alternative design could be considered which only introduces one opcode. This opcode, `NONREENTRANT`, would take a single stack item and set the nonreentrancy flag based on its value. This alternative design can be considered based on feedback.


=== EIP-3220 ===
TITLE: Crosschain Identifier Specification
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-21
REQUIRES: 

SUMMARY:
The crosschain-id is a 32 byte hex string and with some bytes extracted from blockchain hash and some manually defined to characterize a blockchain. We also propose a registration and lookup service to retrieve blockchain metadata from the crosschain-id.

SPECIFICATION:
### Definition of a 32 byte crosschain id | Name | Size(bytes) | Description | |---------------|-------------|-------------| | Truncated Block Hash | 16 | This is the block hash of the genesis block or the block hash of the block immediate prior to the fork for a fork of a blockchain. The 16 bytes is the 16 least significant bytes, assuming network byte order.| |Native Chain ID| 8 | This is the **Chain Id** value that should be used with the blockchain when signing transactions. For blockchains that do not have a concept of **Chain Id**, this value is

MOTIVATION:
With the success of Bitcoin and Ethereum, various blockchains such as EOS, Ripple, Litecoin, Besu, Wanchain and the like have been developed and are growing at a fast pace. There are also other private and consortium blockchains such as Hyperledger Fabric, Hyperledger Besu, Stellar, Corda, Quorum that only allow nodes with permitted identities to join the blockchain network. The growth of public and private blockchains imposes challenges for inter-chain interoperability, particularly when these chains are heterogeneous and incompatible. Enterprise Ethereum Alliance formed Crosschain Interoperability Task Force (CITF) to look into common crosschain problems and solutions. CITF team noticed

RATIONALE:
We have considered various alternative specifications such as using a random unique hex string to represent a blockchain. The drawback of this method is that the random id can not be used to verify a blockchain's intrinsic identity such as the blockhash of the genesis block. A second alternative is simply using a genesis blockhash to represent a blockchain id for crosschain operations. The drawback of this is that this id does not have information about the property of the blockchain and it has problem when a blockchain is forked into two blockchain.


=== EIP-1884 ===
TITLE: Repricing for trie-size-dependent opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-03-28
REQUIRES: 1, 5, 0, ,,  , 1, 0, 5, 2

SUMMARY:
The growth of the Ethereum state has caused certain opcodes to be more resource-intensive at this point than they were previously. This EIP proposes to raise the `gasCost` for those opcodes.

SPECIFICATION:
At block `N`, - The `SLOAD` (`0x54`) operation changes from `200` to `800` gas, - The `BALANCE` (`0x31`) operation changes from `400` to `700` gas, - The `EXTCODEHASH` (`0x3F`) operation changes from `400` to `700` gas, - A new opcode, `SELFBALANCE` is introduced at `0x47`. - `SELFBALANCE` pops `0` arguments off the stack, - `SELFBALANCE` pushes the `balance` of the current address to the stack, - `SELFBALANCE` is priced as `GasFastStep`, at `5` gas.

MOTIVATION:
An imbalance between the price of an operation and the resource consumption (CPU time, memory etc) has several drawbacks: - It could be used for attacks, by filling blocks with underpriced operations which causes excessive block processing time. - Underpriced opcodes cause a skewed block gas limit, where sometimes blocks finish quickly but other blocks with similar gas use finish slowly. If operations are well-balanced, we can maximise the block gaslimit and have a more stable processing time.

RATIONALE:
Here are two charts, taken from a full sync using Geth. The execution time was measured for every opcode, and aggregated for 10K blocks. These bar charts show the top 25 'heavy' opcodes in the ranges 5M to 6M and 6M to 7M: ![bars1](../assets/eip-1884/run3.total-bars-5.png) ![bars2](../assets/eip-1884/run3.total-bars-6.png) Note: It can also be seen that the `SLOAD` moves towards the top position. The `GASPRICE` (`0x3a`) opcode has position one which I believe can be optimized away within the client -- which is not the case with `SLOAD`/`BALANCE`. Here is another chart, showing a full sync with Geth. It represents the blocks


=== EIP-7577 ===
TITLE: Versioning Scheme for EIPs
TYPE: Meta 
STATUS: Stagnant
CREATED: 2023-12-13
REQUIRES: 

SUMMARY:
This EIP introduces a versioning scheme for [Standards Track](./eip-1.md#eip-types) EIPs by applying [Semantic Versioning 2.0.0](../assets/eip-7577/semver.md) based on changes made to the EIP's Specification section once its status has changed from `Draft` to `Review`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Once an EIP has moved out of "Draft" status, it MUST use the EIP versioning scheme outlined below. It MAY already use the versioning scheme in "Draft" status, which could be useful if the specification is actively being implemented. If more than one team is implementing the specification, it is RECOMMENDED to change the EIP's status to "Review". The EIP versioning scheme MUST apply

MOTIVATION:
EIP specifications often receive increasing modifications as more people review them, which is generally the case as client teams start implementing the specifications and the community gains a better understanding of their interaction with the rest of the protocol. These changes can be difficult to track. In particular, as EVM reference tests are often not maintained (and generally not released) by client teams or the EIP's authors, it can be difficult to ascertain whether a release of reference tests is sufficient, or even valid, to test the latest version of an EIP's specifications or the specification as currently

RATIONALE:
Making the version available in the EIP's metadata header allows for programmatic parsing of the version number by tooling used in reference tests or by client teams. Currently, the execution-spec-tests repository, which contains consensus tests for Ethereum execution clients, implements a rudimentary EIP version checker: EIP spec tests are required to declare the EIP's markdown file digest SHA that the test implementation was based on. The current value of the digest SHA is then polled via the Github API to verify that no changes have occurred since the test implementation. While this provides a warning to test implementers


=== EIP-1186 ===
TITLE: RPC-Method to get Merkle Proofs - eth_getProof
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-06-24
REQUIRES: 1474

SUMMARY:
Ethereum uses a [Merkle Tree](https://github.com/ethereum/eth-wiki/blob/master/fundamentals/patricia-tree.md) to store the state of accounts and their storage. This allows verification of each value by simply creating a Merkle Proof. But currently, the standard RPC-Interface does not give you access to these proofs. This EIP suggests an additional RPC-Method, which creates Merkle Proofs for Accounts and Storage Values. Combined with a stateRoot (from the blockheader) it enables offline verification of any account or storage-value. This allows especially IOT-Devices or even mobile apps which are not able to run a light client to verify responses from an untrusted source only given a trusted

SPECIFICATION:
As Part of the eth-Module, an additional Method called `eth_getProof` should be defined as follows: #### eth_getProof Returns the account- and storage-values of the specified account including the Merkle-proof. ##### Parameters 1. `DATA`, 20 Bytes - address of the account. 2. `ARRAY`, 32 Bytes - array of storage-keys which should be proofed and included. See [`eth_getStorageAt`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageat) 3. `QUANTITY|TAG` - integer block number, or the string `"latest"` or `"earliest"`, see the [default block parameter](https://github.com/ethereum/wiki/wiki/JSON-RPC#the-default-block-parameter) ##### Returns `Object` - A account object: - `balance`: `QUANTITY` - the balance of the account. See [`eth_getBalance`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getbalance) - `codeHash`: `DATA`, 32 Bytes - hash

MOTIVATION:
In order to create a MerkleProof access to the full state db is required. The current RPC-Methods allow an application to access single values (`eth_getBalance`,`eth_getTransactionCount`,`eth_getStorageAt`,`eth_getCode`), but it is impossible to read the data needed for a MerkleProof through the standard RPC-Interface. (There are implementations using leveldb and accessing the data via filesystems, but this can not be used for production systems since it requires the client to be stopped first - See https://github.com/zmitton/eth-proof) Today MerkleProofs are already used internally. For example, the [Light Client Protocol](https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29#on-demand-data-retrieval) supports a function creating MerkleProof, which is used in order to verify the

RATIONALE:
This one Method actually returns 3 different important data points: 1. The 4 fields of an account-object as specified in the yellow paper `[nonce, balance, storageHash, codeHash ]`, which allows storing a hash of the account-object in order to keep track of changes. 2. The MerkleProof for the account starting with a stateRoot from the specified block. 3. The MerkleProof for each requested storage entry starting with a storageHash from the account. Combining these in one Method allows the client to work very efficient since the required data are already fetched from the db. ### Proofs for non


=== EIP-5988 ===
TITLE: Add Poseidon hash function precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-11-15
REQUIRES: 

SUMMARY:
This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Parameters | Constant | Value | | ----------------------------- | ----- | | `FORK_BLKNUM` | `TBD` | | `GAS_COST` | `TBD` | | `POSEIDON_PRECOMPILE_ADDRESS` | `0xA` | Here are the Poseidon parameters that the precompile will support: | Parameter name | Description | Encoding size (in bytes) | Comments | | ---------------- | ------------------------------------------------------------------ | ------------------------ | -------- | | `p` | Prime field modulus | 32 | | |

MOTIVATION:
[Poseidon](../assets/eip-5988/papers/poseidon_paper.pdf) is an arithmetic hash function that is designed to be efficient for Zero-Knowledge Proof Systems. Ethereum adopts a rollup centric roadmap and hence must adopt facilities for L2s to be able to communicate with the EVM in an optimal manner. ZK-Rollups have particular needs for cryptographic hash functions that can allow for efficient verification of proofs. The Poseidon hash function is a set of permutations over a prime field, which makes it particularly well-suited for the purpose of building efficient ZK / Validity rollups on Ethereum. Poseidon is one of the most efficient hashing algorithms that can

RATIONALE:
TODO: Add rationale TODO: Add rationale for gas cost e.g. benchmark and computation cost estimation.


=== EIP-7 ===
TITLE: DELEGATECALL
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-15
REQUIRES: 

SPECIFICATION:
`DELEGATECALL`: `0xf4`, takes 6 operands: - `gas`: the amount of gas the code may use in order to execute; - `to`: the destination address whose code is to be executed; - `in_offset`: the offset into memory of the input; - `in_size`: the size of the input in bytes; - `out_offset`: the offset into memory of the output; - `out_size`: the size of the scratch pad for the output. #### Notes on gas - The basic stipend is not given; `gas` is the total amount the callee receives. - Like `CALLCODE`, account creation never happens, so the upfront gas

RATIONALE:
Propagating the sender and value from the parent scope to the child scope makes it much easier for a contract to store another address as a mutable source of code and ''pass through'' calls to it, as the child code would execute in essentially the same environment (except for reduced gas and increased callstack depth) as the parent. Use case 1: split code to get around 3m gas barrier ```python ~calldatacopy(0, 0, ~calldatasize()) if ~calldataload(0) < 2**253: ~delegate_call(msg.gas - 10000, $ADDR1, 0, ~calldatasize(), ~calldatasize(), 10000) ~return(~calldatasize(), 10000) elif ~calldataload(0) < 2**253 * 2: ~delegate_call(msg.gas - 10000, $ADDR2, 0,


=== EIP-2242 ===
TITLE: Transaction Postdata
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-08-16
REQUIRES: 

SUMMARY:
A paradigm shift in how blockchains are used has been seen recently in Eth 2.0, with the rise of [_Execution Environments_](https://notes.ethereum.org/w1Pn2iMmSTqCmVUTGV4T5A?view) (EEs), and [_stateless clients_](https://ethresear.ch/t/the-stateless-client-concept/172). This shift involves blockchains serving as a secure data availability and arbitration layer, _i.e._, they provide a globally-accepted source of available data, and process fraud/validity and data availability proofs. This same paradigm can be applied on Eth 1.x, replacing EEs with [trust-minimized side chains](https://ethresear.ch/t/building-scalable-decentralized-payment-systems-request-for-feedback/5312).

SPECIFICATION:
We propose a consensus modification, beginning at `FORK_BLKNUM`: An additional optional field, `postdata`, is added to transactions. Serialized transactions now have the format: ``` "from": bytes20, "to": bytes20, "startGas": uint256, "gasPrice": uint256, "value": uint256, "data": bytes, "nonce": uint256, ["postdata": bytes], ``` with witnesses signing over the [RLP encoding](https://github.com/ethereum/wiki/wiki/RLP) of the above. `postdata` is data that is posted on-chain, for later historical retrieval by layer-2 systems. `postdata` is an RLP-encoded twople `(version: uint64, data: bytes)`. 1. `version` is `0`. 1. `data` is an RLP-encoded list of binary data. This EIP does not interpret the data in any way, simply

MOTIVATION:
While [EIP-2028](./eip-2028.md) provides a reduction in gas cost of calldata, and is a step in the right direction of encouraging use of history rather than state, the EVM does not actually need to see all data that is posted on-chain. Following the principle of "don't pay for what you don't use," a distinct way of posting data on-chain, but without actually being usable within the EVM, is needed. For [trust-minimized side chains with fraud proofs](https://ethresear.ch/t/minimal-viable-merged-consensus/5617), we simply need to ensure that the side chain block proposer has attested that _some_ data is available. Authentication can be performed as

RATIONALE:
The changes proposed are as minimal and non-disruptive to the existing EVM and transaction format as possible while also supporting possible [future extensions](https://ethresear.ch/t/multi-threaded-data-availability-on-eth-1/5899) through a version code.


=== EIP-7658 ===
TITLE: Light client data backfill
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-21
REQUIRES: 

SUMMARY:
This EIP defines a mechanism for syncing [light client data](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md) between beacon nodes.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Containers #### New containers ##### `SyncData` ```python class SyncData(Container): # Sync committee aggregate signature sync_aggregate: SyncAggregate # Slot at which the aggregate signature was created signature_slot: Slot ``` #### Extended containers ##### `BeaconState` New fields are added to the end of `BeaconState` from the activating fork onward to track the current and previous sync committee period's best sync data. ```python class BeaconState(Container): ...

MOTIVATION:
[Light client data](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md) is collected by beacon nodes to assist [light clients](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/light-client.md) to sync with the network. The [sync protocol](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md) defines a mechanism to sync forward in time. However, it cannot be used to sync backward. Collecting light client data is challenging because beacon nodes need to have access to the corresponding [`BeaconState`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/phase0/beacon-chain.md#beaconstate) and [`SignedBeaconBlock`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/phase0/beacon-chain.md#signedbeaconblock). `BeaconState` objects are not available before the initially synced checkpoint state, and `SignedBeaconBlock` objects have a limited retention period on libp2p. Furthermore, each [sync committee period](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/beacon-chain.md#get_next_sync_committee) consists of `EPOCHS_PER_SYNC_COMMITTEE_PERIOD * SLOTS_PER_EPOCH` slots. To support archive services such as Portal network to provide a

RATIONALE:
### How to rank `SyncAggregate`? The EIP reuses the [`is_better_update`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md#is_better_update) function from existing specs. ### How could a backfill protocol use this? Once the data is available in the `BeaconState`, a light client data backfill protocol could be defined that serves, for past periods: 1. A `LightClientUpdate` from requested `period` + 1 that proves that the entirety of `period` is finalized. 2. `BeaconState.historical_summaries[period].block_summary_root` at (1)'s `attested_header.beacon.state_root` + Merkle proof. 3. For each epoch's slot 0 block within requested `period`, the corresponding `LightClientHeader` + Merkle multi-proof for the block's inclusion into (2)'s `block_summary_root`. 4. For each of the entries


=== EIP-7932 ===
TITLE: Secondary Signature Algorithms
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-04-12
REQUIRES: 1, 5, 5, ,,  , 6, 4, 0, 4, ,,  , 6, 4, 6, 6, ,,  , 6, 4, 9, 3, ,,  , 7, 4, 9, 5, ,,  , 7, 7, 0, 2, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP does three things: - Standardizes the introduction of several new algorithms for signing data. - Introduces a new [EIP-6404](./eip-6404.md) transaction profile & [EIP-2718](./eip-2718.md) transaction type that can modify the signature data of a contained transaction to a different signature algorithm. - Introduces a precompile at address `0x12` for decoding these newly introduced algorithms.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Unless explicitly noted, integer encoding MUST be in big-endian format. ### Parameters | Constant | Value | | - | - | | `MAX_ADDITIONAL_INFO` | `255` | | `GAS_PER_ADDITIONAL_VERIFICATION_BYTE`| `16` | | `SIGRECOVER_PRECOMPILE_ADDRESS`| `Bytes20(0x12)` | | `SIGRECOVER_PRECOMPILE_BASE_GAS` | `3000` | | `ALGORITHMIC_TX_TYPE` | `Bytes1(0x07)` | `SECP256K1_SIGNATURE_SIZE` is defined in [EIP-6404](./eip-6404.md). `ExecutionAddress` is defined in [EIP-6466](./eip-6466.md). ### Algorithmic Transaction (RLP) **This section is only applicable

MOTIVATION:
As quantum computers become more advanced, several new post-quantum (PQ) algorithms have been designed. These algorithms all have certain issues, such as large key sizes (>1KiB), large signature sizes, or long verification times. These issues make them more expensive to compute and store than the currently used secp256k1 curve. This EIP provides a solution to the diversity in algorithms by adding a standardized way to represent alternative algorithms within a transaction.

RATIONALE:
### Opaque `signature_info` type As each algorithm has unique properties, e.g. signature recovery and key sizes, the object needs to hold every permutation of every possible signature and additional recovery information. A bytearray of a dynamic size would be able to achieve this goal. However, this leads to a DoS vector which the [Gas penalties](#gas-penalties) section solves. ### Gas penalties Having multiple different algorithms results in multiple different signature sizes and verification costs. Hence, every signature algorithm that is more expensive than the default ECDSA secp256k1 curve incurs an additional gas penalty. This is to discourage the use


=== EIP-7923 ===
TITLE: Linear, Page-Based Memory Costing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-27
REQUIRES: 

SUMMARY:
This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation and page thrashing are included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.

SPECIFICATION:
Consider the following constants: ```python ALLOCATE_PAGE_COST = 100 THRASH_PAGE_COST = 6 LRU_SIZE = 512 PAGE_SIZE = 4096 MAXIMUM_MEMORY_SIZE = 64 * 1024 * 1024 ``` The memory costing algorithm is changed as follows: 1. For each page touched by an instruction 1. Charge `ALLOCATE_PAGE_COST` gas if it has not been touched before in this message call. 2. Charge `THRASH_PAGE_COST` gas if it is not in the `LRU_SIZE` least-recently touched pages. 2. The base gas cost for all memory instructions, e.g. `MLOAD` and `MSTORE`, remains the same, at 3. The behavior of `msize` remains the same. It returns the

MOTIVATION:
The EVM currently uses a quadratic pricing model for its memory. This was originally put in place to defend against DoS attacks. However, the memory model has several drawbacks. 1. It is anachronistic. Even at a gas limit of 30 million gas, users can only use 3MB of memory in a message call (and that burns all gas). Since the quadratic term for memory expansion starts kicking in at 724 bytes, users use much less memory in practice. To use even 64KB of memory -- the amount of memory available to a PC from the early 80's --

RATIONALE:
Benchmarks were performed on a 2019-era CPU, with the ability to `keccak256` around 256MB/s, giving it a gas-to-ns ratio of 20 ns per 1 gas (given that `keccak256` costs 6 gas per 32 bytes). The following benchmarks were performed: - Time to allocate a fresh page: 1-2us - Time to randomly read a byte from a 2MB range: 1.8ns - Time to randomly read a byte from a 32MB range: 7ns - Time to randomly read a byte from a 4GB range: 40ns - Time to update a hashmap with 512 items: 8ns - Time to update a


=== EIP-5003 ===
TITLE: Insert Code into EOAs with AUTHUSURP
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-03-26
REQUIRES: 3, 0, 7, 4, ,,  , 3, 6, 0, 7

SUMMARY:
This EIP introduces a new opcode, `AUTHUSURP`, which deploys code at an [EIP-3074](./eip-3074.md) authorized address. For externally owned accounts (EOAs), together with [EIP-3607](./eip-3607.md), this effectively revokes the original signing key's authority.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Conventions - **`top - N`** - the `N`th most recently pushed value on the EVM stack, where `top - 0` is the most recent. - **invalid execution** - execution that is invalid and must exit the current execution frame immediately, consuming all remaining gas (in the same way as a stack underflow or invalid jump). - **empty account** - account where its balance is 0, its nonce is

MOTIVATION:
EOAs currently hold a significant amount of user-controlled value on Ethereum blockchains, but are limited by the protocol in a variety of critical ways. These accounts do not support rotating keys for security, batching to save gas, or sponsored transactions to reduce the need to hold ether yourself. There are countless other benefits that come from having a contract account or account abstraction, like choosing one's own authentication algorithm, setting spending limits, enabling social recovery, allowing key rotation, arbitrarily and transitively delegating capabilities, and just about anything else we can imagine. New users have access to these benefits

RATIONALE:
`AUTHUSURP` does not check the nonce of the `authorized` account because it must work with accounts that have previously sent transactions. When using `AUTHUSURP`, if the initcode were to deploy a zero-length contract, there would be no way to prevent using `AUTHUSURP` again later. The account's code must be checked immediately before deploying to catch the situation where the initcode attempts to `AUTHUSURP` at the same address. This is unnecessary with other deployment instructions because they increment and check the account's nonce.


=== EIP-712 ===
TITLE: Typed structured data hashing and signing
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-09-12
REQUIRES: 1, 5, 5, ,,  , 1, 9, 1

SUMMARY:
This is a standard for hashing and signing of typed structured data as opposed to just bytestrings. It includes a * theoretical framework for correctness of encoding functions, * specification of structured data similar to and compatible with Solidity structs, * safe hashing algorithm for instances of those structures, * safe inclusion of those instances in the set of signable messages, * an extensible mechanism for domain separation, * new RPC call `eth_signTypedData`, and * an optimized implementation of the hashing algorithm in EVM. It does not include replay protection.

SPECIFICATION:
The set of signable messages is extended from transactions and bytestrings `𝕋 ∪ 𝔹⁸ⁿ` to also include structured data `𝕊`. The new set of signable messages is thus `𝕋 ∪ 𝔹⁸ⁿ ∪ 𝕊`. They are encoded to bytestrings suitable for hashing and signing as follows: * `encode(transaction : 𝕋) = RLP_encode(transaction)` * `encode(message : 𝔹⁸ⁿ) = "\x19Ethereum Signed Message:\n" ‖ len(message) ‖ message` where `len(message)` is the _non-zero-padded_ ascii-decimal encoding of the number of bytes in `message`. * `encode(domainSeparator : 𝔹²⁵⁶, message : 𝕊) = "\x19\x01" ‖ domainSeparator ‖ hashStruct(message)` where `domainSeparator` and `hashStruct(message)` are defined below. This

MOTIVATION:
Signing data is a solved problem if all we care about are bytestrings. Unfortunately in the real world we care about complex meaningful messages. Hashing structured data is non-trivial and errors result in loss of the security properties of the system. As such, the adage "don't roll your own crypto" applies. Instead, a peer-reviewed well-tested standard method needs to be used. This EIP aims to be that standard. This EIP aims to improve the usability of off-chain message signing for use on-chain. We are seeing growing adoption of off-chain message signing as it saves gas and reduces the

RATIONALE:
The `encode` function is extended with a new case for the new types. The first byte of the encoding distinguishes the cases. For the same reason it is not safe to start immediately with the domain separator or a `typeHash`. While hard, it may be possible to construct a `typeHash` that also happens to be a prefix of a valid RLP encoded transaction. The domain separator prevents collision of otherwise identical structures. It is possible that two DApps come up with an identical structure like `Transfer(address from,address to,uint256 amount)` that should not be compatible. By introducing a domain


=== EIP-2029 ===
TITLE: State Rent A - State counters contract
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-15
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces a place in the Ethereum state where various state counters can be stored. At this point, the most important counter is the total number of transactions happened, and this counter will be used to populate the nonces of newly created non-contract accounts. This way of populating nonce ensures replay protection for accounts that were evicted and then brought back by sending ether to them.

SPECIFICATION:
Prior to the block A, a contract is deployed with the following code: `0x60 0x20 0x60 0x00 0x80 0x80 0x35 0x54 0x90 0x52 0xF3`, which corresponds to this assembly: `PUSH1 32 PUSH1 0 DUP1 DUP1 CALLDATALOAD SLOAD SWAP1 MSTORE RETURN` Call to this contract accepts one 32-byte argument, `x`, and returns the value of the storage item [`x`]. This contract is deployed using `CREATE2` opcode in such a way that it has the same address on any network.

MOTIVATION:
Ethereum currently does not have a special place in the state for tracking state counters such as number of transactions or number of accounts.

RATIONALE:
Two alternative solutions were considered so far: 1. Extending the structure of the Ethereum state to introduce more fields, and hence change the way the state root is constructed. The main downside of this approach is the impact on the software what is currently coupled with the particular way the state root is constructed. Particularly it affects the software that deals with merkle proofs derived from the state root. 2. Extended State Oracle ([EIP-2014](./eip-2014.md)). Under such proposal, there will be a precompile contract with standardised interface, capable of returning current values of the counters. However, the actual data


=== EIP-1240 ===
TITLE: Remove Difficulty Bomb
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-07-21
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty without considering the current block number.

SPECIFICATION:
#### Remove Difficulty For the purposes of `calc_difficulty`, if `block.number >= FORK_BLOCK_NUMBER` then change the epsilon component to `0` rather than having it be a function of block number.

MOTIVATION:
The difficulty bomb operates under the assumption that miners decide what code economic participants are running, rather than economic participants deciding for themselves. In reality, miners will mine whatever chain is most profitable and the most profitable chain is the one that economic participants use. If 99% of miners mine a chain that no economic participants use then that chain will have no value and the miners will cease mining of it in favor of some other chain that does have economic participants. Another way to put this is that miners will follow economic participants, not the other

RATIONALE:
With the difficulty bomb removed, when Casper is released it will be up to economic participants to decide whether they want the features that Casper enables or not. If they do not want Casper, they are free to continue running unpatched clients and participating in the Ethereum network as it exists today. This freedom of choice is the cornerstone of DLTs and making it hard for people to make that choice (by creating an artificial pressure) does not work towards that goal of freedom of choice. If the development team is not confident that economic participants will want


=== EIP-3368 ===
TITLE: Increase block rewards to 3 ETH, with 2 Year Decay to 1 ETH Scheduled
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-12
REQUIRES: 

SUMMARY:
Set the block reward to 3 ETH and then decrease it slightly every block for 4,724,000 blocks (approximately 2 years) until it reaches 1 ETH.

SPECIFICATION:
Adjust block, uncle, and nephew rewards ### Constants * `TRANSITION_START_BLOCK_NUMBER: TBD` * `TRANSITION_DURATION: 4_724_000` (about two years) * `TRANSITION_END_BLOCK_NUMBER: FORK_BLOCK_NUMBER + TRANSITION_DURATION` * `STARTING_REWARD: 3_000_000_000_000_000_000` * `ENDING_REWARD: 1_000_000_000_000_000_000` * `REWARD_DELTA: STARTING_REWARD - ENDING_REWARD` ### Block Reward ```py if block.number >= TRANSITION_END_BLOCK_NUMBER: block_reward = ENDING_REWARD elif block.number = TRANSITION_START_BLOCK_NUMBER: block_reward = STARTING_REWARD elif block.number > TRANSITION_START_BLOCK_NUMBER: block_reward = STARTING_REWARD - REWARD_DELTA * TRANSITION_DURATION / (block.number - TRANSITION_START_BLOCK_NUMBER) ```

MOTIVATION:
A sudden drop in PoW mining rewards could result in a sudden precipitous decrease in mining profitability that may drive miners to auction off their hashrate to the highest bidder while they figure out what to do with their now "worthless" hardware. If enough hashrate is auctioned off in this way at the same time, an attacker will be able to rent a large amount of hashing power for a short period of time at relatively low cost vs. reward and potentially attack the network. By setting the block reward to X (where X is enough to offset

RATIONALE:
2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort as something we have in our pocket should the "network need to attract hashing power quickly and then bleed it off over time" rather than "something that is scheduled to be included in X hard fork" ; Recommendation to have in a fast track state, but NOT deployed to


=== EIP-999 ===
TITLE: Restore Contract Code at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-04-04
REQUIRES: 

SUMMARY:
The `WalletLibrary` contract was used by the [Parity Wallet](https://www.parity.io/) to reduce gas costs for users deploying multi-signature wallets on the Ethereum blockchain. It contained basic functionality such as confirming or revoking multi-signature transactions for any wallet deployed that depends on this library. The [accidental self-destruction](https://github.com/paritytech/parity/issues/6995) of the library contract caused significant amounts of Ether and other assets owned by many different parties to be inaccessible. This proposal suggests restoring the `WalletLibrary` by a [patched](https://github.com/parity-contracts/0x863df6bfa4) version to allow the owners of the dependent multi-signature wallets regain access to their assets.

SPECIFICATION:
The self-destructed contract code at [`0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4`](https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code) shall be replaced with a patched version of the [`walletLibrary.sol`](https://github.com/parity-contracts/0x863df6bfa4/blob/master/contracts/walletLibrary.sol) as reviewed, tested, and approved in [parity-contracts/0x863df6bfa4](https://github.com/parity-contracts/0x863df6bfa4): ```json { "object": "606060405234156200000d57fe5b5b6000808054806001018281620000259190620002d9565b916000526020600020900160005b6000909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506200012081805480602002602001604051908101604052809291908181526020018280548015620000fd57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311620000b2575b505050505060016000620001286401000000000262001d46176401000000009004565b5b5062000330565b600060015411156200013a5760006000fd5b6200015981620001806401000000000262001d71176401000000009004565b620001798383620001c26401000000000262001d9c176401000000009004565b5b5b505050565b60006001541115620001925760006000fd5b80600281905550620001b7620002c16401000000000262001bcf176401000000009004565b6004819055505b5b50565b600060006001541115620001d65760006000fd5b600082111515620001e75760006000fd5b81835110151515620001f95760006000fd5b8251600181905550600090505b8251811015620002b35782818151811015156200021f57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff16600582600101610100811015156200025357fe5b0160005b508190555080600101610105600085848151811015156200027457fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80600101905062000206565b816000819055505b5b505050565b60006201518042811515620002d257fe5b0490505b90565b815481835581811511620003035781836000526020600020918201910162000302919062000308565b5b505050565b6200032d91905b80821115620003295760008160009055506001016200030f565b5090565b90565b611ebf80620003406000396000f300606060405236156100ef576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063173825d91461016d5780632f54bf6e146101a35780634123cb6b146101f157806352375093146102175780635c52c2f51461023d578063659010e71461024f5780637065cb4814610275578063746c9171146102ab578063797af627146102d1578063b20d30a91461030d578063b61d27f61461032d578063b75c7dc61461039c578063ba51a6df146103c0578063c2cf7326146103e0578063c41a360a1461043b578063f00d4b5d1461049b578063f1736d86146104f0575b61016b5b6000341115610168577fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c3334604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b5b565b005b341561017557fe5b6101a1600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610516565b005b34156101ab57fe5b6101d7600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610659565b604051808215151515815260200191505060405180910390f35b34156101f957fe5b610201610691565b6040518082815260200191505060405180910390f35b341561021f57fe5b610227610697565b6040518082815260200191505060405180910390f35b341561024557fe5b61024d61069d565b005b341561025757fe5b61025f6106d7565b6040518082815260200191505060405180910390f35b341561027d57fe5b6102a9600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506106dd565b005b34156102b357fe5b6102bb610829565b6040518082815260200191505060405180910390f35b34156102d957fe5b6102f360048080356000191690602001909190505061082f565b604051808215151515815260200191505060405180910390f35b341561031557fe5b61032b6004808035906020019091905050610dcc565b005b341561033557fe5b61037e600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919080359060200190820180359060200191909192905050610e06565b60405180826000191660001916815260200191505060405180910390f35b34156103a457fe5b6103be60048080356000191690602001909190505061127d565b005b34156103c857fe5b6103de6004808035906020019091905050611392565b005b34156103e857fe5b61042160048080356000191690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190505061141a565b604051808215151515815260200191505060405180910390f35b341561044357fe5b610459600480803590602001909190505061149c565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34156104a357fe5b6104ee600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506114bf565b005b34156104f857fe5b610500611672565b6040518082815260200191505060405180910390f35b600060003660405180838380828437820191505092505050604051809103902061053f81611678565b156106535761010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561057f57610652565b600160015403600054111561059357610652565b6000600583610100811015156105a557fe5b0160005b5081905550600061010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506105e6611890565b6105ee6119d0565b7f58619076adf5bb0943d100ef88d52d7c3fd691b19d3a9071b555b651fbf418da83604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b5b505050565b6000600061010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541190505b919050565b60015481565b60045481565b6000366040518083838082843782019150509250505060405180910390206106c481611678565b156106d35760006003819055505b5b5b50565b60035481565b60003660405180838380828437820191505092505050604051809103902061070481611678565b156108245761071282610659565b1561071c57610823565b610724611890565b60fa600154101515610739576107386119d0565b5b60fa60015410151561074a57610823565b6001600081548092919060010191905055508173ffffffffffffffffffffffffffffffffffffffff1660056001546101008110151561078557fe5b0160005b508190555060015461010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507f994a936646fe87ffe4f1e469d3d6aa417d6b855598397f323de5b449f765f0c382604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b5b5050565b60005481565b600060008261083d81611678565b15610dc45760006101086000866000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415806108c757506000610108600086600019166000191681526020019081526020016000206001015414155b80610906575060006101086000866000191660001916815260200190815260200160002060020180546001816001161561010002031660029004905014155b15610dc25760006101086000866000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415610a5057610a496101086000866000191660001916815260200190815260200160002060010154610108600087600019166000191681526020019081526020016000206002018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610a3f5780601f10610a1457610100808354040283529160200191610a3f565b820191906000526020600020905b815481529060010190602001808311610a2257829003601f168201915b5050505050611b37565b9150610b71565b6101086000856000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166101086000866000191660001916815260200190815260200160002060010154610108600087600019166000191681526020019081526020016000206002016040518082805460018160011615610100020316600290048015610b4a5780601f10610b1f57610100808354040283529160200191610b4a565b820191906000526020600020905b815481529060010190602001808311610b2d57829003601f168201915b505091505060006040518083038185876185025a03f1925050501515610b705760006000fd5b5b7fe3a3a4111a84df27d76b68dc721e65c7711605ea5eee4afd3a9c58195217365c338561010860008860001916600019168152602001908152602001600020600101546101086000896000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661010860008a6000191660001916815260200190815260200160002060020187604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200186600019166000191681526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825284818154600181600116156101000203166002900481526020019150805460018160011615610100020316600290048015610d475780601f10610d1c57610100808354040283529160200191610d47565b820191906000526020600020905b815481529060010190602001808311610d2a57829003601f168201915b505097505050505050505060405180910390a16101086000856000191660001916815260200190815260200160002060006000820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556001820160009055600282016000610db79190611be6565b505060019250610dc3565b5b5b5b5050919050565b600036604051808383808284378201915050925050506040518091039020610df381611678565b15610e0157816002819055505b5b5b5050565b60006000610e1333610659565b1561127357600084849050148015610e305750610e2f85611b51565b5b80610e3d57506001600054145b15610fed5760008673ffffffffffffffffffffffffffffffffffffffff161415610ea457610e9d8585858080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050611b37565b9050610ef3565b8573ffffffffffffffffffffffffffffffffffffffff168585856040518083838082843782019150509250505060006040518083038185876185025a03f1925050501515610ef25760006000fd5b5b7f9738cd1a8777c86b011f7b01d87d484217dc6ab5154a9d41eda5d14af8caf292338688878786604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281038252858582818152602001925080828437820191505097505050505050505060405180910390a1611271565b6000364360405180848480828437820191505082815260200193505050506040518091039020915060006101086000846000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16148015611099575060006101086000846000191660001916815260200190815260200160002060010154145b80156110d85750600061010860008460001916600019168152602001908152602001600020600201805460018160011615610100020316600290049050145b1561118f57856101086000846000191660001916815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550846101086000846000191660001916815260200190815260200160002060010181905550838361010860008560001916600019168152602001908152602001600020600201919061118d929190611c2e565b505b6111988261082f565b1515611270577f1733cbb53659d713b79580f79f3f9ff215f78a7c7aa45890f3b89fc5cddfbf328233878988886040518087600019166000191681526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018281038252848482818152602001925080828437820191505097505050505050505060405180910390a15b5b5b5b5b50949350505050565b60006000600061010560003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054925060008314156112be5761138c565b8260020a9150610106600085600019166000191681526020019081526020016000209050600082826001015416111561138b5780600001600081548092919060010191905055508181600101600082825403925050819055507fc7fb647e59b18047309aa15aad418e5d7ca96d173ad704f1031a2c3d7591734b3385604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182600019166000191681526020019250505060405180910390a15b5b50505050565b6000366040518083838082843782019150509250505060405180910390206113b981611678565b15611415576001548211156113cd57611414565b816000819055506113dc611890565b7facbdb084c721332ac59f9b8e392196c9eb0e4932862da8eb9beaf0dad4f550da826040518082815260200191505060405180910390a15b5b5b5050565b600060006000600061010660008760001916600019168152602001908152602001600020925061010560008673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561147f5760009350611493565b8160020a9050600081846001015416141593505b50505092915050565b6000600560018301610100811015156114b157fe5b0160005b505490505b919050565b60006000366040518083838082843782019150509250505060405180910390206114e881611678565b1561166b576114f683610659565b156115005761166a565b61010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561153b5761166a565b611543611890565b8273ffffffffffffffffffffffffffffffffffffffff166005836101008110151561156a57fe5b0160005b5081905550600061010560008673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508161010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507fb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c8484604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019250505060405180910390a15b5b5b50505050565b60025481565b600060006000600061010560003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054925060008314156116bb57611888565b6101066000866000191660001916815260200190815260200160002091506000826000015414156117455760005482600001819055506000826001018190555061010780548091906001016117109190611cae565b826002018190555084610107836002015481548110151561172d57fe5b906000526020600020900160005b5081600019169055505b8260020a90506000818360010154161415611887577fe1c52dc63b719ade82e8bea94cc41a0d5d28e4aaf536adb5e9cccc9ff8c1aeda3386604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182600019166000191681526020019250505060405180910390a16001826000015411151561185e57610107610106600087600019166000191681526020019081526020016000206002015481548110151561180a57fe5b906000526020600020900160005b5060009055610106600086600019166000191681526020019081526020016000206000600082016000905560018201600090556002820160009055505060019350611888565b8160000160008154809291906001900391905055508082600101600082825417925050819055505b5b5b505050919050565b60006000610107805490509150600090505b818110156119bc576101086000610107838154811015156118bf57fe5b906000526020600020900160005b50546000191660001916815260200190815260200160002060006000820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905560018201600090556002820160006119269190611be6565b505060006001026101078281548110151561193d57fe5b906000526020600020900160005b5054600019161415156119b05761010660006101078381548110151561196d57fe5b906000526020600020900160005b505460001916600019168152602001908152602001600020600060008201600090556001820160009055600282016000905550505b5b8060010190506118a2565b61010760006119cb9190611cda565b5b5050565b6000600190505b600154811015611b33575b60015481108015611a095750600060058261010081101515611a0057fe5b0160005b505414155b15611a1b5780806001019150506119e2565b5b6001600154118015611a4557506000600560015461010081101515611a3d57fe5b0160005b5054145b15611a625760016000815480929190600190039190505550611a1c565b60015481108015611a8b57506000600560015461010081101515611a8257fe5b0160005b505414155b8015611aac5750600060058261010081101515611aa457fe5b0160005b5054145b15611b2e57600560015461010081101515611ac357fe5b0160005b505460058261010081101515611ad957fe5b0160005b508190555080610105600060058461010081101515611af857fe5b0160005b50548152602001908152602001600020819055506000600560015461010081101515611b2457fe5b0160005b50819055505b6119d7565b5b50565b600081516020830184f09050803b15610000575b92915050565b6000611b5c33610659565b15611bc957600454611b6c611bcf565b1115611b89576000600381905550611b82611bcf565b6004819055505b600354826003540110158015611ba55750600254826003540111155b15611bc3578160036000828254019250508190555060019050611bc8565b600090505b5b5b919050565b60006201518042811515611bdf57fe5b0490505b90565b50805460018160011615610100020316600290046000825580601f10611c0c5750611c2b565b601f016020900490600052602060002090810190611c2a9190611cfc565b5b50565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10611c6f57803560ff1916838001178555611c9d565b82800160010185558215611c9d579182015b82811115611c9c578235825591602001919060010190611c81565b5b509050611caa9190611cfc565b5090565b815481835581811511611cd557818360005260206000209182019101611cd49190611d21565b5b505050565b5080546000825590600052602060002090810190611cf89190611d21565b5b50565b611d1e91905b80821115611d1a576000816000905550600101611d02565b5090565b90565b611d4391905b80821115611d3f576000816000905550600101611d27565b5090565b90565b60006001541115611d575760006000fd5b611d6081611d71565b611d6a8383611d9c565b5b5b505050565b60006001541115611d825760006000fd5b80600281905550611d91611bcf565b6004819055505b5b50565b600060006001541115611daf5760006000fd5b600082111515611dbf5760006000fd5b81835110151515611dd05760006000fd5b8251600181905550600090505b8251811015611e85578281815181101515611df457fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1660058260010161010081101515611e2757fe5b0160005b50819055508060010161010560008584815181101515611e4757fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b806001019050611ddd565b816000819055505b5b5050505600a165627a7a7230582016889f0740f073d397f9d00b0d19900fb050b957e3e2942f861085beb9baab180029", "opcodes": "PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH3 0xD JUMPI INVALID JUMPDEST JUMPDEST PUSH1 0x0 DUP1 DUP1 SLOAD DUP1 PUSH1 0x1 ADD DUP3 DUP2 PUSH3 0x25 SWAP2 SWAP1 PUSH3 0x2D9 JUMP JUMPDEST SWAP2 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 ADD PUSH1 0x0 JUMPDEST PUSH1 0x0 SWAP1 SWAP2 SWAP1 SWAP2 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR

MOTIVATION:
This proposal is necessary because the Ethereum protocol does not allow the restoration of self-destructed contracts and there is no other simple way to enable the affected users and companies regaining access to their tokens and Ether. In opposite to previously discussed proposals, this will not change any EVM semantics and tries to achieve the goal of unfreezing the funds by a single state transition as specified in the next section.

RATIONALE:
The design decision to restore the `WalletLibrary` contract code in a single state transition was made after lengthy discussions of [alternate proposals](https://gist.github.com/5chdn/a9bb8617cc8523a030126a3d1c60baf3) that explored different ways to improve the Ethereum protocol to allow contract revivals by adding different built-in contracts. It was eventually concluded that all of these proposals changing the EVM semantics around self-destructed contracts were introducing unwanted side-effects and [potential risks](https://medium.com/@weka/on-paritys-proposed-changes-to-selfdestruct-behaviour-c3f0e5bc0f49) to the existing smart-contract ecosystem on the Ethereum platform. The total supply of Ether is neither changed nor does this proposal require the transfer of any tokens or assets including Ether. It is assumed that


=== EIP-6046 ===
TITLE: Replace SELFDESTRUCT with DEACTIVATE
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-11-25
REQUIRES: 2, 6, 8, 1, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 2, 9

SUMMARY:
Change `SELFDESTRUCT` to not delete all storage keys, and to use a special value in the account nonce to signal *deactivated* accounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction to `DEACTIVATE`.

SPECIFICATION:
1. Change the rules introduced by [EIP-2681](./eip-2681.md) such that regular nonce increase is bound by `2^64-2` instead of `2^64-1`. This applies from genesis. 2. The behaviour of `SELFDESTRUCT` is changed such that: - Does not delete any storage keys and also leave the account in place. - Transfer the account balance to the target **and** set account balance to `0.` - Set the account nonce to `2^64-1`. - Note that no refund is given since [EIP-3529](./eip-3529.md). - Note that the rules of [EIP-2929](./eip-2929.md) regarding `SELFDESTRUCT` remain unchanged. 2. Modify account execution (triggered both via external transactions or CALL*

MOTIVATION:
The `SELFDESTRUCT` instruction currently has a fixed price, but is unbounded in terms of how many storage/account changes it performs (it needs to delete all keys). This has been an outstanding concern for some time. Furthermore, with *Verkle trees*, accounts will be organised differently: account properties, including storage, will have individual keys. It will not be possible to traverse and find all used keys. This makes `SELFDESTRUCT` very challenging to support in Verkle trees.

RATIONALE:
There have been various proposals of removing `SELFDESTRUCT` and many would just outright remove the deletion capability. This breaks certain usage patterns, which the *deactivation* option leaves intact, albeit with minor changes. This only affects *newly* deployed code, and not existing one. All the proposals would leave data in the state, but this proposal provides the flexibility to reuse or remove storage slots one-by-one should the revived contract choose to do so.


=== EIP-2666 ===
TITLE: Repricing of precompiles and Keccak256 function
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-05-22
REQUIRES: 1, 3, 5, 2, ,,  , 2, 0, 4, 6, ,,  , 2, 5, 6, 5

SUMMARY:
Costs of many precompiles and built-in functions are invalid at the current state of the clients. This EIP contains a list of changes to the pricing formulas to better reflect underlying computations' structure.

SPECIFICATION:
If `block_number >= X` set the gas cost of the following precompiles and Keccak256 opcode: - SHA256 (precompile `0x02`): `10 + ((len(input) + 8)/64 + 1) * 9` - RIPEMD (precompile `0x03`): `6 + ((len(input) + 8)/64 + 1) * 12` - KECCAK256 (`0x20`): `13 + (len(input)/136 + 1)*15` This EIP *ideally* requires that `MODEXP` repricing is [implemented](./eip-2565.md) to also accurately reflect that there is no implicit compensation for an old `STATICCALL (0xfa)` cost (pre-2046).

MOTIVATION:
Historical pricing for these functions in EVM does not reflect inner structure of the underlying computations (inner structure of the hash functions). - EIP-2046 changes a `STATICCALL (0xfa)` cost to precompile and it may be necessary to adjust costs of some precompiles that *may* have taken old large cost (`700` gas) into account and tried to compensate for it - Some precompiles are overpriced and their pricing formulas do not reflect the structure of underlying functions - Keccak256 built-in function (opcode) in EVM has pricing that does not reflect underlying hash function structure

RATIONALE:
Cost of functions being executed must accurately reflect real CPU time spent on computations, so benchmarking was performed for current precompiles and Keccak256 function to measure running time versus input parameters. ### Detailed summary of repricing approach This EIP relies on two facts: - apriori knowledge of the inner strucute of the hash functions - benchmarks provided by the client teams for some reasonable range of input lengths for random inputs (random byte strings of a given length) ### Benchmarks on the most popular clients Necessary benchmarks for EIP-2666 were provided by the clients and raw form is


=== EIP-2780 ===
TITLE: Reduce intrinsic transaction gas
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2020-07-11
REQUIRES: 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
Reduce the intrinsic cost `TX_BASE_COST` from `21,000` to `6,000`. If a non-create transaction has `value > 0` and targets a **non-existent** account add `GAS_NEW_ACCOUNT = 25,000` to align with `CALL` account creation and price in state growth. This additional `GAS_NEW_ACCOUNT` cost is not applied in the case of a `CREATE` transaction as it is already applied in its cost structure. Calldata and access-list metering are unchanged. This is a focused change targeted at the initial stage of processing a transaction and returning the gas overpricing to do more useful work. Capacity Impact: * **Average:** +18.5% more transactions per

SPECIFICATION:
After `FORK_BLOCK`, set the following parameters and rules. ### Parameters | Name | Value | Description | | ----------------- | ------ | ------------------------------------------------------------------------- | | `TX_BASE_COST` | 6,000 | Base cost of any transaction | | `GAS_NEW_ACCOUNT` | 25,000 | Surcharge when a **value-transferring** transaction creates a new account | ### New-account surcharge Apply `GAS_NEW_ACCOUNT` when **all** are true: 1. The transaction is not a `CREATE` transaction. 2. `value > 0`. 3. `to` is not a precompile. 4. `to` is **non-existent** per [EIP-161](./eip-161.md) emptiness at the start of transaction execution. If these conditions hold the transfer results in

MOTIVATION:
The current `21,000` intrinsic gas is a legacy constant. It no longer matches the work all transactions must perform under warm/cold accounting. When decomposed into signature recovery, warming `sender` and `to`, and two warm writes for nonce and balance, the common path totals `6,000` gas. Top-level value transfers that create new accounts do not pay an explicit new-account surcharge today, while `CALL` does. This underprices state growth. Charging `GAS_NEW_ACCOUNT = 25,000` on value transfers that create an account aligns entry points and internalizes state growth. A high fixed base penalizes small ETH payments and encourages batching to dodge

RATIONALE:
Price only what every transaction always does: ECDSA recovery, warming `sender` and `to`, and two warm writes. That sums to `6,000` gas. Anything not universal should be metered separately. Calldata remains metered per byte. No calldata allowance is folded into the base. This reinforces ETH as money and payments: a plain ETH transfer carries no calldata, executes no bytecode, and touches no contract storage slots. It only updates warm account nonce and balance, so it receives the discount. When a value transfer creates a previously empty account, charge `GAS_NEW_ACCOUNT = 25,000`, identical to `CALL` account-creation pricing. `CREATE` is


=== EIP-3041 ===
TITLE: Adds `baseFee` to `eth_getBlockByHash`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-13
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getBlockByHash` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getBlockByHash` #### Description Returns information about a block specified by hash. Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork block **MUST** include a `baseFee` field. #### Parameters Parameters remain unchanged. #### Returns For the full specification of `eth_getBlockByHash` see [EIP-1474](./eip-1474.md). Add a new JSON field to the `result` object for block headers containing a base fee (post [EIP-1559](./eip-1559.md) fork block). - {[`Quantity`](./eip-1474.md#quantity)} `baseFee` - base fee for this

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-1153 ===
TITLE: Transient storage opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-06-15
REQUIRES: 2, 2, 0, 0, ,,  , 3, 5, 2, 9

SUMMARY:
This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, and `TSTORE` is not subject to the gas stipend check as defined in [EIP-2200](./eip-2200.md). In other words, the values of transient storage are never deserialized from storage or serialized to storage. Thus transient storage is cheaper since it never requires disk access. Transient storage is accessible to smart contracts via 2 new opcodes, `TLOAD` and `TSTORE`, where “T” stands for "transient:" ``` TLOAD (0x5c) TSTORE (0x5d) ```

SPECIFICATION:
Two new opcodes are added to EVM, `TLOAD` (`0x5c`) and `TSTORE` (`0x5d`). (Note that previous drafts of this EIP specified the values `0xb3` and `0xb4` for `TLOAD` and `TSTORE` respectively to avoid conflict with other EIPs. The conflict has since been removed.) They use the same arguments on stack as `SLOAD` (`0x54`) and `SSTORE` (`0x55`). `TLOAD` pops one 32-byte word from the top of the stack, treats this value as the address, fetches 32-byte word from the transient storage at that address, and pushes the value on top of the stack. `TSTORE` pops two 32-byte words from the

MOTIVATION:
Running a transaction in Ethereum can generate multiple nested frames of execution, each created by `CALL` (or similar) instructions. Contracts can be re-entered during the same transaction, in which case there are more than one frame belonging to one contract. Currently, these frames can communicate in two ways: via inputs/outputs passed via `CALL` instructions, and via storage updates. If there is an intermediate frame belonging to another untrusted contract, communication via inputs/outputs is not secure. Notable example is a reentrancy lock which cannot rely on the intermediate frame to pass through the state of the lock. Communication via

RATIONALE:
Another option to solve the problem of inter-frame communication is repricing the `SSTORE` and `SLOAD` opcodes to be cheaper for the transient storage use case. This has already been done as of [EIP-2200](./eip-2200.md). However, [EIP-3529](./eip-3529.md) reduced the maximum refund to only 20% of the transaction gas cost, which means the use of transient storage is severely limited. Another approach is to keep the refund counter for transient storage separate from the refund counter for other storage uses, and remove the refund cap for transient storage. However, that approach is more complex to implement and understand. For example, the


=== EIP-6404 ===
TITLE: SSZ transactions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-01-30
REQUIRES: 1, 5, 5, ,,  , 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4, ,,  , 7, 4, 9, 5, ,,  , 7, 7, 0, 2, ,,  , 7, 9, 1, 6, ,,  , 8, 0, 1, 6

SUMMARY:
This EIP defines a migration process of [EIP-2718](./eip-2718.md) Recursive-Length Prefix (RLP) transactions to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated here for reference. | Name | Value | | - | - | | [`BYTES_PER_FIELD_ELEMENT`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/deneb/polynomial-commitments.md#constants) | `uint64(32)` | | [`FIELD_ELEMENTS_PER_BLOB`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/deneb/polynomial-commitments.md#blob) | `uint64(4096)` | | Name | SSZ equivalent | | - | - | | [`Hash32`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/phase0/beacon-chain.md#custom-types) | `Bytes32` | | [`ExecutionAddress`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/bellatrix/beacon-chain.md#custom-types) | `Bytes20` | | [`VersionedHash`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/deneb/beacon-chain.md#custom-types) | `Bytes32` |

MOTIVATION:
RLP transactions have a number of shortcomings: 1. **Linear hashing:** The signing hash (`sig_hash`) and unique identifier (`tx_hash`) of an RLP transaction are computed by linear keccak256 hashes across its serialization. Even if only partial data is of interest, linear hashes require the full transaction data to be present, including potentially large calldata or access lists. This also applies when computing the `from` address of a transaction based on the `sig_hash`. 2. **Inefficient inclusion proofs:** The Merkle-Patricia Trie (MPT) backing the execution block header's `transactions_root` is constructed from the serialized transactions, internally prepending a prefix to the transaction

RATIONALE:
### Forward compatibility The proposed transaction design is extensible with new fee types, new signature types, and entirely new transaction features (e.g., CREATE2), while retaining compatibility with the proposed transactions. ### Verifier improvements Future RPC could expose an SSZ based `tx_root` on top of the `tx_hash`, against which proofs can be validated. The `transactions_root` can now be reconstructed from the list of `tx_root`. Further, partial data becomes provable, such as destination / amount without requiring the full calldata. This can reduce gas cost or zk proving cost when verifying L2 chain data in an L1 smart contract. ###


=== EIP-7749 ===
TITLE: Add wallet_signIntendedValidatorData method
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2024-06-21
REQUIRES: 1, 9, 1, ,,  , 7, 1, 2

SUMMARY:
This EIP introduces a new JSON-RPC method, `wallet_signIntendedValidatorData`, which allows signing data with an intended validator address using [ERC-191](./eip-191.md) version 0x00 with this format: ```bash 0x19 <0x00> <intended validator address> <data to sign> ```

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `wallet_signIntendedValidatorData` MUST calculate an Ethereum signature using `sign(keccak256("\x19\x00<signature validator address><data to sign>"))`. This method adds a prefix to the message to prevent malicious dApps from signing arbitrary data (e.g., a transaction) and using the signature to impersonate the victim. #### Parameters ```js interface WalletSignIntendedValidatorDataParams { signerAddress: string; validatorAddress: string; dataToSign: string; } ``` 1. `signerAddress` - 20-byte account address: The address signing the

MOTIVATION:
Currently, signing messages relies heavily on ERC-191 version 0x45 (`eth_sign`) and [EIP-712](./eip-712.md) (`eth_signTypedData`). While EIP-712 provides a more structured approach, it is often seen as complex. On the other hand, ERC-191 version 0x45 is widely used but poses significant phishing risks due to the lack of data parsing. ERC-191 defines three versions: 0x45, 0x01, and 0x00. This proposal aims to fully support ERC-191 by introducing the rpc call for 0x00 version, which enables signing data with an intended validator address. This new method will: - Enable more dApps to use ERC-191 version 0x00 without using raw signing methods

RATIONALE:
The `wallet_signIntendedValidatorData` method aims to bridge the gap between the simplicity of ERC-191 version 0x45 and the structured approach of EIP-712. By specifying the intended validator address, it reduces phishing risks and provides a more secure signing method for smart contract accounts and other use cases requiring a specific validator address.


=== EIP-4758 ===
TITLE: Deactivate SELFDESTRUCT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP renames the `SELFDESTRUCT` opcode to `SENDALL`, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.

SPECIFICATION:
* The `SELFDESTRUCT` opcode is renamed to `SENDALL`, and now only immediately moves all ETH in the account to the target; it no longer destroys code or storage or alters the nonce * All refunds related to `SELFDESTRUCT` are removed

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account. This EIP implements this change. Applications that only use `SELFDESTRUCT` to retrieve funds will still work.

RATIONALE:
Getting rid of the `SELFDESTRUCT` opcode has been considered in the past, and there are currently no strong reasons to use it. Disabling it will be a requirement for statelessness.


=== EIP-908 ===
TITLE: Reward clients for a sustainable network
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-03-01
REQUIRES: 

SUMMARY:
The tragedy of the commons is a phenomenon that is well known in many sectors, most notably in regard to sustainability. It involves the over-utilization of shared finite resources, which detriments all participants and stakeholders involved (which in the case of a global public good can be everyone, including future generations). Without proper management of public resources, a tragedy of the commons can occur. Internalizing externalities (where externalities can be broadly defined as effects that are not accounted for in the intrinsic price of a good, service or resource) is one way of incentivizing the proper management of

SPECIFICATION:
Add a new field to each block called `PrevBlockVerifications`, which is an arbitrary, unlimited size byte array. When a client verifies that a previous block is [valid](https://ethereum.github.io/yellowpaper/paper.pdf#subsubsection.4.3.2), the client appends a user agent to PrevBlockVerifications via an opcode in a transaction, PREV_BLOCK_VERIF. The user agent is a vector with the immutable fields: the blockhash of the block that is validated, and the index of a client address in an access list (details are below). A miner validates a transaction before including it in a block, however they are not able to change these fields of the vector because

MOTIVATION:
Currently there is a lack of incentives for anyone to run a full node, while joining a mining pool is not really economical if one has to purchase a mining rig (several GPUs) now, since there is unlikely to be a return on investment by the time that Ethereum transitions to hybrid Proof-of-Work/Proof-of-Stake with [Casper FFG](./eip-1011.md), then full PoS with [CBC Casper](https://github.com/ethereum/research/blob/master/papers/CasperTFG/CasperTFG.pdf). Additionally, providing a reward for clients gives a revenue stream that is independent of state channels or other layer 2 mechanisms, which are less secure, although this insecurity can be offset by mechanisms such as insurance,

RATIONALE:
### A rough qualitative analysis of fees As of May 4 2018, there are [16428 nodes](https://web.archive.org/web/20180504051128/https://ethernodes.org/network/1). Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented, thus aiding Ethereum's goal of decentralizing everything) assume that there are 10 clients. Thus let us assume that the number of nodes doubles to 30000 nodes within 5 years (this assumption is probably conservative, even if it is forward looking). Assume for simplicity that the costs of a client


=== EIP-7480 ===
TITLE: EOF - Data section access instructions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-08-11
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Four new instructions are introduced, that allow to read EOF container's data section: `DATALOAD` loads 32-byte word to stack, `DATALOADN` loads 32-byte word to stack where the word is addressed by a static immediate argument, `DATASIZE` loads data section size and `DATACOPY` copies a segment of data section to memory.

SPECIFICATION:
We introduce four new instructions on the same block number [EIP-3540](./eip-3540.md) is activated on: 1. `DATALOAD` (0xd0) 2. `DATALOADN` (0xd1) 3. `DATASIZE` (0xd2) 4. `DATACOPY` (0xd3) If the code is legacy bytecode, all of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*) If the code is valid EOF1, the following execution rules apply: ### `DATALOAD` 1. Pops one value, `offset`, from the stack. 2. Reads `[offset:offset+32]` segment from the data section and pushes it as 32-byte value to the stack. 3. If `offset + 32` is greater than the data section size,

MOTIVATION:
Clear separation between code and data is one of the main features of EOF1. Data section may contain anything, e.g. compiler's metadata, but to make it useful for smart contracts, EVM has to have instructions that allow to read from data section. Previously existing instructions for bytecode inspection (`CODECOPY`, `CODESIZE` etc.) are deprecated in EOF1 and cannot be used for this purpose. The `DATALOAD`, `DATASIZE`, `DATACOPY` instruction pattern follows the design of existing instructions for reading other kinds of data (i.e. returndata and calldata). `DATALOADN` is an optimized version of `DATALOAD`, where data offset to read is set

RATIONALE:
### Zero-padding on out of bounds access Existing instructions for reading other kinds of data implicitly pad with zeroes on out of bounds access, with the only exception of return data copying. It is beneficial to avoid exceptional failures, because compilers can employ optimizations like removing a code that copies data, but never accesses this copy afterwards, but such optimization is possible only if instruction never has other side effects like exceptional abort. ### Lack of `EXTDATACOPY` `EXTCODECOPY` instruction is deprecated and rejected in EOF contracts and does not copy contract code when being called in legacy with


=== EIP-5081 ===
TITLE: Expirable Transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-05-06
REQUIRES: 1, 5, 5, ,,  , 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
This EIP adds a new transaction type of that includes expiration with a blocknum.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters - `FORK_BLKNUM` = `TBD` - `CHAIN_ID` = `TBD` - `TX_TYPE` = TBD, > 0x02 ([EIP-1559](./eip-1559.md)) As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` = `TX_TYPE(TBD)`. The intrinsic cost of the new transaction is inherited from [EIP-2930](./eip-2930.md), specifically `21000 + 16 * non-zero calldata bytes + 4 * zero calldata bytes + 1900 * access list storage key count + 2400 * access list address

MOTIVATION:
When a user sends a transaction `tx0` with a low gas price, sometimes it might not be high enough to be executed. A common resolution is for the user to submit the transaction again with the same nonce and higher gas price. That previous `tx0` can theoretically be included in any time in the future unless a `tx` with the exact same nonce is already executed. When network is congested, gas price are high, for critical transactions user might try gas price that is much higher than an average day. This cause the `tx0` choice might be very

RATIONALE:
TODO


=== EIP-7783 ===
TITLE: Add Controlled Gas Limit Increase Strategy
TYPE: Informational 
STATUS: Stagnant
CREATED: 2024-10-06
REQUIRES: 


=== EIP-2464 ===
TITLE: eth/65: transaction announcements and retrievals
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-01-13
REQUIRES: 2364

SUMMARY:
This EIP introduces three additional message types into the `eth` protocol (releasing a new version, `eth/65`): `NewPooledTransactionHashes (0x08)` to announce a set of transactions without their content; `GetPooledTransactions (0x09)` to request a batch of transactions by their announced hash; and `PooledTransactions (0x0a)` to reply to a transaction request. This permits reducing the bandwidth used for transaction propagation from linear complexity in the number of peers to square root; and also reducing the initial transaction exchange from 10s-100s MB to `len(pool) * 32B ~= 128KB`.

SPECIFICATION:
Add three new message types to the `eth` protocol: * `NewPooledTransactionHashes (0x08): [hash_0: B_32, hash_1: B_32, ...]` * Specify one or more transactions that have appeared in the network and which have **not yet been included in a block**. To be maximally helpful, nodes should inform peers of all transactions that they may not be aware of. * There is **no protocol violating hard cap** on the number of hashes a node may announce to a remote peer (apart from the 10MB `devp2p` network packet limit), but 4096 seems a sane chunk (128KB) to avoid a single packet

MOTIVATION:
The `eth` network protocol has two ways to propagate a newly mined block: it can be broadcast to a peer in its entirety (via `NewBlock (0x07)` in `eth/64` and prior or it can be announced only (via `NewBlockHashes (0x01)`). This duality allows nodes to do the high-bandwidth broadcasting (10s-100s KB) for a square root number of peers; and the low-bandwidth announcing (10s-100s B) for the remaining linear number of peers. The square root broadcast is enough to reach all well connected nodes, but the linear announce is needed to get across degenerate topologies. This works well. The `eth`

RATIONALE:
**Q: Why limit `GetPooledTransactions (0x09)` to retrieving items from the pool?** Apart from the transaction pool, transactions in Ethereum are always bundled together by the hundreds in block bodies and existing network retrievals honor this data layout. Allowing direct access to individual transactions in the database has no actionable use case, but would expose costly database reads into the network. For transaction propagation purposes there is no reason to allow disk access, as any transaction finalized to disk will be broadcast inside a block anyway, so at worse there is a few hundred millisecond delay when a node


=== EIP-4760 ===
TITLE: SELFDESTRUCT bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP renames the `SELFDESTRUCT` opcode to `SENDALL`, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller. In order to give apps more warning even if their developers are completely unaware of the EIP process, this version will exponentially increase the gas costs of the opcode, so any developer has time to see this change and react by implementing a version of their contract that does not rely on `SELFDESTRUCT` .

SPECIFICATION:
### Constants | Name | Value | Comment | |------|-------|---------| | `OLD_SELFDESTRUCT_COST` | 5000 | Current gas cost of `SELFDESTRUCT` opcode | | `HARD_FORK_BLOCK` | TBD | (Shanghai HF block height) | | `DOUBLING_SLOTS` | `2**16` | (Time for gas price to double, ca. 9 days) | | `DOUBLINGS_BEFORE_SENDALL` | `13` | `SELFDESTRUCT` will be converted to `SENDALL` at `HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL` | * If `HARD_FORK_BLOCK <= slot < HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL` * `SELFDESTRUCT` functionality remains unchanged * `SELFDESTRUCT` gas cost is now `OLD_SELFDESTRUCT_COST * 2 ** ((slot - HARD_FORK_BLOCK) // DOUBLING_SLOTS)` * For

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account. This EIP implements this change. Applications that only use `SELFDESTRUCT` to retrieve funds will still work.

RATIONALE:
The idea behind this EIP is to disable `SELFDESTRUCT` in a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However, at least if the smart contract has regular use, then users will notice the price of the operation going up tremendously. The period over which this is happening (`HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL`) is chosen to be long enough (ca. 4 months) such that it gives developers time to


=== EIP-1051 ===
TITLE: Overflow checking for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.

SPECIFICATION:
Two new flags are added to the EVM state: overflow (`ovf`) and signed overflow (`sovf`). The `ovf` flag is set in the following circumstances: - When an `ADD` (`0x01`) opcode, with both inputs treated as unsigned integers, produces an ideal output in excess of 2^256 - 1. - When a `SUB` (`0x03`) opcode, with both inputs treated as unsigned integers, produces an ideal output less than 0. - When a `MUL` (`0x02`) opcode, with both inputs treated as unsigned integers, produces an ideal output in excess of 2^256 - 1. The `sovf` flag is set whenever the `ovf`

MOTIVATION:
The correct functioning of many contracts today is dependent on detecting and preventing overflow of arithmetic operations. Since the EVM operates on mod 2^256 integers and provides no built-in overflow detection or prevention, this requires manual checks on every arithmetic operation. In the interests of facilitating efficient and secure contracts, we propose new opcodes that permit efficient detection of overflows, which can be checked periodically rather than after each operation.

RATIONALE:
Any change to implement overflow protection needs to preserve behaviour of existing contracts, which precludes many changes to the arithmetic operations themselves. One option would be to provide an opcode that enables overflow protection, causing a throw or revert if an overflow happens. However, this limits the manner in which overflows can be handled. Instead, we replicate functionality from real world CPUs, which typically implement 'carry' and 'overflow' flags. Separate flags for signed and unsigned overflow are necessary due to the fact that a signed overflow may not result in an unsigned overflow.


=== EIP-3338 ===
TITLE: Limit account nonce to 2^52
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-07
REQUIRES: 

SUMMARY:
Limit account nonce to be between `0` and `2^52`.

SPECIFICATION:
If `block.number >= FORK_BLOCK` introduce two new restrictions: 1. Consider any transaction invalid, where the nonce exceeds `2^52`. 2. The `CREATE` instruction to abort with an exceptional halt, where the account nonce is `2^52`.

MOTIVATION:
Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way. Additionally it could prove beneficial to transaction formats, where some improvements are potentially sought by at least three other proposals. Lastly, this facilitates a minor optimisation in clients, because the nonce no longer needs to be kept as a 256-bit number.

RATIONALE:
1. It is unlikely for any nonce to reach or exceed the proposed limit. If one would want to reach that limit via external transactions, it would cost at least `21000 * (2^64-1) = 387_381_625_547_900_583_915_000` gas. 2. It must be noted that in the past, in the Morden testnet, each new account had a starting nonce of `2^20` in order to differentiate transactions from mainnet transactions. This mode of replay protection is out of fashion since [EIP-155](./eip-155.md) introduced a more elegant way using chain identifiers. 3. Most clients already consider the nonce field to be 64-bit, such as


=== EIP-7912 ===
TITLE: Pragmatic stack manipulation tools
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-25
REQUIRES: 

SUMMARY:
Add `SWAP17`-`SWAP24`, `DUP17` - `DUP24`, `SWAPN`, `DUPN`, and `EXCHANGE` instructions. The arbitrary depth operations must be preceded by `PUSH1` instructions defining operands.

SPECIFICATION:
Let `top - N` be the `N`th most recently pushed value on the stack, and `top - 0` be the most recent. If any of the following instructions reference a stack element beyond the current length of the stack, causing a stack underflow, abort with an exceptional halt. ### Constant `SWAPXX` and `DUPXX` Add the following new instructions: - `SWAP17`, `SWAP18`, ..., `SWAP24`: `0xb0`, `0xb1`, ..., `0xb7`. - `DUP17`, `DUP18`, ..., `DUP24`: `0xb8`, `0xba`, ..., `0xbf`. Let `SWAPXX` and `DUPXX` refer to the static instructions defined above. `XX` is defined as the stack element they are referencing. The

MOTIVATION:
Due to the nature of some compilers, deeper stack access is a desirable VM feature. Previous attempts either required code versioning, like the EVM Object Format (EOF), or caused the behavior of some deployed contracts to change, due to the interpretation of new immediates. This is a pragmatic approach to introducing the desired functionality. It reuses instruction semantics that have been historically agreed on, instead of new, complex encodings and containers.

RATIONALE:
### Constant and Dynamic `SWAP`s and `DUP`s The main trade off between using the constant `SWAPXX` or `DUPXX` instructions versus the dynamic `SWAPN` or `DUPN` instructions is that the dynamic instructions require an additional two bytes in the form of a preceding `PUSH1` operation, whereas the constant versions require no additional bytes. ### One indexed `EXCHANGE` Since `SWAP1` and `DUP1` operate on the top of the stack, it seems fitting that `EXCHANGE(1, 2)` operate on the `top` and `top-1`.


=== EIP-2593 ===
TITLE: Escalator fee market change for ETH 1.0 chain
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-03-13
REQUIRES: 

SUMMARY:
Based on [The Agoric Papers](https://agoric.com/papers/incentive-engineering-for-computational-resource-management/full-text/). Each transaction would have the option of providing parameters that specify an "escalating" bid, creating a time-based auction for validators to include that transaction. This creates highly efficient price discovery, where the price will always immediately fall to the highest bid price, which is not necessarily that user's highest price they would pay. ![escalator algorithm price chart](https://ethresear.ch/uploads/default/original/2X/0/042795efa4c2680d644bc66386cd2984a70293f8.gif)

SPECIFICATION:
**Client-Wide Parameters** * `INITIAL_FORK_BLKNUM`: TBD **Transaction Parameters** The transaction `gasPrice` parameter is now optional, and if excluded can be replaced by these parameters instead: * `START_PRICE`: The lowest price that the user would like to pay for the transaction. * `START_TIME`: The first time that this transaction is valid at. * `MAX_PRICE`: The maximum price the sender would be willing to pay to have this transaction processed. * `MAX_TIME`: The time at which point the user's `MAX_PRICE` is achieved. The transaction remains valid after this time at that price. **Proposal** For all blocks where `block.number >= INITIAL_FORK_BLKNUM`: When

MOTIVATION:
Ethereum currently prices transaction fees using a simple first-price auction, which leads to well documented inefficiencies (some of which are documented in [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md)) when users are trying to estimate what price will get a transaction included in a block, especially during times of price volatility and full blocks. EIP 1559 is currently being championed as an improvement for the Ethereum protocol, and while I agree that the gas market is very inefficient, since a change like this will affect all client and wallet implementations, the Ethereum community should make sure to make a selection based on solid reasoning


=== EIP-7960 ===
TITLE: EOF - Extended types section
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-28
REQUIRES: 3540

SUMMARY:
This EIP extends the definition of `types_section` in EOF format ([EIP-3540](./eip-3540.md)) with an additional `type` parameter.

SPECIFICATION:
`types_section`, as defined in EIP-3540, is changed to be of the following format `(type, reserved, inputs, outputs, max_stack_increase)`. `type` is `uint8`, `reserved` is 24 bits, and `inputs`, `outputs`, `max_stack_increase` are defined as `uint8`, `uint8`, `uint16` respectively, the same as before. The only valid `type` defined in this EIP is `0x01`. Additional EIPs may be defined for other code section `type`s. `version`, as defined in EIP-3540, is changed to `0x02`, to avoid the backward compatibility issue if a third-party chain already deployed EOF in production. In EOF container, the following validation rules are added: * If a `type` in

MOTIVATION:
An additional `type` parameter allows the EOF EVM interpreter to identify the "type" of a code section. This allows the interpreter to "interpret" each code section differently, allowing EOF function calls to, for example, invoke pure EVM64 code or even later support RISC-V.

RATIONALE:
The new `type` parameter allows a contract to "dispatch" to different variants of the interpreter to better suit its need. * The portion of the code where it mainly interacts with Ethereum addresses, balances, storages may run "normal" EVM. * The portion of the code that is computationally heavy may run faster EVM64, but loses the ability to directly interact with Ethereum addresses and balances. Allowing this `type` to be defined for each code section ensures that a contract remains concise -- it can quickly switch between its computational needs and system/runtime needs. `reserved` is added to `types_section`


=== EIP-3014 ===
TITLE: eth_symbol JSON-RPC method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-09-30
REQUIRES: 

SUMMARY:
The new method `eth_symbol` (`eth_`-namespaced) has no parameters and returns a string of the native coin of the network. For the Ethereum mainnet this will be `ETH`, other networks will have other symbols.

SPECIFICATION:
Method: `eth_symbol`. Params: none. Returns: `result` - the native coin symbol, string Example: ```js curl -X POST --data '{"jsonrpc":"2.0","method":"eth_symbol","params":[],"id":1}' // Result { "id": 1, "jsonrpc": "2.0", "result": "ETH" } ```

MOTIVATION:
Wallets that deal with multiple networks need some basic information for every blockchain that they connect to. One of those things is the symbol of the native coin of the network. Instead of requiring the user to research and manually add the symbol it could be provided to the wallet via this proposed JSON-RPC endpoint and used automatically. There are lists of networks with symbols like https://github.com/ethereum-lists/chains where a user can manually look up the correct values. But this information could easily come from the network itself.

RATIONALE:
This endpoint is similar to [EIP-695](./eip-695.md) but it provides the symbol instead of `chainId`. It provides functionality that is already there for [ERC-20](./eip-20.md) tokens, but not yet for the native coin of the network. Alternative naming of `eth_nativeCurrencySymbol` was considered, but the context and the fact that it just returns one value makes it clear that that it returns the symbol for the native coin of the network.


=== EIP-7830 ===
TITLE: Contract size limit increase for EOF
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-11-29
REQUIRES: 1, 7, 0, ,,  , 3, 5, 4, 0, ,,  , 3, 8, 6, 0

SUMMARY:
Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.

SPECIFICATION:
[EIP-170](./eip-170.md) specifies `MAX_CODE_SIZE` as 24576 bytes, and [EIP-3860](./eip-3860.md) specifies `MAX_INITCODE_SIZE` as `2 * MAX_CODE_SIZE` (49152 bytes). Starting `FORK_BLOCK`, for EOF initcode/code (code starting with the `0xEF 0x00` bytes) the limit is changed:`MAX_CODE_SIZE` is set to 65536 bytes (64 KiB). This means `MAX_INITCODE_SIZE` becomes 131072 bytes (128 KiB).

MOTIVATION:
The contract size limit was introduced as a measure against DoS attacks. `JUMPDEST`-analysis is required for legacy contracts, and many of the algorithms performing it are not linear and/or have unknown unknowns. This is one of the reasons for the hesitance of a limit increase. For contract developers the limit poses annoying problems, given modern contracts with good error reporting would consume more space. They are forced to work with workarounds, like "libraries" (using `DELEGATECALL`), splitting an application across regular contracts (and `CALL`-ing across), or working with proxies (e.g. the "diamond pattern"). All these solutions have resulted in

RATIONALE:
The 64 KiB limit is over 2x of existing limit, while it is not a significant increase, it is the realistic increase given the limitations of initcode. In EOF deployment the to-be-deployed code is stored as a section ("subcontainer"), which has a size limit of 64 KiB, therefore it is not possible to deploy larger contracts without introducing a large or variable-length-encoded size field. A further increase can be proposed with applying these changes to EOF. This increase still fits within the gas schedule, limiting the size to less than what gas limits allow. In [EIP-170](./eip-170.md) the gas


=== EIP-4762 ===
TITLE: Statelessness gas cost changes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.

SPECIFICATION:
### Helper functions ```python def get_storage_slot_tree_keys(storage_key: int) -> [int, int]: if storage_key < (CODE_OFFSET - HEADER_STORAGE_OFFSET): pos = HEADER_STORAGE_OFFSET + storage_key else: pos = MAIN_STORAGE_OFFSET + storage_key return ( pos // 256, pos % 256 ) ``` ### Access events Whenever the state is read, one or more of the access events of the form`(address, sub_key, leaf_key)` take place, determining what data is being accessed. We define access events as follows: #### Access events for account headers When: 1. a non-precompile which is also not a system contract is the target of a `*CALL`, `CALLCODE`, `SELFDESTRUCT`, `EXTCODESIZE`, or

MOTIVATION:
The introduction of Verkle trees into Ethereum requires fundamental changes and as a preparation, this EIP is targeting the fork coming right before the verkle tree fork, in order to incentivize Dapp developers to adopt the new storage model, and ample time to adjust to it. It also incentivizes client developers to migrate their database format ahead of the verkle fork.

RATIONALE:
### Gas reform Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design. `WITNESS_CHUNK_COST` is set to charge 6.25 gas per byte for chunks, and `WITNESS_BRANCH_COST` is set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length. The main differences from gas costs in Berlin are: * 200 gas charged per 31 byte chunk of code. This


=== EIP-3337 ===
TITLE: Frame pointer support for memory load and store operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-06
REQUIRES: 3336

SUMMARY:
This EIP introduces four new opcodes, `MLOADFP`, `MSTOREFP`, `GETFP` and `SETFP` that allow for more efficient memory access offset by a user-controlled quantity called the "frame pointer". This permits compilers to more efficiently offload ephemeral data such as local variables to memory instead of the EVM's evaluation stack, which has a number of benefits, including the effective elimination of restrictions on the number of local variables in a function.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. ### Frame pointer A new EVM internal state variable called the "frame pointer" is introduced. This is a signed integer that starts at 0. ### `SETFP` opcode A new opcode, `SETFP` is introduced with value `0x5c`. This opcode costs `G_low` (3 gas) and takes one argument from the stack. The argument is stored as the new value of the frame pointer. ### `GETFP` opcode A new opcode, `GETFP` is introduced with

MOTIVATION:
In most commonly used VMs, ephemeral data such as local variables, function arguments, and return addresses is stored in a region of memory called the stack. In contrast to the EVM's evaluation stack, this area of memory is randomly accessible, and thus can store an arbitrary amount of data, which can be referenced from anywhere they remain in scope. Although this model is possible in the current EVM design, it is made difficult by the linear model of memory (addressed in [EIP-3336](./eip-3336.md)) and by the lack of opcodes for relative memory access commonly found in other architectures. This

RATIONALE:
### Cost of new opcodes The cost of the new opcodes `MLOADFP` and `MSTOREFP` reflects the cost of `MLOAD` and `MSTORE`. They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost. The cost of the new opcodes `SETFP` and `GETFP` is based on other common low-cost opcodes such as `PUSH` and `POP`. ### Absence of `MSTORE8FP` `MSTORE8FP` opcode was not included because it is expected that it would be used infrequently, and there is a desire to minimise the size of the instruction set and to conserve opcodes for future


=== EIP-1109 ===
TITLE: PRECOMPILEDCALL opcode (Remove CALL costs for precompiled contracts)
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-22
REQUIRES: 

SUMMARY:
This EIP tries to resolve the problem of high gas consumption when calling precompiled contracts with a small gas cost. Using this opcode for calling precompiled contracts allows to define precompiled contracts whose effective cost it is less than 700.

SPECIFICATION:
If `block.number >= XXXXX`, define a new opcode named `PRECOMPILEDCALL` with code value `0xfb`. The gas cost of the OPCODE is 2 (Gbase) plus the Specific gas cost defined for each specific precompiled smart contract. The OPCODE takes 5 words from the stack and returns 1 word to the stack. The input stack values are: mu_s[0] = The address of the precompiled smart contract that is called. mu_s[1] = Pointer to memory for the input parameters. mu_s[2] = Length of the input parameters in bytes. mu_s[3] = Pointer to memory where the output is stored mu_s[4] = Length

MOTIVATION:
Each precompiled contract has an already defined cost for calling it. It does not make sense to add the implicit extra gas cost of the CALL opcode. As an example, SHA256 precompiled contract costs 60 and ECADD costs 500 (proposed to costs only 50 in [EIP-1108](./eip-1108.md) . When a precompiled contract is called, 700 gas is consumed just for the CALL opcode besides the costs of the precompiled contract. This makes no sense, and right now it's impossible to define a precompiled contract whose effective cost for using it, is less than 700.

RATIONALE:
There was a first proposal for removing the gast consts for the `CALL`, but it looks that it's easier to implement and test a new opcode just for that. The code is just the next opcode available after the `STATICCALL` opcode.


=== EIP-3374 ===
TITLE: Predictable Proof-of-Work (POW) Sunsetting
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
Sets the block reward to 3 ETH and then incrementally decreases it every block for 2,362,000 blocks (approximately 1 year) until it reaches 1 ETH.

SPECIFICATION:
### Constants * `TRANSITION_START_BLOCK_NUMBER: TBD` * `TRANSITION_DURATION: 2_362_000` // (about one year) * `TRANSITION_END_BLOCK_NUMBER: FORK_BLOCK_NUMBER + TRANSITION_DURATION` * `STARTING_REWARD: 3_000_000_000_000_000_000` * `ENDING_REWARD: 1_000_000_000_000_000_000` * `REWARD_DELTA: STARTING_REWARD - ENDING_REWARD` ### Block Reward ```py if block.number >= TRANSITION_END_BLOCK_NUMBER: block_reward = ENDING_REWARD elif block.number == TRANSITION_START_BLOCK_NUMBER: block_reward = STARTING_REWARD elif block.number > TRANSITION_START_BLOCK_NUMBER: block_reward = STARTING_REWARD - REWARD_DELTA * TRANSITION_DURATION / (block.number - TRANSITION_START_BLOCK_NUMBER) ```

MOTIVATION:
Unnecessarily abrupt changes to the Ethereum ecosystem cause disruption and disharmony resulting in the disenfranchisement of community members while undermining stability and confidence. While moves from Proof-of-Work to Proof-of-Stake will undoubtedly cause friction between those community members vested in either, all benefit from a measured, predictable transition. This proposal: 1) Is issuance neutral over 1 year, and reduces issuance beyond that. 2) Sets an initial block reward of 3; 3) Introduces an ongoing, predictable reduction in future mining rewards down to 1, effectively "sunsetting" POW and codifying the move to POS; 4) Reduces economic incentives for continued development

RATIONALE:
Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame. Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner revenue decrease and the continual reductions thereafter codify Ethereum's move to POS by increasingly disincentivizing POW. Importantly, this approach moderates the rate of change so impacts and threats can be measured and monitored.


=== EIP-2583 ===
TITLE: Penalty for account trie misses
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-21
REQUIRES: 

SUMMARY:
This EIP adds a gas penalty for accesses to the account trie, where the address being looked up does not exist. Non-existing accounts can be used in DoS attacks, since they bypass cache mechanisms, thus creating a large discrepancy between 'normal' mode of execution and 'worst-case' execution of an opcode.

SPECIFICATION:
We define the constant `penalty` as `TBD` (suggested `2000` gas). For opcodes which access the account trie, whenever the operation is invoked targeting an `address` which does not exist in the trie, then `penalty` gas is deducted from the available `gas`. ### Detailed specification These are the opcodes which triggers lookup into the main account trie: | Opcode | Affected | Comment | | ----- | ---------| ----------| | BALANCE| Yes | `balance(nonexistent_addr)` would incur `penalty`| | EXTCODEHASH| Yes | `extcodehash(nonexistent_addr)` would incur `penalty`| | EXTCODECOPY| Yes | `extcodecopy(nonexistent_addr)` would incur `penalty`| | EXTCODESIZE| Yes | `extcodesize(nonexistent_addr)` would

MOTIVATION:
As the ethereum trie becomes more and more saturated, the number of disk lookups that a node is required to do in order to access a piece of state increases too. This means that checking e.g. `EXTCODEHASH` of an account at block `5` was _inherently_ a cheaper operation that it is at, say `8.5M`. From an implementation perspective, a node can (and does) use various caching mechanisms to cope with the problem, but there's an inherent problem with caches: when they yield a 'hit', they're great, but when they 'miss', they're useless. This is attackable. By forcing a

RATIONALE:
With this scheme, we could continue to price these operations based on the 'normal' usage, but gain protection from attacks that try to maximize disk lookups/cache misses. This EIP does not modify anything regarding storage trie accesses, which might be relevant for a future EIP. However, there are a few crucial differences. 1. Storage tries are typically small, and there's a high cost to populate a storage trie with sufficient density for it to be in the same league as the account trie. 2. If an attacker wants to use an existing large storage trie, e.g. some popular


=== EIP-7543 ===
TITLE: EVM arbitrary precision decimal math
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-22
REQUIRES: 

SUMMARY:
This EIP adds *arbitrary precision decimal float* OPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for all inputs given enough precision, as chosen by the user. All calculations are deterministic and gas is precisely embedded bottom-up. Allowing arbitrary precision decimal elementary functions invites the worlds of mathematical finance, machine learning, science, digital art, games and others to Ethereum. The implementation is functional.

SPECIFICATION:
### Decimal A decimal is defined as c * 10^q where c and q are int256. Notationwise: a = ac * 10^aq b = bc * 10^bq etc. ### OPCODE defs 0xd0 DECADD a+b -> c : (ac, aq, bc, bq, precision) -> (cc, cq) 0xd1 DECNEG -a -> b : (ac, aq) -> (bc, bq) 0xd2 DECMUL a*b -> c : (ac, aq, bc, bq, precision) -> (cc, cq) 0xd3 DECINV 1/a -> b : (ac, aq, precision) -> (bc, bq) 0xd4 DECEXP exp(a) -> b : (ac, aq, precision, steps) -> (bc, bq) 0xd5 DECLN ln(a)

MOTIVATION:
Currently, to take a power, a^b, of non integer values, requires vast amounts of Solidity code. The simplest task in trading e.g. is to convert volatilities from yearly to daily, which involves taking the 16th root. Giving users/devs the same ability that scientific calculators have allows for the creation of apps with higher complexity. The files [BlackScholes.yul](../assets/eip-7543/BlackScholes.yul) and [Neuron.yul](../assets/eip-7543/Neuron.yul) demonstrate how these OPCODEs simplify numerical smart contract code. ### Why decimal? To represent a simple value like 0.1 in binary requires infinite many digits and is therefore not exactly represently in a finite binary machine. Decimal types are

RATIONALE:
### gas All the above OPCODEs are deterministic, hence the gas cost can be determined. At the same time, the calculations are complex and depend on the input. It is crucial to have accurate gas costs to avoid energy attacks on nodes. To this end, the underlying uint256 lib can be wrapped with gas accumulation, as found in the reference implementation in ../assets/eip-EVM+/uint256_wrapped.go. This gives a bottom-up approach to calculating gas, by running the OPCODE. Because the EVM interprator expects the gas cost before actually running the OPCODE, we are running the OPCODE twice. the first run, identical


=== EIP-214 ===
TITLE: New opcode STATICCALL
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
This proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present). Any opcode that attempts to perform such a modification (see below for details) will result in an exception instead of performing the modification.

SPECIFICATION:
Introduce a new `STATIC` flag to the virtual machine. This flag is set to `false` initially. Its value is always copied to sub-calls with an exception for the new opcode below. Opcode: `0xfa`. `STATICCALL` functions equivalently to a `CALL`, except it takes only 6 arguments (the "value" argument is not included and taken to be zero), and calls the child with the `STATIC` flag set to `true` for the execution of the child. Once this call returns, the flag is reset to its value before the call. Any attempts to make state-changing operations inside an execution instance with

MOTIVATION:
Currently, there is no restriction about what a called contract can do, as long as the computation can be performed with the amount of gas provided. This poses certain difficulties about smart contract engineers; after a regular call, unless you know the called contract, you cannot make any assumptions about the state of the contracts. Furthermore, because you cannot know the order of transactions before they are confirmed by miners, not even an outside observer can be sure about that in all cases. This EIP adds a way to call other contracts and restrict what they can do

RATIONALE:
This allows contracts to make calls that are clearly non-state-changing, reassuring developers and reviewers that re-entrancy bugs or other problems cannot possibly arise from that particular call; it is a pure function that returns an output and does nothing else. This may also make purely functional HLLs easier to implement.


=== EIP-3607 ===
TITLE: Reject transactions from senders with deployed code
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-06-10
REQUIRES: 

SUMMARY:
Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated `2**80` computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this EIP prevents the worst possible attack, where a safe looking contract (e.g. a token wrapper or an AMM-type contract) is deployed to attract user funds, which can then be spent using the EOA key for the same address. The fix is to never allow to use an address that

SPECIFICATION:
Any transaction where `tx.sender` has a `CODEHASH != EMPTYCODEHASH` MUST be rejected as invalid, where `EMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`. The invalid transaction MUST be rejected by the client and not be included in a block. A block containing such a transaction MUST be considered invalid.

MOTIVATION:
### Generating address collisions By creating keys for `2**80` EOAs and simulating the deployment of `2**80` contracts from these EOAs (one each), one expects to find about one collision where an EOA has the same address as one contract. This very simple form of the attack requires the storage of `2**80` addresses, which is a practical barrier: It would require `2.4*10**25` bytes of memory (24 Yottabyte). However, there are cycle finding algorithms that can perform the collision search without requiring large amounts of storage. An estimate for the complexity has been made [here](https://hackmd.io/Vzhp5YJyTT-LhWm_s0JQpA). We estimate that a collision

RATIONALE:
We note that it was always expected that a contract account's behaviour is constrained by the code in that contract -- which means that the account's funds should not suddenly be spendable by some private key. It was just implicitly assumed in the past that a 160 bit address length is enough to provide collision resistance, and thus that this case could never occur. In that sense, this EIP should be seen as a clarification of protocol behaviour in a previously undefined case rather than an explicit upgrade of consensus rules. This does not exclude all possible attack


=== EIP-7833 ===
TITLE: Scheduled function calls
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-12-06
REQUIRES: 

SUMMARY:
Ethereum's smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers—like MEV attacks—can prevent timely execution. To address these challenges, this Ethereum Improvement Proposal (EIP) introduces a new opcode, OFFERCALL, which allows contracts to schedule function calls. When functions self-schedule, they exhibit bot-like behavior. These scheduled calls would offer ETH to block producers as an incentive to prioritize their execution over manually submitted transactions. If the offer is not fulfilled, the

SPECIFICATION:
Adding bot-like behavior to an EVM function is achieved by recursively scheduling a call to the same function in the next block. We propose introducing a new EVM opcode, OFFERCALL, which, as the name implies, offers ETH to be burnt to the block producer of the next block in exchange for invoking a function. These offers are aggregated and ranked by the Ethereum node, with only the top N offers being retained; all others are discarded. Scheduled calls must be executed before any user transactions, with execution order determined by their rank in the sorted list. The offered

RATIONALE:
The rationale behind this Ethereum Improvement Proposal (EIP) stems from the need to enhance the reliability and fairness of smart contract execution on the Ethereum network. While Ethereum’s smart contracts allow for a high degree of programmability and automation, the execution of these contracts often depends on external triggers, such as user transactions or network conditions. This dependency introduces significant challenges, particularly in situations where timing is critical or when malicious actors, like block producers, can exploit the system for profit.


=== EIP-1803 ===
TITLE: Rename opcodes for clarity
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2017-07-28
REQUIRES: 141

SUMMARY:
Rename the `BALANCE`, `SHA3`, `NUMBER`, `GASLIMIT`, `GAS` and `INVALID` opcodes to reflect their true meaning.

SPECIFICATION:
Rename the opcodes as follows: - `BALANCE` (`0x31`) to `EXTBALANCE` to be in line with `EXTCODESIZE`, `EXTCODECOPY` and `EXTCODEHASH` - `SHA3` (`0x20`) to `KECCAK256` - `NUMBER` (`0x43`) to `BLOCKNUMBER` - `GASLIMIT` (`0x45`) to `BLOCKGASLIMIT` to avoid confusion with the gas limit of the transaction - `GAS` (`0x5a`) to `GASLEFT` to be clear what it refers to - `INVALID` (`0xfe`) to `ABORT` to clearly articulate when someone refers this opcode as opposed to "any invalid opcode"


=== EIP-7642 ===
TITLE: eth/69 - history expiry and simpler receipts
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2024-02-29
REQUIRES: 5793

SUMMARY:
This EIP modifies the 'eth' p2p protocol to announce the historical block range served by the node. We also simplify the handshake to remove total difficulty information, which isn't used anymore after the merge. Additionally we propose to remove the `Bloom` field from receipts transferred over the protocol.

SPECIFICATION:
### Status message changes Modify the `Status (0x00)` message as follows: - (eth/68): `[version: P, networkid: P, td: P, blockhash: B_32, genesis: B_32, forkid]` - (eth/69): `[version: P, networkid: P, genesis: B_32, forkid, earliestBlock: P, latestBlock: P, latestBlockHash: B_32]` Note `blockhash` has moved to the end to match `BlockRangeUpdate`. ### Receipts message changes Modify the encoding for receipts in the `Receipts (0x10)` message as follows: - (eth/68): `receipt = {legacy-receipt, typed-receipt}` with ``` typed-receipt = tx-type || rlp(legacy-receipt) legacy-receipt = [ post-state-or-status: {B_32, {0, 1}}, cumulative-gas: P, bloom: B_256, logs: [log₁, log₂, ...] ] ``` - (eth/69): `receipt

MOTIVATION:
### Block range in Status message In the history expiry working group, it was decided that clients may drop pre-merge history from their storage after May 1, 2025. For clients that want to sync history through the 'eth' protocol, it is essential to know whether a peer still serves old history. A similar idea was proposed in [EIP-7542](./eip-7542.md) but was later withdrawn because a political decision on history expiry had not been reached at the time. ### Removing Bloom in Receipts We recently discovered that none of the clients store the `Bloom` field of the receipts as it

RATIONALE:
### Status changes After the merge, the `TD` field of the `Status` message became meaningless since the difficulty of post-merge blocks are 0. It could in theory be used to distinguish synced with unsynced nodes, but the same thing can be accomplished with the forkid as well. The new `earliestBlock` field is technically not required for history expiry, but there are a couple reasons why adding it can help: - It improves peer finding for clients that still want to sync history from p2p after the agreed-upon removal of pre-merge history has taken place. Without `earliestBlock`, the client


=== EIP-5920 ===
TITLE: PAY opcode
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-03-14
REQUIRES: 2, 1, 4, ,,  , 2, 9, 2, 9, ,,  , 7, 5, 2, 3

SUMMARY:
This EIP introduces a new opcode, `PAY`, taking two stack parameters, `addr` and `val`, that transfers `val` wei to the address `addr` without calling any of its functions.

SPECIFICATION:
### Constants | Constant | Definition | | -------------------------- | ------------------------- | | `WARM_STORAGE_READ_COST` | [EIP-2929](./eip-2929.md) | | `COLD_ACCOUNT_ACCESS_COST` | [EIP-2929](./eip-2929.md) | | `GAS_NEW_ACCOUNT` | [EELS][gna] | | `GAS_CALL_VALUE` | [EELS][gcv] | [gna]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L52 [gcv]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L53 ### Behavior A new opcode is introduced: `PAY` (`0xfc`), which: - Halt with exceptional failure if the current frame is static, as defined in [EIP-214](./eip-214.md). - Pops two values from the stack: `addr` then `val`. - Exceptionally halts if `addr` has any of the high 12 bytes set to a non-zero value (i.e. it does not contain a 20-byte address). - Charges

MOTIVATION:
Currently, to send ether to an address requires you to call into that address, which transfers execution context to that address, which creates several issues: - First of all, it opens a reentrancy attack vector, as the recipient can call back into the sender. More generally, the recipient can unilaterally execute arbitrary state changes, limited only by the gas forwarded, which is not desirable from the point of view of the sender. - In practice, when calling into another account and sending ether, 2300 gas (the "gas stipend") is always available "for free" in the newly created call

RATIONALE:
### Argument order The order of arguments mimics that of `CALL`, which pops `addr` before `val`. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, so `PAY` always appears immediately after `COINBASE`. ### Halting for invalid address The halting behavior is designed to allow for Address Space Extension. If the high bytes were truncated, as in `CALL`, contracts could depend on the truncating behavior. If the address space were extended beyond 20 bytes, `PAY` would either not be able to target those accounts, or code expecting truncation could send ether to the wrong address. Because this behavior


=== EIP-7907 ===
TITLE: Meter Contract Code Size And Increase Limit
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-14
REQUIRES: 1, 7, 0, ,,  , 2, 9, 2, 9, ,,  , 3, 8, 6, 0, ,,  , 7, 7, 0, 2

SUMMARY:
This EIP substantially increases the contract code size limit from 24KB (24576 bytes) introduced in [EIP-170](./eip-170.md) to 48KB (49152 bytes), and adds gas metering. It introduces a gas cost of 4 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of any size while preventing DoS attacks through appropriate gas metering. Lastly, it also commensurately increases initcode size limit from 48KB, introduced in [EIP-3860](./eip-3860.md), to 96KB (98304 bytes).

SPECIFICATION:
### Definitions | Name | Value | Description | | --- | --- | --- | | COLD_SLOAD_COST | `2100` | The cost charged for cold loading storage as defined by [EIP-2929](./eip-2929.md). | | WARM_STORAGE_READ_COST | `100` | The cost charged for loading warm storage as defined by [EIP-2929](./eip-2929.md). | | `COLD_ACCOUNT_ACCESS_COST` | `2600` | The cost charged for loading a cold account as defined by [EIP-2929](./eip-2929.md). | | `GAS_PER_CODE_WORD` | `4` | The cost charged per word of code loaded beyond the initial `24KB` amount. | #### Helpers ```python def ceil32(n: int) -> int: return ((n +

MOTIVATION:
EIP-170 introduced a 24KB contract code size limit to prevent potential DoS attacks, as large contract code requires O(n) resource cost in terms of disk reads, VM preprocessing, and Merkle proof sizes, all of which are not directly compensated by gas fees. However, this limit restricts legitimate use cases for large contracts. This EIP proposes a gas-based solution that allows contracts of larger size while ensuring that users loading large contracts pay gas proportional to the additional resources they consume. This approach aligns with Ethereum's gas model philosophy of paying for the resources consumed. A new limit has

RATIONALE:
The gas cost of 4 per word was chosen in-line with the per word code defined by [EIP-2929](./eip-2929.md)'s `COLD_ACCOUNT_ACCESS_COST`. The value is derived from the current gas per word code of `ceil(2600 / (24676//32)) = 4` where `2600` is the current cold account load cost and `24676` is the maximum allow code size at that price. In general, this accounts for: 1. The additional disk I/O for retrieving larger contract code 2. The increased computational resources for preprocessing larger code for execution (a.k.a. "JUMPDEST analysis"). 3. The growth in Merkle proof sizes for blocks containing very large contracts


=== EIP-2384 ===
TITLE: Muir Glacier Difficulty Bomb Delay
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-11-20
REQUIRES: 

SUMMARY:
Starting with `MUIR_GLACIER_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9 million blocks later than the Homestead fork, which is also 7 million blocks later than the Byzantium fork and 4 million blocks later than the Constantinople fork.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 9_000_000) if block.number >= MUIR_GLACIER_FORK_BLKNUM else block.number

MOTIVATION:
The difficulty bomb started to become noticeable again on October 5th 2019 at block 8,600,000. Block times have been around 13.1s on average and now as of block 8,900,000 are around 14.3s. This will start to accelerate exponentially every 100,000 blocks. Estimating the added impact from the difficulty bomb on block times shows that we will see 20s block times near the end of December 2019 and 30s+ block times starting February 2020. This will start making the chain bloated and more costly to use. It's best to delay the difficulty bomb again to around the time of

RATIONALE:
This will delay the ice age by 52 million seconds (approximately 611 days), so the chain would be back at 20 second block times around July 2021. It's important to note this pushes the ice age 4,000,000 blocks from ~block 8,800,000 NOT from when this EIP is activated in a fork.


=== EIP-7044 ===
TITLE: Perpetually Valid Signed Voluntary Exits
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-18
REQUIRES: 

SUMMARY:
Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.

SPECIFICATION:
### Consensus Layer Specification changes are built into the Consensus Specs Deneb upgrade. The specific makes one change to the state transition function: - Modify [`process_voluntary_exit`](https://github.com/ethereum/consensus-specs/blob/75971a8c218b1d76d605dd8b88a08d39c42de221/specs/deneb/beacon-chain.md#modified-process_voluntary_exit) to compute the signing domain and root fixed on `CAPELLA_FORK_VERSION`. Additionally, the `voluntary_exit` gossip conditions are implicitly modified to support this change. To make the change backwards compatible the signature domain is locked on the Capella fork ### Execution Layer This specification does not require any changes to the Execution Layer.

MOTIVATION:
Currently, signed voluntary exits are valid up-to only two upgrades for block inclusion due to the Beacon Chain state considering only the current and previous fork version. This limitation increases the complexity of some staking operations, specifically those in which the staking operator (holder of active key) is distinct from the owner of the funds (holder of the withdrawal credential). Because voluntary exits can only be signed by the active key, such a relationship requires the exchange of signed exits ahead of time for an unbounded number of forks. The limited validity of voluntary exits was originally motivated

RATIONALE:
Perpetually valid signed voluntary exits allow simpler staking operation designs. It also aligns the UX of such objects to `BLSToExecutionChanges` and deposits, such that downstream tooling does not need to be updated with fork version information.


=== EIP-7910 ===
TITLE: eth_config JSON-RPC Method
TYPE: Standards Track Interface
STATUS: Review
CREATED: 2025-03-18
REQUIRES: 

SUMMARY:
This document describes an RPC method that provides node-relevant configuration data for the current, next, and last known forks.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Clients MUST expose a new RPC method to report the current functional configuration and the expected next configuration via the standard JSON-RPC port. Clients MAY also expose this method through the Engine API. Clients MAY use these configuration objects to manage their per-fork configurations, though they SHOULD NOT simply return unprocessed configuration data. When reporting the current, next and last configurations, clients MUST include

MOTIVATION:
Throughout Ethereum's history, there have been multiple instances where a client was not correctly configured for an upcoming hard fork, causing it to fall out of consensus when the fork boundary was crossed. Most incidents have been minor, such as a single client forking the chain in proof-of-work or having its blocks orphaned in proof-of-stake. The most significant occurrence was during the Pectra activation on the Holešky testnet. Four out of six clients on the network had an incorrect configuration for the deposits contract. Instead of being orphaned, the incorrect chain was justified, and the side effects persist

RATIONALE:
### Why Enumerate Precompiles? (And in General, Why Track a Particular Config Item?) The purpose of this specification is to enable nodes to advertise, prior to a fork, that they have the correct configurations loaded and ready. Past testnet and Ethereum Mainnet forks have revealed clients with incorrect precompile sets, chain IDs, deposit contract addresses, and other configuration errors. For precompiles in particular there has been discussion about removing or replacing precompiles in future forks, so a full enumeration of precompiles will reflect removal. Generally, if a configurable variable or constant causes a client to diverge at a


=== EIP-7587 ===
TITLE: Reserve Precompile Address Range for RIPs
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-21
REQUIRES: 

SUMMARY:
This EIP reserves precompile ranges to ensure there are no conflicts with those used by the Rollup Improvement Proposal (RIP) process.

SPECIFICATION:
The address range between `0x0000000000000000000000000000000000000100` and `0x00000000000000000000000000000000000001ff` is reserved for use by the RIP process.

MOTIVATION:
As L2s begin to deploy RIPs, it is necessary to reserve an address range for use by the RIP process so as to ensure there are no conflicts between precompile addresses used by RIPs and EIPs.

RATIONALE:
By reserving an address range for RIPs, it allows the RIP process to maintain its own registry of precompiles that are not (necessarily) deployed on L1 mainnet, the EIP process is freed from having to maintain a registry of RIP precompiles while still having 255 addresses for its own use.


=== EIP-2294 ===
TITLE: Explicit bound to Chain ID size
TYPE: Informational 
STATUS: Review
CREATED: 2019-09-19
REQUIRES: 155

SUMMARY:
This EIP informationally defines the "Safe Range" and "Max Range" of ChainId based on a few known restrictions such as [EIP-155](./eip-155.md) and major wallet and JSON-RPC representation of ChainId.

SPECIFICATION:
We declared the following chainID range 1. (1, 2^31 - 1): "Safe Range", the higher bound is decided by Javascript number 2. (1, MAX_CHAIN_ID); "Max Range", in which `MAX_CHAIN_ID := floor(MAX_UINT64 / 2) - 36 = 9,223,372,036,854,775,771`:

MOTIVATION:
1. We want chainId to be safe across the different components of the ecosystem such as smart contract, wallet, dApp and JSON-RPC etc. 2. We want to enable Cross-Chain function call 3. We want to ensure [EIP-712](./eip-712.md) domains have a clear definition of how to pack ChainID. 4. Enable possible expansion of chains, such as increasing amount of L2s, L3s, or shards of Ethereum mainnets. 5. Enable hashed based temporary chain: There have been suggestions of using a hash-based identifier in place on Chain ID to allow the value to adapt over time to different contentious forks and

RATIONALE:
### Beyond "Max Range", the EIP-155 will overflow as discussed below The `MAX_CHAIN_ID` is calculated to avoid overflow when performing uint64 math. For reference, a value of 0 or less is also disallowed. Due to how the calculation for chain ID is performed, the maximum value seen during the arithmetic is `CHAIN_ID * 2 + 36`, so clients must test to ensure no overflow conditions are encountered when the highest value is used. No underflow is possible. EIP-155 introduces the Chain ID parameter, which is an important parameter used for domain separation (replay protection) of Ethereum protocol signed


=== EIP-779 ===
TITLE: Hardfork Meta: DAO Fork
TYPE: Meta 
STATUS: Final
CREATED: 2017-11-26
REQUIRES: 606

SUMMARY:
This documents the changes included in the hard fork named "DAO Fork". Unlike other hard forks, the DAO Fork did not change the protocol; all EVM opcodes, transaction format, block structure, and so on remained the same. Rather, the DAO Fork was an "irregular state change" that transferred ether balances from a list of accounts ("child DAO" contracts) into a specified account (the "WithdrawDAO" contract).

SPECIFICATION:
- Codename: DAO Fork - Activation: - Block == 1,920,000 on Mainnet See references [1] and [2] for the original, full specification. It is summarized here for convenience. At block 1880000, the following accounts are encoded into a list `L`: * The DAO (`0xbb9bc244d798123fde783fcc1c72d3bb8c189413`) * its extraBalance (`0x807640a13483f8ac783c557fcdf27be11ea4ac7a`) * all children of the DAO creator (`0x4a574510c7014e4ae985403536074abe582adfc8`) * and the extraBalance of each child <details> <summary>Reference list L</summary> ``` 0xd4fe7bc31cedb7bfb8a345f31e668033056b2728, 0xb3fb0e5aba0e20e5c49d252dfd30e102b171a425, 0x2c19c7f9ae8b751e37aeb2d93a699722395ae18f, 0xecd135fa4f61a655311e86238c92adcd779555d2, 0x1975bd06d486162d5dc297798dfc41edd5d160a7, 0xa3acf3a1e16b1d7c315e23510fdd7847b48234f6, 0x319f70bab6845585f412ec7724b744fec6095c85, 0x06706dd3f2c9abf0a21ddcc6941d9b86f0596936, 0x5c8536898fbb74fc7445814902fd08422eac56d0, 0x6966ab0d485353095148a2155858910e0965b6f9, 0x779543a0491a837ca36ce8c635d6154e3c4911a6, 0x2a5ed960395e2a49b1c758cef4aa15213cfd874c, 0x5c6e67ccd5849c0d29219c4f95f1a7a93b3f5dc5, 0x9c50426be05db97f5d64fc54bf89eff947f0a321, 0x200450f06520bdd6c527622a273333384d870efb, 0xbe8539bfe837b67d1282b2b1d61c3f723966f049, 0x6b0c4d41ba9ab8d8cfb5d379c69a612f2ced8ecb, 0xf1385fb24aad0cd7432824085e42aff90886fef5, 0xd1ac8b1ef1b69ff51d1d401a476e7e612414f091, 0x8163e7fb499e90f8544ea62bbf80d21cd26d9efd, 0x51e0ddd9998364a2eb38588679f0d2c42653e4a6, 0x627a0a960c079c21c34f7612d5d230e01b4ad4c7, 0xf0b1aa0eb660754448a7937c022e30aa692fe0c5, 0x24c4d950dfd4dd1902bbed3508144a54542bba94, 0x9f27daea7aca0aa0446220b98d028715e3bc803d, 0xa5dc5acd6a7968a4554d89d65e59b7fd3bff0f90, 0xd9aef3a1e38a39c16b31d1ace71bca8ef58d315b, 0x63ed5a272de2f6d968408b4acb9024f4cc208ebf, 0x6f6704e5a10332af6672e50b3d9754dc460dfa4d, 0x77ca7b50b6cd7e2f3fa008e24ab793fd56cb15f6,


=== EIP-2930 ===
TITLE: Optional access lists
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-08-29
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 2, 9

SUMMARY:
We introduce a new [EIP-2718](./eip-2718.md) transaction type, with the format `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])`. The `accessList` specifies a list of addresses and storage keys; these addresses and storage keys are added into the `accessed_addresses` and `accessed_storage_keys` global sets (introduced in [EIP-2929](./eip-2929.md)). A gas cost is charged, though at a discount relative to the cost of accessing outside the list.

SPECIFICATION:
### Definitions **`TransactionType`** `1`. See [EIP-2718](./eip-2718.md) **`ChainId`** The transaction only valid on networks with this `chainID`. **`YParity`** The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature. ### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | 12244000 | | `ACCESS_LIST_STORAGE_KEY_COST` | 1900 | | `ACCESS_LIST_ADDRESS_COST` | 2400 | As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` `1`. The [EIP-2718](./eip-2718.md) `TransactionPayload` for this transaction is `rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])`. The `signatureYParity, signatureR, signatureS` elements of this transaction represent

MOTIVATION:
This EIP serves two functions: 1. Mitigates contract breakage risks introduced by [EIP-2929](./eip-2929.md), as transactions could pre-specify and pre-pay for the accounts and storage slots that the transaction plans to access; as a result, in the actual execution, the SLOAD and EXT* opcodes would only cost 100 gas: low enough that it would not only prevent breakage due to that EIP but also "unstuck" any contracts that became stuck due to EIP 1884. 2. Introduces the access list format and the logic for handling the format. This logic can later be repurposed for many other purposes, including block-wide

RATIONALE:
### Charging less for accesses in the access list This is done to encourage transactions to use the access list as much as possible, and because processing transactions is easier when their storage reads are predictable (because clients can pre-load the data from databases and/or ask for witnesses at the time the transaction is received, or at least load the data in parallel). ### Allowing duplicates This is done because it maximizes simplicity, avoiding questions of what to prevent duplication against: just between two addresses/keys in the access list, between the access list and the tx sender/recipient/newly created


=== EIP-3372 ===
TITLE: 5 FNV primes for ethash
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
This EIP is to kick current ASIC implementations out of the network to keep the Ethereum network secure and healthy by changing the `fnv` constants.

SPECIFICATION:
If `block.number >= ETHASH11_BLKNUM`, activate the `ethash1.1` algorithm version. ### ethash1.1 Prior to this change, `fnv` hash function is used throughout the `hashimoto` function. `fnv` is identical for all steps, `ethash1.1` will introduce additional `fnvA`, `fnvB`, `fnvC`, `fnvD`, and `fnvE` functions. All those functions will have different FNV constants. ``` // Previously used FNV prime #define FNV_PRIME_0 0x1000193 // New FNV primes #define FNV_PRIME_A 0x10001a7 #define FNV_PRIME_B 0x10001ab #define FNV_PRIME_C 0x10001cf #define FNV_PRIME_D 0x10001e3 #define FNV_PRIME_E 0x10001f9 ``` Prior to this EIP, all parts of Ethash are using the `fnv` (hereinafter referenced as `fnv0`) function. As of the

MOTIVATION:
ASICs provide a severe centralization risk for the Ethereum network. If we do not get rid of them, small GPU miners will be forced to exit the Ethereum mining because EIP-1559 will make them mining at a loss. Furthermore, ASIC production will be concentrated only at one or two parties, which will make the Ethereum hashrate centralized. Also, it is worth noting that Ethash ASIC machines cost 10k+ USD, while GPUs are priced less than 1000 USD. With GPUs, miners can switch to other mining algorithms, but with ASICs, it is impossible. Leaving everything as-is will almost certainly

RATIONALE:
ASIC Miners have become a threat to the future of Ethereum and a hard fork is required to remove them from the network before additional damage is caused. EIP-3372 proposes the minimum necessary to do so and will not affect ETH stakeholders or the network like Ethash 2.0 would. The threat ASICs pose is legal, social, moral, technical, monetary, and environmental. As we continue to come closer to the merge ASICs will attack the network and the developers personally as they have done in the past because miners will always pursue profits. Legally and socially ASIC's have previously


=== EIP-607 ===
TITLE: Hardfork Meta: Spurious Dragon
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 5, 5, ,,  , 1, 6, 0, ,,  , 1, 6, 1, ,,  , 1, 7, 0, ,,  , 6, 0, 8

SUMMARY:
This specifies the changes included in the hard fork named Spurious Dragon.

SPECIFICATION:
- Codename: Spurious Dragon - Aliases: State-clearing - Activation: - Block >= 2,675,000 on Mainnet - Block >= 1,885,000 on Morden - Included EIPs: - [EIP-155](./eip-155.md) (Simple replay attack protection) - [EIP-160](./eip-160.md) (EXP cost increase) - [EIP-161](./eip-161.md) (State trie clearing) - [EIP-170](./eip-170.md) (Contract code size limit)


=== EIP-6049 ===
TITLE: Deprecate SELFDESTRUCT
TYPE: Meta 
STATUS: Final
CREATED: 2022-11-27
REQUIRES: 

SUMMARY:
This EIP deprecates the `SELFDESTRUCT` opcode and warns against its use. A breaking change to this functionality is likely to come in the future.

SPECIFICATION:
Documentation of the `SELFDESTRUCT` opcode is updated to warn against its use and to note that a breaking change may be forthcoming.

MOTIVATION:
Discussions about how to change `SELFDESTRUCT` are ongoing. But there is a strong consensus that *something* will change.

RATIONALE:
As time goes on, the cost of doing something increases, because any change to `SELFDESTRUCT` will be a breaking change. The Ethereum Blog and other official sources have not provided any warning to developers about a potential forthcoming change.


=== EIP-3198 ===
TITLE: BASEFEE opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-01-13
REQUIRES: 1559

SUMMARY:
Add a `BASEFEE (0x48)` that returns the value of the base fee of the current block it is executing in.

SPECIFICATION:
Add a `BASEFEE` opcode at `(0x48)`, with gas cost `G_base`. | Op | Input | Output | Cost | |:----: |:-----: |:------: |:----: | | 0x48 | 0 | 1 | 2 |

MOTIVATION:
The intended use case would be for contracts to get the value of the base fee. This feature would enable or improve existing use cases, such as: - Contracts that need to set bounties for anyone to "poke" them with a transaction could set the bounty to be `BASEFEE + x`, or `BASEFEE * (1 + x)`. This makes the mechanism more reliable, because they will always pay "enough" regardless of market conditions. - Gas futures can be implemented based on it. This would be more precise than gastokens. - Improve the security for state channels, plasma, optirolls

RATIONALE:
### Gas cost The value of the base fee is needed to process transactions. That means it's value is already available before running the EVM code. The opcode does not add extra complexity and additional read/write operations, hence the choice of `G_base` gas cost.


=== EIP-698 ===
TITLE: OPCODE 0x46 BLOCKREWARD
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-08-28
REQUIRES: 

SUMMARY:
In the EVM, the 0x40 opcodes are reserved for `Block Information`. Currently reserved opcodes are: * `0X40 BLOCKHASH` * `0X41 COINBASE` * `0X42 TIMESTAMP` * `0X43 NUMBER` * `0X44 DIFFICULTY` * `0X45 GASLIMIT` This EIP would add an additional opcode, `0x46 BLOCKREWARD`, which would return the block reward for any finalized block. The finalized block reward would include the base reward, uncle payments, and gas.

SPECIFICATION:
After block `n` all clients should process opcode `0x46` as follows: * Value: `0x46` * Mnemonic: `BLOCKREWARD` * δ:` 0` nothing removed from stack * α:`1` block reward added to stack * Description: `Get the block's reward emission` * GasCost: `G<sub>base</sub>` Where:`µ'<sub>s</sub>[0] ≡ I<sub>HR</sub>`

MOTIVATION:
Per EIP-649 ( #669 ) periodic block reward reductions/variance are now planned in the roadmap, however, this EIP is consensus system agnostic and is most useful in decentralized pool operations and for any contract that benefits from knowing a block reward payout(i.e. Merge mined tokens)

RATIONALE:
### Contract Mining Pools For distributed consensus systems(staking pools and mining pools) ad hoc groups combine resources in order to reduce variance in payouts. Broadly, pool operations function by allowing a collective of miners / stakers to verify their contribution to solving PoW or staking share by periodically submitting solutions which are representative of the miners probability of finding a true block. In all these schemes `B` stands for a block reward minus pool fee and `p` is a probability of finding a block in a share attempt ( `p=1/D`, where `D` is current block difficulty). Some common


=== EIP-7773 ===
TITLE: Hardfork Meta - Glamsterdam
TYPE: Meta 
STATUS: Draft
CREATED: 2024-09-26
REQUIRES: 7, 6, 0, 7, ,,  , 7, 7, 2, 3

SUMMARY:
This Meta EIP lists the EIPs formally Proposed, Considered, Declined for & Scheduled for Inclusion in the Glamsterdam network upgrade.

SPECIFICATION:
Definitions for `Scheduled for Inclusion`, `Considered for Inclusion`, `Declined for Inclusion` and `Proposed for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion * [EIP-7732](./eip-7732.md): Enshrined Proposer-Builder Separation * [EIP-7928](./eip-7928.md): Block-Level Access Lists ### Considered for Inclusion * [EIP-7805](./eip-7805.md): Fork-choice enforced Inclusion Lists (FOCIL) ### Declined for Inclusion * [EIP-7782](./eip-7782.md): Reduce Block Latency ### Proposed for Inclusion 1. [EIP-2926](./eip-2926.md): Chunk-based code merkelization 1. [EIP-6873](./eip-6873.md): Preimage retention 1. [EIP-7667](./eip-7667.md): Raise gas costs of hash functions 1. [EIP-7688](./eip-7688.md): Forward compatible consensus data structures 1. [EIP-7793](./eip-7793.md): Conditional Transactions 1. [EIP-7819](./eip-7819.md): SETDELEGATE instruction 1. [EIP-7843](./eip-7843.md): SLOTNUM opcode 1. [EIP-7919](./eip-7919.md): Pureth

RATIONALE:
This Meta EIP provides a global view of all changes included in the Glamsterdam network upgrade, as well as links to full specification.


=== EIP-4750 ===
TITLE: EOF - Functions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-01-10
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 5, 4, 5, 0

SUMMARY:
Introduce the ability to have several code sections in EOF-formatted ([EIP-3540](./eip-3540.md)) bytecode, each one representing a separate subroutine/function. Two new opcodes,`CALLF` and `RETF`, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.

SPECIFICATION:
### Type Section The type section of EOF containers must adhere to following requirements: 1. The section is a list of metadata where the metadata index in the type section corresponds to a code section index. Therefore, the type section size MUST be `n * 4` bytes, where `n` is the number of code sections. 2. Each metadata item has 3 attributes: a uint8 `inputs`, a uint8 `outputs`, and a uint16 `max_stack_increase`. *Note:* This implies that there is a limit of 255 stack for the input and in the output. This is further restricted to 127 stack items,

MOTIVATION:
Currently, in the EVM everything is a dynamic jump. Languages like Solidity generate most jumps in a static manner (i.e. the destination is pushed to the stack right before, `PUSHn .. JUMP`). Unfortunately however this cannot be used by most EVM interpreters, because of added requirement of validation/analysis. This also restricts them from making optimisations and potentially reducing the cost of jumps. [EIP-4200](./eip-4200.md) introduces static jump instructions, which remove the need for *most* dynamic jump use cases, but not everything can be solved with them. This EIP aims to remove the need and disallow dynamic jumps as it

RATIONALE:
### `RETF` in the top frame ends execution vs exceptionally halts vs is not allowed during validation Alternative logic for `RETF` in the top frame could be to allow it during code validation and make it either: - end execution if the return stack is emptied by the `RETF` or - exceptionally halt if the return stack is empty before the `RETF`. This has been superseded with the validation rule of top frame (0th code section) being non-returning (non-returning sections introduced in a separate EIP), because validating non-returning status of functions is valuable by itself for other reasons.


=== EIP-4938 ===
TITLE: eth/67 - Removal of GetNodeData
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-03-23
REQUIRES: 2, 4, 6, 4, ,,  , 2, 4, 8, 1

SUMMARY:
The [Ethereum Wire Protocol](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md) defines request and response messages for exchanging data between clients. The `GetNodeData` request retrieves a set of trie nodes or contract code from the state trie by hash. We propose to remove the `GetNodeData` and `NodeData` messages from the wire protocol.

SPECIFICATION:
Remove the following message types from the `eth` protocol: * `GetNodeData (0x0d)` * **(eth/66)**: `[request_id: P, [hash_0: B_32, hash_1: B_32, ...]]` * `NodeData (0x0e)` * **(eth/66)**: `[request_id: P, [value_0: B, value_1: B, ...]]`

MOTIVATION:
`GetNodeData` and `NodeData` were introduced in protocol version `eth/63` to allow for a sync mode called "fast sync", which downloads the Ethereum state without executing all blocks. The sync algorithm works by requesting all state trie nodes and contract codes by their hash. Serving `GetNodeData` requests requires clients to store state as a mapping of hashes to trie nodes. Avoiding the need to store such a mapping in the database is the main motivation for removing this request type. At this time, some client implementations cannot serve `GetNodeData` requests because they do not store the state in a

RATIONALE:
A replacement for `GetNodeData` is available in the [snap protocol](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md). Specifically, clients can use the [GetByteCodes](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md#getbytecodes-0x04) and [GetTrieNodes](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md#gettrienodes-0x06) messages instead of `GetNodeData`. The snap protocol can be used to implement the "fast sync" algorithm, though it is recommended to use it for "snap sync".


=== EIP-7919 ===
TITLE: Pureth Meta
TYPE: Meta 
STATUS: Draft
CREATED: 2025-03-26
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 4, 9, 5, ,,  , 7, 6, 6, 8, ,,  , 7, 7, 0, 8, ,,  , 7, 7, 4, 5, ,,  , 7, 7, 9, 9, ,,  , 7, 8, 0, 7, ,,  , 7, 9, 1, 6

SUMMARY:
This Meta EIP bundles a set of improvements to make Ethereum data easier to access and verify without relying on trusted RPC providers or third-party indexers. The improvements achieve this by changing data structures for blocks, transactions, and receipts, so that efficient correctness (i.e., validity) and completion (i.e., nothing omitted) proofs can be added to the RPC responses.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Improve UX: ETH transfer logs ETH transfers currently don't emit logs, and in many situations don't leave any on-chain record in neither transaction nor receipt that they took place. For example, SENDALL can send an arbitrary ETH balance to an arbitrary account as part of a smart contract based wallet. Or a new contract deployment may send ETH to a new account of

MOTIVATION:
- **Security**: Today, most wallets and dApps consume data from very few large RPC providers, which exposes users to the risk of incorrect and incomplete data in case the RPC provider gets hacked, becomes malicious, or uses a faulty software version. - **Privacy**: Centralized infrastructure is subject to external data collection and privacy policies; users may be profiled across distinct wallets even when there is no on-chain link between them. - **Cost**: External indexers can be quite costly, however, are required for even basic wallet use cases. Reducing reliance on them helps lower-funded developers.

RATIONALE:
See individual EIPs.


=== EIP-3670 ===
TITLE: EOF - Code Validation
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-06-23
REQUIRES: 3540

SUMMARY:
Introduce code validation at contract creation time for EOF formatted ([EIP-3540](./eip-3540.md)) contracts. Reject contracts which contain truncated `PUSH`-data or undefined instructions. Legacy bytecode (code which is not EOF formatted) is unaffected by this change.

SPECIFICATION:
This feature is introduced on the same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST be validated according to these rules. 1. Previously deprecated instructions `CALLCODE` (0xf2) and `SELFDESTRUCT` (0xff), as well as instructions deprecated in EIP-3540, are invalid and their opcodes are undefined. (**NOTE** there are more instructions deprecated and rejected in EOF, as specced out by separate EIPs) 2. At contract creation time *code validation* is performed on each code section of the EOF container. The code is invalid if any of the checks below fails. For each instruction: 1. Check if the opcode is

MOTIVATION:
Currently existing contracts require no validation of correctness and EVM implementations can decide how they handle truncated bytecode or undefined instructions. This change aims to bring code validity into consensus, so that it becomes easier to reason about bytecode. Moreover, EVM implementations may require fewer paths to decide which instruction is valid in the current execution context. If there's a desire to introduce new instructions without bumping the EOF version, having undefined instructions already deployed could potentially break such contracts, as some instructions might change their behavior. Rejecting to deploy undefined instructions allows introducing new instructions with or

RATIONALE:
### Immediate data Allowing implicit zero immediate data for `PUSH` instructions introduces inefficiencies to EVM implementations without any practical use-case (the value of a `PUSH` instruction at the code end cannot be observed by EVM). This EIP requires all immediate bytes to be explicitly present in the code. ### Rejection of deprecated instructions The deprecated instructions `CALLCODE` (0xf2) and `SELFDESTRUCT` (0xff) are removed from the `valid_opcodes` list to prevent their use in the future. ### BLOCKHASH instruction The `BLOCKHASH` instruction is well replaced by the system contract introduced in [EIP-2935](./eip-2935). However, despite a replacement being introduced this opcode


=== EIP-7639 ===
TITLE: eth/70 - Cease serving history before PoS
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2024-02-13
REQUIRES: 

SUMMARY:
Execution layer clients will no longer request or respond to p2p queries about block data before the Paris upgrade.

SPECIFICATION:
Add a new `eth` protocol capability with version `70`. Clients connected on this version must not make or respond to p2p queries about block bodies or receipts before block 15537393. The affected protocol messages are: - `GetBlockBodies (0x05)` - `BlockBodies (0x06)` - `GetReceipts (0x0f)` - `Receipts (0x10)`

MOTIVATION:
As of 2024, historical data in clients has grown to around 500 GB. Nearly 400 GB of that is from block data before PoS was activated in the Paris upgrade. Long term, Ethereum plans to bound the amount of data nodes must store. This EIP proposes the first steps to achieve such goal.

RATIONALE:
### Only Pre-PoS data One might ask why the distinction between pre and post PoS data is made in this EIP. The simple answer is that the at the moment of the merge, the block structure changed substantially. Although execution layer client software today continues on with block data on disk which remains similar to per-PoS data, the beacon chain is now the canonical chain definition. Therefore, a beacon block can be used to both record historical data for execution layer and beacon layer. Over the long term, the distinctions of "execution layer" and "consensus layer" may matter


=== EIP-7808 ===
TITLE: Reserve Tx-Type Range for RIPs
TYPE: Meta 
STATUS: Stagnant
CREATED: 2024-11-04
REQUIRES: 2718

SUMMARY:
This EIP reserves a [transaction-type](./eip-2718.md) range for use by the Rollup Improvement Proposal (RIP) process to ensure there are no conflicts.

SPECIFICATION:
The transaction-type (as specified in [EIP-2718](./eip-2718)) range from `0x40` to `0x7f` (inclusive of both) is reserved for use by the RIP process.

MOTIVATION:
For L2s to use new transactrion types, it is necessary to reserve a transaction-type range for use by the RIP process so as to ensure there are no conflicts between transaction types used by RIPs and EIPs.

RATIONALE:
By reserving a transaction-type range for RIPs, it allows the RIP process to maintain its own registry of transaction types that are not (necessarily) in use on L1 mainnet, the EIP process is then freed from having to maintain a registry of RIP tx-types while still having 64 tx-types for its own use.


=== EIP-1344 ===
TITLE: ChainID opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-08-22
REQUIRES: 155

SUMMARY:
This EIP adds an opcode that returns the current chain's EIP-155 unique identifier.

SPECIFICATION:
Adds a new opcode `CHAINID` at 0x46, which uses 0 stack arguments. It pushes the current chain ID onto the stack. Chain ID is a 256-bit value. The operation costs `G_base` to execute. The value of the current chain ID is obtained from the chain ID configuration, which should match the EIP-155 unique identifier a client will accept from incoming transactions. Please note that per EIP-155, it is not *required* that a transaction have an EIP-155 unique identifier, but in that scenario this opcode will still return the configured chain ID and not a default.

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md).

RATIONALE:
The current approach proposed by EIP-712 is to specify the chain ID at compile time. Using this approach will result in problems after a hardfork, as well as human error that may lead to loss of funds or replay attacks on signed messages. By adding the proposed opcode it will be possible to access the current chain ID and validate signatures based on that. Currently, there is no specification for how chain ID is set for a particular network, relying on choices made manually by the client implementers and the chain community. There is a potential scenario where,


=== EIP-7557 ===
TITLE: Block-level Warming with fair cost savings
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-10-01
REQUIRES: 

SUMMARY:
A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots among multiple transactions with shared items in their `accessList`.

SPECIFICATION:
The [EIP-2930: Optional access lists](./eip-2930) already introduced the first part of the solution. Each transaction can specify an array of `accessed_addresses` and `accessed_storage_keys` to announce its intention to read those values during the execution of the transaction. The sender of the transaction is then pre-charged with the cost of accessing this data but is given a small discount compared to unannounced access. The missing component is a mechanism to aggregate the gas costs of the cold access and redistribute the resulting savings amongst the participating transactions. ### Overview During the transaction execution, the cost of all storage-related operations

MOTIVATION:
[EIP-2929: Gas cost increases for state access opcodes](./eip-2929) introduced a new gas cost model that differentiates between "cold" and "warm" access to accounts and storage slots. However, the cost of every cold access is borne by each transaction separately, even though the validator only needs to fetch the state object once for the entire block. When multiple transactions access the same state object in the same block the fees charged for these transactions do not accurately reflect the computations that block builders and validators perform for the blockchain state access during transaction execution. [EIP-2930: Optional access lists](./eip-2930) made

RATIONALE:
### Current cold storage gas cost is unfair As described in the [Motivation](#motivation) section, the amount of gas that users spend on accessing the contract code does not reflect the actual cost of this access for the block builder or a validator. The more popular the contract code or a storage slot is, the more transactions in each block should share the cost. However, the current system multiplies the cost for the users instead of dividing it. ### Issuing a regular gas refund after a transaction is not possible There exists a list of EVM instructions that trigger


=== EIP-3709 ===
TITLE: Remove Support for Type 1 Transactions
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2021-08-07
REQUIRES: 1559

SUMMARY:
Since both `TransactionType` 1 and 2 contain `access_list`, we propose the removal of offering `TransactionType` 1 from wallets and providers, instead the transaction will be converted to `TransactionType` 2 to make use of the new gas properties introduced by [EIP-1559](./eip-1559.md).

SPECIFICATION:
For wallets and providers, if a user submits a transaction for signing with where `TransactionType == 0x1`, the developer should upgrade the transaction to meet the criteria of transaction of type 2. The following fields need to be changed, or amended: - `access_list`: Nothing changes and it should remain in the transaction. - `type`: Should change from `0x1` to `0x2`. - `gas_price`: Should be removed in favour of `max_fee_per_gas` & `max_priority_fee_per_gas` (see [EIP-1559](./eip-1559.md) for proper usage).

MOTIVATION:
[EIP-2930](./eip-2930.md) was introduced as the first `TransactionType`, type 1, with the intention of adding `access_list` to the `TransactionPayload`. [EIP-1559](./eip-1559.md) introduced the second `TransactionType` 2, which is represented as `rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`. The intention behind EIP-1559 was to enhance the user experience surrounding gas fees, and as we move forward we expect that the majority of the network will begin to using `TransactionType` 2 instead of the legacy style transactions. `TransactionType` 1 is a legacy transaction with the addition of `access_list` meaning that users will not benefit from enhancements made

RATIONALE:
Improve the user experience for submitting transactions, and move away from legacy style transactions.


=== EIP-3651 ===
TITLE: Warm COINBASE
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-12
REQUIRES: 2929

SUMMARY:
The `COINBASE` address shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.

SPECIFICATION:
At the start of transaction execution, `accessed_addresses` shall be initialized to also include the address returned by `COINBASE` (`0x41`).

MOTIVATION:
Direct `COINBASE` payments are becoming increasingly popular because they allow conditional payments, which provide benefits such as implicit cancellation of transactions that would revert. But accessing `COINBASE` is overpriced; the address is initially cold under the access list framework introduced in [EIP-2929](./eip-2929.md). This gas cost mismatch can incentivize alternative payments besides ETH, such as [ERC-20](./eip-20.md), but ETH should be the primary means of paying for transactions on Ethereum.

RATIONALE:
The addresses currently initialized warm are the addresses that should already be loaded at the start of transaction validation. The `ORIGIN` address is always loaded to check its balance against the gas limit and the gas price. The `tx.to` address is always loaded to begin execution. The `COINBASE` address should also be always be loaded because it receives the block reward and the transaction fees.


=== EIP-7999 ===
TITLE: Unified multidimensional fee market
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-04
REQUIRES: 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 4, 8, 4, 4, ,,  , 7, 5, 1, 6, ,,  , 7, 6, 9, 1, ,,  , 7, 8, 4, 0, ,,  , 7, 9, 1, 8

SUMMARY:
A unified multidimensional fee market is introduced, where each transaction specifies the maximum amount of ETH it is willing to pay for inclusion using a single `max_fee`. Upon inclusion, the protocol ensures that the transaction is able to pay the gas for all dimensions, treating the `max_fee` as fungible across resources. This enables a more efficient use of capital, and enshrines the same representation that users have when they interact with Ethereum. The fee market is further unified in terms of a single update fraction under a single fee update mechanism, generalized reserve pricing, and a gas normalization

SPECIFICATION:
The specification inherits its logic from [EIP-7706](./eip-7706.md), incorporating the changes necessary for facilitating one aggregate fee, a multidimensional [EIP-7918](./eip-7918.md) logic, a systematic approach to [EIP-7805](./eip-7805.md), and a stable gas normalization function, etc. ### Parameters | Constant | Value | Description | | :--- | :--- | :--- | | `MULTIDIM_TX_TYPE` | `TBD` <!-- TODO --> | Identifier for the new transaction type | | `EVM_LIMIT_TARGET_RATIO` | `2` | Ratio of EVM gas target to EVM gas limit | | `CALLDATA_GAS_PER_TOKEN` | `4` | Gas cost per token for calldata | | `TOKENS_PER_NONZERO_BYTE` | `4` | Tokens per non-zero

MOTIVATION:
A multidimensional fee market enables precise control over resource consumption. It allows *the market* to fairly price resources according to targets and limits deemed safe by developers, and it allows resources to be consumed at maximum capacity within these limits. Directly expanding the current fee market design to the multidimensional setting can however have negative effects on the user experience (UX) and on economic efficiency. Users are forced to set a `max_fee_per_gas` for each resource, where a too low allocation in any dimension can render the transaction ineligible. This EIP leverages the natural fungibility of the user's fee

RATIONALE:
### Why go multidimensional? Many Ethereum resources such as blobs, calldata, access, and compute are in limited supply each block, constrained by the need to, e.g., timely propagate data or run computations. Upholding the constraints on all these resources via a single meta-resource—"gas"—limits developers' ability to control both supply *and* demand. By going multidimensional, developers gain a more fine-grained control over the supply of each resource, preventing one from encroaching on the allotment for another. Resources can then be consumed at maximum capacity within each specified target and limit. With separate base fees for each resource, the market


=== EIP-2937 ===
TITLE: SET_INDESTRUCTIBLE opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-04
REQUIRES: 

SPECIFICATION:
Add a transaction-wide global variable `globals.indestructible: Set[Address]` (i.e. a variable that operates the same way as the selfdestructs set), initialized to the empty set. Add a `SET_INDESTRUCTIBLE` opcode at `0xA8`, with gas cost `G_base`, that adds the current `callee` to the `globals.indestructible` set. If in the current execution context the `callee` is in `globals.indestructible`, the `SELFDESTRUCT` opcode throws an exception.

MOTIVATION:
The intended use case would be for contracts to make their first byte of code be the `SET_INDESTRUCTIBLE` opcode if they wish to serve as libraries that guarantee to users that their code will exist unmodified forever. This is useful in account abstraction as well as other contexts. Unlike EIPs that disable the `SELFDESTRUCT` opcode entirely, this EIP does not modify behavior of any existing contracts.

RATIONALE:
Alternative proposals to this include: * Simply banning `SELFDESTRUCT` outright. This would be ideal, but has larger backwards compatibility issues. * Using a local variable instead of a global variable. This is problematic because it would be broken by `DELEGATECALL`.


=== EIP-2315 ===
TITLE: Simple Subroutines for the EVM
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-10-17
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0

SUMMARY:
This proposal provides a _complete_, _efficient_, _safe_ and _static_ control-flow facility. It introduces two new opcodes to support calling and returning from subroutines: * `RJUMPSUB relative_offset` -- relative jump to subroutine * `RETURNSUB` -- return to `PC` after most recent `RJUMPSUB`. It depends on the two new opcodes proposed by [EIP-4200](./eip-4200.md) to support static jumps: * `RJUMP relative_offset` — relative jump to `PC + relative_offset` * `RJUMPI relative_offset` — conditional relative jump It deprecates `JUMP` and `JUMPI`, allowing valid code to support streaming, one-pass, and other near-linear compilers. In concert with [EIP-3540](./eip-3540.md) and [EIP-3670](./eip-3670.md) it ensures, at initialization

SPECIFICATION:
### Opcodes #### `RJUMPSUB (0x5f) relative_offset` Transfers control to a subroutine. 1. Decode the `relative_offset` from the immediate data at `PC`. 2. Push the current `PC + 3` to the `return stack`. 3. Set `PC` to `PC + relative_offset`. The `relative_offset` is relative to the current `PC`. The offset is encoded as a two-byte, twos-complement signed integer, stored MSB-first. The gas cost is _low_. #### `RETURNSUB (0x5e)` Returns control to the caller of a subroutine. 1. Pop the `return stack` to `PC`. The gas cost is _verylow_. _Notes:_ * _Values popped off the `return stack` do not need

MOTIVATION:
### A complete control-flow facility. Jumps, conditional jumps and subroutines were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine: > We wish to be able to arrange that sequences of orders can divide at various points, continuing in different ways according to the outcome of the calculations to date... We also wish to be able to arrange for the splitting up of operations into subsidiary operations... To start on a subsidiary operation we need only make a note

RATIONALE:
This is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data – a subroutine is not a contiguous sequence of bytecode, it is a subgraph of the bytecode's control-flow graph. The EVM is a simple state machine. We only promise that valid code will not, as it were, jam up the gears of the machine. By avoiding syntactic constraints we allow for optimizations like tail call elimination, multiple-entry subroutines, moving "cold" code out of line, and other ways of reducing redundancy and keeping "hot" code


=== EIP-3436 ===
TITLE: Expanded Clique Block Choice Rule
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-25
REQUIRES: 225

SUMMARY:
The current specification of Clique allows for multiple competing blocks from producers but does not provide any strategies to pick blocks aside from the current "highest total difficulty" rule. This EIP proposes a four step choice rule of highest total difficulty, shortest chain, most recently in-turn, and lowest hash. This would prevent deadlocks that have occurred in production systems.

SPECIFICATION:
When a Clique validator is arbitrating the canonical status between two different chain head blocks, they should choose the canonical block with the following ordered priorities. 1. Choose the block with the most total difficulty. 2. Then choose the block with the lowest block number. 3. Then choose the block whose validator had the least recent in-turn block assignment. 4. Then choose the block with the lowest hash. When resolving rule 3 clients should use the following formula, where `validator_index` is the integer index of the validator that signed the block when sorted as per epoch checkpointing, `header_number`

MOTIVATION:
There has been more than one deadlock in the Goerli multi-client Clique network. The number of active validators was greater than 1/2 of the available validators so a chain halt should not have occurred. The halt was resolved by an inactive validator coming back on line. The state of the chain was in one of two configurations of 8 validators that can result in a chain halt. Three of the four clients observed a choice sequence of lowest total difficulty followed by first observed block. Geth added one extra rule of preferring the shortest chain before preferring the

RATIONALE:
Two scenarios of a halted chain are known based on the current total difficulty then first observed rule. One of the scenarios is also resistant to the shortest chain rule. For the first scenario where chains of different lengths can halt consider a block with 8 validators, whose addresses sort to the same order as their designation in this example. A fully in-order chain exists and validator number 8 has just produced an in-turn block and then validators 5, 7 and 8 go offline, leaving validators 1 to 6 to produce blocks. Two forks form, one with an


=== EIP-5345 ===
TITLE: Silent Signing Extension for JSON-RPC
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-07-26
REQUIRES: 

SUMMARY:
Mobile applications supporting lots of transactions might become a source of bad user experience due to uncontrolled switching between the wallet's and application's UI. By this proposal, we would like to introduce the means to sign and send wallet transactions without the need for user participation. This feature can be implemented by providing user consent for a specific time duration. We call the feature Silent Signing.

SPECIFICATION:
To remedy the situation, we'd like to introduce new RPC methods for the ethereum JSON-RPC. Those methods help enable wallets to implement the Silent Signing feature. ### Silent Signing User Flow The Silent Signing process has the following structure: 1. First, the application requests the wallet to use Silent Signing via the RPC's `wallet_requestSilentSign` method. 2. Second, the wallet prompts the user to confirm enabling the Silent Singing functionality for a specific time duration. 3. If the user does not confirm Silent Signing or the RPC method is not allowed, the application will continue using the regular methods.

MOTIVATION:
Some blockchain applications interact with a blockchain much more frequently than others. It is especially true for gaming applications having their own sidechains. Interrupting the gaming process and switching to the wallet to perform a transaction drastically affect the user experience.

RATIONALE:
Games and Metaverse applications imply lots of cases when the user interacts with the wallet, switching to it and approving transactions. This switching aspect might interfere with gaming per se and create a bad user experience. That is why such applications can benefit if the wallets can support the Silent Signing functionality allowing transactions to be signed with no user interaction.


=== EIP-6690 ===
TITLE: EVM Modular Arithmetic Extensions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-03-15
REQUIRES: 

SUMMARY:
This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1

SPECIFICATION:
### Constants | Name | Value | Description | | ---- | ---- | ---- | | `COST_SETMODX_BASE` | 1 | static cost component for the `SETMODX` opcode | | `COST_STOREX_BASE` | 1 | static cost for the `STOREX` opcode | | `COST_LOADX_BASE` | 1 | static cost for the `LOADX` opcode | ### Conventions 1. The use of `assert` implies that if the assertion fails, the current call frame will consume all call gas and terminate call execution in an exceptional state. 2. Unless otherwise stated, the implied unit for size is bytes. ### Overview The execution

MOTIVATION:
Current opcodes for modular arithmetic only support values up to 256 bits wide. In addition, they are permissive and accept any representable value for the inputs. Many cryptographic operations are heavily-bottlenecked by modular arithmetic. To expand the range of cryptographic primitives that can be implemented efficiently as EVM contracts, we propose new modular arithmetic opcodes designed for efficiency.

RATIONALE:
### Separation of EVM Memory and EVMMAX Virtual Register Space It is assumed that optimized implementations will not store values in EVM-compatible big-endian serialization format, but instead convert them to an internal working representation. The costs in the spec explicitly reflect the choice of Montgomery form as an optimal internal representation. Values represented in Montgomery form can make use of optimized modular reduction for multiplication. See the dedicated section on Montgomery multiplication in the rationale for more details. ### Total Virtual Register Allocation Cap 24576 bytes is chosen as the per-call-context allocation limit with the goal of ensuring


=== EIP-3554 ===
TITLE: Difficulty Bomb Delay to December 2021
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-05-06
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9,700,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 9_700_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
Targeting for the Shanghai upgrade and/or the Merge to occur before December 2021. Either the bomb can be readjusted at that time, or removed all together.

RATIONALE:
The following script predicts a .1 second delay to blocktime the first week of december and a 1 second delay by the end of the month. This gives reason to address because the effect will be seen, but not so much urgency we don't have space to work around if needed. ```python def predict_diff_bomb_effect(current_blknum, current_difficulty, block_adjustment, months): ''' Predicts the effect on block time (as a ratio) in a specified amount of months in the future. Vars used in last prediction: current_blknum = 12382958 current_difficulty = 7393633000000000 block adjustment = 9700000 months = 6 ''' blocks_per_month = (86400


=== EIP-7862 ===
TITLE: Delayed State Root
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-23
REQUIRES: 

SUMMARY:
This proposal introduces a mechanism to decouple state root computation from block validation by deferring the execution layer's state root reference by one block. Each block's `ExecutionPayload` contains the post-state root of the previous block rather than its own, enabling validators to attest to a block's validity without waiting for state root computation.

SPECIFICATION:
### Header Changes The block header structure is modified to support delayed state root computation: ```python @dataclass class Header: # Existing fields parent_hash: Hash32 ommers_hash: Hash32 coinbase: Address # Delayed state root - references the post-state of block (n-1) state_root: Root # Now points to parent block's post-state # Existing fields transactions_root: Root receipt_root: Root bloom: Bloom difficulty: Uint number: Uint gas_limit: Uint gas_used: Uint timestamp: U256 extra_data: Bytes prev_randao: Bytes32 nonce: Bytes8 base_fee_per_gas: Uint withdrawals_root: Root blob_gas_used: U64 excess_blob_gas: U64 parent_beacon_block_root: Root ``` The key change is: 1. `state_root`: Now represents the post-state root of block `n-1`

MOTIVATION:
The primary advantage of this proposal is **asynchronous state root computation**. In the current Ethereum protocol, blocks must compute and include their own post-state root before validators can attest to them. This requirement creates a bottleneck for block production, as the expensive state root computation must complete within critical path. By deferring the state root reference by one block, validators can attest to blocks based on transaction execution alone, without waiting for the state root calculation. This allows state root computation to be pipelined during idle slot time, potentially enabling higher block gas limits and accelerating the timeline

RATIONALE:
### Latency Reduction The separation of state root computation from block validation removes the primary latency bottleneck in block production and validation. Proposers and builders no longer need to compute the state root within the same slot, enabling faster block building and validation. This latency reduction is particularly important in the context of Proposer-Builder-Separation, where builders compete on construction speed. By removing state root computation from the critical path, builders can allocate more time to transaction ordering optimization. ### Throughput Improvements The time currently spent on same-slot state root computation can be repurposed for: 1. **Higher gas limits**:


=== EIP-155 ===
TITLE: Simple replay attack protection
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-14
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM` and `CHAIN_ID` is available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements `(nonce, gasprice, startgas, to, value, data)`, you **SHOULD** hash nine rlp encoded elements `(nonce, gasprice, startgas, to, value, data, chainid, 0, 0)`. If you do, then the `v` of the signature **MUST** be set to `{0,1} + CHAIN_ID * 2 + 35` where `{0,1}` is the parity of the `y` value of the curve point for which `r` is the x-value in the secp256k1 signing process. If you choose

RATIONALE:
This would provide a way to send transactions that work on Ethereum without working on ETC or the Morden testnet. ETC is encouraged to adopt this EIP but replacing `CHAIN_ID` with a different value, and all future testnets, consortium chains and alt-etherea are encouraged to adopt this EIP replacing `CHAIN_ID` with a unique value. ### List of Chain ID's: | `CHAIN_ID` | Chain(s) | | ---------------| -------------------------------------------| | 1 | Ethereum mainnet | | 2 | Morden (disused), Expanse mainnet | | 3 | Ropsten | | 4 | Rinkeby | | 5 | Goerli | | 42


=== EIP-3074 ===
TITLE: AUTH and AUTHCALL opcodes
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-10-15
REQUIRES: 155

SUMMARY:
This EIP introduces two EVM instructions `AUTH` and `AUTHCALL`. The first sets a context variable `authorized` based on an ECDSA signature. The second sends a call as the `authorized` account. This essentially delegates control of the externally owned account (EOA) to a smart contract.

SPECIFICATION:
### Conventions - **`top - N`** - the `N`th most recently pushed value on the EVM stack, where `top - 0` is the most recent. - **`||`** - byte concatenation operator. - **invalid execution** - execution that is invalid and must exit the current execution frame immediately, consuming all remaining gas (in the same way as a stack underflow or invalid jump). ### Constants | Constant | Value | | ---------------- | ------ | | `MAGIC` | `0x04` | `MAGIC` is used for [EIP-3074](./eip-3074.md) signatures to prevent signature collisions with other signing formats. ### Context Variables | Variable

MOTIVATION:
Adding more functionality to EOAs has been a long-standing feature request. The requests have spanned from implementing batching capabilities, allowing for gas sponsoring, expirations, scripting, and beyond. These changes often mean increased complexity and rigidity of the protocol. In some cases, it also means increased attack surfaces. This EIP takes a different approach. Instead of enshrining these capabilities in the protocol as transaction validity requirements, it allows users to *delegate* control of their EOA to a contract. This gives developers a flexible framework for developing novel transaction schemes for EOAs. A motivating use case of this EIP is

RATIONALE:
### Signature in Memory The signature format (`yParity`, `r`, and `s`) is fixed, so it might seem curious that `auth` accepts a dynamic memory range. The signature is placed in memory so that `auth` can be upgraded in the future to work with contract accounts (which might use non-ECDSA signatures) and not just EOAs. ### Signing Address `auth` Argument Including `authority` (the signing address) as an argument to `auth` allows future upgrades to the instruction to work with contract accounts, and not just EOAs. If `authority` were not included and multiple signature schemes allowed, it would not be


=== EIP-2200 ===
TITLE: Structured Definitions for Net Gas Metering
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-07-18
REQUIRES: 

SUMMARY:
This EIP provides a structured definition of net gas metering changes for `SSTORE` opcode, enabling new usages for contract storage, and reducing excessive gas costs where it doesn’t match how most implementation works. This is a combination of [EIP-1283] and [EIP-1706].

SPECIFICATION:
Define variables `SLOAD_GAS`, `SSTORE_SET_GAS`, `SSTORE_RESET_GAS` and `SSTORE_CLEARS_SCHEDULE`. The old and new values for those variables are: * `SLOAD_GAS`: changed from `200` to `800`. * `SSTORE_SET_GAS`: `20000`, not changed. * `SSTORE_RESET_GAS`: `5000`, not changed. * `SSTORE_CLEARS_SCHEDULE`: `15000`, not changed. Change the definition of EIP-1283 using those variables. The new specification, combining EIP-1283 and EIP-1706, will look like below. The terms *original value*, *current value* and *new value* are defined in EIP-1283. Replace `SSTORE` opcode gas cost calculation (including refunds) with the following logic: * If *gasleft* is less than or equal to gas stipend, fail the current call frame

MOTIVATION:
This EIP proposes a way for gas metering on `SSTORE`, using information that is more universally available to most implementations, and require as little change in implementation structures as possible. * Storage slot’s original value. * Storage slot’s current value. * Refund counter. Usages that benefits from this EIP’s gas reduction scheme includes: * Subsequent storage write operations within the same call frame. This includes reentry locks, same-contract multi-send, etc. * Exchange storage information between sub call frame and parent call frame, where this information does not need to be persistent outside of a transaction. This includes sub-frame

RATIONALE:
This EIP mostly achieves what a transient storage tries to do ([EIP-1087] and [EIP-1153]), but without the complexity of introducing the concept of "dirty maps", or an extra storage struct. * We don't suffer from the optimization limitation of EIP-1087. EIP-1087 requires keeping a dirty map for storage changes, and implicitly makes the assumption that a transaction's storage changes are committed to the storage trie at the end of a transaction. This works well for some implementations, but not for others. After [EIP-658], an efficient storage cache implementation would probably use an in-memory trie (without RLP encoding/decoding) or


=== EIP-4399 ===
TITLE: Supplant DIFFICULTY opcode with PREVRANDAO
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-10-30
REQUIRES: 3675

SUMMARY:
This EIP supplants the semantics of the return value of existing `DIFFICULTY (0x44)` opcode and renames the opcode to `PREVRANDAO (0x44)`. The return value of the `DIFFICULTY (0x44)` instruction after this change is the output of the randomness beacon provided by the beacon chain.

SPECIFICATION:
### Definitions * **`TRANSITION_BLOCK`** The definition of this block can be found in the Definitions section of [EIP-3675](./eip-3675.md#definitions). ### Block structure Beginning with `TRANSITION_BLOCK`, client software **MUST** set the value of the `mixHash`, i.e. the field with the number `13` (0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block. ### EVM Beginning with `TRANSITION_BLOCK`, the `DIFFICULTY (0x44)` instruction **MUST** return the value of the `mixHash` field. *Note*: The gas cost of the `DIFFICULTY (0x44)` opcode remains unchanged. ### Renaming The `mixHash` field **SHOULD** further be renamed to `prevRandao`.

MOTIVATION:
Applications may benefit from using the randomness accumulated by the beacon chain. Thus, randomness outputs produced by the beacon chain should be accessible in the EVM. At the point of `TRANSITION_BLOCK` of the Proof-of-Stake (PoS) upgrade described in [EIP-3675](./eip-3675.md), the `difficulty` block field **MUST** be `0` thereafter because there is no longer any Proof-of-Work (PoW) seal on the block. This means that the `DIFFICULTY (0x44)` instruction no longer has it's previous semantic meaning, nor a clear "correct" value to return. Given prior analysis on the usage of `DIFFICULTY`, the value returned by the instruction mixed with other values

RATIONALE:
### Including RANDAO output in the block header Including a RANDAO output in the block header provides a straightforward method of accessing it from inside of the EVM as block header data is already available in the EVM context. Additionally, this ensures that the execution layer can be fully executed with the block alone rather than requiring extra inputs from the PoS consensus layer. Mixing the randomness into a block header may contribute to uniqueness of the block hash in the case when values of other fields of the block header match the corresponding values of the header


=== EIP-1011 ===
TITLE: Hybrid Casper FFG
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-20
REQUIRES: 

SUMMARY:
This EIP specifies a hybrid PoW/PoS consensus model for Ethereum main net. Existing PoW mechanics are used for new block creation, and a novel PoS mechanism called Casper the Friendly Finality Gadget (FFG) is layered on top using a smart contract. Through the use of Ether deposits, slashing conditions, and a modified fork choice, FFG allows the underlying PoW blockchain to be finalized. As network security is greatly shifted from PoW to PoS, PoW block rewards are reduced. This EIP does not contain safety and liveness proofs or validator implementation details, but these can be found in the

SPECIFICATION:
#### Deploying Casper Contract If `block.number == HYBRID_CASPER_FORK_BLKNUM`, then when processing the block before processing any transactions: * set the code of `MSG_HASHER_ADDR` to `MSG_HASHER_CODE` * set the code of `PURITY_CHECKER_ADDR` to `PURITY_CHECKER_CODE` * set the code of `CASPER_ADDR` to `CASPER_CODE` * set balance of `CASPER_ADDR` to `CASPER_BALANCE` Then execute a `CALL` with the following parameters before executing any normal block transactions: * `SENDER`: `NULL_SENDER` * `GAS`: 3141592 * `TO`: `CASPER_ADDR` * `VALUE`: 0 * `NONCE`: 0 * `GASPRICE`: 0 * `DATA`: `CASPER_INIT_DATA` This `CALL` utilizes no gas and does not increment the nonce of `NULL_SENDER` #### Initialize

MOTIVATION:
Transitioning the Ethereum network from PoW to PoS has been on the roadmap and in the [Yellow Paper](https://github.com/ethereum/yellowpaper) since the launch of the protocol. Although effective in coming to a decentralized consensus, PoW consumes an incredible amount of energy, has no economic finality, and has no effective strategy in resisting cartels. Excessive energy consumption, issues with equal access to mining hardware, mining pool centralization, and an emerging market of ASICs each provide a distinct motivation to make the transition as soon as possible. Until recently, the proper way to make this transition was still an open area of

RATIONALE:
Naive PoS specifications and implementations have existed since early blockchain days, but most are vulnerable to serious attacks and do not hold up under crypto-economic analysis. Casper FFG solves problems such as "Nothing at Stake" and "Long Range Attacks" through requiring validators to post slashable deposits and through defining economic finality. #### Minimize Consensus Changes The finality gadget is designed to minimize changes across clients. For this reason, FFG is implemented within the EVM, so that the contract byte code encapsulates most of the complexity of the fork. Most other decisions were made to minimize changes across clients.


=== EIP-2028 ===
TITLE: Transaction data gas cost reduction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-05-03
REQUIRES: 

SPECIFICATION:
The gas per non-zero byte is reduced from 68 to 16. Gas cost of zero bytes is unchanged.

MOTIVATION:
There are a couple of main benefits to accepting this proposal and lowering gas cost of Calldata On-Chain Scalability: Generally speaking, higher bandwidth of Calldata improves scalability, as more data can fit within a single block. * Layer two scalability: Layer two scaling solutions can improve scalability by moving storage and computation off-chain, but often introduce data transmission instead. - Proof systems such as STARKs and SNARKs use a single proof that attests to the computational integrity of a large computation, say, one that processes a large batch of transactions. - Some solutions use fraud proofs which requires

RATIONALE:
Roughly speaking, reducing the gas cost of Calldata leads to potentially larger blocks, which increases the network delay associated with data transmission over the network. This is only part of the full network delay, other factors are block processing time (and storage access, as part of it). Increasing network delay affects security by lowering the cost of attacking the network, because at any given point in time fewer nodes are updated on the latest state of the blockchain. Yonatan Sompolinsky and Aviv Zohar suggested in [1] an elegant model to relate network delay to network security, and this


=== EIP-7825 ===
TITLE: Transaction Gas Limit Cap
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-11-23
REQUIRES: 

SUMMARY:
This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 16,777,216 (2^24) gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the gas limit.

SPECIFICATION:
### Gas Cap - Enforce a protocol-level maximum of **16,777,216 gas (2^24)** for any single transaction. - This cap applies regardless of the block gas limit set by miners or validators. - Transactions specifying gas limits higher than 16,777,216 gas will be rejected with an appropriate error code (e.g., `MAX_GAS_LIMIT_EXCEEDED`). ### Changes to EVM Behavior 1. **Txpool Validation**: During transaction validation, if the `gasLimit` specified by the sender exceeds 16,777,216, the transaction is invalidated (not included in the txpool). 2. **Block Validation**: As part of block validation before processing, any block having a transaction with `gasLimit` > 16,777,216

MOTIVATION:
Currently, transactions can theoretically consume up to the entire block gas limit, which poses several risks: 1. **DoS Attacks**: A single transaction consuming most or all of the block gas can result in uneven load distribution and impact network stability. 2. **State Bloat Risks**: High-gas transactions often result in larger state changes, increasing the burden on nodes and exacerbating the Ethereum state growth problem. 3. **Validation Overhead**: High-gas transactions can lead to longer block verification times, negatively impacting user experience and network decentralization. By limiting individual transactions to a maximum of 16,777,216 gas, we aim to: - Reduce

RATIONALE:
### Why 16,777,216 (2^24)? The proposed cap of 16,777,216 gas (2^24) provides a clean power-of-two boundary that simplifies implementation while still being large enough to accommodate most complex transactions, including contract deployments and advanced DeFi interactions. This value represents approximately half of typical block sizes (30-40 million gas), ensuring multiple transactions can fit within each block. ### Compatibility with Current Gas Dynamics - **Backward Compatibility**: Transactions with gas usage below 16,777,216 remain unaffected. Existing tooling and dApps need only minor updates to enforce the new cap. - **Impact on Validators**: Validators can continue to process blocks with a


=== EIP-6988 ===
TITLE: Elected block proposer has not been slashed
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-05-04
REQUIRES: 

SUMMARY:
Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.

SPECIFICATION:
Specification of the proposed change can be found in [`/_features/eip6988/beacon-chain.md`](https://github.com/ethereum/consensus-specs/blob/0ad3972725e7c22e8edf3bab2dd7730acbe3c272/specs/_features/eip6988/beacon-chain.md).

MOTIVATION:
A block proposed by a slashed validator is rejected by the corresponding validity check in the [`phase0/process_block_header`](https://github.com/ethereum/consensus-specs/blob/3115d1140b23dd4c9c23fbd9e2428186cf816bde/specs/phase0/beacon-chain.md#block-header) function as defined in the consensus layer specification. At the same time the definition of the [`phase0/compute_proposer_index`](https://github.com/ethereum/consensus-specs/blob/3115d1140b23dd4c9c23fbd9e2428186cf816bde/specs/phase0/beacon-chain.md#compute_proposer_index) allows for a slashed validator to be elected as a proposer. This contradiction effectively leads to a missed proposal if it is supposed to be made by a slashed validator. The impact of the proposed fix in the case of a single slashing on Ethereum Mainnet is negligible but it becomes significant in the case of correlated slashings. For instance, a correlated slashing of

RATIONALE:
### Modifying `get_beacon_proposer_index` This function is modified to read a proposer index from a beacon state if a slot of a latest block header is the same as the `state.slot`. This modification is done to make the function return correct proposer index in the case when the proposer of a given block is being slashed during processing of the block.


=== EIP-7951 ===
TITLE: Precompile for secp256r1 Curve Support
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-05-27
REQUIRES: 

SUMMARY:
Add functionality to efficiently perform ECDSA signature verification over the secp256r1 elliptic curve (also known as P-256 or prime256v1). This precompile enables native support for signatures generated by modern secure hardware including Apple Secure Enclave, Android Keystore, and FIDO2/WebAuthn devices. This specification addresses critical security issues discovered in RIP-7212 while maintaining full interface compatibility with existing Layer 2 implementations.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Precompile We introduce `P256VERIFY` a precompile at the address `0x100` which performs ECDSA signature verification over the secp256r1 curve with a gas cost of `6900` gas ### Curve Parameters The secp256r1 curve is fully defined by the following set of parameters: ``` text Base field modulus = p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff Curve equation: y^2 = x^3 + ax + b (mod p) Curve coefficient

MOTIVATION:
The secp256r1 elliptic curve is a NIST-standardized curve widely supported in modern secure hardware and authentication systems. Adding native support for secp256r1 signature verification to Ethereum enables several important use cases that are currently impossible or prohibitively expensive. Modern secure hardware devices, including Apple Secure Enclave, Android Keystore, HSMs, TEEs, and FIDO2/WebAuthn authenticators, use secp256r1 for key storage and signing operations. Native secp256r1 support enables sophisticated account abstraction patterns like device-native signing, multi-factor authentication, and simplified key management - ultimately reducing friction for mainstream adoption through familiar authentication flows. The secp256r1 curve is already widely supported across blockchain

RATIONALE:
### Security Fixes This specification addresses two critical vulnerabilities in RIP-7212: 1. **Point-at-infinity check**: The original RIP-7212 failed to check if the recovered point R' is the point at infinity. This could lead to non-deterministic behavior where the verification result depends on the underlying implementation's handling of infinity points, potentially causing consensus failures. 2. **Modular comparison**: The original comparison `r' == r` should be `r' ≡ r (mod n)` to handle cases where the x-coordinate of R' exceeds the curve order n. This ensures mathematically correct verification according to ECDSA standards. ### Verification vs Recovery This specification uses


=== EIP-1234 ===
TITLE: Constantinople Difficulty Bomb Delay and Block Reward Adjustment
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-07-19
REQUIRES: 

SUMMARY:
Starting with `CNSTNTNPL_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 5 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 5_000_000) if block.number >= CNSTNTNPL_FORK_BLKNUM else block.number #### Adjust Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward = 2_000_000_000_000_000_000 if block.number >= CNSTNTNPL_FORK_BLKNUM else block.reward (2E18 wei, or 2,000,000,000,000,000,000 wei, or 2 ETH). Analogue, if an uncle is included in a block for `block.number >= CNSTNTNPL_FORK_BLKNUM` such that `block.number - uncle.number = k`,

MOTIVATION:
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another 12 months. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it's going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state as before. Reducing

RATIONALE:
This will delay the ice age by 29 million seconds (approximately 12 months), so the chain would be back at 30 second block times in winter 2019. An alternate proposal was to add special rules to the difficulty calculation to effectively _pause_ the difficulty between different blocks. This would lead to similar results. This was previously discussed at All Core Devs Meeting [#42](https://github.com/ethereum/pm/blob/6dbd82303bfcb697eaf9a76de37f5fa570e6379d/AllCoreDevs-EL-Meetings/Meeting%2042.md) and subsequent meetings; and accepted in the Constantinople Session [#1](https://github.com/ethereum/pm/issues/55).


=== EIP-1901 ===
TITLE: Add OpenRPC Service Discovery To JSON-RPC Services
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-02-25
REQUIRES: 

SUMMARY:
### What is this? This is a proposal to add [OpenRPC](https://github.com/open-rpc/spec) support to existing and future JSON-RPC services by adding the method [`rpc.discover`](https://github.com/open-rpc/spec#service-discovery-method) to the projects [JSON-RPC](https://www.jsonrpc.org/specification) APIs, enabling automation and tooling. The OpenRPC Document and generated Documentation that specifies all the methods an EVM-based blockchain should implement can be found [here](https://github.com/etclabscore/ethereum-json-rpc-specification). This was first proposed [here as an ECIP](https://github.com/etclabscore/ECIPs/blob/master/ECIPs/ecip-1053.md), but the benefits of this kind of tooling is apparent across Bitcoin, Ethereum Classic, Ethereum and other JSON-RPC accessible blockchains.

SPECIFICATION:
### What is OpenRPC? The [OpenRPC](https://github.com/open-rpc/spec) Specification defines a standard, programming language-agnostic interface description for [JSON-RPC 2.0](https://www.jsonrpc.org/specification) APIs, which allows both humans and computers to discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic. When properly defined via OpenRPC, a consumer can understand and interact with the remote service with a minimal amount of implementation logic, and share these logic patterns across use cases. Similar to what interface descriptions have done for lower-level programming, the OpenRPC Specification removes guesswork in calling a service. ##### Structure This

MOTIVATION:
Although [EIP-1474](./eip-1474.md) outlines a JSON-RPC specification. Ethereum still lacks a machine-readable JSON-RPC Specification that can be used as the industry standard for tooling. This proposal attempts to standardize such a specification in a way that is versionable, and both human and machine readable. Ethereum clients can expose RPC endpoints with different method signatures and cause compatibility issues between clients. Developers need a reliable developer experience, and an industry standard way to describe Ethereum JSON-RPC 2.0 APIs.

RATIONALE:
### Why would we do this? Services need to figure out how to talk to each other. If we really want to build the next generation of automation, then having up to date libraries, documented APIs, and modern tools are going to provide easy discovery, on-boarding, and enable end user and developer interaction. Use cases for machine-readable [JSON-RPC 2.0](https://www.jsonrpc.org/specification) API definition documents include, but are not limited to: - A common vocabulary and document will keep developers, testers, architects, and technical writers all in sync. - Server stubs/skeletons generated in many languages - Clients generated in many languages


=== EIP-7657 ===
TITLE: Sync committee slashings
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-21
REQUIRES: 

SUMMARY:
This EIP defines a slashing condition for malicious [sync committee messages](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/altair/validator.md#containers).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### State transition checks Note: This still allows having contradictions between attestations/proposals and sync committee messages. This also, by design, allows a validator to not participate at all in honest sync committee messages but solely participate in dishonest sync committee messages. | Name | Value | | - | - | | `BLOCK_STATE_ROOT_INDEX` | `get_generalized_index(BeaconBlock, 'state_root')` (= 11) | | `STATE_BLOCK_ROOTS_INDEX` | `get_generalized_index(BeaconState, 'block_roots')`

MOTIVATION:
A dishonest supermajority of sync committee members is able to convince applications relying on Ethereum's [light client sync protocol](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/altair/light-client/sync-protocol.md) to assume a non-canonical finalized header, and to potentially take over the sync authority for future `SyncCommitteePeriod`. By signing a malicious beacon block root, a malicious (but valid!) `LightClientUpdate` message can be formed and subsequently used to, for example, exploit a trust-minimized bridge contract based on the light client sync protocol. An additional type of slashing is introduced to deter against signing non-canonical beacon block roots as a sync committee member. As is the case with [`ProposerSlashing`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/phase0/beacon-chain.md#proposerslashing) and [`AttesterSlashing`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/phase0/beacon-chain.md#attesterslashing),

RATIONALE:
### What's the use case? Without a slashing, the light client sync protocol is somewhat limited. While wallet applications may benefit from it (the risk being, that incorrect data is displayed) and new beacon nodes may use it for accelerating chain synchronization, other interesting use cases such as bridges, token distributions or other systems requiring proofs depend on the mechanism providing higher security guarantees. By making attacks by sync committee members slashable, a sufficiently high deterrent could be provided. A majority of the sync committee would have to be bribed to succeed in an attack even in the


=== EIP-6110 ===
TITLE: Supply validator deposits on chain
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-12-09
REQUIRES: 7685

SUMMARY:
Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (or `eth1data`) voting from the Consensus Layer. Validator deposits list supplied in a block is obtained by parsing deposit contract log events emitted by each deposit transaction included in a given block.

SPECIFICATION:
### Execution Layer #### Constants | Name | Value | Comment | | - | - | - | |`DEPOSIT_REQUEST_TYPE` | `b'0'` | The [EIP-7685](./eip-7685.md) request type byte for deposit operation | #### Configuration | Name | Value | Comment | | - | - | - | |`DEPOSIT_CONTRACT_ADDRESS` | `0x00000000219ab540356cbb839cbe05303d7705fa` | Mainnet | |`DEPOSIT_EVENT_SIGNATURE_HASH` | `0x649bbc62d0e31342afea4e5cd82d4049e7e1ee912fc0889aa790803be39038c5` | | `DEPOSIT_CONTRACT_ADDRESS`, `DEPOSIT_EVENT_SIGNATURE_HASH` parameters **MUST** be included into client software binary distribution. #### Definitions * **`FORK_BLOCK`** -- the first block in a blockchain after this EIP has been activated. #### Deposit request The structure denoting the new deposit request consists

MOTIVATION:
Validator deposits are a core component of the proof-of-stake consensus mechanism. This EIP allows for an in-protocol mechanism of deposit processing on the Consensus Layer and eliminates the proposer voting mechanism utilized currently. This proposed mechanism relaxes safety assumptions and reduces complexity of client software design, contributing to the security of the deposits flow. It also improves validator UX. Advantages of in-protocol deposit processing consist of but are not limit to the following: * Significant increase of deposits security by supplanting proposer voting. With the proposed in-protocol mechanism, an honest online node can't be convinced to process fake

RATIONALE:
### `index` field Deposit `index` is used to deterministically initialize `deposit_requests_start_index` in the `BeaconState`, this prevents same deposit from being applied twice during `Eth1Data` poll deprecation. ### Not limiting the size of deposit operations list The list is unbounded because of negligible data complexity and absence of potential DoS vectors. See [Security Considerations](#security-considerations) for more details. ### Filtering events by `DEPOSIT_CONTRACT_ADDRESS` and `DEPOSIT_EVENT_SIGNATURE_HASH` Depending on the design, Deposit smart contract can emit different type of events when deposit is being processed. For instance, Deposit smart contract on Sepolia emits `Transfer` in addition to `DepositEvent`. Thus it is important


=== EIP-7997 ===
TITLE: Deterministic Factory Predeploy
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-03
REQUIRES: 2, 1, 1, ,,  , 1, 0, 1, 4

SUMMARY:
A minimal `CREATE2` factory is inserted as a system contract in the precompile range, to enable deterministic deployments at identical addresses across EVM chains. This benefits developer experience, user experience, and security, in particular for multi-chain and cross-chain applications, including account abstraction.

SPECIFICATION:
### Parameters * `FACTORY_ADDRESS` = `0x0B` ### Factory Contract Upon activation of this EIP, the account at `FACTORY_ADDRESS` becomes a contract that, when called, invokes the `CREATE2` instruction ([EIP-1014](./eip-1014.md)) with a salt equal to the first 32 bytes of the call's input data, init code equal to the remaining data, and value equal to the call's value. If input data is smaller than 32 bytes, the call reverts with empty return data. If creation fails (`CREATE2` outputs `0`), the call reverts with return data equal to that of the creation frame. Specifically, the code of `FACTORY_ADDRESS` is set

MOTIVATION:
There are now a large number of EVM chains where users want to transact and developers want to deploy applications, and we can expect this number to continue to grow in line with Ethereum's rollup-centric roadmap and the general adoption of programmable blockchains. Most applications support multiple chains and aspire to support as many as possible, and their developers widely prefer to deploy contracts at identical addresses across all chains, a setup which we will call *multi-chain deterministic deployment*. This kind of deployment reduces the number of addresses that must be distributed to use the application, so that

RATIONALE:
### Precompile-range system contract Unlike previous system contracts, this factory cannot be deployed using a normal transaction because, as explained in the Motivation section, that transaction could not be guaranteed to be valid on other chains. Since the purpose of this factory is to be available in all EVM chains that a contract could be deployed to, an irregular insertion of the code into a special address seems necessary. The address `0x0b` (`0x000000000000000000000000000000000000000b`) is chosen as the next lowest address after existing precompiles, on the assumption that other EVM chains would have reserved this range for future Ethereum


=== EIP-4881 ===
TITLE: Deposit Contract Snapshot Interface
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2021-01-29
REQUIRES: 

SUMMARY:
This EIP defines a standard format for transmitting the deposit contract Merkle tree in a compressed form during weak subjectivity sync. This allows newly syncing consensus clients to reconstruct the deposit tree much faster than downloading all historical deposits. The format proposed also allows clients to prune deposits that are no longer needed to participate fully in consensus (see [Deposit Finalization Flow](#deposit-finalization-flow)).

SPECIFICATION:
Consensus clients MAY continue to implement the deposit Merkle tree however they choose. However, when transmitting the tree to newly syncing nodes, clients MUST use the following format: ```python class DepositTreeSnapshot: finalized: List[Hash32, DEPOSIT_CONTRACT_DEPTH] deposit_root: Hash32 deposit_count: uint64 execution_block_hash: Hash32 execution_block_height: uint64 ``` Where `finalized` is a variable-length list (of maximum size `DEPOSIT_CONTRACT_DEPTH`) containing the hashes defined in the [Deposit Finalization Flow](#deposit-finalization-flow) section below. The fields `deposit_root`, `deposit_count`, and `execution_block_hash` store the same information as the [`Eth1Data`](https://github.com/ethereum/consensus-specs/blob/2b45496fe48fa75450ad29a05bdd48866f86528a/specs/phase0/beacon-chain.md#eth1data) object that corresponds to the snapshot, and `execution_block_height` is the height of the execution block with hash `execution_block_hash`. Consensus clients MUST

MOTIVATION:
To reconstruct the deposit Merkle tree, most client implementations require beacon nodes to download and store every deposit log since the launch of the deposit contract. However, this approach requires beacon nodes to store far more deposits than necessary to participate in consensus. Additionally, this leads to increased sync times for new nodes, which is particularly evident during weak subjectivity sync. This simplistic approach also prevents historical contract logs from being pruned from full nodes, a prospect frequently discussed in the context of limiting state growth.

RATIONALE:
The format in this specification was chosen to achieve several goals simultaneously: 1. Enable reconstruction of the deposit contract Merkle tree without requiring full nodes to store all historical contract logs 2. Avoid requiring consensus nodes to retain more deposits than necessary to fully participate in consensus 3. Simplicity of implementation (see [Reference Implementation](#reference-implementation) section) 4. Increase speed of weak subjectivity sync 5. Compatibility with existing implementations of this mechanism (see discussion) The proposed `DepositTreeSnapshot` structure includes both `execution_block_hash` and `execution_block_height` for convenience to consensus node implementors. While only one of these fields is strictly necessary, different clients


=== EIP-7643 ===
TITLE: History accumulator for pre-PoS data
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-02-29
REQUIRES: 

SUMMARY:
Defines an SSZ object for accumulating all pre-PoS data and commit to the historical hashes accumulator's root `0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701`.

SPECIFICATION:
### Historical Hashes Accumulator The historical hashes accumulator commits to the set of pre-merge headers and their associated total difficulty. The format for this data is defined as: ```python EPOCH_SIZE = 8192 # blocks MAX_HISTORICAL_EPOCHS = 2048 # An individual record for a historical header. HeaderRecord = Container[block_hash: bytes32, total_difficulty: uint256] # The records of the headers from within a single epoch EpochRecord = List[HeaderRecord, max_length=EPOCH_SIZE] HistoricalHashesAccumulator = Container[ historical_epochs: List[bytes32, max_length=MAX_HISTORICAL_EPOCHS], current_epoch: EpochRecord, ] ``` ### Pre-PoS Root The hash tree root of `HistoricalHashesAccumulator` for data before block 15537394 is `0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701`.

MOTIVATION:
There are two main uses we consider for the historical hashes accumulator: * for users who wish to download the pre-PoS data for the execution chain and verify it without executing each block, they may simply compute each block hash, accumulate the epoch records, and then compare the local accumulator root with the expected value. * additionally, the accumulator root allows for `O(log(n))` sized proofs to any pre-PoS block, whereas today to achieve something similar, one must recursively verify the header chain.

RATIONALE:
### Inclusion of total difficulty The total difficulty allowed so that clients may return the value for specific JSON-RPC methods which support it. It is also useful for verifying the TTD of the final proof-of-work block.


=== EIP-608 ===
TITLE: Hardfork Meta: Tangerine Whistle
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 5, 0, ,,  , 7, 7, 9

SUMMARY:
This specifies the changes included in the hard fork named Tangerine Whistle (EIP 150).

SPECIFICATION:
- Codename: Tangerine Whistle - Aliases: EIP 150, Anti-DoS - Activation: - Block >= 2,463,000 on Mainnet - Included EIPs: - [EIP-150](./eip-150.md) (Gas cost changes for IO-heavy operations)


=== EIP-1352 ===
TITLE: Specify restricted address range for precompiles/system contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-27
REQUIRES: 

SUMMARY:
The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts.

SPECIFICATION:
The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts. Due to the extremely low probability (and lack of adequate testing possibilities) no explicit checks should be added to ensure that external transaction signing or the invoking of the `CREATE` instruction can result in a precompile address.

MOTIVATION:
This will simplify certain future features where unless this is implemented, several exceptions must be specified.

RATIONALE:
N/A


=== EIP-7917 ===
TITLE: Deterministic proposer lookahead
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-03-24
REQUIRES: 

SUMMARY:
At the start of each epoch, pre-calculate and store in the `beacon_state` a deterministic `proposer_lookahead` for the next `MIN_SEED_LOOKAHEAD + 1` epochs.

SPECIFICATION:
The `BeaconState` container is extended with a `proposer_lookahead` field, which is a vector of validator indices covering the full visible lookahead period, starting from the beginning of the current epoch to the next `MIN_SEED_LOOKAHEAD` epochs. ```python class BeaconState: ... proposer_lookahead: Vector[ValidatorIndex, (MIN_SEED_LOOKAHEAD + 1) * SLOTS_PER_EPOCH] ``` For example, `proposer_lookahead[0]` is the validator index for the first proposer in the current epoch, `proposer_lookahead[SLOTS_PER_EPOCH + 4]` is the validator index for the fifth proposer in the next epoch, and so forth. The function `get_beacon_proposer_index` is modified to use the pre-calculated `proposer_lookahead` instead of calculating proposer indices on-demand. ```python def

MOTIVATION:
Unlike RANDAO seeds, which have a deterministic lookahead of at least `MIN_SEED_LOOKAHEAD == 1` epochs, the beacon proposer schedule of epoch `N + 1` is not fully predictable from the beacon state during epoch `N`. The reason is that, under certain edge cases, the effective balances (EBs) of active validators—themselves used as input for proposer election in epoch `N + 1`—can change within epoch `N`. Based preconfirmation protocols rely on a deterministic proposer schedule for smooth operations. Since the beacon genesis, slashings and penalties that accumulate to at least 1 ETH can change EBs of active validators and

RATIONALE:
### Considered Alternatives An alternative approach would be to cache the effective balances at the start of epoch `N` so it can be used to calculate the proposer lookahead at the start of epoch `N+MIN_SEED_LOOKAHEAD`. However, this approach would require additional footprint in the beacon state, and would not be able to provide the proposer lookahead to the EVM via the beacon root. ### Single Secret Leader Election Compatibility In the future, we may introduce a Single Secret Leader Election (SSLE) mechanism in which only the selected validator knows their role until they propose a block. However, current


=== EIP-7898 ===
TITLE: Uncouple execution payload from beacon block
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-01
REQUIRES: 

SUMMARY:
Currently, the beacon block in Ethereum Consensus embeds transactions within the `ExecutionPayload` field of `BeaconBlockBody`. This EIP proposes to replace `ExecutionPayload` with `ExecutionPayloadHeader` in `BeaconBlockBody` and to independently transmit `ExecutionPayloadWithInclusionProof`. However, this EIP makes no change to the block import mechanism, with the exception that block availability now includes waiting for the availability of `ExecutionPayloadWithInclusionProof`, making it different and simpler from proposals like ePBS/APS. But this availability requirement can in fact be restricted to `gossip` import while allowing optimistic syncing of the execution layer (EL) on checkpoint/range sync as EL can pull full blocks from their peers in

SPECIFICATION:
- `ExecutionPayload` in the `BeaconBlockBody` is replaced by `ExecutionPayloadHeader` - `ExecutionPayloadWithInclusionProof` is computed by the block proposer/builder and gossiped independently on a separate new topic. Also builder `submitBlindedBlock` api is modified to respond with `ExecutionPayloadWithInclusionProof` instead. - Data availability checks for block import into forkchoice now must wait for availability of the corresponding `ExecutionPayloadWithInclusionProof` but only for gossiped blocks - `newPayloadHeader` engine api is introduced to augment the previous usage of `newPayload` in block processing when `ExecutionPayload` is not available for e.g. in processing range synced blocks signaling EL clients to optimistic sync those payloads from EL p2p

MOTIVATION:
The Ethereum protocol has an ambitious goal to grow the `gasLimit` of the execution payloads (possibly by 10X). This leads to larger messages, negatively affecting the networking and block processing pipelines of the consensus layer (CL) clients leading to following issues: 1. Higher latencies for the arrival of beacon blocks increase, requiring larger bandwidth resources to be made available for the beacon node. 2. The greater number and size of transactions directly increase the merkelization compute time, increasing the import time of the block. We know from timing games that the block import latency greatly affects a client's

RATIONALE:
There is another choice we could have made to go for `SignedExecutionPayload` instead of `ExecutionPayloadWithInclusionProof` and having a `SignedExecutionPayloadHeader` with builder signing these messages (validator is the builder in local block building). But without builder enshrinement tight gossip validation of `SignedExecutionPayload` would be an issue and could become a DOS vector. The benefit of `SignedExecutionPayload` design is that it could be transmitted ahead of even the `SignedExecutionPayloadHeader` inclusion in beacon block and is especially useful in PBS pipeline where the proposal to builder/relay latency can be reduced significantly.


=== EIP-7880 ===
TITLE: EOF - EXTCODEADDRESS instruction
TYPE: Standards Track Core
STATUS: Review
CREATED: 2025-02-08
REQUIRES: 7, 6, 9, 2, ,,  , 7, 7, 0, 2, ,,  , 7, 7, 6, 1

SUMMARY:
Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.

SPECIFICATION:
### Parameters | Constant | Value | |---------------------------|--------------------------------------------------------------------| | `GAS_COLD_ACCOUNT_ACCESS` | Defined as `2600` in the [Ethereum Execution Layer Spec Constants] | | `GAS_WARM_ACCESS` | Defined as `100` in the [Ethereum Execution Layer Spec Constants] | We introduce a new EOFv1 instruction `EXTCODEADDRESS` (`0xea`). EOF code which contains this instruction prior to the fork activating this instruction is considered invalid. Beginning with the first block this EIP is activated in, this instruction is added to the set of valid EOFv1 instructions. ### Execution Semantics #### `EXTCODEADDRESS` - Deduct `GAS_WARM_ACCESS` gas - pop 1 argument `target_address` from the stack

MOTIVATION:
EOFv1 as scoped in [EIP-7692] removes code introspection capabilities from the EVM, preventing EOF from reading raw code values such as code delegation designations set by [EIP-7702]. There are a number of use cases where reading the delegation designation of [EIP-7702] would allow contracts to be more proactive about user experience issues. One example is a managed proxy contract. Such a contract may want to ensure security by not allowing the proxy to be updated to a delegated address. There are also safety concerns with pointing to a delegation, as the contract may be updated to non EOF

RATIONALE:
This EIP is very similar to [EIP-7761], which introduces account type introspection. Its rationale is included by reference as they all apply to this situation. ### Alternative: Return the whole designation, have contract parse One alternative is to have a specially limited `EXTCODECOPY` that would return just delegation designations. Apart from the general objections to code introspection this would then lock in and limit delegation designation formats and capabilities that must be preserved in future forks. By allowing access to the effect of the delegation rather than the mechanism, EOF preserves space for the mechanism to be changed


=== EIP-7848 ===
TITLE: On-chain upgrade signaling
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-22
REQUIRES: 

SUMMARY:
This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a “reference implementation hash” field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.

SPECIFICATION:
Ethereum consensus clients shall identify with a reference implementation having its equivalent behaviors. Ethereum consensus clients shall include a `referenceImplementationHash` (specified below) field immediately following the `extraData` field in the block header. Proposed new Ethereum consensus clients shall initially behave as the then-current network does. If, and only if, a successful upgrade (defined below) is activated will the new behavior take effect. When a network participant is willing to support a network upgrade, they shall immediately begin using the new software. The blocks they create including the new `referenceImplementationHash` will contribute to the network upgrade activation. ### The

MOTIVATION:
Currently, upgrades to Ethereum Mainnet are announced on the ethereum.org blog. This proposal changes that process by activating upgrades based on the consent of network participants.

RATIONALE:
### Forking is no Longer Possible Since the merge, forking Ethereum Mainnet has become practically impossible. Validators stake valuable assets to participate in the network, so any rational validator will choose to upgrade only if they expect widespread adoption. If a validator expects 95% or more participants to upgrade, they should upgrade; if they expect only 5% or less, they should not. For intermediate cases, there is a threshold where a validator would rationally shut down (incurring a small penalty) rather than risk participating in the wrong network—which could result in slashing 100% of their staked ether (currently


=== EIP-4444 ===
TITLE: Bound Historical Data in Execution Clients
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2021-11-02
REQUIRES: 

SUMMARY:
Clients must stop serving historical headers, bodies, and receipts older than one year on the p2p layer. Clients may locally prune this historical data.

SPECIFICATION:
| Parameter | Value | Description | | - | - | - | | `HISTORY_PRUNE_EPOCHS` | 82125 | A year in beacon chain epochs | Clients SHOULD NOT serve headers, block bodies, and receipts that are older than `HISTORY_PRUNE_EPOCHS` epochs on the p2p network. Clients MAY locally prune headers, block bodies, and receipts that are older than `HISTORY_PRUNE_EPOCHS` epochs. #### Bootstrapping and syncing This EIP impacts the way clients bootstrap and sync. Clients will not be able to full sync using devp2p since historical data will no longer be served. Clients MUST use a valid Weak Subjectivity

MOTIVATION:
Historical blocks and receipts currently occupy more than 400GB of disk space (and growing!). Therefore, to validate the chain, users must typically have a 1TB disk. Historical data is not necessary for validating new blocks, so once a client has synced the tip of the chain, historical data is only retrieved when requested explicitly over the JSON-RPC or when a peer attempts to sync the chain. By pruning the history, this proposal reduces the disk requirements for users. Pruning history also allows clients to remove code that processes historical blocks. This means that execution clients don't need to

RATIONALE:
This proposal forces clients to stop serving old historical data over p2p. We make this explicit to force clients to seek historical data from other sources, instead of relying on the optional behavior of some clients which would result in quality degradation. ### Why a year? This proposal sets `HISTORY_PRUNE_EPOCHS` to 82125 epochs (one earth year). This constant is large enough to provide sufficient room for the Weak Subjectivity Period to grow, and it's also small enough so as to not occupy too much disk space.


=== EIP-7736 ===
TITLE: Leaf-level state expiry in verkle trees
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-07-05
REQUIRES: 6800

SUMMARY:
Adds an "update epoch" to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted. A new transaction type with a simple verkle proof pays for the costs of reactivating the extension and suffix nodes, and updating the epoch counter.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants |Name|Description|Value| |----|-----------|-----| |`FORK_TIME`|Fork activation time|TBD| |`EPOCH_LENGTH`|Duration of an epoch, in s|15778800 (6 months)| |`INITIAL_EPOCH_COUNTER`|The epoch that ends at timestamp `FORK_TIME`|0| |`NUM_ACTIVE_EPOCHS`|Number of concurrently unexpired epochs|2| |`RESURRECT_TX_TYPE`|Type ID for resurrection transactions|TBD| ### Change to the verkle tree Add an integral variable called `current_epoch`. It is initialized to `INITIAL_EPOCH_COUNTER` before the fork, and contains the current epoch number. Add a new `last_epoch` field to

MOTIVATION:
Previous attempts at implementing state expiry have been stalled by the quickly-increasing complexity, require heavy change in the structure of ethereum (address space extension, oil, multiple trees, ...). This proposal is offering a simpler albeit non-exhaustive approach to state expiry: only removing the leaf nodes and leaving the rest of the tree intact. This removes the need for methods that would be detrimental to the user and developer experience.

RATIONALE:
This approach has the benefit of simplicity, over previous proposals for state expiry: * no Address Space Extension (ASE) required * it only uses a single tree instead of multiple, per-epoch trees * smaller resurrection proofs, as only providing the data is necessary to resurrect. * clear gas costs * only expire "cold" data, the "hot" data set remains active * it is forward-compatible, as ASE or multiple trees are still possible. * the exponentiation/addition computation for `current_epoch` need only be paid once per epoch, which is quickly amortized. While it's not deleting _all_ the data, it deletes


=== EIP-7692 ===
TITLE: EVM Object Format (EOFv1) Meta
TYPE: Meta 
STATUS: Review
CREATED: 2024-04-17
REQUIRES: 6, 6, 3, ,,  , 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 4, 7, 5, 0, ,,  , 5, 4, 5, 0, ,,  , 6, 2, 0, 6, ,,  , 7, 0, 6, 9, ,,  , 7, 4, 8, 0, ,,  , 7, 6, 2, 0, ,,  , 7, 6, 9, 8

SUMMARY:
This Meta EIP lists the EIPs which belong to the EVM Object Format (EOF) proposal, in its first version (EOFv1), also known as the "Mega EOF".

SPECIFICATION:
### EIPs Included Introduced in eof-devnet-0 - [EIP-3540](./eip-3540.md): EOF - EVM Object Format v1 - [EIP-3670](./eip-3670.md): EOF - Code Validation - [EIP-4200](./eip-4200.md): EOF - Static relative jumps - [EIP-4750](./eip-4750.md): EOF - Functions - [EIP-5450](./eip-5450.md): EOF - Stack Validation - [EIP-6206](./eip-6206.md): EOF - JUMPF and non-returning functions - [EIP-7480](./eip-7480.md): EOF - Data section access instructions - [EIP-663](./eip-663.md): SWAPN, DUPN and EXCHANGE instructions - [EIP-7069](./eip-7069.md): Revamped CALL instructions - [EIP-7620](./eip-7620.md): EOF Contract Creation - [EIP-7698](./eip-7698.md): EOF - Creation transaction Introduced in eof-devnet-1 - [EIP-7873](./eip-7873.md): EOF - TXCREATE and InitcodeTransaction type Removed from eof-devnet-1 - [EIP-7698](./eip-7698.md): EOF - Creation transaction Introduced

RATIONALE:
Refer to the individual EIPs.


=== EIP-7594 ===
TITLE: PeerDAS - Peer Data Availability Sampling
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-01-12
REQUIRES: 4844

SUMMARY:
PeerDAS (Peer Data Availability Sampling) is a networking protocol that allows nodes to perform data availability sampling (DAS) to ensure that blob data has been made available while downloading only a subset of the data. PeerDAS utilizes gossip for distribution, discovery for finding peers of particular data custody, and peer requests for sampling.

SPECIFICATION:
We extend the blobs introduced in EIP-4844 using a one-dimensional erasure coding extension. Each row consists of the blob data combined with its erasure code. It is subdivided into cells, which are the smallest units that can be authenticated with their respective blob's KZG commitments. Each column, associated with a specific gossip subnet, consists of the cells from all rows for a specific index. Each node is responsible for maintaining a deterministic set of column subnets and custodying their data as a function of their node ID. Nodes find and maintain a diverse peer set and sample columns

MOTIVATION:
DAS is a method of scaling data availability beyond the levels of [EIP-4844](./eip-4844.md) by not requiring all nodes to download all data while still ensuring that all of the data has been made available. Providing additional data availability helps bring scale to Ethereum users in the context of layer 2 systems called "roll-ups" whose dominant bottleneck is layer 1 data availability.

RATIONALE:
### Why use DAS to scale the DA layer? PeerDAS is a DAS scheme that requires nodes to only download a small constant fraction of the data to satisfy a local availability check. With the current parameters, this is 1/8 of the total data (i.e. blobs in a block), which can in the future be decreased to 1/16 or even 1/32 by reducing the size of samples (increasing the number of columns). In this way, PeerDAS allows for securely scaling the blob throughput of the network without compromising decentralization, i.e., without increasing node's bandwidth and storage requirements. ###


=== EIP-7523 ===
TITLE: Empty accounts deprecation
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2023-09-19
REQUIRES: 161

SUMMARY:
This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. An empty account is an account with has **no code** and **zero nonce** and **zero balance**. This is the same as the definition in [EIP-161](./eip-161.md). On networks that undergo the merge transition, the pre state of the merge block may not contain any empty accounts. For networks that are merged at genesis, none of the genesis accounts may be empty accounts. Rather than performing

MOTIVATION:
The possibility of empty accounts is a historical artifact of the early history of Ethereum. The only networks that have ever been capable of containing them are Ethereum Mainnet, the deprecated testnet Ropsten, Etheruem Classic Mainnet and various Ethereum Classic testnets. All remaining empty accounts on Mainnet were cleared in block `14049881` (transaction `0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d`) and a similar transaction was sent on Ethereum Classic. None of the other myriad EVM-compatible networks are old enough to have empty accounts and there is no realistic prospect that anyone will encounter an empty account in a production context. Despite empty accounts no

RATIONALE:
This EIP was drafted to be the simplest possible way of eliminating the long term technical debt imposed by empty accounts. The Merge was chosen as a natural easily identifiable cutoff point. Alternative approaches include: - Using an earlier cutoff point, such as block `14049881`. - Identifying a wider range of edge case behaviour that never happened. These approaches were rejected as being unnecessarily complicated.


=== EIP-1380 ===
TITLE: Reduced gas cost for call to self
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-31
REQUIRES: 150

SUMMARY:
Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then decrease the cost of `CALL`, `DELEGATECALL`, `CALLCODE` and `STATICCALL` from 700 to 40, if and only if, the destination address of the call equals to the address of the caller.

MOTIVATION:
The current gas cost of 700 for all call types (`CALL`, `DELEGATECALL`, `CALLCODE` and `STATICCALL`) does not take into account that a call to a contract itself does not need to perform additional I/O operations, because the current contract code has already been loaded into memory. Reducing the call-to-self gas cost would greatly benefit smart contract languages, such as Solidity and Vyper, who would then be able to utilise `CALL` instead of `JUMP` opcodes for internal function calls. While languages can already utilise `CALL` for internal function calls, they are discouraged to do so due to the gas

RATIONALE:
EIP150 has increased the cost of these instructions from 40 to 700 to more fairly charge for loading new contracts from disk, e.g. to reflect the I/O charge more closely. By assuming that 660 is the cost of loading a contract from disk, one can assume that the original 40 gas is a fair cost of creating a new VM instance of an already loaded contract code.


=== EIP-4844 ===
TITLE: Shard Blob Transactions
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-02-25
REQUIRES: 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 9, 5

SUMMARY:
Introduce a new transaction format for "blob-carrying transactions" which contain a large amount of data that cannot be accessed by EVM execution, but whose commitment can be accessed. The format is intended to be fully compatible with the format that will be used in full sharding.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `BLOB_TX_TYPE` | `Bytes1(0x03)` | | `BYTES_PER_FIELD_ELEMENT` | `32` | | `FIELD_ELEMENTS_PER_BLOB` | `4096` | | `BLS_MODULUS` | `52435875175126190479447740508185965837690552500527637822603658699938581184513` | | `VERSIONED_HASH_VERSION_KZG` | `Bytes1(0x01)` | | `POINT_EVALUATION_PRECOMPILE_ADDRESS` | `Bytes20(0x0A)` | | `POINT_EVALUATION_PRECOMPILE_GAS` | `50000` | | `MAX_BLOB_GAS_PER_BLOCK` | `786432` | | `TARGET_BLOB_GAS_PER_BLOCK` | `393216` | | `MIN_BASE_FEE_PER_BLOB_GAS` | `1` | | `BLOB_BASE_FEE_UPDATE_FRACTION` | `3338477` | | `GAS_PER_BLOB` | `2**17` | | `HASH_OPCODE_BYTE` | `Bytes1(0x49)` | | `HASH_OPCODE_GAS` | `3` | | [`MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS`](https://github.com/ethereum/consensus-specs/blob/4de1d156c78b555421b72d6067c73b614ab55584/configs/mainnet.yaml#L148) | `4096` | ### Type aliases | Type | Base type | Additional checks

MOTIVATION:
Rollups are in the short and medium term, and possibly in the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups are significantly reducing fees for many Ethereum users: Optimism and Arbitrum frequently provide fees that are ~3-8x lower than the Ethereum base layer itself, and ZK rollups, which have better data compression and can avoid including signatures, have fees ~40-100x lower than the base layer. However, even these fees

RATIONALE:
### On the path to sharding This EIP introduces blob transactions in the same format in which they are expected to exist in the final sharding specification. This provides a temporary but significant scaling relief for rollups by allowing them to initially scale to 0.375 MB per slot, with a separate fee market allowing fees to be very low while usage of this system is limited. The core goal of rollup scaling stopgaps is to provide temporary scaling relief, without imposing extra development burdens on rollups to take advantage of this relief. Today, rollups use calldata. In the


=== EIP-1474 ===
TITLE: Remote procedure call specification
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-10-02
REQUIRES: 

SUMMARY:
Nodes created by the current generation of Ethereum clients expose inconsistent and incompatible remote procedure call (RPC) methods because no formal Ethereum RPC specification exists. This proposal standardizes such a specification to provide developers with a predictable Ethereum RPC interface regardless of underlying node implementation.

SPECIFICATION:
### Concepts #### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). #### JSON-RPC Communication with Ethereum nodes is accomplished using [JSON-RPC](https://www.jsonrpc.org/specification), a stateless, lightweight [remote procedure call](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol that uses [JSON](http://www.json.org/) as its data format. Ethereum RPC methods **MUST** be called using [JSON-RPC request objects](https://www.jsonrpc.org/specification#request_object) and **MUST** respond with [JSON-RPC response objects](https://www.jsonrpc.org/specification#response_object). #### Error codes If an Ethereum RPC method encounters an error, the `error` member included on the response object **MUST** be an object containing a

RATIONALE:
Much of Ethereum's effectiveness as an enterprise-grade application platform depends on its ability to provide a reliable and predictable developer experience. Nodes created by the current generation of Ethereum clients expose RPC endpoints with differing method signatures; this forces applications to work around method inconsistencies to maintain compatibility with various Ethereum RPC implementations. Both Ethereum client developers and downstream dapp developers lack a formal Ethereum RPC specification. This proposal standardizes such a specification in a way that's versionable and modifiable through the traditional EIP process.


=== EIP-7667 ===
TITLE: Raise gas costs of hash functions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Raise the gas costs of opcodes and precompiles that involve hash functions.

SPECIFICATION:
| Parameter | Previous value | New value | | - | - | - | | `KECCAK_BASE_COST` | 30 | 300 | | `KECCAK_WORD_COST` | 6 | 60 | | `SHA256_BASE_COST` | 60 | 300 | | `SHA256_WORD_COST` | 12 | 60 | | `RIPEMD_BASE_COST` | 600 | 600 | | `RIPEMD_WORD_COST` | 120 | 120 | | `BLAKE2_GFROUND` | 1 | 10 | | `GLOGBYTE` | 8 | 10 | Change the above parameters to their new values.

MOTIVATION:
Gas costs for hash function opcodes and precompiles were originally set based on the time that it takes to execute them on a regular CPU. Since then, however, there has emerged another equally important execution substrate that the EVM is executed on: zero knowledge proof (ZK-SNARK) systems. By that standard, these opcodes and precompiles are _very_ underpriced relative to other operations. Blocks that are heavy with hash function executions take much longer to ZK-SNARK prove than average blocks. Today, many layer-2 protocols are using workarounds such as arbitrary limits and rules enforced by centralized sequencers to deal with

RATIONALE:
The above increases the gas costs of all opcodes and precompiles that can be used to require large amounts of hashing in the EVM. All hashing costs are increased to 300 per hash plus 60 per word (or kept the same if they are already higher than this). '" A possible alternative to this approach is to implement either multidimensional gas pricing (ie. a separate floating basefee and per-block target and limit for hashes) or a "total gas cost floor" similar to what [EIP-7623](eip-7623.md) does for calldata. However, this approach is much harder to implement for in-EVM gas


=== EIP-7782 ===
TITLE: Reduce Block Latency
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-05
REQUIRES: 7, 6, 2, 3, ,,  , 7, 7, 7, 8

SUMMARY:
Reduce Ethereum's slot time from 12 s to 6 s, halving on‑chain latency and epoch duration. This doubles slot throughput while keeping block and blob sizes unchanged, smoothing bandwidth usage. The change delivers better user experience, faster Layer 2 interaction, tighter DEX pricing, reduced MEV, and quicker finality.

SPECIFICATION:
On the consensus layer, a new parameter is added to the configuration: ``` SLOT_SCHEDULE: - EPOCH: 348618 SECONDS_PER_SLOT: 12 - EPOCH: 355368 SECONDS_PER_SLOT: 6 ``` The parameters and schedules above are purely illustrative. Actual values and schedules are beyond the scope of this specification. ### Adjustment to gas and blob limits The first execution block after the fork needs to specify half the previous gas limit. With this fork, all gas limit settings are reinterpreted as "gas per 12 seconds". I.e., if the user configuration or otherwise default gas limit vote was 36,000,000, the client should now vote

MOTIVATION:
- **Protocol Carrying Capacity** It is impractical to increase block sizes beyond 10MiB without substantial networking changes. However it is practical to decrease slot time to achieve similar effect while also improving the UX at same time. - **Enhanced UX**: Confirmations now arrive in ~6 s instead of 12 s. - **Faster Finality**: Epochs shrink from 384 s (32 × 12 s) to 192 s (32 × 6 s), accelerating Casper‑FFG finality. - **L2 Interoperability**: Layer 2 rollups see half the settlement delay on L1, improving throughput and reducing reorg risk period. - **Based rollups**: Based rollup sequencing

RATIONALE:
This proposal balances user experience, economic efficiency, and network stability: - UX & Finality: Halving slot time directly reduces confirmation latency and halves epoch duration, delivering faster feedback to users and speeding up Casper-FFG finality. - Economic Efficiency: Increased block frequency tightens DEX price spreads, lowers slippage, and diminishes arbitrage and MEV opportunities, improving on-chain trading conditions. - L2 & Based Rollups Synergy: Layer 2 rollups, especially based rollups, benefit from reduced L1 settlement delays, enhancing throughput and user-perceived performance in rollup ecosystems. - Network Stability: Maintaining existing p2p network maximum smooths bandwidth usage over time, avoiding peak-load


=== EIP-7045 ===
TITLE: Increase max attestation inclusion slot
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-18
REQUIRES: 

SUMMARY:
Increases max attestation inclusion slot from `attestation.slot + SLOTS_PER_EPOCH` to the last slot of epoch `N+1` where `N` is the epoch containing the attestation slot. This increase is critical to the current LMD-GHOST security analysis as well as the confirmation rule.

SPECIFICATION:
### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | `1710338135` | Mainnet | ### Execution layer This requires no changes to the Execution Layer. ### Consensus layer Specification changes are built into the Consensus Specs Deneb upgrade. The specification makes two minor changes to the state transition function: * Modify [`process_attestation`](https://github.com/ethereum/consensus-specs/blob/95f36d99cf4aa59974da06af24ef9a7c12d3c301/specs/deneb/beacon-chain.md#modified-process_attestation) to not have an upper bound on the slot check and instead define the inclusion range via the minimum slot as well as the target epoch being in either current or previous epoch. * Modify [`get_attestation_participation_flag_indices`](https://github.com/ethereum/consensus-specs/blob/95f36d99cf4aa59974da06af24ef9a7c12d3c301/specs/deneb/beacon-chain.md#modified-get_attestation_participation_flag_indices) to set

MOTIVATION:
Attestations can currently be included after some minimum delay (`1` slot on mainnet) up until `SLOTS_PER_EPOCH` slots after the slot the attestation was created in. This rolling window of one epoch was decided upon during Phase 0 because the equal inclusion window for any attestation was assessed as "fair". The alternative considered path was to allow inclusion during the current and next epoch which means attestations created during the start of an epoch have more potential slots of inclusion than those at the end of the epoch. Since this decision, it has become apparent that the alternative design

RATIONALE:
### Extended max inclusion slot As discussed in the Motivation, extending this max inclusion slot to the end of the next epoch is critical for LMD-GHOST security proofs and confirmation rule. ### Removal of `inclusion_delay` consideration for target reward Previously, `get_attestation_participation_flag_indices` would only set the `TIMELY_TARGET_FLAG` (and thus reward for an attestation with correct target vote) if the attestation was included within a `SLOTS_PER_EPOCH` window. The `inclusion_delay` consideration for this flag is removed to ensure that whatever the valid inclusion window is for an attestation, it can receive a baseline non-zero reward for correct target. This ensures that


=== EIP-2070 ===
TITLE: Hardfork Meta: Berlin
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2019-05-20
REQUIRES: 1679

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Berlin.

SPECIFICATION:
- Codename: Berlin In the current stage of coordination, the changes are tracked and discussed in the [eth1.0-specs](https://github.com/ethereum/eth1.0-specs) repository. For an accurate status please refer to the [`berlin.md`](https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/berlin.md) file.


=== EIP-7607 ===
TITLE: Hardfork Meta - Fusaka
TYPE: Meta 
STATUS: Review
CREATED: 2024-02-01
REQUIRES: 7600

SUMMARY:
This Meta EIP lists the EIPs formally Scheduled for Inclusion in the Fulu/Osaka network upgrade.

SPECIFICATION:
Definitions for `Scheduled for Inclusion`, `Considered for Inclusion`, `Proposed for Inclusion` and `Declined for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion #### Core EIPs * [EIP-7594](./eip-7594.md): PeerDAS - Peer Data Availability Sampling * [EIP-7823](./eip-7823.md): Set upper bounds for MODEXP * [EIP-7825](./eip-7825.md): Transaction Gas Limit Cap * [EIP-7883](./eip-7883.md): ModExp Gas Cost Increase * [EIP-7917](./eip-7917.md): Deterministic proposer lookahead * [EIP-7918](./eip-7918.md): Blob base fee bounded by execution cost * [EIP-7934](./eip-7934.md): RLP Execution Block Size Limit * [EIP-7939](./eip-7939.md): Count leading zeros (CLZ) opcode * [EIP-7951](./eip-7951.md): Precompile for secp256r1 Curve Support #### Other EIPs * [EIP-7892](./eip-7892.md): Blob Parameter Only

RATIONALE:
This Meta EIP provides a global view of all changes included in the Fusaka network upgrade, as well as links to full specification.


=== EIP-2786 ===
TITLE: Ethereum Provider Connect/Disconnect Events
TYPE: Standards Track Interface
STATUS: Withdrawn
CREATED: 2020-07-15
REQUIRES: 2700

SUMMARY:
The Provider is said to be “connected” when it can service RPC requests to at least one chain. The Provider is said to be “disconnected” when it cannot service RPC requests to any chain at all. When the Provider switches from a "connected" state to a "disconnected" state, it will emit a `connect` event. When the Provider switches from a "disconnected" state to a "connected" state, it will emit a `disconnect` event.

SPECIFICATION:
### Definitions #### Connected The Provider is considered `connected` when it is able to service RPC requests to at least one chain. #### Disconnected The Provider is considered `disconnected` when it is unable to service RPC requests to any chain. ### Events #### `connect` The Provider **MUST** emit a `connect` event to all attached [EIP-2700](./eip-2700.md) listeners if it transitions from a `disconnected` state to a `connected` state. All attached listeners **MUST** be called with the parameter `{ chainId }`. `chainId` **MUST** specify the integer ID of the connected chain encoded as a hexadecimal string. If the Provider supports

MOTIVATION:
When an application is hooked up to an Ethereum provider, there is value in having the application be alerted of connect/disconnect events that may occur so the application can appropriately inform the user of the situation. It is left up to the application to decide whether to listen in on these events, and how to handle them.

RATIONALE:
This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn’t a lot of room for improving things such as by having a connect/disconnect event per chain.


=== EIP-4736 ===
TITLE: Consensus Layer Withdrawal Protection
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-01-30
REQUIRES: 

SUMMARY:
If a consensus layer mnemonic phrase is compromised, it is impossible for the consensus layer network to differentiate the legitimate holder of the key from an illegitimate holder. However, there are signals that can be considered in a wider sense without changing core Ethereum consensus. This proposal outlines ways in which on chain evidence such as the execution layer deposit address and list of signed messages could create a social consensus that would significantly favor but not guarantee legitimate mnemonic holders would win a race condition against an attacker.

SPECIFICATION:
The Consensus Layer `BLSToExecutionChange` operation has the following fields: * Validator index * Current withdrawal BLS public key * Proposed execution layer withdrawal address * Signature by withdrawal private key over the prior fields This proposal describes OPTIONAL and RECOMMENDED mechanisms which a client beacon node MAY implement, and end users are RECOMMENDED to use in their beacon node operation. ### `BLSToExecutionChange` Broadcast File Beacon node clients MAY support an OPTIONAL file of lines specifying "validator index" , "current withdrawal BLS public key" , "proposed execution layer withdrawal address", and "signature" which, if implemented and if provided, SHALL

MOTIVATION:
The consensus layer `BLSToExecutionChange` message is secure for a single user who has certainty their keys and mnemonic have not been compromised. However, as validator withdrawals on the consensus layer are not possible until the Capella hard fork, no user can have absolute certainty that their keys are not compromised until the `BLSToExecutionChange` is on chain, and by then too late to change. All legitimate mnemonic phrase holders were originally in control of the execution layer deposit address. Beacon node clients and node operators may optionally load a list of verifiable `BLSToExecutionChange` messages to broadcasts that may create

RATIONALE:
This proposal is intended to protect legitimate validator mnemonic holders where it was knowingly or unknowingly compromised. As there is no safe way to transfer ownership of a validator without exiting, it can safely be assumed that all validator holders intend to set to a withdrawal address they specify. Using the deposit address in the execution layer to determine the legitimate holder is not possible to consider in consensus as it may be far back in history and place an overwhelming burden to maintain such a list. As such, this proposal outlines optional mechanism which protect legitimate original


=== EIP-758 ===
TITLE: Subscriptions and filters for completed transactions
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2017-11-09
REQUIRES: 1474

SUMMARY:
When a new transaction is submitted successfully to an Ethereum node, the node responds with the transaction's hash. If the transaction involved the execution of a contract function that returns data, the data is discarded. If the return data is state-dependent, which is common, there is no straightforward way for the caller to access or compute the return data. This EIP proposes that callers should be able to subscribe to (or poll for) completed transactions. The Ethereum node sends the return data to the caller when the transactions are sealed.

SPECIFICATION:
### Subscription A caller who wants to be notified when transactions of theirs complete sends an `eth_subscribe` RPC request with the first parameter `"completedTransaction"`: ```json {"jsonrpc": "2.0", "id": 1, "method": "eth_subscribe", "params": ["completedTransaction", filter]} ``` The `filter` parameter is a dictionary containing 3 optional named arguments: `from`, `to`, and `hasReturnData`. `from` and `to` can each either be single addresses, or a list of addresses. They are used to filter out any transactions not sent from an address in the `from` list and sent to an address in the to list. `hasReturnData` is a boolean--if it is specified and

MOTIVATION:
External callers presently have no way of accessing return data from Ethereum, if the function was executed via `eth_sendTransaction` or `eth_sendRawTransaction` RPC request. Access to function return data is in many cases a desirable feature. Making return data available to external callers also addresses the inconsistency between internal callers, which have access to return data within the context of the transaction, and external callers, which do not. Presently, a common workaround is to log the return data, which is bad for several reasons: it contributes to chain bloat, imposes additional gas costs on the caller, and can result

RATIONALE:
[EIP-658](./eip-658.md) originally proposed adding return data to transaction receipts. However, return data is not charged for (as it is not stored on the blockchain), so adding it to transaction receipts could result in DoS and spam opportunities. Instead, a simple Boolean `status` field was added to transaction receipts. This modified version of EIP 658 was included in the Byzantium hard fork. While the `status` field is useful, applications often need the return data as well. The primary advantage of using the strategy outlined here is efficiency: no extra data needs to be stored on the blockchain, and minimal


=== EIP-7609 ===
TITLE: Decrease base cost of TLOAD/TSTORE
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-02-01
REQUIRES: 1153

SUMMARY:
Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The gas cost for `TLOAD` is proposed to be 5 gas. The gas cost for `TSTORE` is proposed to be 8 gas + `expansion_cost`, where `expansion_cost` is calculated as `1 gas * len(transient storage mapping)` if the key is not yet in the transient storage mapping, and otherwise 0 gas. In pseudo-code: ```python G_LOW = 5 G_MID = 8 SLOPE = 1 def gas_tload(_key):

MOTIVATION:
[EIP-1153](./eip-1153.md) introduces a new storage region, termed "transient storage". It behaves like storage (word-addressed and persists between call frames), but unlike storage it is wiped at the end of each transaction. During development of EIP-1153, the pricing was set to be the same as warm storage loads and stores. This was for two reasons: conceptual simplicity of the EIP, and it also addressed concerns about two related DoS vectors: being able to allocate too much transient storage, and the cost of rolling back state in the case of reverts. One of the most important use cases that EIP-1153

RATIONALE:
### Gas In benchmarking, `TLOAD` was found to cost a similar amount of CPU time as `MUL`, while `TSTORE` was found to cost about 1.5x that. The values `G_low` and `G_mid` were therefore chosen for `TLOAD` and `TSTORE`, respectively.


=== EIP-197 ===
TITLE: Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-06
REQUIRES: 

SUMMARY:
This EIP suggests to add precompiled contracts for a pairing function on a specific pairing-friendly elliptic curve. This can in turn be combined with [EIP-196](./eip-196.md) to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).

SPECIFICATION:
For blocks where `block.number >= BYZANTIUM_FORK_BLKNUM`, add a precompiled contracts for a bilinear function on groups on the elliptic curve "alt_bn128". We will define the precompiled contract in terms of a discrete logarithm. The discrete logarithm is of course assumed to be hard to compute, but we will give an equivalent specification that makes use of elliptic curve pairing functions which can be efficiently computed below. Address: 0x8 For a cyclic group `G` (written additively) of prime order `q` let `log_P: G -> F_q` be the discrete logarithm on this group with respect to a generator `P`, i.e.

MOTIVATION:
Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive to fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced. Note that fixing these

RATIONALE:
The specific curve `alt_bn128` was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts. The feature of adding curve and field parameters to the inputs was considered but ultimately rejected since it complicates the specification; the gas costs are much harder to determine and it would be possible to call the contracts on something which is not an actual elliptic curve or does not admit an efficient pairing implementation.


=== EIP-8007 ===
TITLE: Glamsterdam Gas Repricings
TYPE: Meta 
STATUS: Draft
CREATED: 2025-08-21
REQUIRES: 2, 7, 8, 0, ,,  , 7, 6, 6, 7, ,,  , 7, 7, 7, 8, ,,  , 7, 9, 0, 4, ,,  , 7, 9, 2, 3, ,,  , 7, 9, 7, 6, ,,  , 7, 9, 8, 1

SUMMARY:
This Meta EIP documents all the proposals for Glamsterdam related to the gas repricing effort. The goal of this effort is to harmonize gas costs across the EVM, thereby reducing the impact of specific bottlenecks on scaling. Proposals include changes to the cost of single EVM operations, as well as bigger changes to the gas model. This Meta EIP is purely informational and does not aim to have an active role in the governance process for the Glamsterdam fork. Instead, it serves as a directory for all repricing-related proposals, helping to organize the work and keeping the community

SPECIFICATION:
This Meta EIP includes two types of EIPs, namely, core and possible additions. This list will continue to be updated as more gas repricing EIPs are proposed. ### Core EIPs | EIP | Description | Type | Status | | ------------------------- | ------------------------------------------------------------------------------------------ | ------------------ | ---------------------- | | [EIP-7778](./eip-7778.md) | Prevent Block Gas Limit Circumvention by Excluding Refunds from Block Gas Accounting. | General Accounting | Proposed for Inclusion | | [EIP-7904](./eip-7904.md) | Gas Cost Repricing to reflect computational complexity and transaction throughput increase | Compute | Pending | | [EIP-7981](./eip-7981.md) | Introduce floor pricing for access

MOTIVATION:
The main objective of the Glamsterdam fork is to improve L1 scalability. A crucial aspect of this initiative is to create a better alignment between gas costs and actual resource usage. Currently, the gas model often misprices operations, resulting in inefficiencies and unintended incentives. For instance, within the pure compute operations, there is a high variance in execution time per gas unit, which indicates that a single unit of computation is not priced equally across the various opcodes. By standardizing gas costs across EVM operations and other resources, we can reduce bottlenecks and enhance the utilization of EVM

RATIONALE:
Discussed in the individual EIPs.


=== EIP-649 ===
TITLE: Metropolis Difficulty Bomb Delay and Block Reward Reduction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-06-21
REQUIRES: 

SUMMARY:
Starting with `BYZANTIUM_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 3 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 3 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 3_000_000) if block.number >= BYZANTIUM_FORK_BLKNUM else block.number #### Adjust Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward = 3_000_000_000_000_000_000 if block.number >= BYZANTIUM_FORK_BLKNUM else block.reward (3E18 wei, or 3,000,000,000,000,000,000 wei, or 3 ETH). Analogue, if an uncle is included in a block for `block.number >= BYZANTIUM_FORK_BLKNUM` such that `block.number - uncle.number = k`,

MOTIVATION:
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another one and a half years. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it's going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state

RATIONALE:
This will delay the ice age by 42 million seconds (approximately 1.4 years), so the chain would be back at 30 second block times at the end of 2018. An alternate proposal was to add special rules to the difficulty calculation to effectively _pause_ the difficulty between different blocks. This would lead to similar results. This was previously discussed at All Core Devs Meeting [#09](https://github.com/ethereum/pm/blob/master/AllCoreDevs-EL-Meetings/Meeting%209.md#metropolis-timing-and-roadmap-discussion), [#12](https://github.com/ethereum/pm/blob/master/AllCoreDevs-EL-Meetings/Meeting%2012.md#5-metropolis-update), [#13](https://github.com/ethereum/pm/blob/master/AllCoreDevs-EL-Meetings/Meeting%2013.md#3-eip-186-reduce-eth-issuance-before-proof-of-stake-hudson), and [#14](https://github.com/ethereum/pm/blob/master/AllCoreDevs-EL-Meetings/Meeting%2014.md#1-eip-186-reduce-eth-issuance-before-proof-of-stake-core-devs). Consensus on the specification was achieved in All Core Devs Meeting [#19](https://github.com/ethereum/pm/blob/master/AllCoreDevs-EL-Meetings/Meeting%2019.md) and specification drafted in EIP issue [#649](https://github.com/ethereum/EIPs/issues/649). It was decided to replace EIP [#186](https://github.com/ethereum/EIPs/issues/186) and include the


=== EIP-2458 ===
TITLE: Updates and Updated-by Header
TYPE: Informational 
STATUS: Withdrawn
CREATED: 2020-01-06
REQUIRES: 

SUMMARY:
EIP headers `updates` and `updated-by` are used for updating `active` EIPs. This is to make the improvement process of EIPs more modular, and have updates to existing `active` EIPs receive similar exposures to EIPs which replace existing `final` EIPs.

SPECIFICATION:
### `updated-by` `updated-by` is reserved for EIPs in `active` status. For an EIP in status `active`, updates to that EIP, which update the header `updated`, should be started by opening a new EIP to start vetting for that update. When an `active` EIP receives a new entry to header `updated`, an associated `updated-by` EIP listing should be included, where that newly listed EIP has reached `final` status. `updates` should be included as an EIP header, as all EIP headers, and include a reference to an EIP designation. When multiple EIP designations are referenced, each should be separated by

MOTIVATION:
Currently, EIP1 specifies EIP headers: `updated`, `replaces`, and `superseded-by`. Headers `replaces` and `superseded-by` indicates when an entire EIP is being replaced by another EIP, indicating when an EIP is now historical, and is updated by a new standard. The header `updated` indicates the date an EIP has received an update by EIP authors and editors, an example EIP being EIP1. `updated` is reserved for EIPs in `draft` or `active` status. In the case of `active` status, an EIP may receive an update, but these updates don't operate as with EIPs in `final` status, where a historical EIP is

RATIONALE:
`updates` and `updated-by` apply only to EIPs in `active` status as updates to EIPs in `final` status are already handled by EIP headers `superseded-by` and `replaces`. The syntax should align with previous EIP header syntax, as this EIP is not updating syntax, simply adding header options.


=== EIP-5069 ===
TITLE: EIP Editor Handbook
TYPE: Meta 
STATUS: Living
CREATED: 2022-05-02
REQUIRES: 1


=== EIP-1965 ===
TITLE: Method to check if a chainID is valid at a specific block Number
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-20
REQUIRES: 155

SUMMARY:
This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.

SPECIFICATION:
Adds a new precompile which uses 2 argument : a 32 bytes value that represent the chainID to test and a 32 bytes value representing the blockNumber at which the chainID is tested. It return 0x1 if the chainID is valid at the specific blockNumber, 0x0 otherwise. Note that chainID are considered valid up to the blockNumber at which they are replaced. So they are valid for every blockNumber past their replacement. The operation will costs no more than `G_blockhash` + `G_verylow` to execute. This could be lower as chainID are only introduced during hardfork. The cost of

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent the replay of transactions between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling off-chain message signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md). [EIP-1344](./eip-1344.md) is attempting to solve this by giving smart contract access to the tip of the chainID history. This is insufficient as such value is changing. Hence why EIP-1344 describes a contract based solution to work around the problem. It would be better to solve it in a simpler, cheaper and safer manner, removing the

RATIONALE:
The rationale at EIP-1959 applies here as well too : - An opcode is better than a caching system for past chainID, It is cheaper, safer and do not include gaps. - Direct access to the latest chainID is dangerous since it make it easy for contract to use it as a replay protection mechanism while preventing otherwise valid old messages to be valid after a fork that change the chainID. This can have disastrous consequences on users. - all off-chain messages signed before a fork should be valid across all side of the fork. The only difference


=== EIP-7666 ===
TITLE: EVM-ify the identity precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.

SPECIFICATION:
| Parameter | Value | | - | - | | `IDENTITY_PRECOMPILE_ADDRESS` | `0x0000....0004` | | `EVM_CODE` | `0x365f5f37365ff3` | At the start of the block in which this fork activates, set the code of `IDENTITY_PRECOMPILE_ADDRESS` to `EVM_CODE`. Starting from and including that block, `IDENTITY_PRECOMPILE_ADDRESS` should no longer be treated as a precompile.

MOTIVATION:
Ethereum today has a large number of precompiles. Nearly half of these precompiles are not seeing significant use, and are contributing to ongoing maintenance cost and risk of consensus bugs, as well as increased development effort for new Ethereum client implementations, including ZK-EVMs and implementations in formal-verification-friendly languages. This EIP proposes a path for the Ethereum ecosystem to gracefully abandon these precompiles, and takes a first step by applying this procedure to the simplest precompile of all: the identity precompile (which outputs returndata equal to the input calldata). The identity precompile was originally introduced because memory copying is

RATIONALE:
The given `EVM_CODE` corresponds to ``` CALLDATASIZE PUSH0 PUSH0 CALLDATACOPY CALLDATASIZE PUSH0 RETURN ``` Which copies calldata into memory, and then returns the same memory slice. This is thus a minimally disruptive change to Ethereum that preserves functionality, and accomplishes the goal of reducing the number of precompiles by 1.


=== EIP-8012 ===
TITLE: Generalized consolidation requests
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-22
REQUIRES: 

SUMMARY:
This EIP redefines the field `target_pubkey` from consolidations requests into a general array of 48 bytes that can be interpreted separately by the consensus layer.

SPECIFICATION:
### Constants #### Consensus Layer | NAME | Value | Comment | | - | - | - | | `MAGIC_PREFIX` | `0xEF0A11` | 3 byte prefix to all generalized consolidation requests | ### Execution Layer No changes are expected ### Consensus Layer This EIP does not establish any changes on the consensus layer, but rather standardizes how consolidation requests are to be treated in the future. When receiving a `ConsolidationRequest` type object on the consensus layer, the `target_pubkey` field is to be treated differently. If it coincides with the BLS publick key of an existing active validator

MOTIVATION:
The current contract to send consolidation requests is not optimized in that the exact same contract, with the exact same calldata and engine API, can be used to transmit more general messages from the EL to the CL without changes on the EL side. In particular, avoiding any cross layer coordination in the event of an CL hard fork. As a possible application, we could use the same contract to allow any existing validator to become a builder as in [EIP-7732](./eip-7732.md).

RATIONALE:
The proposed reinterpretation of the existing contract enables new implementations in the consensus layer without requireing a hard fork in the execution layer.


=== EIP-2584 ===
TITLE: Trie format transition with overlay trees
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-04-03
REQUIRES: 

SUMMARY:
This EIP describes a four phase process to complete the conversion. * In the first phase, all new state writes are made to an overlay binary trie, while the hexary trie is being converted to binary. The block format is changed to have two storage roots: the root of the hexary trie (hereafter called the "base" trie) and the root of the overlay binary trie. * After enough time has been given to miners to perform the conversion, the second phase begins. The overlay tree is progressively merged back into the newly converted binary base trie. A constant

SPECIFICATION:
This specification follows the notation introduced by the [Yellow Paper](https://ethereum.github.io/yellowpaper). Prior to reading it is advisable to be familiar with the Yellow Paper. ### Binary tries This EIP assumes that a binary trie is defined like the MPT, except that: * The series of bytes in I₀ is seen as a series of _bits_ and so ∀i≤256, I₀[i] is the ith bit in key I₀ * The first item of an **extension** or a **leaf** is replacing nibbles with bits; * A **branch** is a 2 item structure in which both items correspond to each of the two

MOTIVATION:
There is a long running interest in switching the state trie from a hexary format to a binary format, for reasons pertaining to proof and storage sizes. The conversion process poses a catch-up issue, caused by the sheer size of the full state: it can not be translated in a reasonable time (i.e. on the same order of magnitude as the block time).

RATIONALE:
Methods that have been discussed until now include a "stop the world" approach, in which the chain is stopped for the significant amount of time that is required by the conversion, and a "copy on write" approach, in which branches are converted upon being accessed. The approach suggested here has the advantage that the chain continues to operate normally during the conversion process, and that the tree is fully converted to a binary format, in a predictable time.


=== EIP-1890 ===
TITLE: Commitment to Sustainable Ecosystem Funding
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-03-31
REQUIRES: 

SUMMARY:
A mechanism that allows specification of two parameters, a beneficiary address and a per-block reward denominated in wei, that allows a portion of block rewards to be captured for the purpose of ecosystem funding. Both values are set to zero.

SPECIFICATION:
Two new constants are introduced: BENEFICIARY_ADDRESS, an Address, and DEVFUND_BLOCK_REWARD, an amount denominated in wei. Both are set to zero. Beginning with block ISTANBUL_BLOCK_HEIGHT, DEVFUND_BLOCK_REWARD wei is added to the balance of BENEFICIARY_ADDRESS at each block. We may optionally add another constant, DECAY_FACTOR, which specifies a linear or exponenential decay factor that reduces the reward at every block > ISTANBUL_BLOCK_HEIGHT until it decays to zero. For simplicity, it has been omitted from this proposal.

MOTIVATION:
In order for Ethereum to succeed, it needs talented, motivated researchers and developers to continue to develop and maintain the platform. Those talented researchers and developers deserve to be paid fairly for their work. At present there is no mechanism in the Ethereum ecosystem that rewards R&D teams fairly for their work on the platform. We recognize that, while technically trivial, the real challenge in inflation-based funding is social: how to fairly capture, govern, and distribute block rewards. It will take time to work out the answer to these questions. For this reason, this EIP only seeks to

RATIONALE:
We believe that the technical design of this EIP is straightforward. The social rationale is explained in [this article](https://medium.com/gitcoin/funding-open-source-in-the-blockchain-era-8ded753bf05f).


=== EIP-198 ===
TITLE: Big integer modular exponentiation
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-01-30
REQUIRES: 


=== EIP-1193 ===
TITLE: Ethereum Provider JavaScript API
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2018-06-30
REQUIRES: 1, 5, 5, ,,  , 6, 9, 5

SUMMARY:
A common convention in the Ethereum web application ("dapp") ecosystem is for key management software ("wallets") to expose their API via a JavaScript object in the web page. This object is called "the Provider". Historically, Provider implementations have exhibited conflicting interfaces and behaviors between wallets. This EIP formalizes an Ethereum Provider API to promote wallet interoperability. The API is designed to be minimal, event-driven, and agnostic of transport and RPC protocols. Its functionality is easily extended by defining new RPC methods and `message` event types. Historically, Providers have been made available as `window.ethereum` in web browsers, but this

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). > Comments like this are non-normative. ### Definitions _This section is non-normative._ - Provider - A JavaScript object made available to a consumer, that provides access to Ethereum by means of a Client. - Client - An endpoint that receives Remote Procedure Call (RPC) requests from the Provider, and returns their results. - Wallet - An end-user application that manages private keys, performs signing operations, and acts as a middleware

RATIONALE:
The purpose of a Provider is to _provide_ a consumer with access to Ethereum. In general, a Provider must enable an Ethereum web application to do two things: - Make Ethereum RPC requests - Respond to state changes in the Provider's Ethereum chain, Client, and Wallet The Provider API specification consists of a single method and five events. The `request` method and the `message` event alone, are sufficient to implement a complete Provider. They are designed to make arbitrary RPC requests and communicate arbitrary messages, respectively. The remaining four events can be separated into two categories: - Changes


=== EIP-3382 ===
TITLE: Hardcoded Block Gas Limit
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
Updates the block validation rules such that a block is invalid if the `gas_limit` header field is not equal to `12,500,000`.

SPECIFICATION:
Refer to `gasLimit` as `gasTarget` post EIP-1559. ### Added Consensus Constraint As of `FORK_BLOCK_NUMBER`, the `header.gasLimit` **MUST** be equal to `BLOCK_GAS_LIMIT`, where `BLOCK_GAS_LIMIT` is a hardcoded constant set to `12,500,000`.

MOTIVATION:
Both Ethereum's Proof of Work and Proof of Stake designs assume that block producers are financially rational, but does not assume block producers to be benevolent. There is one exception however, and it is when block producers choose the gas limit of a block where it is assumed that block producers care about the long term health and decentralisation of the chain. Indeed, the block gas limit is one of the only parameters in Ethereum that is not dictated by node consensus, but instead is chosen by block producers. This decision was initially made to allow urgent changes

RATIONALE:
### Keeping gasLimit in Block Headers While it would be possible to remove the `gasLimit` field from block headers, it would change the data structure to be hashed, which could lead to unintended consequences. It is therefore easier to leave the gasLimit as part of block headers. ### Chosen Gas Limit The `12,500,000` value is being proposed as it's the current block gas limit as of time of writing this EIP. The actual amount could be altered with a subsequent EIP to avoid deviating from the core intent of this EIP.


=== EIP-7981 ===
TITLE: Increase access list cost
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-27
REQUIRES: 2930

SUMMARY:
This EIP charges access lists for their data footprint, closing a loophole that allows circumventing [EIP-7623](./eip-7623.md) floor pricing. This effectively reduces the worst-case block size by ~21% with minimal impact on users.

SPECIFICATION:
| Parameter | Value | Source | | -------------------------------------- | ----- | ------ | | `ACCESS_LIST_ADDRESS_COST` | `2400` | [EIP-2930](./eip-2930.md) | | `ACCESS_LIST_STORAGE_KEY_COST` | `1900` | [EIP-2930](./eip-2930.md) | | `TOTAL_COST_FLOOR_PER_TOKEN` | `10` | [EIP-7623](./eip-7623.md) | Let `access_list_nonzero_bytes` and `access_list_zero_bytes` be the count of non-zero and zero bytes respectively in the addresses (20 bytes each) and storage keys (32 bytes each) contained within the access list. The current formula for access list costs in [EIP-2930](./eip-2930.md) is: ```python access_list_cost = ( ACCESS_LIST_ADDRESS_COST * access_list_addresses + ACCESS_LIST_STORAGE_KEY_COST * access_list_storage_keys ) ``` The formula for access list costs changes to: ```python #

MOTIVATION:
Access lists are only priced for storage but not for their data. Furthermore, access lists can circumvent the [EIP-7623](./eip-7623.md) floor pricing by contributing to EVM gas while still leaving a non-negligible data footprint. This enables to achieve the maximal possible block size by combining access lists with calldata at a certain ratio.

RATIONALE:
Adding 40 gas per non-zero byte and 10 gas per zero byte ensures consistent pricing across all transaction data: - Address (20 bytes, typically mostly non-zero): ~3200 gas (2400 + 800 assuming all non-zero) - Storage key (32 bytes, typically mostly non-zero): ~3180 gas (1900 + 1280 assuming all non-zero) No threshold mechanism is used. The per-byte costs are always applied to maintain simplicity and prevent circumvention. The additional cost makes [EIP-2930](./eip-2930.md) access lists economically irrational for gas optimization, effectively deprecating their use while maintaining compatibility. ### Access List Size Impact At a gas limit of 60M: -


=== EIP-6789 ===
TITLE: Rename gas to mana
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2023-03-27
REQUIRES: 

SUMMARY:
This EIP suggests renaming `gas` to `mana`, as proposed by Vitalik Buterin in 2015.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The core term `gas` MUST be renamed to `mana`. The following opcodes MUST be renamed: - `GASPRICE` to `MANAPRICE`; - `GASLIMIT` to `MANALIMIT`; and - `GAS` to `MANA`. Additionally, the input parameters or outputs of the following opcodes MUST be renamed: - `CALL`'s `gas` input parameter to `mana`; - `CALLCODE`'s `gas` input parameter to `mana`; - `DELEGATECALL`'s `gas` input parameter to `mana`; - `STATICCALL`'s

MOTIVATION:
The underlying motivation for reviving Vitalik's original proposal from 2015 is that we have finally arrived at the age of Proof-of-Stake, and given the roadmap ahead (i.e. "The Surge", "The Scourge", "The Verge", "The Purge", and "The Splurge"), I consider this moment as the last opportunity to make such a far-reaching semantic change.

RATIONALE:
- `mana` reflects the increased environmental friendliness of Proof-of-Stake; - `mana` is generally understood to be ephemeral and non-transferable, which better represents the concept of `gas`; and - `mana` is generally portrayed as renewable, while (natural) `gas` is non-renewable.


=== EIP-1959 ===
TITLE: New Opcode to check if a chainID is part of the history of chainIDs
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-20
REQUIRES: 155

SUMMARY:
This EIP adds an opcode that returns whether the specific number passed in has been a valid chainID (EIP-155 unique identifier) in the history of the chain (including the current chainID).

SPECIFICATION:
Adds a new opcode ```VALID_CHAINID``` at 0x46, which uses 1 stack argument : a 32 bytes value that represent the chainID to test. It will push ```0x1``` onto the stack if the uint256 value is part of the history (since genesis) of chainIDs of that chain, ```0x0``` otherwise. The operation costs `G_blockhash` to execute. The cost of the operation might need to be adjusted later as the number of chainID in the history of the chain grows. Note though that the alternative to keep track of old chainID is to implement a smart contract based caching solution as

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md). [EIP-1344](./eip-1344.md) is attempting to solve this by giving smart contract access to the tip of the chainID history. This is insufficient as such value is changing. Hence why EIP-1344 describes a contract based solution to work around the problem. It would be better to solve it in a simpler, cheaper and safer manner, removing the potential risk of misuse

RATIONALE:
The only approach available today is to specify the chain ID at compile time. Using this approach will result in problems after a contentious hardfork as the contract can't accept message signed with a new chainID. The approach proposed by EIP-1344 is to give access to the latest chainID. This is in itself not sufficient and pose the opposite of the problem mentioned above since as soon as a hardfork that change the chainID happens, every L2 messages signed as per [EIP-712](./eip-712.md) (with the previous chainID) will fails to be accepted by the contracts after the fork. That's


=== EIP-3584 ===
TITLE: Block Access List
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-05-22
REQUIRES: 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
[EIP-2929](./eip-2929.md)/[EIP-2930](./eip-2930.md) centers around normalizing the (low) gas costs of data/storage accesses made by a transaction as well as providing for (and encouraging) a new transaction type format: ``` 0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS]) ``` that makes upfront `access_list` declarations, where `access_list` is some `[[{20 bytes}, [{32 bytes}...]]...]` map of `AccessedAddress=> AccessedStorageKeys`. The first *accesses* of these upfront *declarations* are charged at discounted price (roughly ~`10%`) and first accesses outside this list are charged higher price. Reason is upfront access declaration provides for a way to *preload/optimize/batch* loading these locations while

SPECIFICATION:
A block `access_list` represents: ``` Set [ AccessedAddress, List [AccessedStorageKeys] , Set [ AccessedInBlockTransactionNumber, List [ AccessedStorageKeys ]] ] ``` A **canonical** construction of such an `access_list` is specified as below. ### Canonical Block Access List An `access_list` is defined to be comprised of many `access_list_entry` elements: ``` access_list := [access_list_entry, ...] ``` An `access_list_entry` is a 3-tuple of: * address * sorted list of storage keys of the address accessed across the entire block * sorted list of 2-tuples of: * transaction index in which the address or any of its storage keys were accessed * sorted

MOTIVATION:
Motivation for collating the *transaction* `access_list`s for all the transactions in a **block**’s `access_list` is to have an *access index* of the block with following benefits: 1. Block execution/validation optimizations/parallelization/cache warm-up by enabling construction of *a partial order* for access and hence execution (hint: *chains* in this *poset* can be parallelized). 2. Enabling partial inspection and fetching/serving of a block data/state by *light sync* or *fast sync* protocols concerned with a subset of addresses. 3. Possible future extension of this list to serve as index for bundling, serving and fetching witness data for *stateless* protocols.

RATIONALE:
### Sorting of canonical `access_list` It is specified to be sorted in lexicographic ordering or integer sorting wherever applicable and specified. Sorting with respect to access time was considered but didn't seem to provide any additional benefit at the cost of adding implementation complexity and bookkeeping. ### `AccessListRoot` `AccessListRoot` is generated to prevent any *griefing* attacks and hence will need to be included (and validated) in the *block header*. Even though `AccessListRoot` is currently specified to be a simple `sha256` hash of the canonical `access_list`, it would be beneficial to consider other constructions * a tree structure (`merkle`/`verkle`).


=== EIP-2330 ===
TITLE: EXTSLOAD opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-10-29
REQUIRES: 2929

SUMMARY:
This proposal adds a new opcode `EXTSLOAD` at `0x5c` which pops two items from the stack: `<account address> <storage key>` and pushes one item: `<storage value>`. The gas cost is sum of account access cost and storage read based on [EIP-2929](./eip-2929.md) Access Lists.

SPECIFICATION:
A new EVM instruction `EXTSLOAD (0x5c)` that works like `SLOAD (0x54)` but an additional parameter representing the contract that is to be read from. ```shell EXTSLOAD (0x5c) ``` The `EXTSLOAD` instruction pops 2 values from the stack, first `contract` a contract address and then second `slot` a storage address within `contract`. As result `EXTSLOAD` pushes on the stack the value from the contract storage of `contract` at the storage `slot` address or `0` in case the account `contract` does not exist. ### Gas cost pre-verkle Gas to be charged before Verkle Tree change is specified as `ACCOUNT_ACCESS_COST +

MOTIVATION:
While any off-chain application can read all contract storage data of all contracts, this is not possible for deployed smart contracts themselves. These are bound to use contract calls for any interaction including reading data from other contracts. This EIP adds an EVM opcode to directly read external contract storage. The gas cost when reading from registry style contract such as [EIP-20s](./eip-20.md), ENS and other data contracts is very high, because they incur cross contract call cost, cost for ABI encoding, decoding and dispatching and finally loading the data. In many cases the underlying storage that is being

RATIONALE:
- Without this EIP, a contract can still opt-in to make their entire state public, by having a method that simply SLOADs and returns the values ([example](../assets/eip-2330/Extsload.sol)). The complexity of the gas cost can be seen as `1`x CALL cost + `N`x SLOAD cost. Hence, the gas cost specified for using EXTSLOAD opcode on an account for `N` times, the charge of `1`x `COLD_ACCOUNT_ACCESS_COST` and `N`x `STORAGE_READ_COST` is hereby justified. - Without this EIP, a contract can still use internal state of other contracts. An external party can supply a value and proof to a contract, which the


=== EIP-2972 ===
TITLE: Wrapped Legacy Transactions
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-09-12
REQUIRES: 1, 5, 5, ,,  , 2, 7, 1, 8

SUMMARY:
Introduces two new [EIP-2718](./eip-2718.md) transactions that are signature compatible with legacy transactions and can be automatically upgraded by any client. * `0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))` * `0x01 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))`

SPECIFICATION:
### Definitions * `||` is the byte/byte-array concatenation operator. * `yParity` is the parity (0 for even, 1 for odd) of the `y` value of the curve point for which `r` is the `x` value in the secp256k1 signing process. ### Transactions As of `FORK_BLOCK_NUMBER`, `0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))` will be a valid transaction where: * the RLP encoded transaction portion is signed/processed/handled exactly the same as legacy transactions were signed/processed/handled, with the exception of the final encoding * TODO: Hashing or Merkleizing for block transaction root As of `FORK_BLOCK_NUMBER`, `0x01

MOTIVATION:
We would like to eventually deprecate legacy transactions so we no longer have to retain code in the networking and signer layer that deals with them. However, we also want to ensure that signatures for transactions that were generated prior to that deprecation are still valid and funds don't end up stuck because of an inability to sign a new style transaction. This EIP provides a mechanism for transmitting/including transactions in a way that is [EIP-2718](./eip-2718.md) compatible while still being signature compatible with legacy transactions.

RATIONALE:
### Signature doesn't include transaction type as first signature byte These transaction types are explicitly designed to be signature compatible with legacy transactions, which means we cannot change the data being signed. See Security Considerations section for more details. ### Two transaction types instead of one With the introduction of typed transactions, we no longer need to do bit packing to avoid changing the shape of the signature. Legacy transactions introduced chain ID in [EIP-155](./eip-155.md) and wanted to avoid changing the transaction array length, so it bitpacked the chainID into the signature's `v` value. Since we no longer


=== EIP-86 ===
TITLE: Abstraction of transaction origin and signature
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-02-10
REQUIRES: 


=== EIP-6916 ===
TITLE: Automatically Reset Testnet
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-04-10
REQUIRES: 

SUMMARY:
This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.

SPECIFICATION:
The testnet is set to always reset after a predefined time period. The reset means the generation of the next genesis, discarding the old one and starting a new network. This is possible by introducing functions for the genesis generation and the client reset. ### Genesis To connect to the current instance of the network, the client must implement the genesis function. This function defines how the client stores information about the testnet and generates the current genesis. With each reset, the network starts from a new genesis which needs to be built based on given parameters and

MOTIVATION:
A testnet which automatically resets can provide an alternative environment for short-term testing of applications, validators and also breaking changes in client implementations. It avoids issues of long running testnets which suffer from state bloat, lack of testnet funds or consensus issues. Periodically resetting the network back to genesis cleans the validator set and returns funds back to faucets while keeping the network reasonably small for easy bootstrapping.

RATIONALE:
Ephemeral testnets with deterministic parameters provide a sustainable alternative to traditional testnets, with the same infrastructure. At each reset, the validator set is cleared, faucets are filled again and the database is kept small. Upon reset the whole state is purged, which, on the one hand keeps the network small and easy to bootstrap but introduces problems for testing longer term / advanced applications. However, basic contract infrastructure can be automatically deployed after each reset by any user. Generally, using the network is recommended for short term testing, deploying `Hello World` kinds of contracts that don't need to


=== EIP-7636 ===
TITLE: Extension of EIP-778 for "client" ENR Entry
TYPE: Standards Track Networking
STATUS: Withdrawn
CREATED: 2024-02-25
REQUIRES: 778

SUMMARY:
The Ethereum network consists of nodes running various client implementations. Each client has its own set of features, optimizations, and unique behaviors. Introducing a standardized way to identify client software and its version in the ENR allows for more effective network analysis, compatibility checks, and troubleshooting. This EIP proposes the addition of a "client" field to the ENR.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The "client" entry is proposed to be added to the ENR following the specifications in [EIP-778](./eip-778.md). This entry is OPTIONAL and can be omitted by clients that choose not to disclose such information. The key for this entry is `"client"`. All elements MUST be encoded as a string using the ASCII standard as described in [RFC 20](https://www.rfc-editor.org/rfc/rfc20). The value for this entry MUST be

MOTIVATION:
Understanding the landscape of client software in the Ethereum network is crucial for developers, nodes, and network health assessment. Currently, there is no standardized method for nodes to announce their software identity and version, which can lead to compatibility issues or difficulty in diagnosing network-wide problems. Adding this to the ENR allows clients to audit network health only using discv5, and additionally track discv5 adoption across different services.

RATIONALE:
One key was chosen over using many keys to make efficient use of space. The use of one string, however, does not align with other EIPs of similar purpose and as such the RLP list was decided as the best encoding.


=== EIP-7684 ===
TITLE: Return deposits for distinct credentials
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-12
REQUIRES: 

SUMMARY:
Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.

SPECIFICATION:
### Consensus Layer The configuration values and mechanics of the specification can be found in the [Consensus Layer specs](https://github.com/ethereum/consensus-specs/blob/2360756c8c19c0f7b0e91135f5bbcddecdf0a835/specs/_features/eip9999/beacon_chain.md). A sketch of the resulting changes to the consensus layer is included below. - Modify `apply_deposit` to queue for withdrawal deposits with distinct execution withdrawal credentials - Modify `get_expected_withdrawals` to return pending withdrawals first - Modify `process_withdrawals` to clear the pending withdrawals queue ### Execution Layer This specification does not require any changes to the Execution Layer.

MOTIVATION:
Some staking operations feature two distinct entities, one operating the validating key, and one funding the deposit. The funding entity delegates control of the stake operation but must retain ultimate control of funds. If the funding entity naively submits a single deposit with the full stake amount and the other entity's validating key, it is subject to a front-run attack. The validating entity can front-run the bigger deposit with a second deposit with its own set of withdrawal credentials. The full stake amount deposit becomes a top-up, in control of the validating entity. There exist workarounds to the

RATIONALE:
### Persist pending withdrawals Rejected deposits from block at slot N can not be withdrawn in block N due to a cyclic dependency. An execution client must know the full list of withdrawals before constructing a payload for slot N. After [EIP-6110](./eip-6110.md), a consensus client must know the full execution payload for slot N before constructing the beacon block for slot N. Therefore, rejected deposits must be withdrawn in some future slot. All pending withdrawals are processed at once in the very next slot for simplicity but could be queued and processed progressively if there are DOS concerns.


=== EIP-2069 ===
TITLE: Recommendation for using YAML ABI in ERCs/EIPs
TYPE: Informational 
STATUS: Stagnant
CREATED: 2017-02-11
REQUIRES: 

SPECIFICATION:
The [Standard Contract ABI] is usually represented as a JSON object. This works well and several tools – including compilers and clients – support it to handle data encoding. One shortcoming of the JSON description is its inability to contain comments. To counter this, we suggest the use of YAML for providing user readable specifications. Given YAML was designed to be compatible with JSON, several tools exists to convert between the two formats. The following example contains a single function, `transfer` with one input and one output in YAML: ```yaml # The transfer function. Takes the recipient address

MOTIVATION:
In the past, most ERCs/EIPs included an ABI description purely as a Solidity contract and/or interface. This has several drawbacks: - Prefers a single language over others and could hinder the development of new languages. - Locks the specification to a certain version of the Solidity language. - Allows the use of syntactical elements and features of the Solidity language, which may not be well representable in the ABI. This puts other languages at even more disadvantage. This proposal aims to solve all these issues.

RATIONALE:
The aim was to chose a representation which is well supported by tools and supports comments. While inventing a more concise description language seems like a good idea, it felt as an unnecessary layer of complexity.


=== EIP-7877 ===
TITLE: Enhanced RETURN opcodes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-01-31
REQUIRES: 6, ,,  , 1, 1, 5, 3, ,,  , 3, 8, 5, 5

SUMMARY:
This EIP specifies a series of new `RETURN` opcodes which allow the user to specify which data location to return from instead of defaulting to returning from memory.

SPECIFICATION:
This EIP introduces 3 new opcodes as well as renaming/aliasing an existing one. ``` SRETURN (0xf6) TRETURN (0xf7) RRETURN (0xf8) RETURN -> MRETURN (0xf3) ``` The `MRETURN` opcode is a rename of `RETURN`, whereby sequential bytes in memory are returned. It will operate exactly as it currenty does as of the Cancun hard-fork, and its gas cost will remain the same. `RRETURN` operates similar to `MRETURN`. It pops two items off the stack, an offset to begin reading bytes from in the existing `RETURNDATA` buffer, and a number of bytes to return. Those bytes are used to overwrite

MOTIVATION:
With the introduction of transient storage, many smart contracts have begun to store data using the new transient opcodes to optimize for gas usage, whereby a callback involves returning the data previously stored transiently. However, the current `RETURN` opcode only allows for returning sequential bytes in memory. This requires developers to incur additional gas overhead by manually writing data from transient storage to memory before returning, incuring both an additional memory expansion and opcode cost from complicated for-loops. Similar inefficiencies already occur when attempting to return data already placed in storage. This EIP attempts to rectify this by

RATIONALE:
Allowing for more targeted return opcodes allows for saving gas at all levels of smart contract optimization by eliminating the intermediate steps of first writing any data to memory before returning. In events where this data may be large, this can result in significant gas savings. These opcodes can be built into the Solidity compiler directly so that all contracts can take advantage of them. Similarly, by making return more explicit it allows for better static analysis by avoiding messy memory allocations. There is precedent for these changes. EIP-3855: Introducing `PUSH0` opcode to optimize away alternative methods of


=== EIP-3860 ===
TITLE: Limit and meter initcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-16
REQUIRES: 170

SUMMARY:
We extend [EIP-170](./eip-170.md) by introducing a maximum size limit for `initcode` (`MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152`). Furthermore, we introduce a charge of `2` gas for every 32-byte chunk of `initcode` to represent the cost of jumpdest-analysis. Lastly, the size limit results in the nice-to-have property that EVM code size, code offset (`PC`), and jump offset fits a 16-bit value.

SPECIFICATION:
### Parameters | Constant | Value | | -------------------- | ------------------- | | `INITCODE_WORD_COST` | `2` | | `MAX_INITCODE_SIZE` | `2 * MAX_CODE_SIZE` | Where `MAX_CODE_SIZE` is defined by [EIP-170](./eip-170.md) as `24576`. We define `initcode_cost(initcode)` to equal `INITCODE_WORD_COST * ceil(len(initcode) / 32)`. ### Rules 1. If length of transaction data (`initcode`) in a create transaction exceeds `MAX_INITCODE_SIZE`, transaction is invalid. (*Note that this is similar to transactions considered invalid for not meeting the intrinsic gas cost requirement.*) 2. For a create transaction, extend the transaction data cost formula to include `initcode_cost(initcode)`. (*Note that this is included in transaction

MOTIVATION:
During contract creation the client has to perform jumpdest-analysis on the `initcode` prior to execution. The work performed scales linearly with the size of the `initcode`. This work currently is not metered, nor is there a protocol enforced upper bound for the size. There are three costs charged today: 1. Cost for calldata aka `initcode`: 4 gas for a byte with the value of zero, and 16 gas otherwise. 2. Cost for the resulting deployed code: 200 gas per byte. 3. Cost of address calculation (hashing of code) in case of `CREATE2` only: 6 gas per word. Only

RATIONALE:
### Gas cost constant The value of `INITCODE_WORD_COST` is selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance of `KECCAK256` hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU. | EVM | version | MB/s | B/CPUcycle | CPUcycle/B | cost of 1 B | cost of 32 B | | --------------- | ------- | ---- | ---- | ---- | ---- | ---- | | geth/KECCAK256 | 1.10.9 | 357 | 1.8 | 0.6 | 0.2 | 6.0 |


=== EIP-7745 ===
TITLE: Light client and DHT friendly log index
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-07-17
REQUIRES: 7916

SUMMARY:
Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio. The proposed structure maps all log entries onto a global linear index space and hashes them into a Merkle tree based on that index. It also contains a _filter map_ for every fixed length section of the index space, hashed into the same Merkle tree. These are two dimensional sparse bit maps that allow searching for log address/topic patterns. Unlike the

SPECIFICATION:
### Terms and definitions - _log value_: either an _address value_ or a _topic value_. Each `LOG` opcode adds one _address value_ and 0..4 _topic values_. A _log value_ is represented by a 32 byte hash which is calculated as `sha2(address)` or `sha2(topic)` - _log value index_: values are globally mapped to a linear index space, with a monotonically increasing _log value index_ assigned to each added _log value_. The _log values_ are added in the order of EVM execution (_address value_ first, then the _topic values_) so the logs generated in each block and in each transaction

MOTIVATION:
Adding logs has a significantly lower gas cost and should accordingly be less resource consuming than writing to the state. The original design of bloom filters in each block achieves this goal as there is no complex data structure like the state to update, the set of logs emitted in each block is all contained within the header and receipts belonging to that block. Logs mostly just have long term storage costs. On the other hand, searching logs in a long range of blocks is very expensive. Bloom filters are only useful as long as they are sufficiently

RATIONALE:
### Log value index space In each block a varying number of _log values_ are emitted. In addition to inefficient search, another drawback of per-block fixed size bloom filters is the varying filter utilization leading to over-utilized filters giving many false positives in some blocks and/or wastefully under-utilized filters in some blocks. Block gas limits also tend to change significantly over the long term so any future-proof solution has to be able to adapt to the varying number of _log values_ per block. Mapping _log values_ on their own linear index space ensures uniform filter utilization of identically


=== EIP-7863 ===
TITLE: Block-level Warming
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-01-15
REQUIRES: 

SUMMARY:
This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their "warm" status throughout an entire block's execution. Accessed slots can be effectively cached at the block level, allowing for this optimization.

SPECIFICATION:
### Mechanics When a storage slot is accessed within a block: 1. The first access to a slot in a block incurs the cold access cost as of [EIP-2929](./eip-2929.md). 2. All subsequent accesses to the same slot within the same block incur only the warm access cost as of [EIP-2929](./eip-2929.md). 3. The warm/cold status resets at block boundaries ### Block Processing 1. At the start of each block: * Initialize two empty sets `block_level_accessed_addresses` and `block_level_accessed_storage_keys` 2. For each transaction in the block: * Before processing storage access: * Check if touched address is in `block_level_accessed_addresses` * If

MOTIVATION:
Currently, the EVM's storage slot warming mechanism operates at the transaction level, requiring each transaction to "warm up" slots independently, even when accessing the same storage locations within the same block. This design does not take advantage of the fact that modern node implementations can effectively cache storage access patterns at the block level. By extending the slot warming duration to the block level, we can: 1. Reduce redundant warming costs for frequently accessed slots 2. Better align gas costs with actual computational overhead 3. Improve overall network throughput without compromising security. As of Jan. 2025, the empirically

RATIONALE:
The proposal builds on several key observations: 1. **Caching Efficiency**: Modern Ethereum clients already implement sophisticated caching mechanisms at the block level. Extending address and storage key warming to match this caching behavior better aligns gas costs with actual computational costs. 2. **Backward Compatibility**: The worst-case scenario for any transaction remains unchanged - it will never pay more than the current cold access cost for its first access to a slot. 3. **Handling Reverts**: In EIP-2929, if a sub-call reverts, all accessed addresses and slots are reverted to a cold state. Under block-level warming, it remains an open


=== EIP-7703 ===
TITLE: Increase calldata cost
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-07
REQUIRES: 

SUMMARY:
An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.

SPECIFICATION:
* Increase `G_CALLDATAZERO` from 4 to 12. * Increase `G_CALLDATANONZERO` from 16 to 48.

MOTIVATION:
Larger blocks take longer to propagate through the network. In this way, the maximum potential block size is constraining the block gas limit. Therefore, in order to safely increase the block gas limit, the calldata gas must be increased.

RATIONALE:
Tripling the gas cost of calldata reduces the maximum possible block size by a factor of three.


=== EIP-6188 ===
TITLE: Nonce Cap
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2929

SUMMARY:
This EIP caps the nonce at `2^64-2`, reserving it for contracts with unusual behavior, as defined in other EIPs.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### EOA Transactions The nonce of a transaction originating from an EOA MUST be less than `2^64-2`. If the nonce is either `2^64-1` or `2^64-2`, the transaction MUST be invalid. ### `CREATE` and `CREATE2` If a nonce would be incremented to `2^64-1` by `CREATE` or `CREATE2`, it is instead set to `2^64-2`. `2^64-1` is reserved for alias or other special contracts.

MOTIVATION:
This EIP is not terribly useful on its own, as it adds additional computation without any useful side effects. However, it can be used by other EIPs.

RATIONALE:
Capping a nonce allows for contracts with special properties to be created, with their functionality based on their contract code. As such, only one nonce needs to be reserved.


=== EIP-7542 ===
TITLE: eth/70 - available-blocks-extended protocol
TYPE: Standards Track Networking
STATUS: Withdrawn
CREATED: 2023-10-21
REQUIRES: 7642

SUMMARY:
The purpose of this EIP is to introduce a method that allows an Ethereum node to communicate the range of blocks it has available. By knowing the block range a node can serve, peers can make more informed decisions when choosing whom to request blocks from or whom to connect to, especially when looking for specific block ranges. This can lead to more efficient network behavior. This EIP proposes extending the Ethereum wire protocol (`eth`) handshake, introducing a new version, `eth/70`, which will contain information regarding the block range a node can serve. Furthermore, it extends the protocol

SPECIFICATION:
- Advertise a new `eth` protocol capability (version) at `eth/70`. - The old `eth/69` protocol should still be kept alive side-by-side, until `eth/70` is sufficiently adopted by implementors. - Modify the `Status (0x00)` message for `eth/70` to add an additional `blockRange` field right after the `forkid`: - Current packet for `eth/69`: `[version: P, networkid: P, blockhash: B_32, genesis: B_32, forkid]` - New packet for `eth/70`: `[version: P, networkid: P, blockhash: B_32, genesis: B_32, forkid blockRange]`, where `blockRange` is `[startBlock: uint64, endBlock: uint64]`. - Introduce two new message types: - `RequestBlockRange (0x0b)` - A message from a node to

MOTIVATION:
In a first stage of [EIP-4444](./eip-4444.md), some nodes will still need to serve the historical data of the chain and others might be interested in starting to prune it. Currently, nodes need to connect to peers and request specific blocks to determine if a peer has the requested data. This can be inefficient, leading to unnecessary data requests and wasting both bandwidth and time. Consequently, this change empowers nodes that still want to retrieve historical data from the network to do so efficiently. As a bonus, This change enhances the efficiency of synchronization by allowing a node to

RATIONALE:
Including the available block range in the `eth` handshake allows for immediate understanding of peer capabilities. This can lead to more efficient networking as nodes can prioritize connections based on the data they need. The new message types are introduced to allow nodes to request updated available block range from other nodes since the range can change by the node syncing or pruning blocks. Maintaining connections with peers that don't have the desired range ensures network resilience, while the exception facilitates efficient block sync under full peer capacity.


=== EIP-1014 ===
TITLE: Skinny CREATE2
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-04-20
REQUIRES: 

SPECIFICATION:
Adds a new opcode (`CREATE2`) at `0xf5`, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically to `CREATE` (`0xf0`), except using `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]` instead of the usual sender-and-nonce-hash as the address where the contract is initialized at. The `CREATE2` has the same `gas` schema as `CREATE`, but also an extra `hashcost` of `GSHA3WORD * ceil(len(init_code) / 32)`, to account for the hashing that must be performed. The `hashcost` is deducted at the same time as memory-expansion gas and `CreateGas` is deducted: _before_ evaluation of the resulting address and the execution

MOTIVATION:
Allows interactions to (actually or counterfactually in channels) be made with addresses that do not exist yet on-chain but can be relied on to only possibly eventually contain code that has been created by a particular piece of init code. Important for state-channel use cases that involve counterfactual interactions with contracts. ### Rationale #### Address formula * Ensures that addresses created with this scheme cannot collide with addresses created using the traditional `keccak256(rlp([sender, nonce]))` formula, as `0xff` can only be a starting byte for RLP for data many petabytes long. * Ensures that the hash preimage has a

RATIONALE:
#### Address formula * Ensures that addresses created with this scheme cannot collide with addresses created using the traditional `keccak256(rlp([sender, nonce]))` formula, as `0xff` can only be a starting byte for RLP for data many petabytes long. * Ensures that the hash preimage has a fixed size, #### Gas cost Since address calculation depends on hashing the `init_code`, it would leave clients open to DoS attacks if executions could repeatedly cause hashing of large pieces of `init_code`, since expansion of memory is paid for only once. This EIP uses the same cost-per-word as the `SHA3` opcode. ### Clarifications


=== EIP-7790 ===
TITLE: Controlled Gas Limit Increase Guidelines
TYPE: Informational 
STATUS: Stagnant
CREATED: 2024-10-18
REQUIRES: 7783


=== EIP-1485 ===
TITLE: TEthashV1
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-11-01
REQUIRES: 

SUMMARY:
This EIP pursue "obsolete current ASIC miners" by modifying PoW algorithm in a very low risk manner and update to latest hash algorithm from deprecated FNV Hash algorithms. Following TEthashV1 algorithm suggests safe transition of PoW algorithms and secure the FNV Algorithm in MIX Parts.

SPECIFICATION:
#### 1. Reference materials on ETHASH FNV0 #### Where FNV Applied on ETHASH - In [ETHASH](https://github.com/ethereum/wiki/wiki/Ethash) , FNV Hash is used on * 1) On data aggregation function, MIX parts. * Ethash Algorithm ``` Header + Nonce | Keccak | **[MIX 0]** --> **[DAG Page]** | | Mixing <--| ... | **[Mix 63]** | |-----> Mix64 [Process] ---> Mix Digest [32B] ``` * FNV used in DAG Generation and Mixing for random access or DAG Page. #### 2. Current applied Ethash FNV hash implementation is deprecated now. [FNV-0_hash (deprecated)](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-0_hash_(deprecated)) It is a simple way of hashing algorithm ```

MOTIVATION:
Provide original Ethash proof of work verification with minimal set of changes by updating FNV0 algorithm

RATIONALE:
In case of ethash algorithm, it can't prevent ASIC forever. And, current ethash algorithm's FNV function is deprecated. So, It needs to be upgraded and it will make current ethash based ASICs obsolete. And current TETHASHV1 FNV1A implementation is based on most of ethash , which is verified for a long time. Another propose of big differencing the Ethash algorithm need to crypto analysis for a long times and need to GPU code optimization times. **Verification and Optimization timeline Examples** original ethminer (2015) -> claymore optimized miner (2016) [1year] genoil ethminer (2015) -> ethereum-mining/ethminer (2017) [2year]


=== EIP-5593 ===
TITLE: Restrict Ethereum Provider API Injection
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-09-05
REQUIRES: 1193

SUMMARY:
Historically the web platform has had a notion of “powerful” APIs like those defined in W3C's Geolocation specification and W3C's Mediastreams specification, which are subject to additional security restrictions such as those defined by W3C's secure contexts specification. Since the Ethereum Provider APIs allow dApp websites to request access to sensitive user data and to request use of user funds, new Ethereum Provider APIs generally should align to the security considerations defined by W3C's Secure Context specification in order to better protect the users data and users funds managed via the web. ### Author's Note Unfortunately, because of

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Restrictions for providers The provider objects, e.g. `window.ethereum`, are expected to only inject the Ethereum Provider APIs in secure context when conforming with this specification. The following restrictions are REQUIRED for conformant wallets: - Provider objects MAY be accessible in private (incognito) windows. - The origin MUST be a "potentially trustworthy origin" (defined in W3C's Secure Contexts specification in section 3.1) to have access to `window.ethereum`. This can

MOTIVATION:
Wallets are oftentimes maintaining security and safety of users' funds that can be equivalent to large portions of money. For this reason, it's a good idea to restrict access to the Ethereum Provider APIs to align it with other powerful APIs on the web platform. This will assist in reducing the surface area that attacks can be conducted to access users funds or data. Additionally, by adding in restrictions we're reducing the surface area that malicious web pages could fingerprint the user via the Ethereum Provider APIs providing some additional privacy benefits. An example of a specific attack

RATIONALE:
By limiting the capabilities of where the Ethereum Provider APIs are being injected we can reduce the surface area of where attacks can be executed. Given the sensitivity of data that's passed to the Ethereum Provider APIs some basic levels of authentication and confidentiality should be met in order to ensure that request data is not being intercepted or tampered with. While there have been attempts to [limit request access via the wallet](./eip-2255.md) interface itself, there have not been limitations that have been set to where these Ethereum Provider APIs are expected to be or not be injected.


=== EIP-3155 ===
TITLE: EVM trace specification
TYPE: Standards Track Interface
STATUS: Last Call
CREATED: 2020-12-07
REQUIRES: 

SUMMARY:
Introduce a new JSON standard for EVM traces during execution of state tests.

SPECIFICATION:
Clients should be able to execute simple transactions as well as code and return traces. In the following, we will call this client CUT (client under test) and use go-ethereum's `evm` binary for code examples. ### Datatypes | Type | Explanation | Example | |------------|----------------------------------------------------------------|---------------------| | Number | Plain json number | "pc":0 | | Hex-Number | Hex-encoded number | "gas":"0x2540be400" | | String | Plain string | "opName":"PUSH1" | | Hex-String | Hex-encoded string | | | Array of x | Array of x encoded values | | | Key-Value | Key-Value structure with key and values

MOTIVATION:
The Ethereum Virtual Machine executes all smart contract code on ethereum. In order to debug smart contracts and state tests better, a common format was introduced to log every execution step of the EVM. This format was implemented by Go-Ethereum, Parity-Ethereum, Nethermind and Besu. Since the common format was not well-defined, the implementations differed slightly, making it hard to develop adequate tooling which reduces the usefulness of tracing significantly. This EIP has multiple goals: - Move the specification to a more visible place to encourage new clients to implement it - Strictly define corner cases that were not

RATIONALE:
This EIP is largely based on the previous non-official documentation for EVM tracing. It tries to cover as many corner cases as possible to enable true client compatibility. The datatypes and if a field is optional is chosen to be as compatible with current implementations as possible.


=== EIP-3756 ===
TITLE: Gas Limit Cap
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-08-21
REQUIRES: 

SUMMARY:
Set an in-protocol cap for the gas limit of 30,000,000.

SPECIFICATION:
As of the fork block `N`, consider blocks with a `gas_limit` greater than `30,000,000` invalid.

MOTIVATION:
A high gas limit increases pressure on the network. In the benign case, it increases the size of the state and history faster than we can sustain. In the malicious case, it amplifies the devastation of certain denial-of-service attacks.

RATIONALE:
### Why Cap the Gas Limit The gas limit is currently under the control of block proposers. They have the ability to increase the gas limit to whatever value they desire. This allows them to bypass the EIP and All Core Devs processes in protocol decisions that may negatively affect the security and/or decentralization of the network. ### No Fixed Gas Limit A valuable property of proposers choosing the gas limit is they can scale it down quickly if the network becomes unstable or is undergoing certain types of attacks. For this reason, we maintain their ability to


=== EIP-7940 ===
TITLE: Ethereum Shah
TYPE: Informational 
STATUS: Draft
CREATED: 2025-04-28
REQUIRES: 

SUMMARY:
Ethereum needs a Shah. The role of the Shah is to be the "protector". A Shah, empowered by the community and with a mandate to represent their interests, could solve the communication gaps between the Ethereum community and core devs, represent the interests of the Ethereum community (holders, stakers, app devs & businesses especially) to the core devs with a tighter feedback loop, and eventually dissolve their position when the imminent danger of Ethereum coordination failure is meaningfully addressed.

SPECIFICATION:
The Shah SHOULD be elected by the Ethereum community, using a combination of ETH voting, social signalling, and core dev ratification. The Shah SHOULD be singularly responsible for deciding on the EIP inclusion roadmap, as well as having veto power over which EIPs to include. The Shah SHOULD maintain communication channels with the Ethereum community (holders, stakers, app devs & businesses) to understand their needs & request feedback on EIPs. The Shah SHOULD play a coordinator role in the All Core Devs (ACD) calls, and submit a quarterly progress update to Ethereum stakeholders. The Shah SHOULD NOT have

MOTIVATION:
It is clear from recent events that Ethereum is suffering from a coordination breakdown between the user ecosystem and the core devs. A case in point is the EOF debacle, with years wasted in EOF development that ~~seems ultimately likely to be~~ was just rejected as a result of 1) fragmented communication between researchers/core devs and the greater Ethereum ecosystem, to the extent that even tentative supporters of EOF weren't aware of the toolchain update requirements on the rest of the ecosystem as well as 2) a lack of rigorous compatibility testing such that EOF exposes protocol level

RATIONALE:
During times of war, the Roman Senate would elect an "Imperator" that would be responsible for dealing with an imminent threat, and once the threat was dealt with, would abdicate their power. The Shah is a similar concept, but rooted in the culture of the Persian Empire, which pioneered a "pluralistic" multi-national empire that respected cultural and religious diversity of its member nations—as aligned with Ethereum's culture of plurlism today. This EIP is largely inspired by Greg the Greek's post (below) about the EF core devs lacking strong leadership who can take responsibility for saying "NO" to EIPs


=== EIP-6465 ===
TITLE: SSZ withdrawals root
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-08
REQUIRES: 2, 7, 1, 8, ,,  , 4, 8, 9, 5, ,,  , 6, 4, 0, 4, ,,  , 7, 4, 9, 5, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated here for reference. | Name | SSZ equivalent | | - | - | | [`ValidatorIndex`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/phase0/beacon-chain.md#custom-types) | `uint64` | | [`Gwei`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/phase0/beacon-chain.md#custom-types) | `uint64` | | [`ExecutionAddress`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/bellatrix/beacon-chain.md#custom-types) | `Bytes20` | [`WithdrawalIndex`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/capella/beacon-chain.md#custom-types) | `uint64` | ### Withdrawals New withdrawals use a normalized SSZ representation. The existing consensus [`Withdrawal`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/capella/beacon-chain.md#withdrawal) SSZ container is

MOTIVATION:
While the consensus `ExecutionPayloadHeader` and the execution block header map to each other conceptually, they are encoded differently. This EIP aims to align the encoding of the `withdrawals_root`, taking advantage of the more modern SSZ format. This brings several advantages: 1. **Reducing complexity:** The proposed design reduces the number of use cases that require support for Merkle-Patricia Trie (MPT). 2. **Reducing ambiguity:** The name `withdrawals_root` is currently used to refer to different roots. While the execution block header refers to a Merkle Patricia Trie (MPT) root, the consensus `ExecutionPayloadHeader` instead refers to an SSZ root. With these changes,

RATIONALE:
This change was originally a candidate for inclusion in Shanghai, but was postponed to accelerate the rollout of withdrawals.


=== EIP-3322 ===
TITLE: Account gas storage opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-03-04
REQUIRES: 

SUMMARY:
Contracts can persist gas for later transfer to the refund counter. Three opcodes are introduced to read, add to, and use this gas counter.

SPECIFICATION:
Contract accounts gain an unsigned gas refund counter, initially zero. Three new opcodes are introduced to manage this state. * `SELFGAS` (`0x49`): Pushes the current account's gas refund counter onto the stack. Shares gas pricing with `SELFBALANCE`. * `USEGAS` (`0x4a`): Pops `amount` from the stack. The minimum of `amount` and the current account's gas refund counter is transferred to the execution context's refund counter. Costs `5000` gas. * `STOREGAS` (`0x4b`): Pops `amount` from the stack. Costs `5000 + amount` gas. Increases the current account's gas refund counter by `amount`.

MOTIVATION:
The refund mechanism is currently being used by gas tokens to arbitrage gas price. This brings gas supply elasticity and price stability by moving gas from blocks with less demand to blocks with more demand. Unfortunately this rewards unnecessary state growth. By introducing a superior gas storage mechanism, the gas market will require less storage and computation.

RATIONALE:
By reusing the execution context's refund counter we can reuse its 50% DoS protection, which limits its block elasticity contribution to 2x. The gas costs are based on similar opcodes `SELFBALANCE` and `SSTORE`. Most accounts will store no gas, so the per-account storage overhead should be minimal or even zero in the normal case. The opcode numbers chosen are in the same `0x4X` range as `SELFBALANCE` and `GASLIMIT`.


=== EIP-5450 ===
TITLE: EOF - Stack Validation
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-08-12
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 4, 7, 5, 0

SUMMARY:
Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.

SPECIFICATION:
### Code validation *Remark:* We rely on the notions of *operand stack* and *type section* as defined by [EIP-4750](./eip-4750.md). Each code section is validated independently. #### Instructions validation In the first validation phase defined in [EIP-3670](./eip-3670.md) (and extended by [EIP-4200](./eip-4200.md) and [EIP-4750](./eip-4750.md)) instructions are inspected independently to check if their opcodes and immediate values are valid. #### Operand stack validation In the second validation phase control-flow analysis is performed on the code. *Operand stack height* here refers to the number of stack values accessible by this function, i.e. it does not take into account values of caller functions'

MOTIVATION:
The current EVM performs a number of validity checks for each executed instruction, such as checking for instruction being defined, stack overflow and underflow, and enough amount of gas remaining. This EIP minimizes the number of such checks required at run-time by verifying that no exceptional conditions can happen and preventing the execution and deployment of any invalid code. The operand stack validation provides several benefits: - removes the run-time stack underflow check for all instructions, - removes the run-time stack overflow check for all instructions except `CALLF` and `JUMPF` (`JUMPF` introduced in a separate EIP) , -

RATIONALE:
### Properties of validated code Any code section validated according to operand stack validation has the following properties: 1. There are no unreachable instructions 2. There are no instructions reachable only via backwards jump 3. Operand stack underflow cannot happen. 4. Operand stack overflow can only happen at `CALLF` or `JUMPF` instruction. 5. Multiple forward jump instructions executing at different stack heights may target the same instruction; the stack of target basic block is validated for all possible heights. 6. Any backwards jump instruction can only target an instruction that is executed with equal stack height; this prevents


=== EIP-7927 ===
TITLE: History Expiry Meta
TYPE: Meta 
STATUS: Draft
CREATED: 2025-03-28
REQUIRES: 4444

SUMMARY:
This Meta-EIP documents the activation process and plan for history expiry as well as providing links to other EIPs that are related.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Execution layer client MUST implement [EIP-7642](./eip-7642.md) to support the `eth/69` over DevP2P. Execution layer clients MAY drop pre-merge history according to [EIP-7639](./eip-7639.md). Consensus layer clients SHOULD NOT depend on Execution Layer clients having the deposit logs from pre-merge blocks and SHOULD implement [EIP-6110](./eip-6110.md). ### Mainnet Activation Mainnet activation of history expiry will occur shortly (a few days or weeks) after the activation of the

MOTIVATION:
[EIP-4444](./eip-4444.md) documents the motivation for history expiry itself. This EIP exists to document the process through which history expiry will be activated on mainnet, the testnet activation on Sepolia, devnet testing and other information surrounding history expiry that doesn't fit cleanly in any of the supporting EIPs.

RATIONALE:
### Why wait for Pectra Consensus Layer clients have a dependency on pre-merge deposit logs. [EIP-6110](./eip-6110.md) will remove this dependency when the Pectra fork is activated. ### Why drop Sepolia history The Sepolia history drop is intended as a testing ground for the mainnet activation. ### Why drop Devnet history The Devnet history drop is intended to test prior to Sepolia to avoid any breakage on the Sepolia network. ### Won't this break JSON-RPC History Expiry doesn't require clients to remove this data. It only allows them to. Clients that wish to preserve this history in their client


=== EIP-140 ===
TITLE: REVERT instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-06
REQUIRES: 

SUMMARY:
The `REVERT` instruction will stop execution, roll back all state changes done so far and provide a pointer to a memory section, which can be interpreted as an error code or message. While doing so, it will not consume all the remaining gas.

SPECIFICATION:
On blocks with `block.number >= BYZANTIUM_FORK_BLKNUM`, the `REVERT` instruction is introduced at `0xfd`. It expects two stack items, the top item is the `memory_offset` followed by `memory_length`. It does not produce any stack elements because it stops execution. The semantics of `REVERT` with respect to memory and memory cost are identical to those of `RETURN`. The sequence of bytes given by `memory_offset` and `memory_length` is called "error message" in the following. The effect of `REVERT` is that execution is aborted, considered as failed, and state changes are rolled back. The error message will be available to the caller

MOTIVATION:
Currently this is not possible. There are two practical ways to revert a transaction from within a contract: running out of gas or executing an invalid instruction. Both of these options will consume all remaining gas. Additionally, reverting an EVM execution means that all changes, including LOGs, are lost and there is no way to convey a reason for aborting an EVM execution.


=== EIP-1 ===
TITLE: EIP Purpose and Guidelines
TYPE: Meta 
STATUS: Living
CREATED: 2015-10-27
REQUIRES: 


=== EIP-7768 ===
TITLE: No-Ether transactions with free-for-all tips
TYPE: Meta 
STATUS: Draft
CREATED: 2024-09-14
REQUIRES: 

SUMMARY:
A technique is introduced where an externally-owned account having no Ether can send transactions and pay tips using a new "free-for-all" bucket and using their own `origin.tx`. This requires no client changes and is compatible with existing ecosystem parts.

SPECIFICATION:
### End user process 1. An end user who controls an externally-owned account, say Alice, will prepare transaction(s) she would like to execute and she signs this (series of) transactions. 2. If Alice will like to provide consideration for executing these transactions, she will ensure that a well-known address on the network, "the free-for-all bucket" will control tokens (such as 20, 721, 1155 tokens) at the end of her series of transactions. 3. Alice orders her transaction nonces carefully considering that what will eventually be executed may be: 1. None of them; 2. Only the first; 3. The

MOTIVATION:
There is much interest in third-party-pay transactions on Ethereum and competing networks. Other proposals require changes to the Ethereum client, that transactions be sent to the network (i.e. `tx.origin`) using a separate account and/or other additional things. In contrast, this proposal introduces and standardizes a solution to this problem that works only with existing client and technology, and which preserves the `tx.origin` of the originator of a transaction.

RATIONALE:
This approach can be useful for end users who do not want to or are not able to add Ether to their account. This approach allows to use the correct `origin.tx` which may be required for important transactions like ERC-721 `setApprovalForAll`. This approach may use more gas than other approaches where the consensus client is changed or where transactions can execute from (`origin.tx`) a different account. ### Alternatives considered * Update [EIP-1559](./eip-1559) so that transactions with gasPrice = 0 are legal, but only if the commensurate amount of gas will be burnt by the block preparer in that


=== EIP-689 ===
TITLE: Address Collision of Contract Address Causes Exceptional Halt
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-08-15
REQUIRES: 

SUMMARY:
Some test cases in the consensus test suite try to deploy a contract at an address already with nonempty code. Although such cases can virtually never happen on the main network before the Constantinople fork block, the test cases detected discrepancies in clients' behavior. Currently, the Yellow Paper says that the contract creation starts with the empty code and the initial nonce even in the case of address collisions. To simplify the semantics, this EIP proposes that address collisions cause failures of contract creation.

SPECIFICATION:
If `block.number >= 0`, when a contract creation is on an account with non-zero nonce or non-empty code, the creation fails as if init code execution resulted in an exceptional halt. This applies to contract creation triggered by a contract creation transaction and by CREATE instruction.

MOTIVATION:
This EIP has no practical relevance to the main net history, but simplifies testing and reasoning. This EIP has no effects after Constantinople fork because [EIP-86](./eip-86.md) contains the changes proposed in this EIP. Even before the Constantinople fork, this EIP has no practical relevance because the change is visible only in case of a hash collision of keccak256. Regarding testing, this EIP relieves clients from supporting reversion of code overwriting. Regarding reasoning, this EIP establishes an invariant that non-empty code is never modified.

RATIONALE:
It seems impractical to implement never-used features just for passing tests. Client implementations will be simpler with this EIP.


=== EIP-2387 ===
TITLE: Hardfork Meta: Muir Glacier
TYPE: Meta 
STATUS: Final
CREATED: 2019-11-22
REQUIRES: 1, 6, 7, 9, ,,  , 2, 3, 8, 4

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hard fork named Muir Glacier. This hard fork addresses the impending Ice Age on Ethereum Mainnet and includes a commitment to solving the problems with the ice age more permanently.

SPECIFICATION:
- Codename: Muir Glacier ### Activation - `Block >= 9,200,000` on the Ethereum mainnet - `Block >= 7,117,117` on the Ropsten testnet - `Block >= N/A` on the Kovan testnet - `Block >= N/A` on the Rinkeby testnet - `Block >= N/A` on the Görli testnet ### Included EIPs - [EIP-2384](./eip-2384.md): Istanbul/Berlin Difficulty Bomb Delay

MOTIVATION:
Ethereum achieves a consistent block time due to its' difficulty retargeting algorithm. If a block-time is higher than 20 seconds, it reduces the difficulty, and if a block time is lower than 10 seconds, it increases the difficulty. This mechanism reaches typically an equilibrium of around 13-14 seconds. Included within this mechanism is something we refer to as the Difficulty Bomb or the Ice Age. It artificially adds to the difficulty in such a way that the retargeting mechanism, at some point, can not adapt to the increase, and we see increased block times throughout the network. The

RATIONALE:
I want to address the rationale for the intention of the Iceage and the implementation of the Iceage separately. **The original intentions of the ice age include:** - At the time of upgrades, inhibit unintentional growth of the resulting branching forks leading up to Eth 2.0. * - Encourage a prompt upgrade schedule for the path to Eth 2.0. * - Forces the community to come back into agreement repeatedly...and it gives whatever portion of the community that wants to a chance to fork off - Is a check for the Core Devs in the case that a


=== EIP-233 ===
TITLE: Formal process of hard forks
TYPE: Meta 
STATUS: Stagnant
CREATED: 2017-03-23
REQUIRES: 

SUMMARY:
To describe the formal process of preparing and activating hard forks.

SPECIFICATION:
A Meta EIP should be created and merged as a *Draft* as soon as a new hard fork is planned. This EIP should contain: - the desired codename of the hard fork, - activation block number once decided - a timeline section - an EIPs to include section - the **Requires** header should point to the previous hard fork meta EIP. The draft shall be updated with summaries of the decisions around the hard fork. ### Timeline Once a timeline with key dates is agreed upon for other crucial dates. The basic outline of a hardfork timeline should

MOTIVATION:
Today discussions about hard forks happen at various forums and sometimes in ad-hoc ways.

RATIONALE:
A meta EIP for coordinating the hard fork should help in visibility and traceability of the scope of changes as well as provide a simple name and/or number for referring to the proposed fork.


=== EIP-1930 ===
TITLE: CALLs with strict gas semantic. Revert if not enough gas available.
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-10
REQUIRES: 

SUMMARY:
The current CALL, DELEGATE_CALL, STATIC_CALL opcode do not enforce the gas being sent, they simply consider the gas value as a maximum. This pose serious problem for applications that require the call to be executed with a precise amount of gas. This is for example the case for meta-transaction where the contract needs to ensure the call is executed exactly as the signing user intended. But this is also the case for common use cases, like checking "on-chain" if a smart contract support a specific interface (via [EIP-165](./eip-165.md) for example). The solution presented here is to add new

SPECIFICATION:
There are 2 possibilities a) one is to add opcode variant that have a stricter gas semantic b) The other is to consider a specific gas value range (one that have never been used before) to have strict gas semantic, while leaving other values as before Here are the details description #### option a) - add a new variant of the CALL opcode where the gas specified is enforced so that if the gas left at the point of call is not enough to give the specified gas to the destination, the current call revert - add a

RATIONALE:
Currently the gas specified as part of these opcodes is simply a maximum value. And due to the behavior of [EIP-150](./eip-150.md) it is possible for an external call to be given less gas than intended (less than the gas specified as part of the CALL) while the rest of the current call is given enough to continue and succeed. Indeed since with EIP-150, the external call is given at max ```G - Math.floor(G/64)``` where G is the gasleft() at the point of the CALL, the rest of the current call is given ```Math.floor(G/64)``` which can be plenty enough


=== EIP-6051 ===
TITLE: Private Key Encapsulation
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-11-21
REQUIRES: 

SUMMARY:
This EIP proposes a mechanism to encapsulate a private key so that it could be securely relocated to another application without providing the seed. This EIP combines `ECIES` (Elliptic Curve Integrated Encryption Scheme) and optional signature verification under various choices to ensure that the private key is encapsulated for a known or trusted party.

SPECIFICATION:
### Sender and Recipient We hereby define: - *Sender* as the party who holds in custody the private key to be encapsulated; *Sender Application* as the client-side application that said *Sender* uses to send the encapsulated private key. - *Recipient* as the party who accepts the encapsulated private key, unwraps, and then uses it; *Recipient Application* as the client-side application that *Recipient* uses to receive the encapsulated private key. ### Core Algorithms The basic idea is to encapsulate the private key with ECIES. To ensure that the ephemeral public key to encapsulate the private key is indeed generated

MOTIVATION:
There are various cases in which we might want to export one of many private keys from a much more secure but less convenient wallet, which is controlled with a seed or passphrase. 1. We might dedicate one of many private keys for messaging purposes, and that private key is probably managed in a not-so-secure manner; 2. We might want to export one of many private keys from a hardware wallet, and split it with MPC technology so that a 3rd party service could help us identify potential frauds or known bad addresses, enforce 2FA, etc., meanwhile we

RATIONALE:
A critical difference between this [EIP-6051](./eip-6051.md) with [EIP-5630](./eip-5630.md) is that, as the purpose of key encapsulation is to transport a private key securely, the public key from the key recipient should be ephemeral, and mostly used only one-time. While in EIP-5630 settings, the public key of the message recipient shall be stable for a while so that message senders can encrypt messages without key discovery every time. There is security implication to this difference, including perfect forward secrecy. We aim to achieve perfect forward secrecy by generating ephemeral key pairs on both sides every time: 1) first *Recipient*


=== EIP-6 ===
TITLE: Renaming SUICIDE opcode
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2015-11-22
REQUIRES: 

SUMMARY:
The solution proposed in this EIP is to change the name of the `SUICIDE` opcode in Ethereum programming languages with `SELFDESTRUCT`. ### Motivation Mental health is a very real issue for many people and small notions can make a difference. Those dealing with loss or depression would benefit from not seeing the word suicide in our programming languages. By some estimates, 350 million people worldwide suffer from depression. The semantics of Ethereum's programming languages need to be reviewed often if we wish to grow our ecosystem to all types of developers. An Ethereum security audit commissioned by DEVolution,

MOTIVATION:
Mental health is a very real issue for many people and small notions can make a difference. Those dealing with loss or depression would benefit from not seeing the word suicide in our programming languages. By some estimates, 350 million people worldwide suffer from depression. The semantics of Ethereum's programming languages need to be reviewed often if we wish to grow our ecosystem to all types of developers. An Ethereum security audit commissioned by DEVolution, GmbH and [performed by Least Authority](https://github.com/LeastAuthority/ethereum-analyses/blob/master/README.md) recommended the following: > Replace the instruction name "suicide" with a less connotative word like "self-destruct", "destroy",


=== EIP-7792 ===
TITLE: Verifiable logs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-21
REQUIRES: 6466

SUMMARY:
This EIP defines a method to make the `eth_getLogs` JSON-RPC response verifiable.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Configuration | Name | Value | | - | - | | `LOG_CONTRACT_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | ### Log accumulation After executing all transactions of a block, commitments of all emitted logs are accumulated into the storage of `LOG_CONTRACT_ADDRESS`. The contract has no code, and its storage layout consists of three slots of type `mapping`. However to prevent [EIP-158](./eip-158.md) cleanup, the contract's nonce is

MOTIVATION:
The `eth_getLogs` endpoint is used by wallets to obtain the transaction history pertaining to an account or a topic. To verify correctness and completeness of the logs, a wallet would also have to obtain all block headers and check against their logs bloom. However, that mechanism is inefficient due to its high false positive rate and also involves an unpractical amount of network round trips. This EIP defines a replacement mechanism to efficiently and incrementally verify correctness and completeness of `eth_getLogs` responses.

RATIONALE:
Making the `eth_getLogs` response verifiable adds the necessary security attributes to enable wallets to transition away from relying on trusted data providers, ultimately improving the wallet's privacy guarantees as it is no longer subject to the privacy policy of any given provider. ### Gas cost The gas cost produced by this scheme is significantly higher than what `LOG#` opcodes produce as of Prague, primarily due to the additional `SLOAD` / `SSTORE` and the double cost of `SHA256` opcodes compared to `KECCAK256` opcodes. The gas cost increases outweigh the savings from dropping logs blooms. If the mechanism turns out


=== EIP-3336 ===
TITLE: Paged memory allocation for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-06
REQUIRES: 

SUMMARY:
Presently, the EVM charges for memory as a linear array starting at address 0 and extending to the highest address that has been read from or written to. This suffices for simple uses, but means that compilers have to generate programs that use memory compactly, which leads to wasted gas with reallocation of memory elements, and makes some memory models such as separate heap and stack areas impractical. This EIP proposes changing to a page-based billing model, which adds minimal complexity to implementations, while providing for much more versatility in EVM programs.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `PAGE_BITS` | 10 | | `PAGE_BASE_COST` | 96 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. ### Changes to memory allocation in EVM implementations Memory is now allocated in pages of `2**PAGE_BITS` bytes each. The most significant `256 - PAGE_BITS` bits of each memory address denote the page number, while the least significant `PAGE_BITS` bits of the memory address denote the location in the page. Pages are initialized to contain all zero bytes and allocated when the

MOTIVATION:
Most modern computers implement "virtual memory" for userspace programs, where programs have access to a large address space, with pages of RAM that are allocated as needed by the OS. This allows them to distribute data throughout memory in ways that minimises the amount of reallocation and copying that needs to go on, and permits flexible use of memory for data with different lifetimes. Implementing a simple version of paged memory inside the EVM will provide the same flexibility to compilers targeting the EVM.

RATIONALE:
### Memory expansion gas cost The new gas cost follows the same curve as the previous one, while ensuring that the new gas cost is always less than or equal to the previous cost. This prevents existing programs that make assumptions about memory allocation gas costs from resulting in errors, without unduly discounting memory below what it costs today. Intuitively, a program that uses up to a page boundary pays for one page less than they would under the old model, while a program that uses one word more than a page boundary pays for one word less


=== EIP-7958 ===
TITLE: EVM64 - Little endian opcodes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-26
REQUIRES: 7937

SUMMARY:
This EIP defines additional little endian opcodes that can be deployed alongside [EIP-7937](./eip-7937.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. We define the following gas cost constant: * `G_VERYLOW64`: 2 ### `BYTE64` `BYTE64` (0xc01a) is defined as `(x >> i * 8) & 0xFF`. Note that the definition is changed from big endian to little endian. The gas cost is `G_VERYLOW64`. ### `MLOAD64` and `MSTORE64` `MLOAD64` (0xc051) will load a 64-bit integer in little endian onto the stack. `MSTORE64` (0xc052) will read an 64-bit

MOTIVATION:
The core EIP that defines EVM64 (EIP-7937) is endianness-independent. This EIP defines those additional opcodes that must expose endianness. They are the bitwise opcode `BYTE64`, memory opcodes `MLOAD64` and `MSTORE64`, and stack opcodes `PUSH*64`.

RATIONALE:
For detailed rationale discussion, please see the core EVM64 definition [EIP-7937](./eip-7937.md).


=== EIP-5 ===
TITLE: Gas Usage for `RETURN` and `CALL*`
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-22
REQUIRES: 

SUMMARY:
This EIP makes it possible to call functions that return strings and other dynamically-sized arrays. Currently, when another contract / function is called from inside the Ethereum Virtual Machine, the size of the output has to be specified in advance. It is of course possible to give a larger size, but gas also has to be paid for memory that is not written to, which makes returning dynamically-sized data both costly and inflexible to the extent that it is actually unusable. The solution proposed in this EIP is to charge gas only for memory that is actually written

SPECIFICATION:
The gas and memory semantics for `CALL`, `CALLCODE` and `DELEGATECALL` (called later as `CALL*`) are changed in the following way (`CREATE` does not write to memory and is thus unaffected): Suppose the arguments to `CALL*` are `gas, address, value, input_start, input_size, output_start, output_size`, then, at the beginning of the opcode, gas for growing memory is only charged for `input_start + input_size`, but not for `output_start + output_size`. If the called contract returns data of size `n`, the memory of the calling contract is grown to `output_start + min(output_size, n)` (and the calling contract is charged gas for that)

MOTIVATION:
In general, it is good practice to reserve a certain memory area for the output of a call, because letting a subroutine write to arbitrary areas in memory might be dangerous. On the other hand, it is often hard to know the output size of a call prior to performing the call: The data could be in the storage of another contract which is generally inaccessible and determining its size would require another call to that contract. Furthermore, charging gas for areas of memory that are not actually written to is unnecessary. This proposal tries to solve both

RATIONALE:
This way of dealing with the problem requires a minimal change to the Ethereum Virtual Machine. Other means of achieving a similar goal would have changed the opcodes themselves or the number of their arguments. Another possibility would have been to only change the gas mechanics if `output_size` is equal to `2**256-1`. Since the main difficulty in the implementation is that memory has to be enlarged at two points in the code around `CALL`, this would not have been a simplification. At an earlier stage, it was proposed to also add the size of the returned data on


=== EIP-2 ===
TITLE: Homestead Hard-fork Changes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-15
REQUIRES: 


=== EIP-1015 ===
TITLE: Configurable On Chain Issuance
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-20
REQUIRES: 


=== EIP-4520 ===
TITLE: Multi-byte opcodes prefixed by EB and EC.
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-12-01
REQUIRES: 

SUMMARY:
Reserve `0xEB` and `0xEC` for usage as extended opcode space.

SPECIFICATION:
For example, a new arithmetic opcode may be allocated to `0xEC 01`(`ADD`), and a novel opcode may be introduced at `0xEB F4`(`DELEGATECALL`). Triple byte opcodes may be doubly-prefixed by `0xEB EB`, `0xEC EC`, `0xEB EC` and `0xEC EB`. It is possible to allocate experimental opcodes to this triple-byte space initially, and if they prove safe and useful, they could later be allocated a location in double-byte or single-byte space. Only `0xEB EB`, `0xEC EC`, `0xEC EC`, and `0xEB EC` may be interpreted as further extensions of the opcode space. `0xEB` and `0xEC` do not themselves affect the stack

MOTIVATION:
It would be convenient to introduce new opcodes that are likely to be infrequently used, whilst also being able to have greater than 256 opcodes in total. As a single byte opcode is half the size of a double byte opcode, the greatest efficiency in code sizes will be one where frequently used opcodes are single bytes. Two prefix bytes are used to accommodate up to 510 double byte opcodes.

RATIONALE:
It was considered that two prefix bytes rather than one would be adequate for reservation as extension addresses. Both `0xEB` and `0xEC` were chosen to be part of the E-series of opcodes. For example, the `0xEF` byte is reserved for contracts conforming to the Ethereum Object Format. By having unassigned opcodes for extending the opcode space, there will be a lower risk of breaking the functionalities of deployed contracts compared to choosing assigned opcodes.


=== EIP-2256 ===
TITLE: wallet_getOwnedAssets JSON-RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-08-29
REQUIRES: 5, 5, ,,  , 1, 5, 5, ,,  , 1, 4, 7, 4

SUMMARY:
There is no standardized way for a dApp to request a list of owned assets from a user. Now, each dApp needs to keep a list of all the popular or existing assets and check the user's balance against the blockchain, for each of these assets. This leads to duplicated effort across dApps. It also leads to the user being presented with asset options that the user does not care about, from various, unwanted airdrops.

SPECIFICATION:
New JSON-RPC method to be added to web3 browsers: `wallet_getOwnedAssets`. This method is for dApp-wallet communication and only targets the assets that have already been whitelisted by the wallet, for the user account. **Arguments:** - type `address`, Ethereum address that owns the assets - options object, optional: - `chainId` - type `uint`, chain id respecting [EIP-155](./eip-155.md); optional - `limit` - type `uint`, the maximum number of owned assets expected by the dApp to be returned; optional - `types` - type `string[]`, array of asset interface identifiers such as `['ERC20', 'ERC721']`; optional - `justification` - type `string`, human-readable text

MOTIVATION:
There are financial dApps that require a list of owned assets from a user, for various purposes - calculating taxes, selecting customized payment options, etc. Each of these dApps are now forced to keep a list of popular assets (smart contract addresses, ABIs) and retrieve the user's data from the blockchain, for each asset. This leads to effort duplication and nonoptimal UX where the user is presented with either more or less asset options than the user would like - various airdrops, incomplete list of assets kept by the dApp. This list of owned assets can be retrieved

RATIONALE:
In order to avoid duplication of effort for dApps that require keeping a list of all or popular assets and to provide optimal UX, the `wallet_getOwnedAssets` JSON-RPC method is proposed. The `chainId` and `types` optional parameters enable dApps to provide options in order to restrict the selection list that the user will be presented with by the wallet, in accordance with the dApp's functionality. The `limit` parameter enables the dApp to tell the user an upper limit of accounts that the user can select. It remains to be seen if a lower bound should also be provided. At


=== EIP-5027 ===
TITLE: Remove the limit on contract code size
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-21
REQUIRES: 1, 7, 0, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.

SPECIFICATION:
### Parameters | Constant | Value | | ------------------------- | ---------------- | | `FORK_BLKNUM` | TBD | | `CODE_SIZE_UNIT` | 24576 | | `COLD_ACCOUNT_CODE_ACCESS_COST_PER_UNIT` | 2600 | | `CREATE_DATA_GAS` | 200 | If `block.number >= FORK_BLKNUM`, the contract creation initialization can return data with any length, but the contract-related opcodes will take extra gas as defined below: - For `CODESIZE/CODECOPY/EXTCODESIZE/EXTCODEHASH`, the gas is unchanged. - For CREATE/CREATE2, if the newly created contract size > `CODE_SIZE_UNIT`, the opcodes will take extra write gas as `(CODE_SIZE - CODE_SIZE_UNIT) * CREATE_DATA_GAS`. - For `EXTCODECOPY/CALL/CALLCODE/DELEGATECALL/STATICCALL`, if the contract code size > `CODE_SIZE_UNIT`,

MOTIVATION:
The motivation is to remove the limit on the code size so that users can deploy a large-code contract without worrying about splitting the contract into several sub-contracts. With the dramatic growth of dApplications, the functionalities of smart contracts are becoming more and more complicated, and thus, the sizes of newly developed contracts are steadily increasing. As a result, we are facing more and more issues with the 24576-bytes contract size limit. Although several techniques such as splitting a large contract into several sub-contracts can alleviate the issue, these techniques inevitably increase the burden of developing/deploying/maintaining smart contracts.

RATIONALE:
### Gas Metering The goal is to measure the CPU/IO cost of the contract read/write operations reusing existing gas metering so that the resources will not be abused. - For code-size-related opcodes (`CODESIZE`/`EXTCODESIZE`), we would expect the client to implement a mapping from the hash of code to the size, so reading the code size of a large contract should still be O(1). - For `CODECOPY`, the data is already loaded in memory (as part of `CALL/CALLCODE/DELEGATECALL/STATICCALL`), so we do not charge extra gas. - For `EXTCODEHASH`, the value is already in the account, so we do not


=== EIP-2481 ===
TITLE: eth/66 request identifier
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-01-17
REQUIRES: 2464

SUMMARY:
The `eth` protocol defines various request and response commands that are used to exchange data between Ethereum nodes. For example, to ask a peer node for a specific set of headers, a node sends it the [`GetBlockHeaders`](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md#getblockheaders-0x03) command. *Citing from the [`GetBlockHeaders` spec definition](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md#getblockheaders-0x03):* >`[block: {P, B_32}, maxHeaders: P, skip: P, reverse: P in {0, 1}]` >Require peer to return a `BlockHeaders` message. Reply must contain a number of block headers, of rising number when `reverse` is `0`, falling when `1`, `skip` blocks apart, beginning at block `block` (denoted by either number or hash) in the canonical chain,

SPECIFICATION:
Change the following message types in the `eth` protocol: * `GetBlockHeaders (0x03)` * **Current (eth/65):** `[block: {P, B_32}, maxHeaders: P, skip: P, reverse: P in {0, 1}]` * **Then (eth/66)**: `[request_id: P, [block: {P, B_32}, maxHeaders: P, skip: P, reverse: P in {0, 1}]]` * `BlockHeaders (0x04)` * **Current (eth/65):** `[blockHeader_0, blockHeader_1, ...]` * **Then (eth/66)**: `[request_id: P, [blockHeader_0, blockHeader_1, ...]]` * `GetBlockBodies (0x05)` * **Current (eth/65):** `[hash_0: B_32, hash_1: B_32, ...]` * **Then (eth/66)**: `[request_id: P, [hash_0: B_32, hash_1: B_32, ...]]` * `GetPooledTransactions (0x09)`: * **Current (eth/65)**`[hash_0: B_32, hash_1: B_32, ...]` * **Then (eth/66)**`[request_id: P, [hash_0: B_32,

MOTIVATION:
The lack of request identifiers in the request / response paris of the `eth` protocol puts unnecessary burden of code complexity into every Ethereum client. It also makes the communication slightly less efficient. Another argument can be made that the addition of request identifiers makes the protocol more aligned with the `les` protocol which **does** already defines request identifiers for each request / response pair.

RATIONALE:
**Q: The efficiency gains might encourage clients to flood their peers with too many simultaneous requests** Peers can always throttle or disconnect if they don't feel treated well. This is the same as today. **Q: If `les` already defines the commands like this, why not just use the `les` protocol?** In practice, peers that serve the `les` protocol are much harder to find in the network. The reasons for this are varied but might boil down to client defaults, immature implementations or missing incentives. **Q: Networking works today, isn't this just adding bloat?** This is adding a single


=== EIP-7867 ===
TITLE: Flow Control Wallet Call Capability
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2025-01-17
REQUIRES: 5792

SUMMARY:
This proposal extends [EIP-5792](./eip-5792.md) to allow dapps to downgrade their required atomicity guarantees and control the behaviour after a failed/reverted call. It introduces the batch-scope concept of `strict` vs. `loose` atomicity, where a `strict` batch remains atomic in the face of chain reorgs and a `loose` batch does not; and the per-call ability to continue after a failed/reverted call (`continue`) or stop processing (`halt`).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### RPC Interface The following subsections are modifications to the API endpoints from EIP-5792. If a request does not match the schema defined below, the wallet MUST reject the request with an error code of `INVALID_SCHEMA`. #### `wallet_sendCalls` The following JSON Schema SHALL be inserted, in the request object, as values of either the batch-scope or call-scope `capabilities` objects (as appropriate) with a key

MOTIVATION:
While the base EIP-5792 specification works extremely well for smart contract wallets, it does not allow the expression of the full range of flow control options that wallets can implement. For example, a dapp may only be submitting a batch for gas savings and not care about whether all calls are reverted on failure. A wallet may only be able to offer a limited form of atomicity through block builder backchannels, but that may be sufficient for a trading platform.

RATIONALE:
<!-- The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The current placeholder is acceptable for a draft. TODO: Remove this comment before submitting --> TBD


=== EIP-1985 ===
TITLE: Sane limits for certain EVM parameters
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
Introduce an explicit value range for certain EVM parameters (such as gas limit, block number, block timestamp, size field when returning/copying data within EVM). Some of these already have an implicit value range due to various (practical) reasons.

SPECIFICATION:
If `block.number >= {FORK_BLOCK}`, the following value ranges are introduced. They restrict the results (i.e. values pushed to the stack) of the instructions listed below. 1. *gas*, *gas limit*, *block gas limit* is a range between `0` and `0x7fffffffffffffff` (`2**63 - 1`, `9223372036854775807`). It affects the following instructions: - `GASLIMIT` (`0x45`), - `GAS` (`0x5a`). 2. *block number*, *timestamp* is a range between `0` and `0x7fffffffffffffff` (`2**63 - 1`, `9223372036854775807`). It affects the following instructions: - `TIMESTAMP` (`0x42`), - `NUMBER` (`0x43`). 3. *account address* is a range between `0` and `0xffffffffffffffffffffffffffffffffffffffff` (`2**160 - 1`, `1461501637330902918203684832716283019655932542975`) i.e. the address occupies

MOTIVATION:
Having such an explicit value range can help in creating compatible client implementations, in certain cases it can also offer minor speed improvements, and can reduce the effort needed to create consensus critical test cases by eliminating unrealistic edge cases.

RATIONALE:
These limits have been: - proposed by [EVMC] - implemented partially by certain clients, such as [Aleth], [geth], [Parity] and [ethereumjs] - allowed by certain test cases in the [Ethereum testing suite] - and implicitly also allowed by certain assumptions, such as due to gas limits some of these values cannot grow past a certain limit Most of the limits proposed in this document have been previously explored and tested in [EVMC]. Using the `2**63 - 1` constant to limit some of the ranges: - allows using signed 64-bit integer type to represent it, what helps programming languages


=== EIP-7727 ===
TITLE: EVM Transaction Bundles
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-06-24
REQUIRES: 2718

SUMMARY:
This EIP introduces two new [EIP-2718](./eip-2718.md) transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native 'bundles', which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles offered by builders to searchers. One of the EIP-2718 transactions is an extended normal transaction that supports: - Specifying the entity who can place the transaction in a bundle. - An optional block number that the transaction is valid in. The other EIP-2718 transaction is a 'meta' transaction that

SPECIFICATION:
### Constants | Name | Value | | --- | --- | | DELEGATED_TX_TYPE | 0x05 | | BUNDLE_TX_TYPE | 0x06 | | BUNDLE_BASE_GAS_COST | TBD <!-- TODO --> | | BUNDLE_SIGNER_OPCODE_NUMBER | TBD <!-- TODO --> | ### New Transaction Payload Types Two new [EIP-2718](./eip-2718.md) transactions with types `DELEGATED_TX_TYPE` and `BUNDLE_TX_TYPE`. For the `DELEGATED_TX_TYPE`, the transaction payload should be interpreted as: ```go 0x05 || rlp([ bundleSigner, blockNumber, chainId, nonce, gasPrice, gasLimit, to, value, data, signatureYParity, signatureR, signatureS ]) ``` The `signatureYParity`, `signatureR`, `signatureS` elements of the `DELEGATED_TX_TYPE` represent a secp256k1 signature over: ```go keccak256(0x05 || rlp([bundleSigner, blockNumber,

MOTIVATION:
Currently, a single block builder has unrestricted control over the final sequencing of a block’s transactions. This poses a problem, as sequencing—the choice of who gets to interact with specific pieces of state and in what order—significantly influences value flow. The objective of this EIP is to allow more parties to participate in the construction of single blocks by exposing sequencing concepts inside of the EVM. This change would enable EVM applications to reclaim some of the sequencing value that is currently monopolized by block builders, redirecting it back to the applications themselves.

RATIONALE:
### Allowing invalid transactions to be included in a `BUNDLE_TX_TYPE`'s `transactionList` Knowing how a transaction will execute is challenging without knowing the state root to which the transaction is applied. Creators of `BUNDLE_TX_TYPE` transactions can only access the previous block’s state root and cannot predict which transactions will precede the `BUNDLE_TX_TYPE` transaction in the upcoming block's total order. If only valid transactions were permitted, `BUNDLE_TX_TYPE` transaction lists could be easily invalidated by a single inner transaction attempting to grief the bundle through nonce or gas invalidations. ### Charging the `BUNDLE_TX_TYPE`'s signer `CALLDATA` gas costs for invalid transactions Blockchains


=== EIP-7938 ===
TITLE: Exponential Gas Limit Increase
TYPE: Informational 
STATUS: Draft
CREATED: 2025-04-27
REQUIRES: 

SUMMARY:
This proposal introduces a deterministic gas limit growth schedule via client-side defaults. Ethereum clients will vote to increase the gas limit according to an exponential schedule unless explicitly configured otherwise by the user. The gas limit increase occurs every beacon chain epoch, aligned to a factor-of-10 increase every approximately 164,250 epochs (2 years). It will stop after 4 years when an updated gas increase schedule should be decided and committed to.

SPECIFICATION:
### Schedule Let `G0 = 50,000,000` be the gas limit at the activation epoch. Let the activation epoch be Ethereum beacon chain **epoch 369017**, which corresponds to approximately June 1, 2025. Let `t` be the current beacon chain epoch and `t0 = 369017` be the activation epoch. Let `T = 164,250` be the number of epochs for a 10x increase. The gas limit at epoch `t` is calculated as follows: ```text G(t) = { current default limit, if t < t0 round(G0 * 10^((t-t0)/T)), if t0 ≤ t ≤ t0 + 2*T 100 * G0, if t >

MOTIVATION:
The current gas limit mechanism relies on miner/operator voting, which lacks coordination and predictability. While flexible, this approach can lead to stagnation or overly cautious increases. By introducing a predictable exponential growth pattern as a client default, this EIP encourages a sustainable and transparent gas limit trajectory, aligned with expected advancements in hardware and protocol efficiency.

RATIONALE:
This EIP maintains Ethereum's current gas voting mechanism but enhances it with a predictable and community-coordinated trajectory. By distributing responsibility across clients rather than enforcing protocol changes via consensus rules, this proposal offers flexibility while encouraging scalability. The exponential growth model ensures gradual but significant increases, allowing the network to adapt while targeting ambitious throughput goals.


=== EIP-150 ===
TITLE: Gas cost changes for IO-heavy operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-09-24
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then: - Increase the gas cost of EXTCODESIZE to 700 (from 20). - Increase the base gas cost of EXTCODECOPY to 700 (from 20). - Increase the gas cost of BALANCE to 400 (from 20). - Increase the gas cost of SLOAD to 200 (from 50). - Increase the gas cost of CALL, DELEGATECALL, CALLCODE to 700 (from 40). - Increase the gas cost of SELFDESTRUCT to 5000 (from 0). - If SELFDESTRUCT hits a newly created account, it triggers an additional gas cost of 25000 (similar to CALLs). - Increase the recommended gas

RATIONALE:
Recent denial-of-service attacks have shown that opcodes that read the state tree are under-priced relative to other opcodes. There are software changes that have been made, are being made and can be made in order to mitigate the situation; however, the fact will remain that such opcodes will be by a substantial margin the easiest known mechanism to degrade network performance via transaction spam. The concern arises because it takes a long time to read from disk, and is additionally a risk to future sharding proposals as the "attack transactions" that have so far been most successful in


=== EIP-616 ===
TITLE: SIMD Operations for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-04-25
REQUIRES: 


=== EIP-7889 ===
TITLE: Emit log on revert
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-02-20
REQUIRES: 

SUMMARY:
All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.

SPECIFICATION:
### Parameters <!-- TODO --> * `REVERTTOPIC`: `TBD` * `DATA_LIMIT`: `TBD` ### Functionality Whenever `REVERT` is called with non-zero size, emit a log identical to a LOG1 with the topic `REVERTTOPIC`. The log data is the raw bytes of the revert message. The data is truncated to `DATA_LIMIT`.

MOTIVATION:
Revert messages are currently inaccessible to users as they are not available via standard RPC. Instead, users have to request a node to trace the transaction and check the stack and memory at the moment when the REVERT opcode was executed. This introduces overhead for users and nodes - users must make an additional request to find out why their transaction failed, and the node has to replay the full transaction (which may be slow and computationally expensive) to get back a relatively small piece of data. Currently it is up to smart wallet developers to emit logs

RATIONALE:
This is the simplest possible implementation that allows revert messages to be accessible via RPC methods. It does not require any changes to client libraries, or other RPC consumers as it is backward compatible. It does not introduce new RPC methods or new opcodes.


=== EIP-7668 ===
TITLE: Remove bloom filters
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.

SPECIFICATION:
The logs bloom of an execution block is now required to be empty (ie. 0 bytes long). The logs bloom of a transaction receipt is now required to be empty (ie. 0 bytes long).

MOTIVATION:
Logs were originally introduced to give applications a way to record information about onchain events, which decentralized applications (dapps) would be able to easily query. Using bloom filters, dapps would be able to quickly go through the history, identify the few blocks that contained logs relative to their application, and then quickly identify which individual transactions have the logs that they need. In practice, this mechanism is far too slow. Almost all dapps that access history end up doing so not through RPC calls to an Ethereum node (even a remote-hosted one), but through centralized extra-protocol services. This

RATIONALE:
This is a minimally disruptive way to remove the need to handle blooms from clients. A future EIP can later clean up by removing this field entirely, along with other fields that have been deprecated. Gas costs of LOG are not reduced, because while the externality of polluting the bloom filter no longer needs to be accounted for, the costs of hashing have increased due to the needs of ZK-SNARK EVM implementations.


=== EIP-7896 ===
TITLE: ABI attachment in `wallet_sendCalls`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2025-02-27
REQUIRES: 5792

SUMMARY:
This EIP extends [EIP-5792](./eip-5792.md) with a new `interfaces` capability, whereby an application can attach the contract interface specifications (aka. ABIs) that the wallet needs to reliably decode the calldata in the request.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A new capability called `interfaces` is added to EIP-5792 requests. ### `wallet_sendCalls` When this capability is supported, `wallet_sendCalls` requests MAY include a global `interfaces` field. The `interfaces` field provided by an application MUST map contract addresses to interface specs. These contract addresses SHOULD correspond to those of the `to` fields in the `calls` array of the request, and SHOULD be compared with them case-sensitively.

MOTIVATION:
The security model of Ethereum accounts relies on a separation of concerns between applications and wallets, the latter being responsible for securing private key material and providing restricted access to it. When an application requests a transaction or a signature, the wallet prompts the user to accept it or reject it. The user is expected to make an assessment about the desirability of the operation, given that it can potentially operate on all account assets, in the extreme case "draining" them all for the benefit of an attacker. The wallet is tasked with providing information about the request

RATIONALE:
<!-- TODO -->


=== EIP-7713 ===
TITLE: Box type for EIP-712 messages
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2024-05-23
REQUIRES: 712

SUMMARY:
This EIP defines a new type `box` for use in [EIP-712](./eip-712.md) messages. A `box` value is a value of an arbitrary struct type whose underlying type is encapsulated and hidden from the outer struct but transparent and type-checkable by the wallet, and thus able to be fully inspected by the user prior to signing. A verifying contract can be made agnostic to the underlying type of a `box` value, but this type is not erased and can be verified on-chain if necessary.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. EIP-712 is extended as follows: ### Typed structured data A struct type may contain a *boxed member* by declaring it with type `box`. Example: ```solidity struct Envelope { address account; box contents; } ``` A boxed member has an underlying *unboxed type*, which is an arbitrary struct type and may be different in each message. ### `encodeType` A boxed member is encoded as `"box

MOTIVATION:
EIP-712 signatures have become a widely used primitive for users to express and authorize intents off-chain. Wide-ranging applications are able to define parameterized messages for users to sign in their wallet through a general-purpose interface that clearly surfaces the type, parameters, and domain of authorization. This crucially applies to hardware wallets as a last line of defense. The general-purpose nature of EIP-712 is key to its success, but in addition wallets are able to develop special-purpose interfaces and capabilities for specific types of messages as they become more widely used. For example, [ERC-2612](./eip-2612.md) Permits are a well-known EIP-712

RATIONALE:
TBD <!-- TODO -->


=== EIP-2488 ===
TITLE: Deprecate the CALLCODE opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-12-20
REQUIRES: 7

SUMMARY:
Deprecate `CALLCODE` in a *somewhat* backwards compatible way, by making it always return failure.

SPECIFICATION:
If `block.number >= FORK_BLOCK`, the `CALLCODE` (`0xf2`) instruction always returns `0`, which signals failure.

MOTIVATION:
`CALLCODE` was part of the Frontier release of Ethereum. In the first few weeks/months it became clear that it cannot accomplish its intended design goal. This was rectified with introducing `DELEGATECALL` ([EIP-7](./eip-7.md)) in the Homestead update (early 2016). `CALLCODE` became never utilized, but it still puts a burden on EVM implementations. Disabling it will not improve the situation for any client whose goal is to sync from genesis, but would help light clients or clients planning to sync from a later point in time.

RATIONALE:
It would be possible just to remove the opcode and exceptionally abort if it is encountered. However, by returning failure, the contract has a chance to act on it and potentially recover.


=== EIP-4345 ===
TITLE: Difficulty Bomb Delay to June 2022
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-10-05
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 10_700_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
Targeting for The Merge to occur before June 2022. If it is not ready by then, the bomb can be delayed further.

RATIONALE:
The following script predicts a ~0.1 second delay to block time by June 2022 and a ~0.5 second delay by July 2022. This gives reason to address because the effect will be seen, but not so much urgency we don't have space to work around if needed. ```python def predict_diff_bomb_effect(current_blknum, current_difficulty, block_adjustment, months): ''' Predicts the effect on block time (as a ratio) in a specified amount of months in the future. Vars used for predictions: current_blknum = 13423376 # Oct 15, 2021 current_difficulty = 9545154427582720 block adjustment = 10700000 months = 7.5 # June 2022 months =


=== EIP-7903 ===
TITLE: Remove Initcode Size Limit
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-05
REQUIRES: 1, 7, 0, ,,  , 3, 8, 6, 0

SUMMARY:
This EIP proposes the removal of the `initcode` size limit of 49152 bytes introduced in [EIP-3860](./eip-3860). The restriction complicates deploying multiple contracts addressing the [EIP-170](./eip-170) limit (24576 bytes) within a single transaction, while the existing gas metering for `initcode`, already ensures fair `initcode` costing, including for `JUMPDEST` analysis.

SPECIFICATION:
Revert the `initcode` size limit introduced in EIP-3860. Specifically: - Remove the 49152-byte cap on `initcode` size during contract creation. - Retain existing gas costs for `initcode` execution, including the 2 gas per byte for `JUMPDEST` analysis, as defined in EIP-3860. No changes to deployed contract size limits (EIP-170) or gas schedules beyond removing the size restriction are proposed.

MOTIVATION:
The EIP-3860 `initcode` size limit imposes an unnecessary constraint on deployment patterns, particularly for creation transactions creating large _logical_ contracts composed of multiple _physical sub-contracts_ in a single transaction. A key argument for retaining EIP-170's 24KB runtime code limit is that high-level languages (HLLs) should abstract it away. However, the EIP-3860 limit prevents HLLs from cleanly abstracting this, as deploying large logical contracts exceeding 49152 bytes of `initcode` requires splitting into multiple transactions, undermining the abstraction. Removing the cap simplifies smart contract deployment and enables HLLs to cleanly abstract large contracts, without compromising network security or cost attribution.

RATIONALE:
This proposal is driven by the need to restore flexibility in contract deployment patterns, such as factory contracts creating multiple sub-contracts in one transaction. The design decision to remove the 49152-byte cap leverages the pre-existing gas metering system, which scales linearly with `initcode` size (i.e., 2 gas per byte), ensuring fair cost attribution without artificial limits. A key justification for EIP-170's 24576-byte limit is that high-level languages (HLLs) should abstract it away. However, EIP-3860's `initcode` cap undermines this by forcing multi-transaction deployments for large contracts, breaking the abstraction HLLs aim to provide. Removing the cap aligns with this


=== EIP-2228 ===
TITLE: Canonicalize the name of network ID 1 and chain ID 1
TYPE: Informational 
STATUS: Final
CREATED: 2019-08-04
REQUIRES: 

SUMMARY:
The name for the Ethereum network with network ID 1 and chain ID 1 shall be Ethereum Mainnet or just Mainnet. This is a proper noun. This standard specifies the name for this network and provides reference examples in an effort to standardize the word choice and provide a common language for use to refer to this network.

SPECIFICATION:
The network name for network ID 1 and chain ID 1 shall be Ethereum Mainnet, or just Mainnet if the context is known to be discussing Ethereum networks. This IS a proper noun. Several examples are given below which differentiate between usage of the name of the network versus a descriptive reference to the network. Any name or word styling (i.e. capitalization of the letters) of the network which is inconsistent with the test cases cited below shall NOT be used. ### Trademark note "Ethereum" is trademarked by the Ethereum Foundation. For more information on your obligations when

MOTIVATION:
The Ethereum network with network ID 1 and chain ID 1 is referenced using several conflicting names across EIPs, client implementations, and information published on the internet at large. In several locations, even documents written by the same author use inconsistent names to refer to the Ethereum network with network ID 1 and chain ID 1. Names in use at the time of this writing include: * "main net" * "mainnet" * "Main net" * "Mainnet"

RATIONALE:
Choosing common word use promotes interoperability of implementations and increases customer awareness. Also, it adds a sense of professionalism when customers see the same word and word styling (i.e. capitalization of letters) across different implementations. Anybody that has travelled to certain countries and seen an "IPhone [sic]" repair store should immediately recognize that this is off-brand and unofficial. Likewise, the astute customer of Ethereum should recognize if they see the network referred to using inconsistent names in different software, so let's avoid this.


=== EIP-3300 ===
TITLE: Phase out refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-26
REQUIRES: 

SUMMARY:
This EIP would define a block when the `SSTORE` and `SELFDESTRUCT` refunds would begin to diminish. The refund would step linearly downward, eroding the implicit value of such refunds at an accelerating pace.

SPECIFICATION:
Parameters: * `FORK_BLOCK_NUM`: EIP-3300 activation block * `REFUND_DECAY_STEP`: 1 gas * `REFUND_DECAY_FREQUENCY`: 100 blocks Computed: * `REFUND_DECAY`: `REFUND_DECAY_STEP * ceil((block.number + 1 - FORK_BLOCK_NUM) / REFUND_DECAY_FREQUENCY)` On the block this EIP activates, and again every `REFUND_DECAY_FREQUENCY` blocks, all gas refunds, including `SELFDESTRUCT` and `SSTORE` would diminish by `REFUND_DECAY_STEP`, until 0. The current difference is called the `REFUND_DECAY`, which shall be subtracted from each gas refund. For gas-cost regimes with refund removals that cancel prior refunds, the invariant that the refund counter cannot go negative will be preserved by diminishing the magnitude of those removals by `REFUND_DECAY`, until 0.

MOTIVATION:
Refunds increase block elasticity, so the block gas target can exceed the number established by miners by up to 2x. This can cause hesitancy for miners to increase the block gas target. Refunds, tokenized or not, are valuable to their holders, especially during congestion. If refunds must be removed, a gradual change in their value would be less-disruptive to the gas market than sudden abolition. Refund consumption would proceed, especially during periods of congestion, and the refunds would be cleaned up from the state. Refund creation, driven by demand, would naturally diminish as the efficiency of the refunds

RATIONALE:
Persisted refunds would become worthless before they fall below their activation cost. Once the refunds are worthless, they can be removed by another hard fork without waiting for 0. The rate of diminishing specified would currently require (24000-5000) * 100 = 1,900,000 blocks for `SELFDESTRUCT` and (15000-5000) * 100 = 1,000,000 blocks for `SSTORE`. This timeframe is currently about a year, which should be enough flexibility for the remaining refunds to be consumed.


=== EIP-7519 ===
TITLE: Atomic Storage Operations SCREDIT and SDEBIT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-09-16
REQUIRES: 2, 2, 0, 0, ,,  , 2, 9, 2, 9

SUMMARY:
Two new opcodes that atomically mutate smart contract storage are proposed: SCREDIT, which increments a storage slot by a specified value, and SDEBIT, which decrements a storage slot by a specified value. Overflow and underflow errors are enforced, reverting when an unsigned 256-bit integer would overflow or underflow.

SPECIFICATION:
Two operations to atomically increment and decrement a storage will be introduced at `0xTBD`. Each operation takes two stack arguments and has no immediate arguments. Gas schedule will be the same as SSTORE. | Mnemonic | Op | Input | Output | |-----------|-----------|-------|--------| | `SCREDIT` | `0xTBD` | `2` | `0` | | `SDEBIT` | `0xTBD+1` | `2` | `0` | ### SCREDIT `SCREDIT: slot, value` #### Description Adds `value` to the value stored in contract storage `slot.` If an overflow would occur the operation halts exceptionally. #### Gas Charging Gas charging is identical to SSTORE. including interactions

MOTIVATION:
There has been a large amount of energy around parallel EVMs across multiple chains, however there is a lack of parallel primitives within the EVM to support any model other than optimistic concurrency control (OCC). By adding concurrent increment and decrement operations more advanced parallel environments can be introduced in Layer 2 networks. This also provides the opportunity to serve the principal use case of increment and decrement: token balances. We can introduce failures on overflow and underflow conditions and provide an operation that is also useful outside of parallel use cases.

RATIONALE:
The primary consideration when choosing between alternatives is that the primary intended audiences is token contracts and other asset-tracking contracts combined with a desire to ship the minimum necessary changes to enable that use case. General concurrency controls is not a goal of this EIP. ### Enforcing Overflow Semantics When allowing for out-of-order execution there needs to be mechanism to handle any possible order of execution. OCC handles this by validating pre- and post-conditions, and re-evaluating the transactions if those invariants did not hold. This technique breaks down around writing to balances and counters. Increment/decrement with rollover checking


=== EIP-615 ===
TITLE: Subroutines and Static Jumps for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2016-12-10
REQUIRES: 

SUMMARY:
EVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine—including the compilers—are sufficiently performant to reduce the need for precompiles and otherwise meet the network's long-term demands. This proposal identifies dynamic jumps as a major reason for these issues, and proposes changes to the EVM specification to address the problem, making further efforts towards a safer and more performant the EVM possible. We also propose to validate—in near-linear time—that EVM contracts correctly use subroutines, avoid misuse

SPECIFICATION:
### Dependencies > **[EIP-1702](./eip-1702.md). Generalized Account Versioning Scheme.** This proposal needs a versioning scheme to allow for its bytecode (and eventually eWasm bytecode) to be deployed with existing bytecode on the same blockchain. ### Proposal We propose to deprecate two existing instructions—`JUMP` and `JUMPI`—and propose new instructions to support their legitimate uses. In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price. Especially important is efficient translation to and from [eWasm](https://github.com/ewasm/design) and to machine code. To that end we maintain a close

MOTIVATION:
Currently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack. Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs. So dynamic jumps cannot be avoided, yet they obscure the structure of the code and thus mostly inhibit control- and data-flow analysis. This puts the quality and speed of optimized compilation fundamentally at odds. Further, since many jumps can potentially be to any jump destination in the code, the number of possible paths through the code can go

RATIONALE:
This design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment. It was also informed by the lead author's previous work implementing Java and Scheme interpreters. As such there was very little room for alternative designs. As described above, the approach was simply to deprecate the problematic dynamic jumps, then ask what opcodes were necessary to provide for the features they supported. These needed to include those provided by eWasm, which themselves were modeled after typical hardware. The only real innovation was to move the frame


=== EIP-5000 ===
TITLE: MULDIV instruction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-03-14
REQUIRES: 

SUMMARY:
Introduce a new instruction, `MULDIV(x, y, z)`, to perform `((x * y) / z) % 2**256` in 512-bit precision. `z = 0` is a special case for `(x * y) / 2**256`.

SPECIFICATION:
A new instruction is introduced: `MULDIV` (`0x1e`). - Pops 3 values from the stack, first `x`, then `y` and `z`. - If `z == 0`, `r = (uint512(x) * y) / 2**256`. - Otherwise `r = (uint512(x) * y / z) % 2**256`, where the intermediate calculation is performed with 512-bit precision. - Pushes `r` on the stack. ```python # operations `*` and `//` are done in 512 bit precision def muldiv(x, y, z): if z == 0: return (x * y) // (2**256) else: return ((x * y) // z) % (2**256) ``` The cost of the

MOTIVATION:
Fixed point operations in high level languages are very commonly used on Ethereum, especially in the domain of financial applications. While fixed point addition and subtraction can be done with merely `add` and `sub` respectively, being able to efficiently do fixedpoint multiplication and division is a very sought after feature. A commonly used workaround relies on a `mulmod`-based, rather complex implementation (taking around 50 instructions, excluding stack manipulation). This instruction reduces that to a single opcode. A secondary use case is likely in cryptographic applications, where the `muldiv` instruction allows full precision 256x256->512 multiplication. `mul(x y)` (or `muldiv(x,

RATIONALE:
### The special 0 case All the arithmetic instructions in EVM handle division or modulo 0 specially: the instructions return 0. We have decided to break consistency in order to provide a flexible opcode, which can be used to detect wrapping behaviour. Alternate options include: - Returning a flag for wrapping - Returning two stack items, higher and lower order bits - Compute the higher order 256 bits in EVM: ```solidity /// Returns `hi` such that `x × y = hi × 2**256 + mul(x, y)` function hob(uint x, uint y) returns (uint hi) { uint uint_max =


=== EIP-7688 ===
TITLE: Forward compatible consensus data structures
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-04-15
REQUIRES: 6, 1, 1, 0, ,,  , 7, 0, 0, 2, ,,  , 7, 2, 5, 1, ,,  , 7, 4, 9, 5, ,,  , 7, 5, 4, 9, ,,  , 7, 5, 6, 9, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP defines the changes needed to adopt `ProgressiveContainer` from [EIP-7495](./eip-7495.md) and `ProgressiveList` from [EIP-7916](./eip-7916.md) in consensus data structures.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `Container` conversion `Container` types that are expected to evolve over forks SHALL be redefined as `ProgressiveContainer(active_fields=[1] * len(type.fields()))`. For example, given a type in the old fork: ```python class Foo(Container): a: uint8 b: uint16 ``` This type can be converted to support stable Merkleization in the new fork: ```python class Foo(ProgressiveContainer(active_fields=[1, 1])): a: uint8 b: uint16 ``` As part of the conversion, a

MOTIVATION:
Ethereum's consensus data structures make heavy use of [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md) `Container`, which defines how they are serialized and merkleized. The merkleization scheme allows application implementations to verify that individual fields (and partial fields) have not been tampered with. This is useful, for example, in smart contracts of decentralized staking pools that wish to verify that participating validators have not been slashed. While SSZ `Container` defines how data structures are merkleized, the merkleization is prone to change across the different forks. When that happens, e.g., because new features are added or old features get removed, existing verifier implementations

RATIONALE:
### Best timing? Applying this EIP breaks `hash_tree_root` and Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by a `Container` reaching a new power of 2 in its number of fields. ### Can this be applied retroactively? While `Profile` serializes in the same way as the legacy `Container`, the merkleization and `hash_tree_root` of affected data structures changes. Therefore, verifiers that wish to process Merkle proofs of legacy variants still need to support the corresponding


=== EIP-1872 ===
TITLE: Ethereum Network Upgrade Windows
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-03-25
REQUIRES: 

SUMMARY:
Four different weeks, spaced roughly evenly throughout the year, are targeted for network upgrades to be launched. Regular network upgrades should announce their intention to launch in a particular window early in their process and choose a block number four to six weeks prior to that window. If a network upgrade is cancelled then it would be rescheduled for the next window. Not all windows will be used. Priority upgrades outside the roadmap may be scheduled in the third week of any month, but such use is discouraged. Critical upgrades are scheduled as needed.

SPECIFICATION:
Scheduling is defined for three categories of network upgrades. First are `Roadmap` network upgrades that include deliberate protocol improvements. Next are `Priority` network updates, where there are technical reasons that necessitate a prompt protocol change but these reasons do not present a systemic risk to the protocol or the ecosystem. Finally, `Critical` network upgrades are to address issues that present a systemic risk to the protocol or the ecosystem. ### Roadmap Network Upgrades Roadmap network upgrades are network upgrades that are deliberate and measured to improve the protocol and ecosystem. Historical examples are Homestead, Byzantium, and Constantinople. Roadmap

MOTIVATION:
The aim of this EIP is to provide some level of regularity and predictability to the Ethereum network upgrade/hard fork process. This will allow service providers such as exchanges and node operators a predictable framework to schedule activities around. This also provides a framework to regularize the delivery of network upgrades.

RATIONALE:
The rationale for defining launch windows is to give business running Ethereum infrastructure a predictable schedule for when upgrades may or may not occur. Knowing when a upgrade is not going to occur gives the businesses a clear time frame within which to perform internal upgrades free from external changes. It also provides a timetable for developers and IT professionals to schedule time off against.


=== EIP-7778 ===
TITLE: Block Gas Accounting without Refunds
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-01
REQUIRES: 

SUMMARY:
This EIP modifies the block gas accounting mechanism to prevent the circumvention of block gas limits. It proposes that gas refunds, particularly those from SSTORE operations setting storage slots to zero, should not reduce the gas counted toward the block gas limit, while still being applied to transaction gas costs for users.

SPECIFICATION:
### Gas Accounting Changes 1. **User Gas Costs (Unchanged):** - Users continue to receive gas refunds for operations that qualify (e.g., setting storage to zero) - The transaction gas cost remains: `tx.gas_used = gas_used - gas_refund` 2. **Block Gas Accounting (Modified):** - When calculating gas for block gas limit enforcement, refunds are not subtracted - Block gas accounting becomes: `block.gas_used += gas_used` (without subtracting refunds) - Storage discounts that reflect actual reduced computational work (e.g., warm storage access, reverting to original values) remain applied to block gas accounting ### Block Gas Limit Enforcement - The sum of unrefunded

MOTIVATION:
Currently, gas refunds from operations like clearing storage slots (setting to zero) reduce both the transaction gas cost for users and the gas counted toward the block gas limit. This creates a discrepancy between the computational work performed and the gas accounted for in the block. Example: Block `20878522` shows a net usage of 28.5 MGas, but contains 4.01 MGas of refunds, bringing the gross usage to 32.51 MGas—exceeding the block gas limit by 2.51 MGas. This mechanism can be exploited to perform more operations in a block than the gas limit intends to allow, potentially leading to:

RATIONALE:
### Aligning Gas Limits with Computational Work - The block gas limit is designed to constrain the computational load per block - Gas refunds were introduced to incentivize "cleaning up" the state, not to allow exceeding computational limits - By excluding refunds from block gas accounting, we ensure the block gas limit effectively constrains computational load ### Preserving User Incentives - Users still receive gas refunds, maintaining incentives for efficient state management - Only the accounting for block-level constraints changes, not the economics for individual users


=== EIP-7732 ===
TITLE: Enshrined Proposer-Builder Separation
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-06-28
REQUIRES: 

SUMMARY:
This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being a *builder*) and a new duty (submitting *payload timeliness attestations*) to Ethereum validators. The `ExecutionPayload` field of the `BeaconBlockBody` is removed and instead it is replaced by a signed commitment (a `SignedExecutionPayloadHeader` object) from a builder to later reveal the corresponding execution payload. This commitment specifies in particular the blockhash of the execution block and a *value* to be paid to the

SPECIFICATION:
### Execution Layer No changes are required. ### Consensus Layer The full consensus changes can be found in the consensus-specs Github repository. They are split between: - [Beacon Chain](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/beacon-chain.md) changes. - [Fork choice](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/fork-choice.md) changes. - [P2P](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/p2p-interface.md) changes. - [Honest validator guide](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/validator.md) changes. - A new [honest builder](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/builder.md) guide. - [Fork logic](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/fork.md) changes. A summary of the main changes is included below, the [Rationale](#rationale) section contains explanation for most of the design decisions around these changes. #### Beacon chain changes ##### Constants | Name | Value | | - | - | | `DOMAIN_BEACON_BUILDER` | `DomainType('0x1B000000')` | | `DOMAIN_PTC_ATTESTER`

MOTIVATION:
This EIP solves a different set of unrelated important problems. - An overwhelming majority of beacon block proposers outsource the construction of the execution payload within their blocks to a third party (henceforth called a *builder*). In order to do so, they request the hash tree root (HTR) of a promised execution payload and submit a `SignedBlindedBeaconBlock` to a trusted party that is tasked with replacing the HTR with the full execution payload (received from the builder) before broadcasting. This EIP allows for a trust-free fair exchange between the beacon block proposer and the builder, guaranteeing that an

RATIONALE:
### Staked builders Being a builder is a new attribution of validators. As such builders are staked in the beacon chain and they have their own withdrawal credential prefix. This allows for in-protocol trustless enforcement of the builder's payment to the proposer. Alternatively, payment could be enforced in the Execution Layer (EL) at the cost of adding the corresponding EL consensus-changing logic. Payments in the EL have the advantage of not requiring the builder to periodically submit deposit transactions to replenish their validator balance. Both systems require availability of funds before the payload is revealed: in the Consensus


=== EIP-3298 ===
TITLE: Removal of refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-02-26
REQUIRES: 

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. Do not apply the `refund`. The description above is sufficient to describe the change, but for the sake of clarity we enumerate all places where gas refunds are currently used and which should/could be removed within a node implementation. 1. Remove all use of the "refund counter" in SSTORE gas accounting, as defined in [EIP 2200](https://eips.ethereum.org/EIPS/eip-2200). Particularly: * If a storage slot is changed and the _current value_ equals the _original

MOTIVATION:
Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It is now widely accepted that the only solution to state growth is some form of [statelessness or state expiry](https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/state_size_management), and if such a solution is implemented, then disused storage slots and contracts would start to be ignored automatically. Gas refunds additionally have multiple harmful consequences: * Refunds give rise

RATIONALE:
A full removal of refunds is the simplest way to solve the issues with refunds; any gains from partial retention of the refund mechanism are not worth the complexity that that would leave remaining in the Ethereum protocol.


=== EIP-3076 ===
TITLE: Slashing Protection Interchange Format
TYPE: Standards Track Interface
STATUS: Last Call
CREATED: 2020-10-27
REQUIRES: 

SUMMARY:
A standard format for transferring a key's signing history allows validators to easily switch between clients without the risk of signing conflicting messages. While a common keystore format provides part of the solution, it does not contain any information about a key's signing history. For a validator moving their keys from client A to client B, this could lead to scenarios in which client B inadvertently signs a message that conflicts with an earlier message signed with client A. The interchange format described here provides a solution to this problem.

SPECIFICATION:
### JSON Schema A valid interchange file is one that adheres to the following JSON schema, and is interpreted according to the [Conditions](#conditions). ```json { "title": "Signing history", "description": "This schema provides a record of the blocks and attestations signed by a set of validators", "type": "object", "properties": { "metadata": { "type": "object", "properties": { "interchange_format_version": { "type": "string", "description": "The version of the interchange format that this document adheres to" }, "genesis_validators_root": { "type": "string", "description": "Calculated at Genesis time; serves to uniquely identify the chain" } }, "required": [ "interchange_format_version", "genesis_validators_root" ] }, "data": { "type":

MOTIVATION:
The proof of stake (PoS) protocol penalises validators for voting in ways that could result in two different versions of the chain being finalised. These types of penalties are called slashings. For a validator following the protocol correctly, there is, in principle, no risk of being slashed. However, changing clients (from client A to client B, say) can result in a slashing risk if client B is unaware of the blocks and attestations that were signed with client A. This can occur if client A and client B do not agree on what the present time is. For

RATIONALE:
### Supporting Different Strategies The interchange format is designed to be flexible enough to support the full variety of slashing protection strategies that clients may implement, which may be categorised into two main types: 1. **Complete**: a database containing every message signed by each validator. 2. **Minimal**: a database containing only the latest messages signed by each validator. The advantage of the minimal strategy is its simplicity and succinctness. Using only the latest messages for each validator, safe slashing protection can be achieved by refusing to sign messages for slots or epochs prior. On the other hand, the


=== EIP-2026 ===
TITLE: State Rent H - Fixed Prepayment for accounts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-14
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces a fixed charge for state expansion that comes from adding new accounts to the state. Theoretically, it puts a bound on the number of accounts that can be ever created, because that fixed charge cannot be recycled via mining.

SPECIFICATION:
On and after block `H`, every newly created account gets a new field `rentbalance` of type unsigned 256-bit integer. On and after block `H`, any operation that leads to the creation of a new account, deducts the amount `ACCOUNT_PREPAYMENT` from `tx.origin`. This amount is added to the `rentbalance` field of the created account. On and after block `H`, any operation that modifies an account that does not yet have `rentbalance` field, deducts the amount `ACCOUNT_PREPAYEMENT` from `tx.origin`. This amount is added to the `rentbalance` field of the modified account. This is an anti-hoarding measure. Operations leading to the

MOTIVATION:
The penalty is levied to the transaction sender. Rather than raising the gas cost of account creation (that would direct levy towards the miner), this change directs prepayment into the account's special field, `rentbalance`. It addresses several shortcomings of the simple raising of the gas cost: 1. Prepayments cannot be recycled via mining, which puts a theoretical bound on number of accounts in the state (though it is unlikely to ever be reached). 2. It is not possible for miners to circumvent the penalty or to extend such circumventions onto other users (via private fee rebates, for example).

RATIONALE:
Prior to rent prepayments, other alternatives were considered: 1. Simple raising of the gas cost - discussed in the Motivation section. 1. In [first version of State Rent proposal](https://github.com/ledgerwatch/eth_state/blob/master/State_rent.pdf), there was no notion of extra levy upon account creation. It created a slight usability issue, where newly created contracts with 0 endowment would be evicted in the same block (when rent is introduced). It delays the benefits of the State Rent programme until the actual introduction of rent (in second or third hard-fork). 2. In the [second version of State Rent proposal](https://github.com/ledgerwatch/eth_state/blob/master/State_Rent_2.pdf), there was a notion of lock-up.


=== EIP-2542 ===
TITLE: New opcodes TXGASLIMIT and CALLGASLIMIT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-29
REQUIRES: 

SUMMARY:
Currently, there is an existing opcode `0x45 GASLIMIT` that provides access to the block gas limit. While this information may be useful in some cases, it is probably not a value that smart contract developers may be concerned about. The opcode `0x5a GAS` provides the remaining gas, not the initial one. Also, it is worth noting how existing `0x32 ORIGIN`, `0x33 CALLER`, `0x34 CALLVALUE` and `0x3a GASPRICE` opcodes set a pattern of having access to both the transaction and current execution frame state. TBD: as 0x30 opcode range is exhausted, the proposed opcodes can be added to 0x50

SPECIFICATION:
If block.number >= TBD, add three new opcodes: TXGASLIMIT: 0x5c Pushes the gas limit of the entire transaction onto the stack. This is a value of the 'startgas' parameter signed by the externally owned account. Gas costs: 2 (same as `GASLIMIT`) CALLGASLIMIT: 0x5d Pushes the gas limit of the current execution frame onto the stack. This is the 'callGas' value that was obtained after the application of the EIP-150 “all but one 64th” rule. Gas costs: 2 (same as `GASLIMIT`) Also, consider renaming `0x45 GASLIMIT` to `BLOCKGASLIMIT` to avoid confusion.

MOTIVATION:
As concepts of relaying, meta-transactions, gas fees, and account abstraction gain popularity, it becomes critical for some contracts to be able to track gas expenditure with absolute precision. Without access to this data on an EVM level, such contracts resort to approximation, mimicking EVM logic on-chain, and some use-cases even become infeasible.

RATIONALE:
Consider a solidity smart contract that wants to know how much gas the entire transaction or a part of it had consumed. It is not entirely possible with the current EVM. With proposed changes, using a pseudo-Solidity syntax, this information would be easily available: ``` function keepTrackOfGas(string memory message, uint256 number) public { ... uint gasUsed = msg.gasLimit - gasleft(); } ``` This is an extremely common use case, and multiple implementations suffer from not taking the non-accessible expenses into consideration. The state-of-the-art solution for the `gasUsed` problem is to access 'gasleft()' as the first line of your


=== EIP-5133 ===
TITLE: Delaying Difficulty Bomb to mid-September 2022
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-06-01
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 11_400_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
To avoid network degradation due to a premature activation of the difficulty bomb.

RATIONALE:
The following script predicts the bomb will go off at block 15530314, which is expected to be mined around mid-September. ```python import math def predict_bomb_block(current_difficulty, diff_adjust_coeff, block_adjustment): ''' Predicts the block number at which the difficulty bomb will become noticeable. current_difficulty: the current difficulty diff_adjust_coeff: intuitively, the percent increase in work that miners have to exert to find a PoW block_adjustment: the number of blocks to delay the bomb by ''' return round(block_adjustment + 100000 * (2 + math.log2(diff_adjust_coeff * current_difficulty // 2048))) # current_difficulty = 13891609586928851 (Jun 01, 2022) # diff_adjust_coeff = 0.1 (historically, the bomb is


=== EIP-695 ===
TITLE: Create `eth_chainId` method for JSON-RPC
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-08-21
REQUIRES: 155

SUMMARY:
The `eth_chainId` method should return a single STRING result for an integer value in hexadecimal format, describing the currently configured `CHAIN_ID` value used for signing replay-protected transactions, introduced by [EIP-155](./eip-155.md).

SPECIFICATION:
### `eth_chainId` Returns the currently configured chain ID, a value used in replay-protected transaction signing as introduced by [EIP-155](./eip-155.md). The chain ID returned should always correspond to the information in the current known head block. This ensures that caller of this RPC method can always use the retrieved information to sign transactions built on top of the head. If the current known head block does not specify a chain ID, the client should treat any calls to `eth_chainId` as though the method were not supported, and return a suitable error. #### Parameters None. #### Returns `QUANTITY` - integer

MOTIVATION:
Currently although we can use `net_version` RPC call to get the current network ID, there's no RPC for querying the chain ID. This makes it impossible to determine the current actual blockchain using the RPC.

RATIONALE:
An ETH/ETC client can accidentally connect to an ETC/ETH RPC endpoint without knowing it unless it tries to sign a transaction or it fetch a transaction that is known to have signed with a chain ID. This has since caused trouble for application developers, such as MetaMask, to add multi-chain support.


=== EIP-6963 ===
TITLE: Multi Injected Provider Discovery
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2023-05-01
REQUIRES: 1193

SUMMARY:
An alternative discovery mechanism to `window.ethereum` for [EIP-1193](./eip-1193.md) providers which supports discovering multiple injected Wallet Providers in a web page using Javascript's `window` events.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [RFC-2119]. ### Definitions Wallet Provider: A user agent that manages keys and facilitates transactions with Ethereum. Decentralized Application (DApp): A web page that relies upon one or many Web3 platform APIs which are exposed to the web page via the Wallet. Provider Discovery Library: A library or piece of software that assists a DApp to interact with the Wallet. ### Provider Info Each Wallet Provider will be announced with the following

MOTIVATION:
Currently, Wallet Provider that offer browser extensions must inject their Ethereum providers ([EIP-1193](./eip-1193.md)) into the same window object `window.ethereum`; however, this creates conflicts for users that may install more than one browser extension. Browser extensions are loaded in the web page in an unpredictable and unstable order, resulting in a race condition where the user does not have control over which Wallet Provider is selected to expose the Ethereum interface under the `window.ethereum` object. Instead, the last wallet to load usually wins. This results not only in a degraded user experience but also increases the barrier to entry

RATIONALE:
The previous proposal introduced mechanisms that relied on a single, mutable window object that could be overwritten by multiple parties. We opted for an event-based approach to avoid the race conditions, the namespace collisions, and the potential for "pollution" attacks on a shared mutable object; the event-based orchestration creates a bidirectional communication channel between wallet and dapp that can be re-orchestrated over time. To follow the Javascript event name conventions, the names are written in present tense and are prefixed with the number of this document (`EIP6963`). ### Interfaces Standardizing an interface for provider information (`EIP6963ProviderInfo`) allows a


=== EIP-2935 ===
TITLE: Serve historical block hashes from state
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-09-03
REQUIRES: 

SUMMARY:
Store last `HISTORY_SERVE_WINDOW` historical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact on `BLOCKHASH` resolution mechanism (and hence its range/costs etc).

SPECIFICATION:
| Parameter | Value | | - | - | | `BLOCKHASH_SERVE_WINDOW` | `256` | | `HISTORY_SERVE_WINDOW` | `8191` | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | | `HISTORY_STORAGE_ADDRESS` | `0x0000F90827F1C53a10cb7A02335B175320002935` | This EIP specifies for storing last `HISTORY_SERVE_WINDOW` block hashes in a ring buffer storage of `HISTORY_SERVE_WINDOW` length. Note that `HISTORY_SERVE_WINDOW` > `BLOCKHASH_SERVE_WINDOW` (which remains unchanged). ### Block processing At the start of processing any block where this EIP is active (ie. before processing any transactions), call to `HISTORY_STORAGE_ADDRESS` as `SYSTEM_ADDRESS` with the 32-byte input of `block.parent.hash`, a gas limit of `30_000_000`, and `0` value. This will trigger the

MOTIVATION:
EVM implicitly assumes the client has the recent block (hashes) at hand. This assumption is not future-proof given the prospect of stateless clients. Including the block hashes in the state will allow bundling these hashes in the witness provided to a stateless client. This is already possible in the MPT and will become more efficient post-Verkle. Extending the range of blocks which `BLOCKHASH` can serve (`BLOCKHASH_SERVE_WINDOW`) would have been a semantics change. Using extending that via this contract storage would allow a soft-transition. Rollups can benefit from the longer history window through directly querying this contract. A side

RATIONALE:
Very similar ideas were proposed before. This EIP is a simplification, removing two sources of needless complexity: 1. Having a tree-like structure with multiple layers as opposed to a single list 2. Writing the EIP in EVM code 3. Serial unbounded storage of hashes for a deep access to the history However after weighing pros and cons, we decided to go with just a limited ring buffer to only serve the requisite `HISTORY_SERVE_WINDOW` as [EIP-4788](./eip-4788.md) and beacon state accumulators allow (albeit a bit more complex) proof against any ancestor since merge. Second concern was how to best transition


=== EIP-2926 ===
TITLE: Chunk-Based Code Merkleization
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2020-08-25
REQUIRES: 1, 6, 1, ,,  , 1, 7, 0

SUMMARY:
Code merkleization, along with binarification of the trie and gas cost bump of state-accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing contracts to this model would look like.

SPECIFICATION:
What follows is structured to have two sections: 1. How a given contract code is split into chunks and then merkleized 2. How to merkleize all existing contract codes during a hardfork ### Constants and Definitions #### Constants - `CHUNK_SIZE`: 31 (bytes) - `VERSION_KEY`: `max(u256)` - `VERSION`: 0 - `EMPTY_CODE_ROOT`: `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470` (==`keccak256('')`) - `HF_TIMESTAMP`: to be defined - `ITERATOR_STRIDE`: `TBC` but based on verkle numbers, first devnets should use `50_000` #### Definitions - `BE(x, N)`: casts `x` to an unsigned integer of `N` bytes and returns its big-endian representation ### Code merkleization For an account record `A` with

MOTIVATION:
Bytecode is currently the second contributor to block witness size, after the proof hashes. Transitioning the trie from hexary to binary reduces the hash section of the witness by 3x, thereby making code the first contributor. By breaking contract code into chunks and committing to those chunks in a merkle tree, stateless clients would only need the chunks that were touched during a given transaction to execute it.

RATIONALE:
### Hexary vs binary trie The trie format is chosen to be the same as that of the account trie. If a tree conversion happens at a later stage, the chunk tree will have to be converted as well, e.g. the way it is in [EIP-6800](./eip-6800.md) or [EIP-7864](./eip-7864.md). ### Chunk size The current recommended chunk size of 31 bytes has been selected based on a few observations. Smaller chunks are more efficient (i.e. have higher chunk utilization), but incur a larger hash overhead (i.e. number of hashes as part of the proof) due to a higher trie depth.


=== EIP-3788 ===
TITLE: Strict enforcement of chainId
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-09-02
REQUIRES: 155

SUMMARY:
Reject transactions that do not explicitly have the same chainId as the node's configuration.

SPECIFICATION:
As of the fork block `N`, consider transactions with a `chaindId = 0` to be invalid. Such that transactions are verified based on the nodes configuration. Eg: ``` if (node.cfg.chainId != tx.chainId) { // Reject transaction } ```

MOTIVATION:
Per [EIP-155](./eip-155.md) a transaction with a `chainId = 0` is considered to be a valid transaction. This was a feature to offer developers the ability to submit replayable transactions across different chains. With the rise of evm compatible chains, many of which use forks, or packages from popular Ethereum clients, we are putting user funds at risk. This is because most wallet interfaces do not expose the chainId to the user, meaning they typically do not have insight into what chainId they are signing. Should a malicious actor (or accidental) choose to, they can easily have users submit

RATIONALE:
The configuration set by the node is the main source of truth, and thus should be explicitly used when deciding how to filter out a transaction. This check should exist in two places, as a filter on the JSON-RPC (eg: `eth_sendTransaction`), and strictly enforced on the EVM during transaction validation. This ensures that users will not have transactions pending that will be guaranteed to fail, and prevents the transaction from being included in a block.


=== EIP-2982 ===
TITLE: Serenity Phase 0
TYPE: Informational 
STATUS: Final
CREATED: 2020-09-15
REQUIRES: 

SUMMARY:
This EIP specifies Phase 0 of Serenity (eth2), a multi-phased upgrade to the consensus mechanism for Ethereum mainnet. In Phase 0, the existing PoW chain and mechanics are entirely unaffected, while a PoS chain -- the beacon chain -- is built in parallel to serve as the core of the upgraded consensus. In subsequent phases, the beacon chain is enhanced to support and secure the consensus of a number of parallel shard chains, ultimately incorporating current Ethereum mainnet as one of those shards. At the core of the beacon chain is a proof of stake consensus mechanism called

SPECIFICATION:
Phase 0 is designed to require _no breaking consensus changes_ to existing Ethereum mainnet. Instead, this is the bootstrapping a new PoS consensus that can, once stable, supplant the current PoW consensus. Phase 0 specifications are maintained in a repository independent of this EIP. `SPEC_RELEASE_VERSION` release of the specs at `SPEC_RELEASE_COMMIT` are considered the canonical Phase 0 specs for this EIP. This EIP provides a high level view on the Phase 0 mechanisms, especially those that are relevant to Ethereum mainnet (e.g. the deposit contract) and users (e.g. validator mechanics and eth2 issuance). The extended and low level

MOTIVATION:
Eth2 aims to fulfill the original vision of Ethereum to support an efficient, global-scale, general-purpose transactional platform while retaining high cryptoeconomic security and decentralization. Today, Ethereum blocks are consistently full due to increasingly high demand for decentralized applications. Ever since the first serious spikes in adoption in 2017 (cryptokitties), the Ethereum community has consistently and vocally demanded scaling solutions. Since day 0 of Ethereum, the investigation and expectation in scaling solutions has been two-pronged -- scale from both Layer 1 upgrades and Layer 2 adoption. This EIP represents the start to a multi-phased rollout of the former. ###

RATIONALE:
### Principles * **Simplicity**: especially since cryptoeconomic proof of stake and quadratic sharding are inherently complex, the protocol should strive for maximum simplicity in its decisions as much as possible. This is important because it (i) minimizes development costs, (ii) reduces risk of unforeseen security issues, and (iii) allows protocol designers to more easily convince users that parameter choices are legitimate. When complexity is unavoidable to achieve a given level of functionality, the preference order for where the complexity goes is: layer 2 protocols > client implementations > protocol spec. * **Long-term stability**: the low levels of the


=== EIP-2537 ===
TITLE: Precompile for BLS12-381 curve operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-02-21
REQUIRES: 

SUMMARY:
Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification. Along with the curve arithmetic, multi-scalar-multiplication operations are included to efficiently aggregate public keys or individual signer's signatures during BLS signature verification.

SPECIFICATION:
### Constants | Name | Value | Comment | |---------------------|-------|--------------------| | BLS12_G1ADD | 0x0b | precompile address | | BLS12_G1MSM | 0x0c | precompile address | | BLS12_G2ADD | 0x0d | precompile address | | BLS12_G2MSM | 0x0e | precompile address | | BLS12_PAIRING_CHECK | 0x0f | precompile address | | BLS12_MAP_FP_TO_G1 | 0x10 | precompile address | | BLS12_MAP_FP2_TO_G2 | 0x11 | precompile address | We introduce *seven* separate precompiles to perform the following operations: - BLS12_G1ADD - to perform point addition in G1 (curve over base prime field) with a gas cost of `375` gas -

MOTIVATION:
The motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security.

RATIONALE:
The motivation section covers a total motivation to have operations over the BLS12-381 curves available. We also extend a rationale for more specific fine points. ### MSM as a separate call Explicit separate MSM operation that allows one to save execution time (so gas) by both the algorithm used (namely Pippenger's algorithm) and (usually forgotten) by the fact that `CALL` operation in Ethereum is expensive (at the time of writing), so one would have to pay non-negligible overhead if e.g. for MSM of `100` points would have to call the multiplication precompile `100` times and addition for `99`


=== EIP-1355 ===
TITLE: Ethash 1a
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-08-26
REQUIRES: 

SPECIFICATION:
1. Define hash function `fnv1a()` as ```python def fnv1a(v1, v2): return ((v1 ^ v2) * FNV1A_PRIME) % 2**32 ``` where `FNV1A_PRIME` is 16777499 or 16777639. 2. Change the hash function that determines the DAG item index in Ethash algorithm from `fnv()` to new `fnv1a()`. In [Main Loop](https://github.com/ethereum/eth-wiki/blob/master/concepts/ethash/ethash.md#main-loop) change ```python p = fnv(i ^ s[0], mix[i % w]) % (n // mixhashes) * mixhashes ``` to ```python p = fnv1a(i ^ s[0], mix[i % w]) % (n // mixhashes) * mixhashes ```

MOTIVATION:
Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.

RATIONALE:
The usual argument for decentralization and network security. Unless programmable, an ASIC is hardwired to perform sequential operations in a given order. fnv1a changes the order in which an exclusive-or and a multiply are applied, effectively disabling the current wave of ASICS. A second objective is minimize ethash changes to be the least disruptive, to facilitate rapid development, and to lower the analysis and test requirements. Minimizing changes to ethash reduces risk associated with updating all affected network components, and also reduces the risk of detuning existing GPUs. It's expected that this specific change would have no effect


=== EIP-3403 ===
TITLE: Partial removal of refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-16
REQUIRES: 

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `SSTORE_REFUND_GAS` | 19000 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. 1. Remove the `SELFDESTRUCT` refund. 2. Remove the `SSTORE` refund in all cases except for one specific case: if the _new value_ and _original value_ of the storage slot both equal 0 but the _current value_ does not (those terms being defined as in [EIP-1283](https://eips.ethereum.org/EIPS/eip-1283)), refund `SSTORE_REFUND_GAS` gas.

MOTIVATION:
Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It is now widely accepted that the only solution to state growth is some form of statelessness or state expiry, and if such a solution is implemented, then disused storage slots and contracts would start to be ignored automatically. Gas refunds additionally have multiple harmful consequences: * Refunds give rise

RATIONALE:
Preserving refunds in the `new = original = 0 != current` case ensures that a few key use cases that deserve favorable gas cost treatment continue to receive favorable gas cost treatment, particularly: * Anti-reentrancy locks (typically flipped from 0 to 1 right before a child call begins, and then flipped back to 0 when the child call ends) * ERC20 approve-and-send (the "approved value" goes from zero to nonzero when the token transfer is approved, and then back to zero when the token transfer processes) It also preserves two key goals of EIP 3298: 1. Gas tokens


=== EIP-1679 ===
TITLE: Hardfork Meta: Istanbul
TYPE: Meta 
STATUS: Final
CREATED: 2019-01-04
REQUIRES: 1, 5, 2, ,,  , 1, 1, 0, 8, ,,  , 1, 3, 4, 4, ,,  , 1, 7, 1, 6, ,,  , 1, 8, 8, 4, ,,  , 2, 0, 2, 8, ,,  , 2, 2, 0, 0

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Istanbul.

SPECIFICATION:
- Codename: Istanbul ### Activation - `Block >= 9,069,000` on the Ethereum Mainnet - `Block >= 6,485,846` on the Ropsten testnet - `Block >= 14,111,141` on the Kovan testnet - `Block >= 5,435,345` on the Rinkeby testnet - `Block >= 1,561,651` on the Görli testnet ### Included EIPs - [EIP-152](./eip-152.md): Add Blake2 compression function `F` precompile - [EIP-1108](./eip-1108.md): Reduce alt_bn128 precompile gas costs - [EIP-1344](./eip-1344.md): Add ChainID opcode - [EIP-1884](./eip-1884.md): Repricing for trie-size-dependent opcodes - [EIP-2028](./eip-2028.md): Calldata gas cost reduction - [EIP-2200](./eip-2200.md): Rebalance net-metered SSTORE gas cost with consideration of SLOAD gas cost change


=== EIP-101 ===
TITLE: Serenity Currency and Crypto Abstraction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2015-11-15
REQUIRES: 

SPECIFICATION:
1. Accounts now have only two fields in their RLP encoding: **code** and **storage**. 2. Ether is no longer stored in account objects directly; instead, at address `0`, we premine a contract which contains all ether holdings. The `eth.getBalance` command in web3 is remapped appropriately. 3. `msg.value` no longer exists as an opcode. 4. A transaction now only has four fields: **to**, **startgas**, **data** and **code**. 5. Aside from an RLP validity check, and checking that the **to** field is twenty bytes long, the **startgas** is an integer, and **code** is either empty or hashes to the **to**

RATIONALE:
This allows for a large increase in generality, particularly in a few areas: 1. Cryptographic algorithms used to secure accounts (we could reasonably say that Ethereum is quantum-safe, as one is perfectly free to secure one's account with Lamport signatures). The nonce-incrementing approach is now also open to revision on the part of account holders, allowing for experimentation in k-parallelizable nonce techniques, UTXO schemes, etc. 2. Moving ether up a level of abstraction, with the particular benefit of allowing ether and sub-tokens to be treated similarly by contracts 3. Reducing the level of indirection required for custom-policy accounts


=== EIP-7441 ===
TITLE: Upgrade block proposer election to Whisk
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-09-01
REQUIRES: 

SUMMARY:
Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.

SPECIFICATION:
### Execution layer This requires no changes to the Execution Layer. ### Consensus layer The protocol can be summarized in the following concurrent steps: - Validators register a tracker and unique commitment on their first proposal after the fork - At the start of a shuffling phase a list of candidate trackers is selected using public randomness from RANDAO - During each shuffling phase each proposer shuffles a subset of the candidate trackers using private randomness - After each shuffling phase an ordered list of proposer trackers is selected from the candidate set using RANDAO The full specification

MOTIVATION:
The beacon chain currently elects the next 32 block proposers at the beginning of each epoch. The results of this election are public and everyone gets to learn the identity of those future block proposers. This information leak enables attackers to launch DoS attacks against each proposer sequentially in an attempt to disable Ethereum.

RATIONALE:
### Fields per validator Whisk requires having one tracker `(rG,krG)` and one unique commitment `kG` per validator. Both are updated only once on a validator's first proposal after the fork. Trackers are registered with a randomized base `(rG,krG)` to make it harder for adversaries to track them through shuffling gates. It can become an issue if the set of honest shufflers is small. ### Identity binding Each tracker must be bound to a validator's identity to prevent multiple parties to claim the same proposer slot. Otherwise, it would allow proposers to sell their proposer slot, and cause fork-choice


=== EIP-6914 ===
TITLE: Reuse Withdrawn Validator Indices
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-19
REQUIRES: 

SUMMARY:
Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.

SPECIFICATION:
### Consensus Layer The configuration values and mechanics of the specification can be found in the [Consensus Layer specs](https://github.com/ethereum/consensus-specs/blob/1a38b83e5db8638ee01c9461cccf11e7d8a3ebce/specs/_features/eip6914). Note that validator indices are reused in the event that the validator has been fully withdrawn *and* that the validator has been withdrawable for a sufficient safe period. ### Execution Layer This specification does not require any changes to the Execution Layer.

MOTIVATION:
The beacon chain maintains a list of validators and a separate list of balances associated with each validator. When a new deposit for a new validator occurs, the current mechanism only appends, rather than reusing previously fully withdrawn validator indices. As validators fully withdraw and new validators enter, this means the two lists will grow unbounded. This specification allows for the reuse of validator indices in the event that it is safe to do so, eliminating the concerns around the unbounded validator list growth.

RATIONALE:
The `validators` and `balances` lists are currently appended to each time a new Deposit for a new pubkey comes into the beacon chain. Due to the natural mechanics of stakers entering and leaving consensus over long time spans, these lists, thus the state size, will grow unbounded. Increased state size represents load and/or complexity in client implementations. This comes in the form of client memory footprint, state root calculations, validator set scans, and more. This is a relatively simple clean-up within the state transition that will prevent the unnecessary load and complexity of the otherwise unbounded lists.


=== EIP-7707 ===
TITLE: Incentivize Access List Provisioning
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-12
REQUIRES: 2930

SUMMARY:
This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.

SPECIFICATION:
We shall update [EIP-2930](./eip-2930.md) parameters: | Constant | Value | | - | - | | `ACCESS_LIST_STORAGE_KEY_COST` | 320 | | `ACCESS_LIST_ADDRESS_COST` | 512 |

MOTIVATION:
While [EIP-2930](./eip-2930.md) introduced `accessLists` as a mechanism for `SLOAD` pre-warming to reduce gas costs by informing the EVM upfront about which storage slots a transaction will access, the practical use is limited and uncommon due to the savings versus penalties involved. In order to break even for each address included `24 storage keys` are required per address, and there is a `100 gas` saving per key at `25+`; in contrast the penalty for including an unused key is `1900 gas`, so break-even where one key is unused is `43 keys`.\ \ This situation makes the break-even and risk-reward

RATIONALE:
As stated in the introduction the gas cost benefit analysis does not encourage the users of the chain to provide accessList hints, even though the mechanism is already in protocol (and a call to `eth_createAccessList` will give them, or a wallet the correct list to include). So we propose a reduction in the pricing of those data access lists to make them more inline with calldata.\ \ Levelling the playing field between small `call_data` and `access_lists` costs, (and incentivise `access_lists` provisioning from transaction senders as they are needed for transaction execution in a faster manner), the price model


=== EIP-2378 ===
TITLE: EIPs Eligible for Inclusion
TYPE: Meta 
STATUS: Stagnant
CREATED: 2019-11-13
REQUIRES: 

SUMMARY:
The pipeline for Core EIPs, per the EIP-Centric upgrade model, is as follows. ``` [ DRAFT ] -> [ ELLIGLE FOR INCLUSION ] -> [ IMPLEMENTATION ] -> [ TESTING ] -> [ ACCEPTED ] -> [ DEPLOYED ] ``` This EIP documents all EIPs marked as **Eligible For Inclusion** by the All Core Devs. Typically to reach this stage, an EIP must be discussed in brief on an AllCoreDevs Call and motioned by rough consenses to be moved to this stage. Any additions to this list are required to provide a link to the meeting notes when

SPECIFICATION:
| EIP | Title | Pipeline Status | Date of Initial Decision | REF | | -------- | ----------------------------------------------------- | -------- | ---------- | ---- | | EIP-663 | Unlimited SWAP and DUP instructions | ELIGIBLE | 2019-11-01 | [🔗](https://github.com/ethereum/pm/blob/master/All%20Core%20Devs%20Meetings/Meeting%2074.md) | | EIP-1057 | ProgPoW, a Programmatic Proof-of-Work | ELIGIBLE | 2019-11-01 | [🔗](https://github.com/ethereum/pm/blob/master/All%20Core%20Devs%20Meetings/Meeting%2074.md) | | EIP-1380 | Reduced gas cost for call to self | ELIGIBLE | 2019-11-01 | [🔗](https://github.com/ethereum/pm/blob/master/All%20Core%20Devs%20Meetings/Meeting%2074.md) | | EIP-1559 | Fee market change for ETH 1.0 chain | ELIGIBLE | 2019-11-01 | [🔗](https://github.com/ethereum/pm/blob/master/All%20Core%20Devs%20Meetings/Meeting%2074.md) | | EIP-1702 | Generalized Account Versioning Scheme | ELIGIBLE

MOTIVATION:
Development of clear specifications and pull requests to existing Ethereum Clients is a large investment of time and resources. The state of *Eligible for Inclusion* is a signal from the Ethereum Core Developers to an EIP Author validiating the idea behind an EIP and confirms investing their time further pursing it is worthwhile.

RATIONALE:
**EIP Number** **Title** **Pipeline Status** : Show the current status in the context of the EIP centric model. The list is sorted by furthest along in the process. **Date of Initial Decision** : Date of the initial decision for Eligibility for Inclusion **REF** : Link to the decision on the AllCoreDevs Notes


=== EIP-7976 ===
TITLE: Increase Calldata Floor Cost
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-06-18
REQUIRES: 7623

SUMMARY:
This EIP proposes an adjustment to calldata pricing by raising the floor cost from 10/40 to 15/60 gas per zero/non-zero calldata byte. This reduces the worst-case block size by ~33% with minimal impact.

SPECIFICATION:
| Parameter | Value | | ---------------------------- | ----- | | `STANDARD_TOKEN_COST` | `4` | | `TOTAL_COST_FLOOR_PER_TOKEN` | `15` | Let `tokens_in_calldata = zero_bytes_in_calldata + nonzero_bytes_in_calldata * 4`. Let `isContractCreation` be a boolean indicating the respective event. Let `execution_gas_used` be the gas used for EVM execution with the gas refund subtracted. Let `INITCODE_WORD_COST` be 2 as defined in [EIP-3860](./eip-3860.md). The formula for determining the gas used per transaction changes from [EIP-7623](./eip-7623.md)'s implementation to: ```python tx.gasUsed = ( 21000 + max( STANDARD_TOKEN_COST * tokens_in_calldata + execution_gas_used + isContractCreation * (32000 + INITCODE_WORD_COST * words(calldata)), TOTAL_COST_FLOOR_PER_TOKEN * tokens_in_calldata ) )

MOTIVATION:
While [EIP-7623](./eip-7623.md) successfully reduced the maximum possible block size by introducing a floor cost of 10/40 gas per byte for data-heavy transactions, continued increases in gas limit demands further optimization. The current floor cost still permits relatively large data-heavy payloads that contribute to block size variance. By increasing the floor cost to 15/60 gas per byte, this proposal aims to: - Further reduce the maximum possible block size for data-heavy transactions - Create additional headroom for potential block gas limit increases - Maintain the same exemption for transactions with significant EVM computation - Have minimal impact on users

RATIONALE:
With [EIP-7623](./eip-7623.md)'s implementation, data-heavy transactions cost 10/40 gas per zero/non-zero byte, reducing the maximum possible EL payload size to approximately 1.07 MB (`45s_000_000/40`). This EIP further reduces this to approximately 0.72 MB (`45_000_000/60`) for non zero bytes and maintains proportional costs for non-zero bytes. By increasing calldata costs from 10/40 to 15/60 gas per byte for data-heavy transactions, this EIP provides: - **Enhanced block size reduction**: Maximum data-heavy payload size drops by ~33%. - **Maintained user experience**: Regular users engaging in DeFi, token transfers, and other EVM-heavy operations remain unaffected - **Better blob incentivization**: Higher calldata costs further


=== EIP-2970 ===
TITLE: IS_STATIC opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-13
REQUIRES: 

SPECIFICATION:
Add a `IS_STATIC (0x4A)` opcode that pushes `1` if the current context is static (ie. the execution is in a `STATICCALL` or a descendant thereof, so state-changing operations are not possible), and `0` if it is not.

MOTIVATION:
The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA's security model) but not state-changing calls.

RATIONALE:
Determining staticness is already possibly using the following hacky technique: make a `CALL` with limited gas, and inside that `CALL` issue one `LOG` and exit. If the context is static, the `CALL` would fail and leave a 0 on the stack; if the context is non-static, the `CALL` would succeed. However, this technique is fragile against changes to gas costs, and is needlessly wasteful. Hence, the status quo neither allows a reasonably effective way of determining whether or not the context is static, nor provides any kind of invariant that executions that do not fail outright will execute


=== EIP-7378 ===
TITLE: Add time-weighted averaging to the base fee
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-22
REQUIRES: 

SUMMARY:
This EIP proposes a new formula to update the base fee, derived from [EIP-1559](./eip-1559.md). The existing base fee update formula, $$b[i+1]\triangleq b[i] \cdot \left( 1+\frac{1}{8} \cdot \frac{s[i]-s^* }{s^* }\right)$$ only considers the last block size $s[i]$. This mechanism incentivizes proposers to collude with users to manipulate the base fee. We propose that even previous block sizes be considered by replacing the last block size with an exponential moving average. In particular, we suggest the following base fee update formula: $$b[i+1]\triangleq b[i] \cdot \left( 1+\frac{1}{8} \cdot \frac{s_{\textit{avg}}[i]-s^* }{s^* }\right)$$ where $s_{\textit{avg}}[i]$ is defined by: $$s_{\textit{avg}}[i] \triangleq \alpha\sum_{k=1}^{\infty} (1-\alpha)^k\cdot s[i-k+1]$$

SPECIFICATION:
$s[i]$ is replaced by $s_{\textit{avg}}[i]$, where: $$s_{\textit{avg}}[i] \triangleq \alpha\sum_{k=1}^{\infty} (1-\alpha)^k\cdot s[i-k+1]$$ which simplifies to the recursive form $$s_{\textit{avg}}[i] = \alpha\cdot s[i] + (1-\alpha)\cdot s_{\textit{avg}}[i-1]$$ where $\alpha\in(0, 1)$ is the smoothing factor. A higher smoothing factor means that the average responds more quickly to changes in block size (e.g., if $\alpha = 1$ the proposed formula degenerates to the existing rule).

MOTIVATION:
To reduce bribe motivation when the demand for blockspace is high (see Incentive Considerations section) and to reduce oscillations, thus, having a more stable fee setting mechanism. Proposers use a mechanism described in EIP-1559 to determine which messages to include in a block. This mechanism includes a "base fee": a portion of the transaction fee that is burned. The base fee varies according to the fill rate of blocks. A target block size is defined. If a block exceeds the target size, the base fee increases, and if it is smaller, the base fee lowers. Research on the

RATIONALE:
An intuitive option for the Transaction Fee Mechanism (TFM) that adjusts supply and demand economically is *First price auction*, which is well known and studied. Nevertheless, the Ethereum network choice was to use EIP-1559 for the TFM (one stated reason was to try and simplify the fee estimation for users, and reduce the advantage of sophisticated users). In this proposal, our design goal is to improve the TFM (of EIP-1559) by mitigating known problems that it raises. It is important to note that these problems severity are in direct relation to the demand for block space, and currently


=== EIP-7966 ===
TITLE: eth_sendRawTransactionSync Method
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2025-06-11
REQUIRES: 

SUMMARY:
This EIP proposes a new JSON-RPC method, `eth_sendRawTransactionSync`, which submits a signed raw transaction and waits synchronously for the transaction receipt or a configurable timeout before returning. This method addresses the user experience gap in high-frequency applications by offering stronger delivery guarantees than `eth_sendRawTransaction`.

SPECIFICATION:
### Method Name `eth_sendRawTransactionSync` ### Parameters | Position | Type | Description | Required | |----------|------------|-----------------------------------|----------| | 1 | `DATA` | The signed transaction data | Yes | | 2 | `QUANTITY` | Maximum wait time in milliseconds | No | #### Parameter Validation Rules - **Transaction Data**. MUST be a valid hex-encoded, RLP-encoded signed transaction (same as in `eth_sendRawTransaction`). - **Timeout**. MUST be a positive integer not greater than the node-configured maximum timeout. ### Returns - **On success**. Node implementations MUST return the transaction receipt object as defined by the `eth_getTransactionReceipt` method. - **On timeout error**. Node

MOTIVATION:
Currently, Ethereum clients submit signed transactions asynchronously using `eth_sendRawTransaction`. Clients receive a transaction hash immediately but must poll repeatedly for the transaction receipt, which increases latency and complicates client-side logic. This asynchronous approach is not efficient for high-frequency blockchains or Layer 2 solutions with fast block times and low latency, where rapid transaction throughput and quick confirmation feedback are critical. The need to separately poll for receipts results in increased network overhead, slower overall transaction confirmation feedback, and more complex client implementations. ![Sync vs Async Transaction Sending](../assets/eip-7966/sync-vs-async.png) _In a low-latency blockchain, transaction receipts are often available right after

RATIONALE:
### Why Not Extend Existing RPC? Modifying `eth_sendRawTransaction` to support this behavior would risk compatibility issues and ambiguity. A separate method makes the semantics explicit and opt-in. ### Node-Configured Timeouts Node implementations SHOULD allow configuration of the timeout period, defaulting to 2 seconds (depending on the implementation). This balances responsiveness and propagation guarantees without creating excessive overhead in node clients. ### User-Configured Timeouts The optional timeout parameter allows clients to specify their preferred maximum wait time for transaction processing. - Applications can adjust timeouts based on their specific latency requirements. - The optional timeout prevents the RPC call


=== EIP-1682 ===
TITLE: Storage Rent
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-11-10
REQUIRES: 

SUMMARY:
This EIP describes a scheme to charge for data in state, and 'archive' data which is no longer being paid for. It also describes how resurrection of 'archived' data happens.

SPECIFICATION:
The cost of storing an account over time is called `rent`. The amount of `rent` due depends on the size of the account. The `ether` that is paid for `rent` is destroyed. The `rent` is deducted whenever an account is touched. `rent` can be paid from the account's regular `balance` or from its 'rent balance'. Accounts can be endowed with `rent balance` through a new EVM opcode. When `rent` is charged, it is first taken from the `rent balance`. When `rent balance` is zero, it is instead charged from the account's regular `balance` instead. The reason to separate

MOTIVATION:
The Ethereum blockchain in its current form is not sustainable because it grows indefinitely. This is true of any blockchain, but Ethereum grows faster than most chains. Many implementation strategies to slow down growth exist. A common strategy is 'state pruning' which discards historical state, keeping only the active copy of contract data and a few recent versions to deal with short-range chain reorganizations. Several implementations also employ compression techniques to keep the active copy of the state as small as possible. A full node participating in consensus today requires storing large amounts of data even with advanced

RATIONALE:
### Why do we need a separate rent balance? Accounts need a separate rent balance because some contracts are non-payable, i.e. they reject regular value transfers. Such contracts might not be able to keep themselves alive, but users of those contracts can keep them alive by paying rent for them. Having the additional balance also makes things easier for contracts that hold balance on behalf of a user. Consider the canonical crowdfunding example, a contract which changes behavior once a certain balance is reached and which tracks individual user's balances. Deducting rent from the main balance of the


=== EIP-7975 ===
TITLE: eth/70 - partial block receipt lists
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2025-06-16
REQUIRES: 7, 6, 4, 2, ,,  , 7, 8, 2, 5

SUMMARY:
This EIP modifies the 'eth' p2p protocol to allow requesting partial block receipt lists.

SPECIFICATION:
Modify the encoding for receipts in the `Receipts (0x10)` message as follows: - (eth/69): `[request-id: P, [[receipt₁, receipt₂], ...]]` - (eth/70): `[request-id: P, lastBlockIncomplete: {0,1}, [[receipt₁, receipt₂], ...]]` If the `lastBlockIncomplete` flag is set to true (`1`), the last receipt list does not contain all receipts of the block, and the client will have to request the remaining receipts of that block in a new request. To support such partial queries, we also modify the `GetReceipts (0x0f)` message: - (eth/69): `[request-id: P, [blockhash₁: B_32, blockhash₂: B_32, ...]]` - (eth/70): `[request-id: P, firstBlockReceiptIndex: P, [blockhash₁: B_32, blockhash₂: B_32, ...]]`

MOTIVATION:
As Ethereum moves toward a higher block gas limit on mainnet, the worst-case total size of a block receipts list also becomes larger, and may eventually exceed the 10MiB message size limit commonly applied in clients. This can lead to sync failures.

RATIONALE:
Since [EIP-7825] caps the gas limit of a single transaction to 30M gas, a single transaction receipt will always be limited in size. Specifically, a transaction can produce at most 30000000/8 = 3.75MiB of log data. However, a block can contain contain multiple transactions, and thus the entire block receipts list can be much larger. At a block gas limit of ~83M, the `Receipts` message could exceed 10MiB. Clients typically reject messages above this size because their validity can only be determined after fetching the complete message. For a `Receipts` message, each block receipts list is validated by


=== EIP-7329 ===
TITLE: ERC/EIP Repository split
TYPE: Meta 
STATUS: Final
CREATED: 2023-07-13
REQUIRES: 1

SUMMARY:
Describes the motivation and rational for splitting the EIP repositories into an EIP repository, targeting core ethereum changes and an ERC repository, targeting application layer specifications.

SPECIFICATION:
This specification only details with the initial mechanism of the split. The particulars of how each repository will govern itself is out of scope for this EIP, as it is the motivating point of this EIP that the divergent needs of the community will require highly divergent methods. 1. All ERCs and Interface-category EIPs are removed from this repository and migrated to a new repo. The history should be intact so that repo should be forked of this one with the non-ERCs removed. 2. The new ERCs repository goes live and includes the changes from the script. 3.

MOTIVATION:
Long ago when the EIPs repository was created, there was a vision of a single home for all standards related to Ethereum. The community was small and most people were interacting at every level of the ecosystem. It made sense to combine application standards with core consensus changes. Since then, the ecosystem has grown. Today, the chasm between application development and core development is wide. Fewer people are involved across the ecosystem (for better or worse); yet the repository remains unified. For years, we've considered separating the repository. This would allow ERC and EIP specifications to evolve more

RATIONALE:
There are two major communities served by the EIP process that are highly divergent and very differentiated in their needs. Let's consider the impact of specification ambiguity, the impacts are different based on the community. The core protocol community has a low tolerance for difference of implementation and a high penalty for specification ambiguity. An improperly implemented part of a new spec could cause the ethereum mainnet to split, possibly costing millions to billions of value lost to node operators as well as community members using the services offered by the Ethereum protocols. A poorly specified solidity interface,


=== EIP-7568 ===
TITLE: Hardfork Meta Backfill - Berlin to Shapella
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-01
REQUIRES: 2, 0, 7, 0, ,,  , 2, 3, 8, 7, ,,  , 2, 9, 8, 2, ,,  , 6, 1, 2, 2, ,,  , 6, 9, 5, 3

SUMMARY:
Following Muir Glacier hard fork, Meta EIPs were abandoned in favor of other ways to track changes included in Ethereum network upgrades. This EIP aggregates the specifications for these upgrades, which themselves list the specific changes included. Specifically, it covers the Beacon Chain launch (Serenity Phase 0), Berlin, London, Altair, Arrow Glacier, Gray Glacier, The Merge (Paris + Bellatrix) and Shapella (Shanghai + Capella).

SPECIFICATION:
The network upgrades below are listed in order of activation. Upgrades to Ethereum's execution layer are marked "[EL]", and those to Ethereum's consensus layer are marked "[CL]". ### Beacon Chain Launch - Serenity Phase 0 [CL] The full specifications for the Beacon Chain at launch can be found in the [`v1.0.0` release of the `ethereum/consensus-specs` repository](https://github.com/ethereum/consensus-specs/blob/579da6d2dc734b269dbf67aa1004b54bb9449784/README.md#phase-0). Additionally, [EIP-2982](./eip-2982.md) provides context on the Beacon Chain design and rationale for its mainnet parametrization. ### Berlin [EL] The set of EIPs included in Berlin were originally specified in [EIP-2070](./eip-6953.md), but then moved to the [`berlin.md`](https://github.com/ethereum/execution-specs/blob/8dbde99b132ff8d8fcc9cfb015a9947ccc8b12d6/network-upgrades/mainnet-upgrades/berlin.md) file of the `ethereum/execution-specs` repository. ###

MOTIVATION:
For many years, Ethereum used Meta EIPs to document network upgrades. Recently, consensus has formed around using them again. This EIP aggregates the network upgrades who did not have Meta EIPs and links out to their specifications.

RATIONALE:
The EIP repository is well known within the Ethereum community, and Meta EIPs have historically been useful to clearly list the EIPs included in a specific network upgrade. While the specification process for the execution and consensus layers differ, there is value in having a single, harmonized, list of EIPs included in each upgrade, and for the lists for both layers to be part of the same repository. Re-introducing Hardfork Meta EIPs enables this, and allows for de-duplication in cases where an EIP affects both the execution and consensus layer of Ethereum. This EIP covers the upgrades which


=== EIP-8013 ===
TITLE: Static relative jumps and calls for the EVM
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-19
REQUIRES: 7979

SUMMARY:
Five new EVM jump instructions are introduced (`RJUMP`, `RJUMPI`, `RJUMPV`, `RJUMPSUB`, and `RJUMPSUBV`) which encode destinations as signed immediate values. These can be useful in almost all `JUMP` and `JUMPI` use cases and offer improvements in cost, performance, and static analysis.

SPECIFICATION:
We introduce five new instructions, each taking either a two-byte relative offset or else a table of offsets as immediate arguments. 1) relative jump: * `RJUMP (0xe0) relative_offset` * sets the `PC` to `PC_post_instruction + relative_offset`, where * `relative_offset` is encoded as a 16-bit **signed** (two's-complement) big-endian value. 2) conditional relative jump: * `RJUMPI (0xe1) relative_offset` * pops a value (`condition`) from the stack, and * sets the `PC` to `PC_post_instruction + ((condition == 0) ? 0 : relative_offset)`. 3) relative jump via jump table: * `RJUMPV (0xe2) max_index relative_offset+` * pops a value (`case`) from the stack,

MOTIVATION:
A recurring discussion topic is that the EVM only has a mechanism for dynamic jumps. They provide a very flexible architecture with only 2 (!) instructions. This flexibility comes at a cost however: it makes analysis of code more complicated, often intractable, and it also (partially) resulted in the need to have the `JUMPDEST` marker. In a great many cases control flow is actually static and there is no need for any dynamic behaviour, though not every use case can be solved by static jumps. There are various ways to reduce the need for dynamic jumps, some examples:

RATIONALE:
### Relative addressing We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code like `PUSHn PC ADD JUMPI`. We do not see any significant downside to relative addressing and it allows us to also deprecate the `PC` instruction. ### Immediate size The signed 16-bit immediate means that the largest jump distance possible is 32767. In the case the bytecode at `PC=0` starts with an `RJUMP`, it will be possible to


=== EIP-4788 ===
TITLE: Beacon block root in the EVM
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-02-10
REQUIRES: 1559

SUMMARY:
Commit to the hash tree root of each beacon chain block in the corresponding execution payload header. Store each of these roots in a smart contract.

SPECIFICATION:
| constants | value | |--- |--- | | `FORK_TIMESTAMP` | `1710338135` | | `HISTORY_BUFFER_LENGTH` | `8191` | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | | `BEACON_ROOTS_ADDRESS` | `0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02` | ### Background The high-level idea is that each execution block contains the parent beacon block's root. Even in the event of missed slots since the previous block root does not change, we only need a constant amount of space to represent this "oracle" in each execution block. To improve the usability of this oracle, a small history of block roots are stored in the contract. To bound the amount of

MOTIVATION:
Roots of the beacon chain blocks are cryptographic accumulators that allow proofs of arbitrary consensus state. Exposing these roots inside the EVM allows for trust-minimized access to the consensus layer. This functionality supports a wide variety of use cases that improve trust assumptions of staking pools, restaking constructions, smart contract bridges, MEV mitigations and more.

RATIONALE:
### Why not repurpose `BLOCKHASH`? The `BLOCKHASH` opcode could be repurposed to provide the beacon root instead of some execution block hash. To minimize code change, avoid breaking changes to smart contracts, and simplify deployment to mainnet, this EIP suggests leaving `BLOCKHASH` alone and adding new functionality with the desired semantics. ### Beacon block root instead of state root Block roots are preferred over state roots so there is a constant amount of work to do with each new execution block. Otherwise, skipped slots would require a linear amount of work with each new payload. While skipped slots


=== EIP-8016 ===
TITLE: SSZ CompatibleUnion
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-28
REQUIRES: 7, 4, 9, 5, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP introduces a new [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md) type to represent unions with forward-compatible Merkleization: A given field is always assigned the same stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/merkle-proofs.md#generalized-merkle-tree-index) across all type options.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### `CompatibleUnion({selector: type})` A new [SSZ composite type](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#composite-types) is defined: - **compatible union**: union type containing one of the given subtypes with compatible Merkleization - notation `CompatibleUnion({selector: type})`, e.g. `CompatibleUnion({1: Square, 2: Circle})` Compatible unions are always considered ["variable-size"](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#variable-size-and-fixed-size), even when all type options share the same fixed length. The [default value](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#default-values) is defined as: | Type | Default Value | | ----------------------------------- |

MOTIVATION:
Certain types, e.g., transactions, allow multiple variants carving out slightly different feature sets. Merkleization equivalence is still desirable, as it allows verifiers to check common fields across variants. These types should still efficiently deserialize into one of their possible variants corresponding to its known tree shape. In programming languages, this is typically achieved by tagged unions. If multiple versions of an SSZ container coexist at the same time, for example to represent transaction types, the same field may be assigned to a different gindex in each version. This unnecessarily complicates verifiers and introduces a maintenance burden, as the

RATIONALE:
### Why are `CompatibleUnion` selectors limited to `1 ... 127`? Reserving `0` prevents issues with incomplete initialization, and can possibly be used in a future EIP to denote optionality. Reserving selectors above `127` (i.e., highest bit is set) enables future backwards compatible extensions. The range `1 ... 127` is sufficient to satisfy current demand. ### Why not field collections? An alternative design was explored where the `active_fields` bitvector was emitted. While that works in principle, it becomes very inefficient to parse when `ProgressiveContainer` are nested, as the parser cannot immediately determine the overall tree shape. Further, the bitvector


=== EIP-1108 ===
TITLE: Reduce alt_bn128 precompile gas costs
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-05-21
REQUIRES: 1, 9, 6, ,,  , 1, 9, 7

SUMMARY:
Changes in 2018 to the underlying library used by the official Go reference implementation led to significant performance gains for the `ECADD`, `ECMUL`, and pairing check precompiled contracts on the `alt_bn128` elliptic curve. In the Parity client, field operations used by the precompile algorithms were optimized in 2018, and recent changes to the pairing algorithm used by the `bn` crate have brought considerable speedups. Faster operations on Ethereum clients should be reflected in reduced gas costs.

SPECIFICATION:
Following is a table with the current gas cost and new gas cost: | Contract | Address | Current Gas Cost | Updated Gas Cost | | ------------- | --------- | ----------------------------- | ------------------- | | `ECADD` | `0x06` | 500<sup>[1]</sup> | 150 | | `ECMUL` | `0x07` | 40 000<sup>[1]</sup> | 6 000 | | Pairing check | `0x08` | 80 000 * k + 100 000<sup>[2]</sup>| 34 000 * k + 45 000 | The gas costs for `ECADD` and `ECMUL` are updates to the costs listed in EIP-196, while the gas costs for the pairing

MOTIVATION:
Recently, the underlying library used by the [official Go reference implementation](https://github.com/ethereum/go-ethereum) to implement the `ECADD` (at address `0x06`), `ECMUL` (at address `0x07`), and pairing check (at address `0x08`) precompiled contracts was shifted to [Cloudflare's bn256 library](https://github.com/cloudflare/bn256). Based on the [initial PR that introduced this change](https://github.com/ethereum/go-ethereum/pull/16203), and corroborated in [a later note](https://github.com/ethereum/go-ethereum/pull/16301#issuecomment-372687543), the computational cost of `ECADD`, `ECMUL`, and pairing checks (excepting the constant) has dropped roughly an order of magnitude across the board. Also, optimizations in the bn library [in 2018](https://github.com/paritytech/bn/pull/9) and [2019](https://github.com/paritytech/bn/pull/14) used by the [Parity client](https://github.com/paritytech/parity-ethereum) led to a significant performance boost we [benchmarked](https://gist.github.com/zac-williamson/838410a3da179d47d31b25b586c15e53) and compared


=== EIP-3102 ===
TITLE: Binary trie structure
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-01
REQUIRES: 

SUMMARY:
This proposal presents a binary structure and merkelization rule for the account and storage tries, which are merged into a single “state” trie. RLP and most of the MPT’s optimizations are dropped to simplify the design. Keccak256 is replaced with blake2b.

SPECIFICATION:
### Conventions | Code | Description | | :-: | - | | `u256(x)` | Big endian, 32-byte representation of number _x_ | |`||` | Byte-wise concatenation operator| | `++` | Bit-wise concatenation operator | | `0b0101` | The binary string `0101` | | `hash()` | The usual hashing function | | `empty_hash` | The empty hash: `hash("")` | | `length(x)` | The byte length of object `x` | | `d[a..b]` | The big-endian bit sequence taken from byte sequence `d`, starting at bit index `a`, up to and including the bit at index `b`. | ### Notable

MOTIVATION:
The current design of the Merkle Patricia Trie (MPT) uses an hexary trie. Hexary Merkle trees are more shallow than their binary counterparts, which means less hashing. Over the course of the 5 years of Ethereum’s existence, it has become apparent that disk accesses are a greater bottleneck than hashing. Clients are therefore moving away from a storage model in which all internal nodes are stored, in favor of a flat (key, value) storage model first used by turbo-geth, in which the intermediate nodes are recalculated only when needed. There is a push for making Ethereum easier to

RATIONALE:
### blake2b BLAKE2 offers better performance, which is key to compensate for the loss of performance associated to a ~4x increase in the number of nodes. BLAKE3 offers even better performance. No official golang release exists at the time of the writing of this document. This presents a security risk, and therefore BLAKE2 is considered instead. ### Merging of the account and storage tries The trend in clients is to store the keys and values in a "flat" database. Having the key of any storage slot prefixed with the address key of the account it belongs to helps


=== EIP-7939 ===
TITLE: Count leading zeros (CLZ) opcode
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-04-28
REQUIRES: 

SUMMARY:
Introduce a new opcode, `CLZ(x)`, which pops `x` from the stack and pushes the number of leading zero bits in `x` to the stack. If `x` is zero, pushes 256.

SPECIFICATION:
A new opcode is introduced: `CLZ` (`0x1e`). - Pops 1 value from the stack. - Pushes a value to the stack, according to the following code: ```solidity /// @dev Count leading zeros. /// Returns the number of zeros preceding the most significant one bit. /// If `x` is zero, returns 256. /// This is the fastest known `CLZ` implementation in Solidity and uses about 184 gas. function clz(uint256 x) internal pure returns (uint256 r) { /// @solidity memory-safe-assembly assembly { r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x)) r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x)))) r := or(r, shl(5, lt(0xffffffff, shr(r,

MOTIVATION:
Count leading zeros (CLZ) is a native opcode in many processor architectures (even in RISC architectures like ARM). It is a basic building block used in math operations, byte operations, compression algorithms, data structures: - lnWad - powWad - lambertW0Wad - sqrt - cbrt - byte string comparisons - generalized calldata compression/decompression - bitmaps (for finding the next/previous set/unset bit) - post quantum signature schemes Adding a `CLZ` opcode will: - Lead to cheaper compute. - Lead to cheaper ZK proving costs. The fastest known Solidity implementation uses several dynamic bitwise right shifts `shr`, which are very expensive

RATIONALE:
### The special 0 case 256 is the smallest number after 255. Returning a small number allows the result to be compared with minimal additional bytecode. For byte scanning operations, one can get the number of bytes to be skipped for a zero word by simply computing `256 >> 3`, which gives 32. ### Preference over `CTZ` (count trailing zeros) Computing the least significant bit can be easily implemented with `CLZ` by isolating the smallest bit via `x & -x`. However, it is not possible to implement `CLZ` with `CTZ`. ### Gas cost We have benchmarked the `CLZ`


=== EIP-7934 ===
TITLE: RLP Execution Block Size Limit
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-04-16
REQUIRES: 

SUMMARY:
This proposal introduces a protocol-level cap on the maximum RLP-encoded execution block size to 10 megabytes (MiB), which includes a margin of 2 MiB to account for beacon block sizes.

SPECIFICATION:
### Block Size Cap - Introduce constants: - `MAX_BLOCK_SIZE` set to **10 MiB (10,485,760 bytes)** - `SAFETY_MARGIN` set to **2MiB (2,097,152 bytes)** - `MAX_RLP_BLOCK_SIZE` calculated as `MAX_BLOCK_SIZE - MARGIN` - Any RLP-encoded block exceeding `MAX_RLP_BLOCK_SIZE` must be considered invalid. Thus add the following check to the Ethereum protocol: ```python MAX_BLOCK_SIZE = 10_485_760 # 10 MiB SAFETY_MARGIN = 2_097_152 # 2 MiB MAX_RLP_BLOCK_SIZE = MAX_BLOCK_SIZE - SAFETY_MARGIN # if true, the block is invalid and should be rejected/not get built def exceed_max_rlp_block_size(block: Block) -> bool: return len(rlp.encode(block)) > MAX_RLP_BLOCK_SIZE ``` ### Changes to Protocol Behavior 1. **Block Creation**: Validators

MOTIVATION:
Currently, Ethereum does not enforce a strict upper limit on the encoded size of blocks. This lack of constraint can result in: 1. **Network Instability**: Extremely large blocks slow down propagation and increase the risk of temporary forks and reorgs. 2. **DoS Risks**: Malicious actors could generate exceptionally large blocks to disrupt network performance. Additionally, blocks exceeding 10 MiB are not propagated by the consensus layer's (CL) gossip protocol, potentially causing network fragmentation or denial-of-service (DoS) conditions. By imposing a protocol-level limit on the RLP-encoded block size, Ethereum can ensure enhanced resilience against targeted attacks on block validation

RATIONALE:
### Why 10 MiB? A cap of 10 MiB aligns with the gossip protocol constraint in Ethereum's consensus layer (CL). An additional 2MiB margin explicitly accounts for beacon block sizes, ensuring compatibility and consistent block propagation across the network. Blocks significantly larger than 10 MiB will not be broadcast by the CL, potentially leading to network fragmentation or denial-of-service scenarios.


=== EIP-7600 ===
TITLE: Hardfork Meta - Pectra
TYPE: Meta 
STATUS: Final
CREATED: 2024-01-18
REQUIRES: 2, 5, 3, 7, ,,  , 2, 9, 3, 5, ,,  , 6, 1, 1, 0, ,,  , 7, 0, 0, 2, ,,  , 7, 2, 5, 1, ,,  , 7, 5, 4, 9, ,,  , 7, 6, 2, 3, ,,  , 7, 6, 8, 5, ,,  , 7, 6, 9, 1, ,,  , 7, 7, 0, 2

SUMMARY:
This Meta EIP lists the EIPs Included in the Prague/Electra network upgrade.

SPECIFICATION:
### Included EIPs #### Core EIPs * [EIP-2537](./eip-2537.md): Precompile for BLS12-381 curve operations * [EIP-2935](./eip-2935.md): Save historical block hashes in state * [EIP-6110](./eip-6110.md): Supply validator deposits on chain * [EIP-7002](./eip-7002.md): Execution layer triggerable exits * [EIP-7251](./eip-7251.md): Increase the MAX_EFFECTIVE_BALANCE * [EIP-7549](./eip-7549.md): Move committee index outside Attestation * [EIP-7623](./eip-7623.md): Increase calldata cost * [EIP-7685](./eip-7685.md): General purpose execution layer requests * [EIP-7691](./eip-7691.md): Blob throughput increase * [EIP-7702](./eip-7702.md): Set EOA account code #### Other EIPs * [EIP-7840](./eip-7840.md): Add blob schedule to EL config files (Informational) * [EIP-7642](./eip-7642.md): eth/69 - Drop pre-merge fields (Networking) * While not necessary for the Pectra network

RATIONALE:
This Meta EIP provides a global view of all changes included in the Prague/Electra network upgrade, as well as links to the full specification.


=== EIP-7516 ===
TITLE: BLOBBASEFEE instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-09-11
REQUIRES: 3, 1, 9, 8, ,,  , 4, 8, 4, 4

SUMMARY:
Add a `BLOBBASEFEE (0x4a)` instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical to [EIP-3198](./eip-3198.md) (`BASEFEE` opcode) except that it returns the blob base-fee as per [EIP-4844](./eip-4844.md).

SPECIFICATION:
Add a `BLOBBASEFEE` instruction with opcode `0x4a`, with gas cost `2`. | Op | Input | Output | Cost | |------|-------|--------|------| | 0x4a | 0 | 1 | 2 | `BLOBBASEFEE` returns the result of the `get_blob_gasprice(header) -> int` function as defined in [EIP-4844 §Gas accounting](./eip-4844.md#gas-accounting).

MOTIVATION:
The intended use case would be for contracts to get the value of the blob base-fee. This feature enables blob-data users to programmatically account for the blob gas price, eg: - Allow rollup contracts to trustlessly account for blob data usage costs. - Blob gas futures can be implemented based on it which allows for blob users to smooth out data blob costs.

RATIONALE:
### Gas cost The value of the blob base-fee is needed to process data-blob transactions. That means its value is already available before running the EVM code. The instruction does not add extra complexity and additional read/write operations, hence the choice of `2` gas cost. This is also identical to [EIP-3198](./eip-3198.md) (`BASEFEE` opcode)'s cost as it just makes available data that is in the header.


=== EIP-225 ===
TITLE: Clique proof-of-authority consensus protocol
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-03-06
REQUIRES: 

SUMMARY:
Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.

SPECIFICATION:
We define the following constants: * **`EPOCH_LENGTH`**: Number of blocks after which to checkpoint and reset the pending votes. * Suggested `30000` for the testnet to remain analogous to the mainnet `ethash` epoch. * **`BLOCK_PERIOD`**: Minimum difference between two consecutive block's timestamps. * Suggested `15s` for the testnet to remain analogous to the mainnet `ethash` target. * **`EXTRA_VANITY`**: Fixed number of extra-data prefix bytes reserved for signer *vanity*. * Suggested `32 bytes` to retain the current extra-data allowance and/or use. * **`EXTRA_SEAL`**: Fixed number of extra-data suffix bytes reserved for signer seal. * `65 bytes` fixed as signatures

MOTIVATION:
Ethereum's first official testnet was Morden. It ran from July 2015 to about November 2016, when due to the accumulated junk and some testnet consensus issues between Geth and Parity, it was finally laid to rest in favor of a testnet reboot. Ropsten was thus born, clearing out all the junk and starting with a clean slate. This ran well until the end of February 2017, when malicious actors decided to abuse the low PoW and gradually inflate the block gas limits to 9 billion (from the normal 4.7 million), at which point sending in gigantic transactions crippling


=== EIP-5749 ===
TITLE: The 'window.evmproviders' object
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-10-04
REQUIRES: 1193

SUMMARY:
A Javascript Ethereum Provider interface injection that will allow for the interoperability of multiple browser wallets at the same time. Replacing `window.ethereum` with `window.evmproviders` is a simple solution that will provide multiple benefits including: improving user experience, encouraging innovation in the space, removing race conditions and a 'winner-takes-most' environment as well as lowering barriers for user adoption.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### `window.evmproviders={}` ```typescript /** * Represents the assets needed to display a wallet */ interface ProviderInfo { /** * A UUIDv4 unique to the wallet provider. * * This must remain the same across versions but must be different across channels. For example, MetaMask, Trust wallet and Enkrypt should each have different UUIDs, but MetaMask 10.22.2 and MetaMask 9.8.1 should have the same UUID. * * @readonly */ uuid:

MOTIVATION:
At present, `window.ethereum` is the prevailing method by which Ethereum-compatible applications interact with injected wallets. This originated with Mist Wallet in 2015 to interact with other applications. With the proliferation of both applications and wallets, `window.ethereum` has unintended negative consequences: - `window.ethereum` only permits one wallet to be injected at a time, resulting in a race condition between two or more wallets. This creates an inconsistent connection behavior that makes having and using more than one browser wallet unpredictable and impractical. The current solution is for wallets to inject their own namespaces, but this is not feasible as

RATIONALE:
Standardizing a `ProviderInfo` type allows determining the necessary information to populate a wallet selection popup. This is particularly useful for web3 onboarding libraries such as Web3Modal, Web3React, and Web3Onboard. The name `evmproviders` was chosen to include other EVM-compliant chains. The SVG image format was chosen for its flexibility, lightweight nature, and dynamic resizing capabilities.


=== EIP-8024 ===
TITLE: Backward compatible SWAPN, DUPN, EXCHANGE
TYPE: Standards Track Core
STATUS: Review
CREATED: 2025-08-16
REQUIRES: 

SUMMARY:
Currently, `SWAP*` and `DUP*` instructions are limited to a stack depth of 16. Introduce three new instructions, `SWAPN`, `DUPN` and `EXCHANGE` which lift this limitation and allow accessing the stack at higher depths.

SPECIFICATION:
We introduce three new instructions: - `DUPN` (`0xe6`) - `SWAPN` (`0xe7`) - `EXCHANGE` (`0xe8`) Each instruction carries one or two immediate operands. Informally, using 1-based indexing, the semantics are: - `DUPN n`: The `n`'th stack item is duplicated at the top of the stack. - `SWAPN n`: The `n + 1`'th stack item is swapped with the top of the stack. - `EXCHANGE n m`: The `n + 1`'th stack item is swapped with the `m + 1`'th stack item. Formally, when `code[pc]` is one of these opcodes, the VM executes as follows: - `DUPN`: 1. Charge 3

MOTIVATION:
While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a "stack to memory elevation" in a compiler. This can result in complex and inefficient code. Furthermore, implementing higher level constructs, such as functions, on top of EVM will result in a list of input and output parameters as well as an instruction offset to return to. The number of these arguments (or stack items) can easily exceed 16 and thus will require extra care from a

RATIONALE:
### Use of an immediate operand Allowing dynamic selection of the arguments to swap or dup could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate operand that is not dynamic in nature. ### Disallowed immediate range Allowing the encoding of the immediate operand to take the values `0x5b` or `0x60` to `0x7f` would create a backwards incompatibility. These values correspond to the `JUMPDEST` and `PUSH1` to


=== EIP-1962 ===
TITLE: EC arithmetic and pairings with runtime definitions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-22
REQUIRES: 1109

SUMMARY:
This EIP proposes a new precompile to bring cryptographic functionality desired for privacy and scaling solutions. Functionality of such precompile will require the following: - Implementation the following operations over elliptic curves in the Weierstrass form with curve parameters such as base field, A, B coefficients defined in runtime: - Point addition - Multiplication of a single point over a scalar - Multiexponentiation - Implementation pairing operation over elliptic curves from the following "families" with parameters such as base field, extension tower structure, coefficients defined in runtime: - BLS12 - BN - MNT4/6 (Ate pairing) Full functionality of

SPECIFICATION:
If `block.number >= XXXXX`, define a set of `10` new precompiles with an addresses `[0x.., 0x.., ...]` and the following functionality. - Addition of points on the curve defined over base field - Multiplication of a point on the curve defined over base field - Multiexponentiation for `N` pairs of `(scalar, point)` on the curve defined over base field - Addition of points on the curve defined over quadratic or cubic extension of the base field - Multiplication of a point on the curve defined over quadratic or cubic extension of the base field - Multiexponentiation for `N`

MOTIVATION:
- There is a pending proposal to implement base elliptic curve arithmetic is covered by [EIP-1829](./eip-1829.md) and will allow to implement various privacy-preserving protocols with a reasonable gas costs per operation. - Pairings are an important extension for basic arithmetic and so this new precompile is proposed with the following benefits: - Extended set of curves will be available to allow Ethereum users to choose their security parameters and required functionality. - Generic approach of this precompile will allow Ethereum users to experiment with newly found curves of their choice and new constructions constructions without waiting for new

RATIONALE:
Only the largest design decisions will be covered: - While there is no arithmetic over the scalar field (which is modulo size of the main group) of the curve, it's required for gas estimation purposes. - Multiexponentiation is a separate operation due to large cost saving - There are no point decompressions due to impossibility to get universal gas estimation of square root operation. For a limited number of "good" cases prices would be too different, so specifying the "worst case" is expensive and inefficient, while introduction of another level if complexity into already complicated gas costs formula


=== EIP-778 ===
TITLE: Ethereum Node Records (ENR)
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-11-23
REQUIRES: 


=== EIP-7961 ===
TITLE: EVM64 - EOF code section
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-28
REQUIRES: 3, 5, 4, 0, ,,  , 4, 7, 5, 0, ,,  , 7, 9, 6, 0

SUMMARY:
An EOF-only specification for EVM64 instruction set. This defines a separate "EVM64" type for EOF code section in addition to "regular EVM". The interpreter then enters EVM64 mode when entering the code section. This EIP is an alternative to [EIP-7937](./eip-7937.md).

SPECIFICATION:
Define `0x02` as an allowed `type` in `types_section`, as defined in EIP-7960. This denotes an EVM64 code section. ### EOF function execution When entering an EOF code section (either at the beginning of the contract call, or through `CALLF`), it enters "pure EVM64 mode". Unless defined below, no other opcodes are allowed. Those opcodes all only operates on the least significant 64-bit, in little endian. During EOF validation, the validation function should enforce that only allowed opcodes exist. ### Gas cost constants We define the following gas cost constants: * `G_BASE64`: 1 * `G_VERYLOW64`: 2 * `G_LOW64`: 3

MOTIVATION:
EIP-7937 has maximum compatibility with existing EVM. It implements EVM64 simply as a group of additional opcodes (using a prefix opcode). This EIP defines an alternative method, using EOF container's code section. It has its pros and cons. The code size will obviously become shorter, due to not needing multibyte opcodes any more. On the other hand, interop with EVM system calls become more difficult because it cannot be done in an EVM64 code section. The advantages and disadvantages are discussed further in the Rationale section.

RATIONALE:
### Stack behavior "Pure" in "pure EVM64" refers to the fact that all opcodes in EVM64 mode only operates on the least significant 64 bits. In this specification, we don't specifically define 64-bit stack. As far as this EIP is concerned, stack is still 256-bit. However, because it only operates on the least significant 64 bits. The most significant 192 bits becomes unobservable as long as the interpreter is in an EVM64 code section. Thus an EVM interpreter can optimize EVM64 execution as follows: * When entering EVM64 code section, truncate `inputs` to 64 bits. * Use 64-bit


=== EIP-1052 ===
TITLE: EXTCODEHASH opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-05-02
REQUIRES: 161

SUMMARY:
This EIP specifies a new opcode, which returns the keccak256 hash of a contract's code.

SPECIFICATION:
A new opcode, `EXTCODEHASH`, is introduced, with number `0x3f`. The `EXTCODEHASH` takes one argument from the stack, zeros the first 96 bits and pushes to the stack the keccak256 hash of the code of the account at the address being the remaining 160 bits. In case the account does not exist or is empty (as defined by [EIP-161](./eip-161.md)) `0` is pushed to the stack. In case the account does not have code the keccak256 hash of empty data (i.e. `c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`) is pushed to the stack. The gas cost of the `EXTCODEHASH` is 400.

MOTIVATION:
Many contracts need to perform checks on a contract's bytecode, but do not necessarily need the bytecode itself. For instance, a contract may want to check if another contract's bytecode is one of a set of permitted implementations, or it may perform analyses on code and whitelist any contract with matching bytecode if the analysis passes. Contracts can presently do this using the `EXTCODECOPY` (`0x3c`) opcode, but this is expensive, especially for large contracts, in cases where only the hash is required. As a result, we propose a new opcode, `EXTCODEHASH`, which returns the keccak256 hash of a

RATIONALE:
As described in the motivation section, this opcode is widely useful, and saves on wasted gas in many cases. The gas cost is the same as the gas cost for the `BALANCE` opcode because the execution of the `EXTCODEHASH` requires the same account lookup as in `BALANCE`. Only the 20 last bytes of the argument are significant (the first 12 bytes are ignored) similarly to the semantics of the `BALANCE` (`0x31`), `EXTCODESIZE` (`0x3b`) and `EXTCODECOPY` (`0x3c`). The `EXTCODEHASH` distinguishes accounts without code and non-existing accounts. This is consistent with the way accounts are represented in the state trie.


=== EIP-7645 ===
TITLE: Alias ORIGIN to SENDER
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-03
REQUIRES: 

SUMMARY:
This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns associated with the use of ORIGIN that have and will continue to surface in all or most account abstraction proposals.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This EIP proposes the alteration of the behavior of the ORIGIN opcode within the Ethereum Virtual Machine (EVM). Currently, the ORIGIN opcode returns the address of the original transaction initiator. Under this EIP, the ORIGIN opcode would, instead, return the same value as the SENDER opcode, which is the address of the immediate sender of the message or transaction. Definition Change: The ORIGIN opcode

MOTIVATION:
The ORIGIN opcode in Ethereum returns the address of the account that started the transaction chain, differing from the SENDER (or CALLER) opcode, which returns the address of the direct caller. The use of ORIGIN has been discouraged and deemed deprecated since mid-2016 due to the security problems it introduces, such as susceptibility to phishing attacks and other vulnerabilities where the distinction between the original sender and the immediate sender can be exploited. For instance, if an [ERC-4337](./eip-4337.md) bundler has tokens or other authority in a smart contract determined by ORIGIN, any of the transactions it bundles can

RATIONALE:
The rationale behind aliasing ORIGIN to SENDER is to: Facilitate Account Abstraction: Elegantly nullify a universal barrier to account abstraction, enabling more flexible and powerful account models in Ethereum. Enhance Security: Eliminate the security vulnerabilities associated with differentiating between the original transaction initiator and the immediate caller. Clean up tech debt and simplify the EVM Model: Reduce the complexity of the EVM's transaction and execution model by removing an outdated and deprecated feature, making future changes easier and safer.


=== EIP-7928 ===
TITLE: Block-Level Access Lists
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-31
REQUIRES: 

SUMMARY:
This EIP introduces Block-Level Access Lists (BALs) that record all accounts and storage locations accessed during block execution, along with their post-execution values. BALs enable parallel disk reads, parallel transaction validation, and executionless state updates.

SPECIFICATION:
### Block Structure Modification We introduce a new field to the block header, `block_access_list_hash`, which contains the Keccak-256 hash of the RLP-encoded block access list. When no state changes are present, this field is the hash of an empty rlp list `0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347`, i.e. `keccak256(rlp.encode([]))`. ```python class Header: # Existing fields ... block_access_list_hash: Hash32 = keccak256(rlp.encode(block_access_list)) ``` The block body includes a `BlockAccessList` containing all account accesses and state changes. This field is RLP-encoded as a list of `AccountChanges`. When no state changes are present, this field is the empty RLP list `0xc0`, i.e. `rlp.encode([])`. ### RLP Data Structures

MOTIVATION:
Transaction execution cannot be parallelized without knowing in advance which addresses and storage slots will be accessed. While [EIP-2930](./eip-2930.md) introduced optional transaction access lists, they are not enforced. This proposal enforces access lists at the block level, enabling: - Parallel disk reads and transaction execution - State reconstruction without executing transactions - Reduced execution time to `parallel IO + parallel EVM`

RATIONALE:
### BAL Design Choice This design variant was chosen for several key reasons: 1. **Size vs parallelization**: BALs include all accessed addresses (even unchanged) for complete parallel IO and execution. 2. **Storage values for writes**: Post-execution values enable state reconstruction during sync without individual proofs against state root. 3. **Overhead analysis**: Historical data shows ~45 KiB average BAL size. 4. **Transaction independence**: 60-80% of transactions access disjoint storage slots, enabling effective parallelization. The remaining 20-40% can be parallelized by having post-transaction state diffs. 5. **RLP encoding**: Native Ethereum encoding format, maintains compatibility with existing infrastructure. ### Block Size


=== EIP-7834 ===
TITLE: Separate Metadata Section for EOF
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-12-06
REQUIRES: 3540

SUMMARY:
Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Extending the format introduced in [EIP-3540](./eip-3540.md), this EIP proposes to add a new OPTIONAL section in the body called `metadata_section` before the `data_section`, and to add two new OPTIONAL fields `kind_metadata` (value: `0x05`) and `metadata_size` to the header before the `kind_data` and `data_size` fields. ``` container := header, body header := magic, version, kind_type, type_size, kind_code, num_code_sections, code_size+, [kind_container, num_container_sections, container_size+,] [kind_metadata, metadata_size,] kind_data,

MOTIVATION:
It is desirable to include metadata in contract's bytecode for various reasons. For instance, both the Solidity and Vyper compilers by default include the language and compiler version used to compile. Vyper (with 0.4.1) appends an integrity hash to the initcode in CBOR encoding. Solidity additionally includes the IPFS or the Swarm hash of the Solidity contract metadata.json file, and the experimental Solidity flag. The current (pre-EOF) practice is to append this CBOR encoded metadata section in the contract's runtime bytecode, followed by the 2 bytes length of the CBOR encoded bytes. ``` Solidity ┌──────────────────────────────────────────0x0033 bytes──────────────────────────────────────────────┐ ...7265206c656e677468a2646970667358221220dceca8706b29e917dacf25fceef95acac8d90d765ac926663ce4096195952b6164736f6c634300060b0033 ```

RATIONALE:
The `metadata_section` in the `body`, as well as the `kind_metadata` and `metadata_size` fields in the `header`, are OPTIONAL. This way, the compilers can avoid additional bytes in the container if they don't want to write any metadata. The `data_section` can change in its size and content during deployment, therefore it needs to be REQUIRED, even if the data is empty. The `metadata_section` is not expected to change during the deployment. The reason for placing the `metadata_section` before the `data_section`, and assigning `kind_metadata` the value `0x05` (and not `0x04`) is to make it easier for the existing EOF tooling


=== EIP-7495 ===
TITLE: SSZ ProgressiveContainer
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-08-18
REQUIRES: 7916

SUMMARY:
This EIP introduces a new [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md) type to represent containers with forward-compatible Merkleization: A given field is always assigned the same stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/merkle-proofs.md#generalized-merkle-tree-index) even when different container versions append new fields or drop existing fields.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `ProgressiveContainer(active_fields)` A new [SSZ composite types](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#composite-types) is defined: - **progressive container**: ordered heterogeneous collection of values with stable Merkleization - python dataclass notation with key-type pairs, e.g. ```python class Square(ProgressiveContainer(active_fields=[1, 0, 1])): side: uint16 # Merkleized at field index #0 (location of first 1 in `active_fields`) color: uint8 # Merkleized at field index #2 (location of second 1 in `active_fields`) class Circle(ProgressiveContainer(active_fields=[0, 1,

MOTIVATION:
SSZ containers are frequently versioned, for example across fork boundaries. When the number of fields reaches a new power of two, or a field is removed or replaced with one of a different type, the shape of the underlying Merkle tree changes, breaking verifiers of Merkle proofs for these containers. Deploying a new verifier may involve security councils to upgrade smart contract logic, or require firmware updates for embedded devices. This effort is needed even when no semantic changes apply to the fields that the verifier is interested in. Progressive containers address these shortcomings by: - Using the

RATIONALE:
### Why is `active_fields` limited to 256 bits? 256 bits (1 word) allows the mix-in to be simple, consistent with the length mix-in for lists, and is practically sufficient. An alternate design with a `ProgressiveBitlist` mix-in was explored, however deemed too over-engineered as it would effectively require introducing caches to pre-compute the mix-in's `hash_tree_root` to avoid repeated computations, and also makes verifier logic more complex than necessary. Even though the 256 field limit includes all fields (including deprecated ones), it is unlikely that many progressive containers come close to reach 256 fields (`BeaconState` currently reaches around 40 fields).


=== EIP-3091 ===
TITLE: Block Explorer API Routes
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-11-02
REQUIRES: 

SUMMARY:
This proposal brings standardization between block explorers API routes when linking transactions, blocks, accounts and tokens.

SPECIFICATION:
Block explorers will route their webpages accordingly for the following data: ### Blocks `<BLOCK_EXPLORER_URL>/block/<BLOCK_HASH_OR_HEIGHT>` ### Transactions `<BLOCK_EXPLORER_URL>/tx/<TX_HASH>` ### Accounts `<BLOCK_EXPLORER_URL>/address/<ACCOUNT_ADDRESS>` ### Tokens `<BLOCK_EXPLORER_URL>/token/<TOKEN_ADDRESS>`

MOTIVATION:
Currently wallets and dapps link transactions and accounts to block explorer web pages but as chain diversity and layer two solutions grow it becomes harder to maintain a consistent user experience. Adding new chains or layer two solutions becomes harder given these endpoints are inconsistent. Standardizing the API routes to these links improves interoperability between wallets and block explorers.

RATIONALE:
The particular paths used in this proposal are chosen to be compatible with the majority of existing block explorers.


=== EIP-7039 ===
TITLE: Scheme-Handler Discovery Option for Wallets
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2023-05-15
REQUIRES: 1193

SUMMARY:
This proposal (affectionately known as SHADOW) is an alternative to [EIP-1193](./eip-1193.md) for wallet discovery in web browsers that requires no special permissions. Web pages intending to open a connection to a wallet inject an `iframe` tag pointing at a well-known scheme. Communication between the page and the wallet uses the `postMessage` API.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Initiating a Connection To initiate a connection to a provider, a web page SHOULD: 1. Add an event listener to `window` for the `"message"` event (or set `window.onmessage`.) 2. Create an `iframe` tag with a `src` attribute value of `web+evm://`; then 3. Attach the `iframe` to the DOM. 4. Wait for a `"message"` event with a non-nullish `source` equal to the `iframe`'s `contentWindow`.

MOTIVATION:
Current wallet discovery methods (eg. `window.ethereum`) only support one active wallet at a time, and require browser extensions to request broad permissions to modify web pages. Ideally users should be able to have multiple wallets active, and choose between them at runtime. This not only results in an improved user experience but also reduces the barrier to entry for new browser extensions as users are no longer forced to only install one browser extension at a time. With SHADOW, and unlike other recent proposals, browser extensions do not need blanket `content_scripts` or any `permissions` at all. Furthermore, any

RATIONALE:
Instead of directly using the `iframe.contentWindow`'s message port, SHADOW transfers a message port in the first message. This allows the `iframe`, in some specific scenarios, to completely hand off communication, so the web page and the provider communicate directly, without any proxying in the `iframe`.


=== EIP-7664 ===
TITLE: Access-Key opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2024-03-27
REQUIRES: 1, 1, 5, 3, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4

SUMMARY:
This EIP introduces a new opcode to inspect the access-list keys of the executing address.

SPECIFICATION:
### Parameters | Constant | Value | |----------------------------|--------| | `ACCESS_KEY_OPCODE_GAS` | `3` | | `ACCESS_KEY_OPCODE_BYTE` | `0x4B` | ### Opcode We add an instruction `ACCESS_KEY` (with opcode `ACCESS_KEY_OPCODE_BYTE`) which pops `index` from the top of the stack as big-endian `uint256`, and pushes `tx.access_list[address][index]` back on the stack, if `address` is present in the `tx.access_list` and `index < len(tx.access_list[address])`, and otherwise pushes a zeroed `bytes32` value. ### Gas costs The opcode has a fixed gas cost of `ACCESS_KEY_OPCODE_GAS`. The intrinsic gas costs of the access-list contents of the transaction itself do not change.

MOTIVATION:
This EIP serves as a substitute of top-level-call detection to enable a smart-contract to enforce static declaration of attributes. Previously, application-layer contracts, against common advice from account-abstraction proponents, used to rely on the `tx.origin` to enforce a top-level call, such that the contract inputs are encoded as transaction input. While the access-list of transactions directly affects the execution, it only affects the gas-costs. This EIP enhances the access-list feature to provide the property of statically-defined contract-inputs, without relying on top-level calls, the `tx.origin` behavior, or gas introspection. This enables smart contracts to reliably enforce static declaration of inputs.

RATIONALE:
### Static analysis of transactions Static declaration of contract-inputs enables advanced layer-two constructions and block-building techniques: data is available without EVM introspection, and contracts can reliably tell if the executing transaction declared critical properties to the block builder and verifying nodes. Static-declaration of contract inputs is now independent of account-abstraction related changes, such as transaction bundlers, as well as in-protocol with 3074. <!-- EIP link/requires omitted due to Walidator EIP status bug --> ### Global read-only values Akin to `TLOAD`, as described in [EIP-1153](./eip-1153.md), the `ACCESS_KEY` opcode provides contracts with a view that is global to the message-execution


=== EIP-2255 ===
TITLE: Wallet Permissions System
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-08-22
REQUIRES: 1193

SUMMARY:
This EIP adds two new wallet-namespaced RPC endpoints, `wallet_getPermissions` and `wallet_requestPermissions`, providing a standard interface for requesting and checking permissions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal adds two new methods to a wallet's web3 provider API: `wallet_getPermissions` and `wallet_requestPermissions`. ### `wallet_getPermissions` The `wallet_getPermissions` method is used for getting an array of current permissions (empty by default). It takes no parameters and returns an array of `Permission` objects. #### `wallet_getPermissions` Returns The format of the returned permissions MUST be an array of `Permission` objects, which are defined as follows: ```typescript interface Caveat { type:

MOTIVATION:
Wallets are responsible for mediating interactions between untrusted applications and users' keys through appropriate user consent. Today, wallets always prompt the user for every action. This provides security at the cost of substantial user friction. We believe that a single permissions request can achieve the same level of security with vastly improved UX. The pattern of permissions requests (typically using Oauth2) is common around the web, making it a very familiar pattern: ![Facebook Permissions](../assets/eip-2255/facebook_permissions.png) ![Log in With Apple](../assets/eip-2255/log_in_with_apple.jpeg) Many web3 applications today begin their sessions with a series of repetitive requests: - Reveal your wallet address to this

RATIONALE:
While the current model of getting user consent on a per-action basis has high security, there are huge usability gains to be had bo getting more general user consent which can cover broad categories of usage, which can be expressed in a more human-readable way. This pattern has a variety of benefits to offer different functions within a web3 wallet. The `requestPermissions` method can be expanded to include other options related to the requested permissions, for example, sites could request accounts with specific abilities. For example, a website like an exchange that requires `signTypedData_v3` (which is not supported


=== EIP-107 ===
TITLE: safe "eth_sendTransaction" authorization via html popup
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2016-06-05
REQUIRES: 

SUMMARY:
This draft EIP describes the details of an authorization method that if provided by rpc enabled ethereum nodes would allow regular websites to send transactions (via ```eth_sendTransaction```) without the need to enable CORS. Instead, user would be asked to confirm the transaction via an html popup. Every read only rpc call the dapp wants to perform is redirected to an invisible iframe from the node's domain and for every transaction that the dapp wish to execute, an html popup is presented to the user to allow him/her to cancel or confirm the transaction. This allows the dapp to

SPECIFICATION:
In order for the mechanism to work, the node needs to serve an html file via http at the url \<node url\>/authorization.html This file will then be used by the dapp in 2 different modes (invisible iframe and popup window). The invisible iframe will be embedded in the dapp to allow the dapp to send its read-only rpc call without having to enable CORS for the dapp's website domain. This is done by sending message to the iframe (via javascript ```window.postMessage```) which in turn execute the rpc call. This works since the iframe and the node share the

MOTIVATION:
Currently, if a user navigates to a dapp running on a website using her/his everyday browser, the dapp will by default have no access to the rpc api for security reasons. The user will have to enable CORS for the website's domain in order for the dapp to work. Unfortunately if the user does so, the dapp will be able to send transactions from any unlocked account without the need for any user consent. In other words, not only does the user need to change the node's default setting, but the user is also forced to trust the

RATIONALE:
The design for that proposal was chosen for its simplicity and security. A previous idea was to use an oauth-like protocol in order for the user to accept or deny a transaction request. It would have required deeper code change in the node and some geth contributors argues that such change did not fit into geth code base as it would have required dapp aware code. The current design, instead has a very simple implementation (self contained html file that can be shared across node's implementation) and its safeness is guaranteed by browsers' cross domain policies. The use


=== EIP-7675 ===
TITLE: Retroactively Included EIPs
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2024-04-04
REQUIRES: 2, 6, 8, 1, ,,  , 3, 6, 0, 7, ,,  , 4, 8, 0, 3, ,,  , 7, 5, 2, 3, ,,  , 7, 6, 1, 0

SUMMARY:
This Meta EIP lists Core EIPs introducing changes to Ethereum's consensus which were activated independently of an Ethereum hard fork due to their backward compatible nature. These EIPs generally introduce constraints to underspecified protocol rules or clarify how certain edge cases should be handled.

SPECIFICATION:
### Retroactively Activated EIPs * [EIP-2681](./eip-2681.md): Limit account nonce to 2^64-1 * [EIP-3607](./eip-3607.md): Reject transactions from senders with deployed code * [EIP-4803](./eip-4803.md): Limit transaction gas to a maximum of 2^63-1 * [EIP-7523](./eip-7523.md): Empty accounts deprecation * [EIP-7610](./eip-7610.md): Revert creation in case of non-empty storage ### Activation All EIPs listed above are considered activated as of Ethereum's genesis block. Note that EIP-7523 distinguishes pre- and post-merge behavior on the Ethereum mainnet.

MOTIVATION:
To maintain consensus across all nodes, backward incompatible changes to Ethereum must be activated synchronously. Given the coordination required for this, changes are usually bundled together in network upgrades. A Meta EIP is typically used to list the changes included in a network upgrade, as well as its activation time. However, backward compatible consensus changes do not require a network upgrade to be activated. For example, if a consensus rule is underspecified, an EIP can propose a constraint to bound it. If the constraint was never broken in Ethereum's history and is unlikely to be broken in the

RATIONALE:
This Meta EIP provides a global view of all changes included in the Ethereum protocol without an explicit network upgrade, as well as links to full specification.


=== EIP-3332 ===
TITLE: MEDGASPRICE Opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-05
REQUIRES: 

SUMMARY:
Adds `MEDGASPRICE (0x46)` opcode that returns the median gas price for the parent block.

SPECIFICATION:
If `block.number >= TBD`, add a new opcode `MEDGASPRICE (0x46)`: Pushes the median gas price of the parent block onto the stack. | Op | Input | Output | Cost | |:----: |:-----: |:------: |:----: | | 0x46 | 0 | 1 | 8 |

MOTIVATION:
With the emergence of rollups as core mechanisms in scaling Ethereum there are a number of common transactions that can be front-run. Optimistic rollups rely on the submission of fraud proofs to maintain the integrity of their systems. As a result actors submitting fraud proofs typically receive a financial reward for doing so. This opens a trivial front-running strategy of watching the mempool for fraud proof submissions and copying such transactions with a much higher gas price to reap the reward. Such front-runners do not perform validation independently and de-incentivize others from performing validation. Adding a mechanism enforcing

RATIONALE:
Having access to the current gas price economy allows contracts to implement more robust and automated logic surrounding acceptable transaction gas prices. ### Naming note The name `MEDGASPRICE` was chosen because the median gas price of the network can only be calculated from the latest complete block. Thus transactions being executed should expect the median gas price to be calculated from the previous block.


=== EIP-6780 ===
TITLE: SELFDESTRUCT only in same transaction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-03-25
REQUIRES: 2, 6, 8, 1, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 2, 9

SUMMARY:
This EIP changes the functionality of the `SELFDESTRUCT` opcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved when `SELFDESTRUCT` is called in the same transaction a contract was created.

SPECIFICATION:
The behaviour of `SELFDESTRUCT` is changed in the following way: 1. When `SELFDESTRUCT` is executed in a transaction that is not the same as the contract calling `SELFDESTRUCT` was created: - The current execution frame halts. - `SELFDESTRUCT` does not delete any data (including storage keys, code, or the account itself). - `SELFDESTRUCT` transfers the entire account balance to the target. - Note that if the target is the same as the contract calling `SELFDESTRUCT` there is no net change in balances. Unlike the prior specification, Ether will not be burnt in this case. - Note that no

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account. This EIP implements this change. Applications that only use `SELFDESTRUCT` to retrieve funds will still work. Applications that only use `SELFDESTRUCT` in the same transaction as they created a contract will also continue to work without any changes.

RATIONALE:
Getting rid of the `SELFDESTRUCT` opcode has been considered in the past, and there are currently no strong reasons to use it. This EIP implements a behavior that will attempt to leave some common uses of `SELFDESTRUCT` working, while reducing the complexity of the change on EVM implementations that would come from contract versioning. Handling the account creation and contract creation as two distinct and possibly separate events is needed for use cases such as counterfactual accounts. By allowing the `SELFDESTRUCT` to delete the account at contract creation time it will not result in stubs of counterfactually instantiated


=== EIP-7620 ===
TITLE: EOF Contract Creation
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-02-12
REQUIRES: 1, 7, 0, ,,  , 6, 8, 4, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 4, 0, ,,  , 3, 5, 4, 1, ,,  , 3, 6, 7, 0

SUMMARY:
EVM Object Format (EOF) removes the possibility to create contracts using `CREATE` or `CREATE2` instructions. We introduce a new/replacement method in form of pair of instructions : `EOFCREATE` and `RETURNCODE` to provide a way to create contracts using EOF containers.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Wherever not explicitly listed, the rules of EOF contract creation, as well as the `EOFCREATE` instruction, should be identical or analogous to those of `CREATE2` instruction. This includes but is not limited to: - behavior on `accessed_addresses` and address collision ([EIP-684](./eip-684.md) and [EIP-2929](./eip-2929.md)) - EVM execution frame created for the `EOFCREATE` initcode - memory, account context etc. - nonce bumping of the account of

MOTIVATION:
This EIP uses terminology from the [EIP-3540](./eip-3540.md) which introduces the EOF format. EOF aims to remove code observability, which is a prerequisite to legacy EVM contract creation logic using legacy-style create transactions, `CREATE` or `CREATE2`, because both the initcode and code are available to the EVM and can be manipulated. On the same premise, EOF removes opcodes like `CODECOPY` and `EXTCODECOPY`, introducing EOF subcontainers as a replacement to cater for factory contracts creating other contracts. The new instructions introduced in this EIP operate on EOF containers enabling factory contract use case that legacy EVM has.

RATIONALE:
### Data section appending The data section is appended to during contract creation and also its size needs to be updated in the header. Alternative designs were considered, where: - additional section kinds for the data were introduced - additional fields describing a subcontainer were introduced - data section would be written over as opposed to being appended to, requiring it to be filled with 0 bytes prior to deployment All of these alternatives either complicated the otherwise simple data structures or took away useful features (like the dynamically sized portion of the data section). ### `keccak256(initcontainer)` in


=== EIP-1681 ===
TITLE: Temporal Replay Protection
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-01-08
REQUIRES: 

SPECIFICATION:
The roll-out would be performed in two phases, `X` (hardfork), and `Y` (softfork). At block `X`, - Add an optional field `valid-until` to the RLP-encoded transaction, defined as a `uint64` (same as `nonce`). - If the field is present in transaction `t`, then - `t` is only eligible for inclusion in a block if `block.timestamp` < `t.valid-until`. At block `Y`, - Make `valid-until` mandatory, and consider any transaction without `valid-until` to be invalid.

MOTIVATION:
There are a couple of different motivators for introducing a timebased transaction validity. - If any form of dust-account clearing is introduced, e.g. (https://github.com/ethereum/EIPs/issues/168), it will be necessary to introduce a replay protection, such as https://github.com/ethereum/EIPs/issues/169 . Having temporal replay protection removes the need to change nonce-behaviour in the state, since transactions would not be replayable at a later date than explicitly set by the user. - In many cases, such as during ICOs, a lot of people want their transactions to either become included soon (within a couple of hours) or not at all. Currently, transactions are

RATIONALE:
### Rationale for this EIP For the dust-account clearing usecase, - This change is much less invasive in the consensus engine. - No need to maintain a consensus-field of 'highest-known-nonce' or cap the number of transactions from a sender in a block. - Only touches the transaction validation part of the consensus engine - Other schemas which uses the `nonce` can have unintended side-effects, - such as inability to create contracts at certain addresses. - more difficult to integrate with offline signers, since more elaborate nonce-schemes requires state access to determine. - More intricate schemes like `highest-nonce` are


=== EIP-627 ===
TITLE: Whisper Specification
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-05-05
REQUIRES: 

SUMMARY:
This EIP describes the format of Whisper messages within the ÐΞVp2p Wire Protocol. This EIP should substitute the [existing specification](https://github.com/ethereum/wiki/wiki/Whisper-Wire-Protocol). More detailed documentation on Whisper could be found [here](https://github.com/ethereum/go-ethereum/wiki/Whisper).

SPECIFICATION:
All Whisper messages sent as ÐΞVp2p Wire Protocol packets should be RLP-encoded arrays of data containing two objects: integer packet code followed by another object (whose type depends on the packet code). If Whisper node does not support a particular packet code, it should just ignore the packet without generating any error. ### Packet Codes The message codes reserved for Whisper protocol: 0 - 127. Messages with unknown codes must be ignored, for forward compatibility of future versions. The Whisper sub-protocol should support the following packet codes: | EIP | Name | Int Value | |-------|----------------------------|-----------| | |

MOTIVATION:
It is necessary to specify the standard for Whisper messages in order to ensure forward compatibility of different Whisper clients.

RATIONALE:
Packet codes 0x00 and 0x01 are already used in all Whisper versions. Packet code 0x02 will be necessary for the future development of Whisper. It will provide possibility to adjust the PoW requirement in real time. It is better to allow the network to govern itself, rather than hardcode any specific value for minimal PoW requirement. Packet code 0x03 will be necessary for scalability of the network. In case of too much traffic, the nodes will be able to request and receive only the messages they are interested in. Packet codes 0x7E and 0x7F may be used to


=== EIP-7843 ===
TITLE: SLOTNUM opcode
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-12-06
REQUIRES: 

SUMMARY:
This EIP proposes to add a new opcode `SLOTNUM` (`0x4b`), that returns the corresponding slot number for the current block.

SPECIFICATION:
A new opcode `SLOTNUM` is introduced at `0x4b`. It shall return one stack element. ### Output One element `SlotNumber` is added to the stack; it is equal to the corresponding slot number for this block. `SlotNumber` is a `uint64` in big endian encoding. ### Gas Cost The gas cost for `SLOTNUM` is a fixed fee of `2`. ### RPC changes The slot number is calculated in the consensus layer and passed to the execution layer through the engine API. #### Header extension The header encoding shall be extended to include a `slot_number` field of type `uint64`. #### PayloadAttributes

MOTIVATION:
There are currently two ways to get the current slot number onchain: 1) Calculate from the block timestamp. This requires hardcoding the chain slot length into a smart contract. 2) Provide the slot number as calldata and prove it against the beacon block root (using [EIP-4788](./eip-4788.md)). Both of these approaches have significant drawbacks. (1) would break contracts in the event of a change to the slot length. (2) is expensive in terms of gas, encouraging approach (1) to be used instead. A better approach is for the slot length to be abstracted away from applications, and instead the

RATIONALE:
### Gas Price The opcode is priced to match similar opcodes in the `W_base` set. ### Calculation in consensus layer The slot number could alternatively be calculated in the execution layer using the timestamp, but it is more appropriate to calculate values pertaining to the beacon chain in the consensus layer. Additionally this avoids code duplication, as the slot number is already calculated in the consensus layer. ### ZK-VM proving The `SLOTNUM` opcode should not increase the complexity of proving EVM execution, as it is similar to existing opcodes such as `TIMESTAMP`. The slot number is included in


=== EIP-145 ===
TITLE: Bitwise shifting instructions in EVM
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.

SPECIFICATION:
The following instructions are introduced: ### `0x1b`: `SHL` (shift left) The `SHL` instruction (shift left) pops 2 values from the stack, first `arg1` and then `arg2`, and pushes on the stack `arg2` shifted to the left by `arg1` number of bits. The result is equal to ``` (arg2 * 2^arg1) mod 2^256 ``` Notes: - The value (`arg2`) is interpreted as an unsigned number. - The shift amount (`arg1`) is interpreted as an unsigned number. - If the shift amount (`arg1`) is greater or equal 256 the result is 0. - This is equivalent to `PUSH1 2 EXP

MOTIVATION:
EVM is lacking bitwise shifting operators, but supports other logical and arithmetic operators. Shift operations can be implemented via arithmetic operators, but that has a higher cost and requires more processing time from the host. Implementing `SHL` and `SHR` using arithmetic cost each 35 gas, while the proposed instructions take 3 gas.

RATIONALE:
Instruction operands were chosen to fit the more natural use case of shifting a value already on the stack. This means the operand order is swapped compared to most arithmetic instructions.


=== EIP-2031 ===
TITLE: State Rent B - Net transaction counter
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-15
REQUIRES: 2029

SUMMARY:
It is part of the State Rent roadmap. This particular change makes any Ethereum transaction increment the transaction counter, which is a special storage slot in the *State counter contract*. This counter will be used to populate the nonces of newly created non-contract accounts. This way of populating nonce ensures replay protection for accounts that were evicted and then brought back by sending ether to them.

SPECIFICATION:
A new field, with the location 0 (that means it resides in the storage slot 0 in the state counter contract, and can be read by calling that contract with argument being 32 zero bytes), is added to the state counter contract. It will eventually contain `txCount`, the total number of transactions processed up until that point. On an after block B, or after the deployment of the state counter contract (which comes first), the field `txCount` is incremented after each transaction. Updating `txCount` means updating the storage of state counter contract at the location 0. These changes

MOTIVATION:
Ethereum currently does not have a special place in the state for tracking number of transactions.

RATIONALE:
Two main alternatives were proposed for the replay protection of the accounts that were evicted by subsequently brought back by sending ether to them: 1. Temporal replay protection. The nonce of the new accounts (and those brought back) is still zero, but a new `valid-until` field is introduced, making transactions invalid for inclusion after the time specified in this field. This, however, has unwanted side effected related to the fact that account nonces are not only used for replay protection, but also for computing the addresses of the deployed contracts (except those created by `CREATE2`). 2. Setting nonce


=== EIP-6888 ===
TITLE: Arithmetic verification at EVM level
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-16
REQUIRES: 

SUMMARY:
This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Starting from `BLOCK_TIMESTAMP >= HARDFORK_TIMESTAMP` ### Constants | Constant | Type | Value | | -------------------- | --------- | --------- | | `HARDFORK_TIMESTAMP` | `uint64` | `TBD` | | `UINT_MAX` | `uint256` | `2 ** 256 - 1` | | `INT_MIN` | `int256` | `-(2**255)` | ### Flags | Variable | Type | Initial Value | | ------------------- | --------- |:------------- | | `carry`

MOTIVATION:
The importance of math checks in smart contract projects is very clear. It was an OpenZeppelin library and then incorporated in Solidity's default behavior. Bringing this to EVM level can combine both gas efficiency and safety.

RATIONALE:
EVM uses two's complement for negative numbers. The opcodes listed above triggers one or two flags depending if they are used for signed and unsigned numbers. The conditions described for each opcode is made with implementation friendliness in mind. The only exception is EXP as it is hard to give a concise test as most of the others relied on the inverse operation and there is no native `LOG`. Most `EXP` implementations will internally use `MUL` so the flag `carry` can be drawn from that instruction, not the `overflow`. Both flags are cleaned at the same time because


=== EIP-1102 ===
TITLE: Opt-in account exposure
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-05-04
REQUIRES: 1474

SUMMARY:
The previous generation of Ethereum-enabled DOM environments follows a pattern of injecting a provider populated with accounts without user consent. This puts users of such environments at risk because malicious websites can use these accounts to view detailed account information and to arbitrarily initiate unwanted transactions on a user's behalf. This proposal outlines a protocol in which Ethereum-enabled DOM environments can choose to expose no accounts until the user approves account access.

SPECIFICATION:
### Concepts #### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). #### `eth_requestAccounts` Providers exposed by Ethereum-enabled DOM environments define a new RPC method: `eth_requestAccounts`. Calling this method may trigger a user interface that allows the user to approve or reject account access for a given dapp. This method returns a `Promise` that is resolved with an `Array` of accounts or is rejected with an `Error` if accounts are not available. ```typescript ethereum.send('eth_requestAccounts'): Promise<Array<string>> ``` #### Provider#enable

RATIONALE:
The pattern of automatic account exposure followed by the previous generation of Ethereum-enabled DOM environments fails to protect user privacy and fails to maintain safe user experience: untrusted websites can both view detailed account information and arbitrarily initiate transactions on a user's behalf. Even though most users may reject unsolicited transactions on untrusted websites, a protocol for account access should make such unsolicited requests impossible. This proposal establishes a new pattern wherein dapps must request access to user accounts. This protocol directly strengthens user privacy by allowing the browser to hide user accounts and preventing unsolicited transaction requests


=== EIP-3855 ===
TITLE: PUSH0 instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-02-19
REQUIRES: 

SUMMARY:
Introduce the `PUSH0` (`0x5f`) instruction, which pushes the constant value 0 onto the stack.

SPECIFICATION:
The instruction `PUSH0` is introduced at `0x5f`. It has no immediate data, pops no items from the stack, and places a single item with the value 0 onto the stack. The cost of this instruction is 2 gas (aka `base`).

MOTIVATION:
Many instructions expect offsets as inputs, which in a number of cases are zero. A good example is the return data parameters of `CALLs`, which are set to zeroes in case the contract prefers using `RETURNDATA*`. This is only one example, but there are many other reasons why a contract would need to push a zero value. They can achieve that today by `PUSH1 0`, which costs 3 gas at runtime, and is encoded as two bytes which means `2 * 200` gas deployment cost. Because of the overall cost many try to use various other instructions to

RATIONALE:
### Gas cost The `base` gas cost is used for instructions which place constant values onto the stack, such as `ADDRESS`, `ORIGIN`, and so forth. ### Opcode `0x5f` means it is in a "contiguous" space with the rest of the `PUSH` implementations and potentially could share the implementation.


=== EIP-1283 ===
TITLE: Net gas metering for SSTORE without dirty maps
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
This EIP proposes net gas metering changes for `SSTORE` opcode, enabling new usages for contract storage, and reducing excessive gas costs where it doesn't match how most implementation works. This acts as an alternative for EIP-1087, where it tries to be friendlier to implementations that use different optimization strategies for storage change caches.

SPECIFICATION:
Definitions of terms are as below: * *Storage slot's original value*: This is the value of the storage if a reversion happens on the *current transaction*. * *Storage slot's current value*: This is the value of the storage before SSTORE operation happens. * *Storage slot's new value*: This is the value of the storage after SSTORE operation happens. Replace `SSTORE` opcode gas cost calculation (including refunds) with the following logic: * If *current value* equals *new value* (this is a no-op), 200 gas is deducted. * If *current value* does not equal *new value* * If *original value*

MOTIVATION:
This EIP proposes a way for gas metering on SSTORE (as an alternative for EIP-1087 and EIP-1153), using information that is more universally available to most implementations, and require as little change in implementation structures as possible. * *Storage slot's original value*. * *Storage slot's current value*. * Refund counter. Usages that benefits from this EIP's gas reduction scheme includes: * Subsequent storage write operations within the same call frame. This includes reentry locks, same-contract multi-send, etc. * Exchange storage information between sub call frame and parent call frame, where this information does not need to be persistent

RATIONALE:
This EIP mostly achieves what a transient storage tries to do (EIP-1087 and EIP-1153), but without the complexity of introducing the concept of "dirty maps", or an extra storage struct. * We don't suffer from the optimization limitation of EIP-1087. EIP-1087 requires keeping a dirty map for storage changes, and implicitly makes the assumption that a transaction's storage changes are committed to the storage trie at the end of a transaction. This works well for some implementations, but not for others. After EIP-658, an efficient storage cache implementation would probably use an in-memory trie (without RLP encoding/decoding) or


=== EIP-1227 ===
TITLE: Defuse Difficulty Bomb and Reset Block Reward
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-18
REQUIRES: 649

SUMMARY:
Starting with `FORK_BLKNUM` the client will calculate the difficulty without the additional exponential component. Furthermore, block rewards will be adjusted to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Remove Exponential Component of Difficulty Adjustment For the purposes of `calc_difficulty`, simply remove the exponential difficulty adjustment component, `epsilon`, i.e. the `int(2**((block.number // 100000) - 2))`. #### Reset Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward = 5_000_000_000_000_000_000 if block.number >= FORK_BLKNUM else block.reward (5E18 wei, or 5,000,000,000,000,000,000 wei, or 5 ETH). Analogue, if an uncle is included in a block for `block.number >= FORK_BLKNUM` such that `block.number - uncle.number = k`, the uncle reward is new_uncle_reward = (8 - k) * new_block_reward / 8 This

MOTIVATION:
Due to the "difficulty bomb" (also known as the "ice age"), introduced in EIP [#2](./eip-2.md), an artificial exponential increase in difficulty until chain freeze, users may find it much more challenging to remain on the unforked chain after a hard-fork. This is a desirable effect of the ice age (in fact, its only stated purpose) in the case of a scheduled network upgrade, but is especially problematic when a hard-fork includes a controversial change. This situation has already been observed: during the Byzantium hard-fork users were given the "choice" of following the upgraded side of the chain or

RATIONALE:
This will permanently, without further changes, disable the "ice age." It will also reset the block reward to pre-Byzantium levels. Both of these changes are specified similarly to EIP [#649](./eip-649.md), so they should require only minimal changes from client developers.


=== EIP-7545 ===
TITLE: Verkle proof verification precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-13
REQUIRES: 

SUMMARY:
This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A precompiled contract is added at address `0x21`, wrapping the stateless ethereum proof verification function. The precompile's `input` is the tightly packed concatenation of the following fields: * `version` (1 byte) specifies which version of the stateless proof verification function should be used. Version 0 is used for an MPT and version 1 is used for the polynomial commitment scheme multiproof used in [EIP-6800](./eip-6800.md).

MOTIVATION:
The proposed proof systems for stateless Ethereum require an upgrade to many tools and applications, that need a simple path to keep their proving systems up-to-date, without having to develop and deploy new proving libraries each time another proof format must be supported.

RATIONALE:
Stateless Ethereum relies on proofs using advanced mathematical concepts and tools from a fast-moving area of cryptography. As a result, a soft-fork approach is currently favored in the choice of the proof format: proofs are going to be distributed outside of consensus, and in the future, stateless clients will be able to chose their favorite proof format. This introduces a burden on several application, e.g. bridges, as they will potentially need to support proof formats designed after the release of the bridge contract. Delegating the proof verification burden to a version-aware precompile will ensure that these applications can


=== EIP-7775 ===
TITLE: BURN opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-09-30
REQUIRES: 

SUMMARY:
This proposal introduces a `BURN` opcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Behaviour The `BURN` opcode `(0xFC)` is introduced with the following behavior: 1. Pops one 32-byte word from the top of the stack, treating these bytes as the `uint256` amount of native ether to be burned. 2. Retrieves the current address from the EVM execution context. 3. Checks the balance of the current address. 4. If the amount to be burned is greater than

MOTIVATION:
The motivation for this proposal is to provide a standardized and efficient way to burn native ether directly within the EVM. Historically, contracts such as the BeaconDepositContract have "burned" ether by making it irrecoverable from the given address. This approach can lead to confusion and potential misuse. By introducing a dedicated `BURN` opcode, we can ensure a clear and consistent method for burning native ether. This could become useful for Ethereum L2s when transferring ether back to the L1, as well as other EVM L1 chains that could leverage this for their cryptoeconomics.

RATIONALE:
The introduction of the `BURN` opcode helps clean up a piece of weird semantics in the Ethereum. Historically, burning native ether involved sending them to an address from which they could not be recovered, such as the zero address or a contract with no withdrawal functionality. This method is not only inefficient but also confusing for indexers and other tools that track token movements. By providing a dedicated `BURN` opcode, we eliminate this ambiguity and ensure that the act of burning tokens is explicit and standardized. Potential Pros: - Provides a clear and standardized method for burning native


=== EIP-7804 ===
TITLE: Withdrawal Credential Update Request
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-31
REQUIRES: 

SUMMARY:
This proposal defines a mechanism to allow validators to update their withdrawal credentials using a new execution request type (0x03). The request allows for changing the execution address and the withdrawal credential prefix (0x01 or 0x02).

SPECIFICATION:
### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | *TBD* | Mainnet | ### Configuration | Name | Value | Comment | | - | - | - | | `WITHDRAWAL_CREDENTIALS_UPDATE_REQUEST_PREDEPLOY_ADDRESS` | `0x09Fc772D0857550724b07B850a4323f39112aAaA` | Where to call and store relevant details about the withdrawal credentials update mechanism | | `WITHDRAWAL_CREDENTIALS_UPDATE_REQUEST_TYPE` | `0x03` | The [EIP-7685](./eip-7685.md) type prefix for withdrawal credential update request | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | Address used to invoke system operation on contract | `EXCESS_WITHDRAWAL_CREDENTIALS_UPDATE_REQUESTS_STORAGE_SLOT` | 0 | | | `WITHDRAWAL_CREDENTIALS_UPDATE_REQUEST_COUNT_STORAGE_SLOT` | 1 | | |

MOTIVATION:
When the ability to update a validator BLS withdrawal credentials to execution address was introduced in Capella, one of the most common questions was about allowing the withdrawal credential to be changed in the future. Either for security (e.g. credential rotation) or to allow for alternative ways of handling withdrawals (e.g. having a contract address as credentials). The main reason for not adding this options was because implementing this communication channel between the Execution Layer and the Consensus Layer is complex (based on the experience with the Eth1 bridge). In Electra, the protocol was upgraded with Execution Requests

RATIONALE:
<!-- TODO -->


=== EIP-5806 ===
TITLE: Delegate transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-10-20
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters - `FORK_BLKNUM` = `TBD` - `TX_TYPE` = TBD, > 0x03 ([EIP-4844](./eip-4844.md)) As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` = `TX_TYPE(TBD)`. The intrinsic cost of the new transaction is inherited from [EIP-2930](./eip-2930.md), specifically `21000 + 16 * non-zero calldata bytes + 4 * zero calldata bytes + 1900 * access list storage key count + 2400 * access list address count`. The [EIP-2718](./eip-2718.md) `TransactionPayload` for

MOTIVATION:
EOA are the most widely used type of account, yet their ability to perform operations is limited to deploying contracts and sending "call" transactions. It is currently not possible for an EOA to execute arbitrary code, which greatly limits the interactions users can have with the blockchain. Account abstraction has been extensively discussed but the path toward mainstream adoption is still unclear. Some approaches, such as [ERC-4337](./eip-4337.md) hope to improve the usability of smart wallets, without addressing the issue of smart wallet support by applications. While smart contract wallets have a lot to offer in terms of UX,

RATIONALE:
EOAs are the most widely used type of wallet. This EIP would drastically expand the ability of EOAs to interact with smart contracts by using the pre-existing and well-understood delegation mechanism introduced in [EIP-7](./eip-7.md) and without adding new complexity to the EVM.


=== EIP-6206 ===
TITLE: EOF - JUMPF and non-returning functions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-12-21
REQUIRES: 4, 7, 5, 0, ,,  , 5, 4, 5, 0

SUMMARY:
This EIP allows for tail call optimizations in EOF functions ([EIP-4750](./eip-4750.md)) by introducing a new instruction `JUMPF`, which jumps to a code section without adding a new return stack frame. Additionally the format of the type sections is extended to allow declaring sections as non-returning, with simplified stack validation for `JUMPF` to such section.

SPECIFICATION:
### Type section changes We define a non-returning section as one that cannot return control to its caller section. Type section `outputs` field contains a special value `0x80` when corresponding code section is non-returning. See [Non-returning status validation](#non-returning-status-validation) below for validation details. The first code section MUST have 0 inputs and be non-returning. ### Execution Semantics A new instruction, `JUMPF (0xe5)`, is introduced. 1. `JUMPF` has one immediate argument, `target_section_index`, encoded as a 16-bit unsigned big-endian value. 2. If the operand stack size exceeds `1024 - type[target_section_index].max_stack_increase` (i.e. if the called function may exceed the global stack height

MOTIVATION:
It is common for functions to make a call at the end of the routine only to then return. `JUMPF` optimizes this behavior by changing code sections without needing to update the return stack. Knowing at validation time that a function will never return control allows for `JUMPF` to such function to be treated similar to terminating instructions, where extra items may be left on the operand stack at execution termination. This provides opportunities for compilers to generate more optimal code, both in code size and in spent gas. It is particularly beneficial for small error handling helpers,

RATIONALE:
### Allowing `JUMPF` to section with less outputs An alternative rule for `JUMPF` stack validation could require the target section's outputs to be exactly equal to the current section's outputs. Under such rule, a particular target section (a shared "helper" piece of code) would only "match" sections (requiring some shared "helper" code to execute before returning) *with the same number of outputs*. Instead, we allow a given `JUMPF` target section to be called from sections with more outputs, as long as these sections provide these extra stack elements (the "delta") themselves. This will reduce duplicated code as it


=== EIP-6122 ===
TITLE: Forkid checks based on timestamps
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-12-13
REQUIRES: 2124

SUMMARY:
[EIP-2124](./eip-2124.md) proposed a way of identifying nodes on the p2p network based on their chain configuration via the forkid parameter. It allows nodes to cut incompatible nodes off quickly which makes the P2P network more reliable. After the merge, forks are scheduled by block time instead of block number. This EIP updates the forkid calculation with block time.

SPECIFICATION:
Each node maintains the following values: - **`FORK_HASH`**: IEEE CRC32 checksum (`[4]byte`) of the genesis hash and fork blocks numbers or timestamps that already passed. - The fork block numbers or timestamps are fed into the CRC32 checksum in ascending order. - If multiple forks are applied at the same block or time, the block number or timestamp is checksummed only once. - Block numbers are regarded as `uint64` integers, encoded in big endian format when checksumming. - Block timestamps are regarded as `uint64` integers, encoded in big endian format when checksumming. - If a chain is configured

MOTIVATION:
While in proof-of-work forks were scheduled by block number, the proof-of-stake consensus layer schedules forks by slot number. The slot number is a time based measurement. In order to schedule forks at the same time on the consensus and execution layer, the execution layer is forced to also schedule forks by timestamp after the merge. The forkid calculation allows peers to quickly determine the configuration of peers and disconnect peers that are misconfigured or configured for other networks.

RATIONALE:
Shanghai will be scheduled by timestamp thus the forkid calculations need to be updated to work with timestamps and blocks. Since all block number based forks are before time based forks, nodes need to check the block based forks before the time based forks.


=== EIP-3046 ===
TITLE: Adds `baseFee` to `eth_getUncleByBlockNumberAndIndex`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getUncleByBlockNumberAndIndex` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getUncleByBlockNumberAndIndex` #### Description Returns information about an uncle specified by block number and uncle index position Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork block **MUST** include a `baseFee` field. #### Parameters Parameters remain unchanged. #### Returns For the full specification of `eth_getUncleByBlockNumberAndIndex` see [EIP-1474](./eip-1474.md). Add a new JSON field to the `result` object for block headers containing a base fee (post [EIP-1559](./eip-1559.md) fork block). - {[`Quantity`](./eip-1474.md#quantity)} `baseFee`

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-7702 ===
TITLE: Set Code for EOAs
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-05-07
REQUIRES: 2, ,,  , 1, 6, 1, ,,  , 1, 0, 5, 2, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0, ,,  , 3, 5, 4, 1, ,,  , 3, 6, 0, 7, ,,  , 4, 8, 4, 4

SUMMARY:
Add a new [EIP-2718](./eip-2718.md) transaction type that allows Externally Owned Accounts (EOAs) to set the code in their account. This is done by attaching a list of authorization tuples -- individually formatted as `[chain_id, address, nonce, y_parity, r, s]` -- to the transaction. For each tuple, a delegation indicator `(0xef0100 || address)` is written to the authorizing account's code. All code executing operations must load and execute the code pointed to by the delegation.

SPECIFICATION:
### Parameters | Parameter | Value | | ------------------------ | ------- | | `SET_CODE_TX_TYPE` | `0x04` | | `MAGIC` | `0x05` | | `PER_AUTH_BASE_COST` | `12500` | | `PER_EMPTY_ACCOUNT_COST` | `25000` | ### Set code transaction A new [EIP-2718](./eip-2718.md) transaction known as the "set code transaction" is introduced, where the `TransactionType` is `SET_CODE_TX_TYPE` and the `TransactionPayload` is the RLP serialization of the following: ``` rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, value, data, access_list, authorization_list, signature_y_parity, signature_r, signature_s]) authorization_list = [[chain_id, address, nonce, y_parity, r, s], ...] ``` The fields `chain_id`, `nonce`, `max_priority_fee_per_gas`, `max_fee_per_gas`, `gas_limit`, `destination`, `value`, `data`, and

MOTIVATION:
Despite great advances in the smart contract wallet ecosystem, EOAs have held back broad adoption of UX improvements across applications. This EIP therefore focuses on adding short-term functionality improvements to EOAs which will allow UX improvements to permeate through the entire application stack. Three particular features this EIP is designed around are: * **Batching**: allowing multiple operations from the same user in one atomic transaction. One common example is an [ERC-20](./eip-20.md) approval followed by spending that approval. This is a common workflow in DEXes that requires two transactions today. Advanced use cases of batching occasionally involve dependencies: the

RATIONALE:
Below is the rationale for both general design directions of the EIP, as well as specific technical choices. ### General design philosophy #### Persistence of code delegation The first draft of this proposal had a clever idea to avoid disagreement on whether in-protocol revocation was needed or not. The idea was to temporarily set code in the account with the authorization. After the transaction finished, the code would be completely cleared. This was a new design space for enriching EOA functionality. Even this approach was not without its flaws. Fundamentally, there was not much friction for users including


=== EIP-6475 ===
TITLE: SSZ Optional
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-02-09
REQUIRES: 

SUMMARY:
This EIP introduces a new [Simple Serialize (SSZ) type](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/ssz/simple-serialize.md) to represent `Optional[T]` values.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Type definition `Optional[T]` is defined as a type that can represent: - A value of SSZ type `T` - Absence of a value, indicated by `None` ### Default value The default value of `Optional[T]` is `None`. ### Serialization ```python if value is None: return b"" else: return b"\x01" + serialize(value) ``` ### Deserialization The deserialization of an `Optional[T]` depends on the input length:

MOTIVATION:
Optional values are currently only representable in SSZ using workarounds. Adding proper support provides these benefits: 1. **Better readability:** SSZ structures with optional values can be represented with idiomatic types of the underlying programming language, e.g., `Optional[T]` in Python, making them easier to interact with. 2. **Compact serialization:** SSZ serialization can rely on the binary nature of optional values; they either exist or they don't. This allows more compact serialization than using alternative approaches based on workarounds.

RATIONALE:
### Why not `Union[None, T]`? `Union[None, T]` leaves ambiguity about the intention whether the type may be extended in the future, i.e., `Union[None, T, U]`. Furthermore, SSZ Union types are currently not used in any final Ethereum specification and do not have a finalized design themselves. If the only use case is a workaround for lack of `Optional[T]`, the simpler `Optional[T]` type is sufficient, and support for general unions could be delayed until really needed. Note that the design of `Optional[T]` could be used as basis for a more general `Union`. ### Why not `List[T, 1]`? The serialization


=== EIP-7870 ===
TITLE: Hardware and Bandwidth Recommendations
TYPE: Informational 
STATUS: Living
CREATED: 2025-01-26
REQUIRES: 

SUMMARY:
This proposal specifies hardware and bandwidth recommendations for different types of Ethereum nodes: - **Full nodes**: Nodes that follow the tip of the chain without necessarily proposing blocks. - **Validators**: Split into: - **Attesters**: Validators that validate and attest to blocks created by proposers. - **Local block builders** (Proposers): Validators that create blocks locally and broadcast them to the network. The resource-intensive aspect for local block builders lies in creating the block and quickly broadcasting the data required for attesters to validate it in time. We note that it may be possible to run a client with less

SPECIFICATION:
### Roles and Their Recommended Specifications Node operators typically run both an **Execution Layer (EL)** client and a **Consensus Layer (CL)** client on the same machine. The specifications below assume the combined resource usage of both. | Node Type | Storage | Memory | CPU Cores / Threads | **PassMark CPU Rating** | Bandwidth Download / Upload | | ----------------------- | --------- | ------ | ------------------- | ----------------------- | --------------------------- | | **Full Node** | 4 TB NVMe | 32 GB | 4c / 8t | ~1000 ST / 3000 MT | 50 Mbps / 15 Mbps |

MOTIVATION:
Clear system specifications are crucial for: - Ensuring meaningful benchmark comparisons across different client implementations. - Enabling informed decision-making about protocol upgrades and their resource usage implications. - Providing clear guidance for node operators to ensure alignment with future network requirements. Without a shared understanding of target hardware specifications: - Benchmark results lose significance due to inconsistent testing environments. - Decision-making becomes challenging for implementation choices, as performance characteristics are heavily hardware-dependent. - Network participants lack clear guidance for hardware investments.

RATIONALE:
### Storage - **Recommended**: 4 TB NVMe M.2 drive with: - **Sequential R/W**: 7,000 MB/s - **Random 4K R/W**: Up to 1,000,000 IOPS - **Why NVMe over SATA?** - NVMe drives have significantly higher throughput and lower latency than SATA SSDs. - Drives without DRAM (DRAMless) or with QLC flash are not advised, due to lower endurance and potentially lower sustained performance. - **On Endurance (TBW)** - Running a node involves frequent writes (e.g., database updates, logs). Ensure that the SSD’s Total Bytes Written (TBW) rating is sufficient for multi-year operation. - **Capacity Considerations** - As of January


=== EIP-2938 ===
TITLE: Account Abstraction
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-09-04
REQUIRES: 2718

SUMMARY:
**See also: [https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020](https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020) and the links therein for historical work and motivation.** Transaction validity, as of Muir Glacier, is defined rigidly by the protocol: ECDSA signature, a simple nonce, and account balance. Account abstraction extends the validity conditions of transactions with the execution of arbitrary EVM bytecode (with some limits on what state may be accessed.) To signal validity, we propose a new EVM opcode `PAYGAS`, which also sets the gas price and gas limit the contract is willing to pay. We split account abstraction into two tiers: **single-tenant AA**, which is intended to support wallets or other

SPECIFICATION:
### Single Tenant After `FORK_BLOCK`, the following changes will be recognized by the protocol. #### Constants | Constant | Value | | - | - | | **`AA_ENTRY_POINT`** | `0xffffffffffffffffffffffffffffffffffffffff` | | **`AA_TX_TYPE`** | `2` | | **`FORK_BLOCK`** | TBD | | **`AA_BASE_GAS_COST`** | 15000 | #### New Transaction Type A new [EIP-2718](./eip-2718.md) transaction with type `AA_TX_TYPE` is introduced. Transactions of this type are referred to as "AA transactions". Their payload should be interpreted as `rlp([nonce, target, data])`. The base gas cost of this transaction is set to `AA_BASE_GAS_COST` instead of 21000 to reflect the lack of "intrinsic"

MOTIVATION:
The existing limitations preclude innovation in a number of important areas, particularly: 1. Smart contract wallets that use signature verification other than ECDSA (eg. Schnorr, BLS, post-quantum...) 2. Smart contract wallets that include features such as multisig verification or social recovery, reducing the highly prevalent risk of funds being lost or stolen 3. Privacy-preserving systems like [tornado.cash](http://tornado.cash) 4. Attempts to improve gas efficiency of DeFi protocols by preventing transactions that don't satisfy high-level conditions (eg. existence of a matching order) from being included on chain 5. Users being able to pay for transaction fees in a token other

RATIONALE:
The core problem in an account abstraction setup is always that miners and network nodes need to be able to verify that a transaction that they attempt to include, or rebroadcast, will actually pay a fee. Currently, this is fairly simple, because a transaction is guaranteed to be includable and pay a fee as long as the signature and nonce are valid and the balance and gasprice are sufficient. These checks can be done quickly. In an account abstraction setup, the goal is to allow accounts to specify EVM code that can establish more flexible conditions for a


=== EIP-5656 ===
TITLE: MCOPY - Memory copying instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-02-01
REQUIRES: 

SUMMARY:
Provide an efficient EVM instruction for copying memory areas.

SPECIFICATION:
The instruction `MCOPY` is introduced at `0x5E`. ### Input stack | Stack | Value | |-------|-------| | top - 0 | `dst` | | top - 1 | `src` | | top - 2 | `length` | This ordering matches the other copying instructions, i.e. `CALLDATACOPY`, `RETURNDATACOPY`. ### Gas costs Per yellow paper terminology, it should be considered part of the `W_copy` group of opcodes, and follow the gas calculation for `W_copy` in the yellow paper. While the calculation in the yellow paper should be considered the final word, for reference, as of time of this writing, that

MOTIVATION:
Memory copying is a basic operation, yet implementing it on the EVM comes with overhead. This was recognised and alleviated early on with the introduction of the "identity" precompile, which accomplishes memory copying by the use of `CALL`'s input and output memory offsets. Its cost is `15 + 3 * (length / 32)` gas, plus the call overhead. The identity precompile was rendered ineffective by the raise of the cost of `CALL` to 700, but subsequently the reduction by [EIP-2929](./eip-2929.md) made it slightly more economical. Copying exact words can be accomplished with `<offset> MLOAD <offset> MSTORE` or `<offset>

RATIONALE:
Production implementation of exact-word memory copying and partial-word memory copying can be found in the Solidity, Vyper and Fe compilers. With [EIP-2929](./eip-2929.md) the call overhead using the identity precompile was reduced from 700 to 100 gas. This is still prohibitive for making the precompile a reasonable alternative again.


=== EIP-1459 ===
TITLE: Node Discovery via DNS
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2018-09-26
REQUIRES: 778

SUMMARY:
This document describes a scheme for authenticated, updateable Ethereum node lists retrievable via DNS.

SPECIFICATION:
A 'node list' is a list of 'node records' [as defined by EIP-778](./eip-778.md) of arbitrary length. Lists may refer to other lists using links. The entire list is signed using a secp256k1 private key. The corresponding public key must be known to the client in order to verify the list. To refer to a DNS node list, clients use a URL with 'enrtree' scheme. The URL contains the DNS name on which the list can be found as well as the public key that signed the list. The public key is contained in the username part of the

MOTIVATION:
Many Ethereum clients contain hard-coded bootstrap node lists. Updating those lists requires a software update. The current lists are small, giving the client little choice of initial entry point into the Ethereum network. We would like to maintain larger node lists containing hundreds of nodes, and update them regularly. The scheme described here is a replacement for client bootstrap node lists with equivalent security and many additional benefits. Large lists populated by traversing the node discovery DHT can serve as a fallback option for nodes which can't join the DHT due to restrictive network policy. DNS-based node lists

RATIONALE:
### Why DNS? We have chosen DNS as the distribution medium because it is always available, even under restrictive network conditions. The protocol provides low latency and answers to DNS queries can be cached by intermediate resolvers. No custom server software is needed. Node lists can be deployed to any DNS provider such as CloudFlare DNS, dnsimple, Amazon Route 53 using their respective client libraries. ### Why is this a merkle tree? Being a merkle tree, any node list can be authenticated by a single signature on the root. Hash subdomains protect the integrity of the list. At


=== EIP-1285 ===
TITLE: Increase Gcallstipend gas in the CALL opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
Currently, the ``CALL`` opcode forwards a stipend of ``2,300`` gas units for a non zero value ``CALL`` operations where a contract is called. This stipend is given to the contract to allow execution of its ``fallback`` function. The stipend given is intentionally small in order to prevent the called contract from spending the call gas or performing an attack (like re-entrancy). While the stipend is small it should still give the sufficient gas required for some cheap opcodes like ``LOG``, but it's not enough for some more complex and modern logics to be implemented. This EIP proposes to

SPECIFICATION:
Increase the ``Gcallstipend`` fee parameter in the ``CALL`` opcode from ``2,300`` to ``3,500`` gas unit. The actual change to the Ethereum clients would be to change the ``CallStipend`` they store as a constant. For an implementation example you can find a Geth client implementation linked [here](https://github.com/ben-kaufman/go-ethereum/tree/eip-1285). The actual change to the code can be found [here](https://github.com/ben-kaufman/go-ethereum/blob/eip-1285/params/protocol_params.go#L41).

MOTIVATION:
The main motivation behind this EIP is to allow simple fallback functions to be implemented for contracts following the ``"Proxy"`` pattern. Simply explained, a ``"Proxy Contract"`` is a contract which use ``DELEGATECALL`` in its ``fallback`` function to behave according to the logic of another contract and serve as an independent instance for the logic of the contract it points to. This pattern is very useful for saving gas per deployment (as Proxy contracts are very lean) and it opens the ability to experiment with upgradability of contracts. On average, the ``DELEGATECALL`` functionality of a proxy contract costs about

RATIONALE:
The rational for increasing the ``Gcallstipend`` gas parameter by ``1,200`` gas units comes from the cost of performing ``DELEGATECALL`` and ``SLOAD`` with a small margin for some small additional operations. All while still keeping the stipend relatively small and insufficient for accessing the storage or changing the state.


=== EIP-2696 ===
TITLE: JavaScript `request` method RPC transport
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2020-06-04
REQUIRES: 

SUMMARY:
This standard provides the description of an object that is made available to JavaScript applications which they can use to communicate with the Ethereum blockchain through. This standard only describes the transport mechanism, it does not specify the payloads that are valid nor does it specify how the client or the provider will discover or agree on payload content. How/where this Ethereum object is exposed is left to future standards.

SPECIFICATION:
### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Interface TypeScript interface definition: ```ts interface RequestArguments { readonly method: string; readonly params?: readonly unknown[] | object; } interface EthereumProvider { request(args: RequestArguments): Promise<unknown> } ``` The Provider **MUST** implement a `request` method on the exposed `EthereumProvider` object. The `request` method **MUST** be callable with a single parameter which contains the arguments for the request as defined in the TypeScript `interface` above. If the Provider supports a

MOTIVATION:
When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime. Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or scripts running within that runtime in order to provide indirect access to an Ethereum-like blockchain and potentially signing tools. In order to achieve maximum compatibility between the provider and the client, a standard is necessary for what the shape of that object is.

RATIONALE:
While this standard is perhaps not the greatest mechanism for communicating between an application and a blockchain, it is closely aligned with established practices within the community so migration from existing systems to this one should be relatively easy. Most communication is currently done via JSON-RPC, so aligning with the JSON-RPC standard was desired to enable quick integration with existing systems.


=== EIP-7793 ===
TITLE: Conditional Transactions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-17
REQUIRES: 7843

SUMMARY:
This EIP proposes to add a new transaction format for "conditional transactions", that are only valid at a specified slot and index within the block. A new opcode `TXINDEX` is introduced to expose the conditional transaction index onchain.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `COND_TX_TYPE` | `Bytes1(0x05)` | | `TXINDEX_OPCODE_BYTE` | `Bytes1(0x4c)` | | `TXINDEX_OPCODE_GAS` | `2` | ### Conditional Transaction Type We introduce a new type of [EIP-2718](./eip-2718.md) transaction, "conditional transactions", where the `TransactionType` is `COND_TX_TYPE` and the `TransactionPayload` is the RLP serialization of the following `TransactionPayloadBody`: ``` [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, max_fee_per_blob_gas, blob_versioned_hashes, conditional_slot, conditional_tx_index, y_parity, r, s] ``` The fields `chain_id`, `nonce`, `max_priority_fee_per_gas`, `max_fee_per_gas`, `gas_limit`, `to`, `value`, `data`, `access_list`, `max_fee_per_blob_gas` follow the same semantics as [EIP-4844](./eip-4844.md). The field `blob_versioned_hashes` is the

MOTIVATION:
The proposal aims to improve support for encrypted mempools. Transactions in an encrypted mempool are ordered while the transactions are encrypted, before being decrypted and included onchain at the top of the block. If the builder does not respect the order when including the decrypted transactions then they could frontrun decrypted transactions. The new transaction type can be used to make this impossible; if a decrypted transaction is not included at the correct index, it will be invalid.

RATIONALE:
### Transaction Type An alternative design could simply return the current transaction index without adding a new transaction type. Adding a new transaction type is favoured as it means that the expected transaction index must be declared statically upfront, rather than allowing dynamic behaviour based on the returned transaction index. This prevents complex constraints being imposed that makes it difficult to build a block. ### Gas Price The opcode is priced to match similar opcodes in the `W_base` set.


=== EIP-7956 ===
TITLE: Tx Ordering via Block-level Randomness
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-24
REQUIRES: 7998

SUMMARY:
Proposers and builders can currently permute pending transactions arbitrarily, enabling reorder‑driven MEV. This EIP introduces a consensus rule that sorts all transactions inside a block by XOR‑ing each transaction hash with fresh slot randomness. The randomness is unknown until the slot starts, so the order is deterministic once known but unpredictable beforehand. The mechanism **significantly reduces reorder‑based MEV**; latency‑driven back‑running, censorship, and other classes of MEV remain and should be mitigated through complementary techniques (encrypted mempools, reputation, PBS marketplaces, etc.).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Slot Randomness `R` We define our randomness `R` as the `randao_reveal` of the each slot, after [EIP-7998](./eip-7998.md), since this EIP provides slot-by-slot randomness for `randao_reveal` (only predictable for the builder). This provides enough randomness for our purpose of reducing MEV attacks by MEV bots. ``` R = body.randao_reveal[0:32] : bytes32 ``` ### Builder Flow 1. **Candidate‑set selection** – Builders **MAY** choose **any subset**

MOTIVATION:
Unrestricted ordering is the key enabler of sandwich and classic front‑running attacks. Deterministic ordering collapses these vectors to latency racing and information asymmetry. Clear candidate‑set and bundle semantics preserve fee markets while removing the need for trusted sequencers. Academic works shows deterministic ordering drives sandwich profits toward zero. ### References * Julia Ofoegbu, “Maximal Extractable Value (MEV): A Tale As Old As Time,” Medium (2024). * J. Qian et al., “Deterministic Transaction Ordering Without Trusted Sequencers,” arXiv:2411.03327 v1 (2024). * “Shutter Network Introduces Plan for First Encrypted Mempool on Ethereum,” GlobeNewswire, 13 Feb 2025.

RATIONALE:
### Why randomness‑driven ordering? * Objective & Verifiable – Using a function of on‑chain randomness (R) and a transaction’s own hash gives every validator an identical, cheap check on order validity. * Unpredictable Until Slot Start – The XOR of slot‑level RANDAO and the proposer’s VRF output ensures that neither users nor builders can know the final sort key before the slot begins, closing the classic front‑run window. * Minimal Surface Area – A single 16‑byte field in the execution payload plus a hash operation keeps consensus changes small and auditable. ### Why XOR as the mixing function?


=== EIP-1087 ===
TITLE: Net gas metering for SSTORE operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-17
REQUIRES: 

SUMMARY:
This EIP proposes a change to how gas is charged for EVM `SSTORE` operations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.

SPECIFICATION:
The following changes are made to the EVM: - A 'dirty map' for each transaction is maintained, tracking all storage slots in all contracts that have been modified in the current transaction. The dirty map is scoped in the same manner as updates to storage, meaning that changes to the dirty map in a call that later reverts are not retained. - When a storage slot is written to with the value it already contains, 200 gas is deducted. - When a storage slot's value is changed for the first time, the slot is marked as dirty. If

MOTIVATION:
Presently, `SSTORE` (`0x55`) operations are charged as follows: - 20,000 gas to set a slot from 0 to non-0 - 5,000 gas for any other change - A 10,000 gas refund when a slot is set from non-0 to 0. Refunds are applied at the end of the transaction. In situations where a single update is made to a storage value in a transaction, these gas costs have been determined to fairly reflect the resources consumed by the operation. However, this results in excessive gas costs for sequences of operations that make multiple updates. Some examples to illustrate

RATIONALE:
We believe the proposed mechanism represents the simplest way to reduce storage gas costs in situations where they do not reflect the actual costs borne by nodes. Several alternative designs were considered and dismissed: - Charging a flat 200 gas for `SSTORE` operations, and an additional 19800 / 4800 at the end of a transaction for new or modified values is simpler, and removes the need for a dirty map, but pushes a significant source of gas consumption out of the EVM stack and applies it at the end of the transaction, which is likely to complicate debugging


=== EIP-7979 ===
TITLE: Call and Return Opcodes for the EVM
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-12-17
REQUIRES: 3541

SUMMARY:
This is the smallest possible change to the EVM to support calls and returns. This proposal introduces three new control-flow instructions to the EVM: * `CALLSUB` transfers control to the `destination` on the `stack`. * `ENTERSUB` marks a `CALLSUB` destination. * `RETURNSUB` returns to the `PC` after the most recent `CALLSUB`. Code can also be prefixed with `MAGIC` bytes. The complete control flow of `MAGIC` code can be traversed in time and space linear in the size of the code, enabling tools for validation, static analysis, and AOT and Jit compilers. On-chain, `MAGIC` code is validated at `CREATE`

SPECIFICATION:
> _The key words MUST and MUST NOT in this Specification are to be interpreted as described in RFC 2119 and RFC 8174._ ### `CALLSUB (0x..)` Transfers control to a subsidiary operation. 1. Pop the `destination` on top on the `stack`. 2. Push the current `PC + 1` to the `return stack`. 3. Set `PC` to `destination`. The gas cost is _mid_ (`8`). ### `ENTERSUB (0x..)` The `destination` of every `CALLSUB` MUST be an `ENTERSUB`. ### `RETURNSUB (0x..)` Returns control to the caller of a subsidiary operation. 1. Pop the `return stack` to `PC`. The gas cost is

MOTIVATION:
**_Dynamic jumps must die._** ### The original control-flow facilities #### Babbage, 1833: Jumps and conditional jumps In 1833 Charles Babbage began the design of a steam-powered, mechanical, Turing-complete computer. Programs were to be encoded on punch cards which controlled a system of rods, gears and other machinery to implement storage, arithmetic, jumps, and conditional jumps. Its first published description was by L. F. Menabre, 1842. The translator, Ada Augusta, Countess of Lovelace, made extensive notes. The notes include her famous program for recursively computing the Bernoulli numbers, which used conditional jumps to implement the required nested loops. #####

RATIONALE:
### How do dynamic jumps cause quadratic control flow? Static analysis amounts to most anything you can do with a program without actually running it. And traversing the flow of control -- in a way that follows each possible path only once -- is a fundamental first step for many static analyses, especially for recovering control-flow graphs. When all jumps are static the number of steps is linear in the number of instructions: a fixed number of paths must be explored for each jump. But with dynamic jumps every possible destination must be explored at every jump: at


=== EIP-663 ===
TITLE: SWAPN, DUPN and EXCHANGE instructions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2017-07-03
REQUIRES: 3, 5, 4, 0, ,,  , 5, 4, 5, 0

SUMMARY:
Currently, `SWAP*` and `DUP*` instructions are limited to a stack depth of 16. Introduce three new instructions, `SWAPN`, `DUPN` and `EXCHANGE` which lift this limitation and allow accessing the stack at higher depths.

SPECIFICATION:
We introduce three new instructions: 1. `DUPN` (`0xe6`) 2. `SWAPN` (`0xe7`) 3. `EXCHANGE` (`0xe8`) If the code is legacy bytecode, any of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*) If the code is valid EOF1, the following rules apply: 1. The instructions are followed by an 8-bit immediate value, which we call `imm`, and can have a value of 0 to 255. 1. In the case of `DUPN` and `SWAPN`, we introduce the variable `n` which equals to `imm + 1`. 2. In the case of `EXCHANGE`, we introduce the variable

MOTIVATION:
While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a "stack to memory elevation" in a compiler. This can result in complex and inefficient code. Furthermore, implementing higher level constructs, such as functions, on top of EVM will result in a list of input and output parameters as well as an instruction offset to return to. The number of these arguments (or stack items) can easily exceed 16 and thus will require extra care from a

RATIONALE:
### Use of an immediate argument Allowing dynamic selection of the arguments to swap, dup, or exchange could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate argument that is not dynamic in nature. ### EOF-only Since this instruction depends on an immediate argument encoding, it can only be enabled within EOF. In legacy bytecode that encoding could contradict jumpdest-analysis. ### Size of immediate argument For `DUPN`


=== EIP-7918 ===
TITLE: Blob base fee bounded by execution cost
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-03-25
REQUIRES: 4, 8, 4, 4, ,,  , 7, 8, 4, 0

SUMMARY:
This EIP assigns a reserve price `BLOB_BASE_COST * base_fee_per_gas` to blobs by introducing an `if`-clause in `calc_excess_blob_gas()`. Specifically, when the reserve price is higher than `GAS_PER_BLOB * base_fee_per_blob_gas`, the function will not subtract `target_blob_gas` from `excess_blob_gas`, causing `excess_blob_gas` to increase according to `blob_gas_used`, while keeping the per-block maximum increase unchanged. The proposal ensures that the blob fee market can function properly and that blob consumers pay at least a relevant fraction of the market rate for the compute they request from nodes.

SPECIFICATION:
### Parameters | Constant | Value | - | - | | `BLOB_BASE_COST` | `2**13` | ### Functions An `if`-clause is added to `calc_excess_blob_gas()` from [EIP-4844](./eip-4844.md). The function no longer subtracts `target_blob_gas` when updating `excess_blob_gas` if the price of a `blob` is below the price of `BLOB_BASE_COST` execution gas. The `blobSchedule` for referencing target and max blobs was introduced in [EIP-7840](./eip-7840.md). The current block's `blobSchedule` is used during processing. Thus, in the first block after a fork—when calculating `base_fee_per_blob_gas` via `get_base_fee_per_blob_gas(parent)`—`fake_exponential()` must use the *new* `blobSchedule.baseFeeUpdateFraction`. Likewise, the *new* `blobSchedule.max` and `blobSchedule.target` must be used in `calc_excess_blob_gas()`. ```python

MOTIVATION:
Ethereum uses a dynamic pricing auction to set the blob base fee, lowering the fee if less gas is consumed than `target_blob_gas = GAS_PER_BLOB * blobSchedule.target` and raising the fee if more gas is consumed. Such an auction can function well when the blob base fee represents the price signal, allowing the mechanism to control the real price for blob consumers. However, when execution costs dominate, the price signal is lost. The blob base fee then no longer represents a significant component of the total cost facing the consumer, and the protocol can no longer rely on the

RATIONALE:
### Fee-inelasticity and reserve price This proposal alleviates idiosyncrasies in the blob base fee auction. When a rollup's costs are dominated by execution costs for the blob-carrying transactions, ZK proof verification, or priority fees, the protocol can no longer rely on the blob base fee to control the equilibrium quantity of blobs consumed. The fee update mechanism is unaware of the full price of the goods that it regulates the price for and therefore fails to converge on equilibrium in a timely manner. We can express a simple real demand function for blobspace as $Q(b + c).$ It


=== EIP-2831 ===
TITLE: Transaction Replacement Message Type
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-07-26
REQUIRES: 1193

SUMMARY:
The current communication between providers and consumers of providers are fundamentally broken in the event that a transaction in the mempool has been superseded by a newer transactions. Providers currently have no way of communicating a transaction replacement, and consumers are required to poll block by block for the resulting transaction.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Definitions _This section is non-normative._ - Provider - A JavaScript object made available to a consumer, that provides access to Ethereum by means of a Client. - Wallet - An end-user application that manages private keys, performs signing operations, and acts as a middleware between the Provider and the Client. - Transaction Replacement - Submitting a transaction with both: the same nonce and a 10% increase in the gas

MOTIVATION:
Exert from EIP-1193 > A common convention in the Ethereum web application ("dapp") ecosystem is for key management software ("wallets") to expose their API via a JavaScript object in the web page. This object is called "the Provider". Many ingenious developments have been made by wallet developers to improve the overall user experience while interacting with the Ethereum blockchain. One specific innovation was transaction replacement, offering users the ability to effectively cancel a previously sent transaction. Transaction replacement is not a new concept, but unfortunately causes major user experience problems for dapp developers as the replaced transaction is

RATIONALE:
The implementation was chosen to help the ease of implementation for both providers and dapp developers. Since `ProviderMessage` is widely used by dapp developers already it means that the implementation path would be as trivial as adding and additional `if` clause to their existing message listener. This also provides a benefit to dapps in the event that a provider has not yet implemented the events, it will not cause the dapp panic with `undefined` should it be implemented natively (eg: `ethereum.txCancel(...)` which would error with `ethereum.txReplacement()` is not a function).


=== EIP-7922 ===
TITLE: Dynamic exit queue rate limit
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-24
REQUIRES: 

SUMMARY:
This EIP proposes updating Ethereum's validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period ("generation") based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This approach reduces validator wait times during periods of high exit demand *without sacrificing network safety*.

SPECIFICATION:
Since the validator exit process is complex, we start with the stack trace and a verbal description of the end-to-end process in Electra. 1. `initiate_validator_exit` – a validator signals their intent to exit, which is actuated by setting `validator.exit_epoch` and `validator.withdrawable_epoch` based on the output of `compute_exit_epoch_and_update_churn`. 2. `compute_exit_epoch_and_update_churn` – is used to determine the exit epoch of a validator. This function implements the exit queue in the following way: - `get_balance_churn_limit` - returns the amount of withdrawable ETH per epoch by dividing the total active balance by 2**16. - set `exit_balance_to_consume` to the churn available in the

MOTIVATION:
Ethereum currently implements a fixed, rate-limited queue for validator exits to ensure the security and stability of the network. The exit queue ensures the economic security of transactions finalized by the validator set. Suppose a malicious validator could immediately exit the set without any delay. In that case, they may attempt to execute a double spend attack by publishing a block while withholding a conflicting block, which they release after their stake has exited the protocol. The slashing mechanism can no longer hold the malicious validator accountable, and two conflicting finalized transactions may exist (if the attacker has

RATIONALE:
As we described earlier, by computing unused churn from the previous 14 generations, the churn limit dynamically responds to actual validator behavior. This mechanism: - Reduces validator waiting times during periods of congestion. - Ensures security by restricting maximum churn limit increases. - Simplifies implementation compared to more complex dynamic mechanisms. A generation length of 256 epochs (~27 hours) and a history of 14 generations (~16 days) balances responsiveness and stability, enabling Ethereum to adapt smoothly to sustained changes in validator exit behavior.


=== EIP-7942 ===
TITLE: Available Attestation
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-04-30
REQUIRES: 

SUMMARY:
This EIP proposes Available Attestation (AA), a protocol enhancement to make Ethereum PoS resilient against reorganization attacks. The proposal introduces a stability criterion for blocks based on attestation quorums, requiring that a block must include at least one-third of validators' attestations from the previous slot to be considered stable. The proposal includes three main changes: (1) modifying the parent selection rule to require AA from the previous slot, (2) replacing HLMD-GHOST with a Longest Stable Chain fork choice rule, and (3) adding a reference field to recent unstable blocks to preserve transaction continuity. These changes collectively prevent Byzantine

SPECIFICATION:
### Overview We provide a lightweight yet efficient solution for Ethereum PoS which is: 1) reorg resilient in a synchronous network; 2) safe and live in a partially synchronous network; 3) easy to implement and deploy. We introduce AA, an approach inspired by conventional BFT protocols from *weak quorum* of attestations. Namely, consider a system with $N$ validators, among which at most $f$ are faulty. If $f+1$ validators vote for a block $b$ in slot $t$, at least one honest validator has validated $b$. The $f+1$ attestations become a *proof* of the availability of $b$. We use $AA_t$

MOTIVATION:
We find that all known effective attacks on Ethereum PoS belong to reorganization attacks, although they emphasize different types of adversarial strategies. According to how the canonical chain is manipulated by the adversary, we classify known attacks into two categories: attacks from *changing block weight* and attacks from *filtering block tree*. The attacks from changing block weight refer to the strategy where Byzantine validators modify the *weight* of their proposed blocks to make their fork eventually become the canonical chain. Meanwhile, the attacks from filtering block tree do not change the block weight. Instead, these attacks make honest

RATIONALE:
The reason why our approach is reorg resilient is that the AA mechanism *prevents* Byzantine validators from creating conflicting branches. As summarized in the table, there are two strategies for Byzantine validators: (1) Byzantine validators directly propose a block conflicting with the canonical chain and (2) Byzantine validators propose a block that extends the canonical chain and delay releasing the block. Neither of these strategies works anymore after AA is implemented. For the first type, only the leaf blocks in the block tree can be the output of the fork choice rule. If a Byzantine validator tries to


=== EIP-2718 ===
TITLE: Typed Transaction Envelope
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-06-13
REQUIRES: 

SUMMARY:
`TransactionType || TransactionPayload` is a valid transaction and `TransactionType || ReceiptPayload` is a valid transaction receipt where `TransactionType` identifies the format of the transaction and `*Payload` is the transaction/receipt contents, which are defined in future EIPs.

SPECIFICATION:
### Definitions * `||` is the byte/byte-array concatenation operator. ### Transactions As of `FORK_BLOCK_NUMBER`, the transaction root in the block header **MUST** be the root hash of `patriciaTrie(rlp(Index) => Transaction)` where: * `Index` is the index in the block of this transaction * `Transaction` is either `TransactionType || TransactionPayload` or `LegacyTransaction` * `TransactionType` is a positive unsigned 8-bit number between `0` and `0x7f` that represents the type of the transaction * `TransactionPayload` is an opaque byte array whose interpretation is dependent on the `TransactionType` and defined in future EIPs * `LegacyTransaction` is `rlp([nonce, gasPrice, gasLimit, to, value, data,

MOTIVATION:
In the past, when we have wanted to add new transaction types we have had to ensure they were backward compatible with all other transactions, meaning that you could differentiate them based only on the encoded payload, and it was not possible to have a transaction that matched both types. This was seen in [EIP-155](./eip-155.md) where the new value was bit-packed into one of the encoded fields. There are multiple proposals in discussion that define new transaction types such as one that allows EOA accounts to execute code directly within their context, one that enables someone besides `msg.sender`

RATIONALE:
### TransactionType only goes up to 0x7f For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit. This also prevents us from colliding with legacy transaction types, which always start with a byte `>= 0xc0`. ### **SHOULD** instead of **MUST** for the TransactionType being first byte of signed data While it is strongly recommended that all future transactions sign the first byte to ensure that there is no problem with signature reuse, the authors acknowledge that this may not


=== EIP-7637 ===
TITLE: Optimize EOA EXTCODEHASH
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-02-26
REQUIRES: 1052

SUMMARY:
This proposal is an optimization for [EIP-1052](./eip-1052.md), For addresses with a balance, but without code, the codehash should still be `0x`. When an address `add.code == 0x` and `add.balance != 0`, `add.codehash==0` is required instead of `add.codehash==keccak256("")`

SPECIFICATION:
The behaviour of `EXTCODEHASH` is changed in the following way: 1. When calling `EXTCODEHASH`, the codehash of the address with balance but no code is still `0x`

MOTIVATION:
EIP-1052 was proposed to save gas fees. However, due to some flaws in the set specifications, in actual applications, due to safety concerns, they will not actually be used. In order for EIP-1052 to be truly useful, it should be optimized. If someone uses it based on the proposal of EIP-1052 and does not notice the change when `add.balance != 0`, there may be security issues.

RATIONALE:
EIP-1052 In order to include the function of `BALANCE`, let the `EXTCODEHASH` of the address without balance be `0x`, and the `EXTCODEHASH` of the address with balance be `keccak256("")`. The contract address can be calculated in advance. Whether it is `CREATE` or `CREATE2`, it is possible that the contract is not created but has a balance. For security, You can actually only use `keccak256(add.code) == keccak256("")` or `add.code.length ==0` instead of `add.codehash == 0`,, which makes the original intention of EIP-1052 meaningless. For example, uniswap V2 uses stored addresses to determine whether a contract exists. If this `EXTCODEHASH`


=== EIP-7935 ===
TITLE: Set default gas limit to 60M
TYPE: Informational 
STATUS: Last Call
CREATED: 2025-04-22
REQUIRES: 

SUMMARY:
The gas limit on mainnet is currently 36M. This should be significantly increased to 60M by the time Fusaka is released by execution layer clients updating their default configurations.

SPECIFICATION:
Execution layer clients have different configuration formats. They should all update the gas limit value generated in their default configurations to 60M.

MOTIVATION:
There is currently great interest in scaling L1 execution. This can likely be done to some extent without implementing any new features. However, it requires guidance from EL devs as we expect to find bugs in clients at higher gas limits than currently used on mainnet. This will require time from client developers both to test and to fix any bugs that arise, therefore it makes sense to include as an EIP in a hard fork to commit to this.

RATIONALE:
In the past there has been some difficulty coordinating EL clients to update gas limit values in their default configurations. Therefore we suggest tying a new value to a hard fork release.


=== EIP-1898 ===
TITLE: Add `blockHash` to defaultBlock methods
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-04-01
REQUIRES: 234

SUMMARY:
For JSON-RPC methods which currently accept a default block parameter, additionally allow the parameter to be a block hash. This EIP can be considered a generalization of [EIP-234](./eip-234.md). It would enable clients to unambiguously specify the block they want to query for certain JSON-RPC methods, even if the block is not in the canonical chain. This allows clients to maintain a coherent picture of blockchain state that they are interested in, even in the presence of reorgs, without requiring that the node maintain a persistent connection with the client or store any client-specific state.

SPECIFICATION:
The following JSON-RPC methods are affected: - `eth_getBalance` - `eth_getStorageAt` - `eth_getTransactionCount` - `eth_getCode` - `eth_call` - `eth_getProof` The following options, quoted from the Ethereum JSON-RPC spec, are currently possible for the defaultBlock parameter: > - HEX String - an integer block number > - String "earliest" for the earliest/genesis block > - String "latest" - for the latest canonical block > - String "pending" - for the pending state/transactions > - String "safe" - for the most recent safe block > - String "finalized" - for the most recent finalized block Since there is no way to

RATIONALE:
Currently, the state-querying JSON-RPC methods specified above have no option to unambiguously specify which block to query the state for. This can cause issues for applications which need to make multiple calls to the RPC. For instance, a wallet which just executed a transfer may want to display the balances of both the sender and recipient. If there is a re-org in between when the balance of the sender is queried via `eth_getBalance` and when the balance of the recipient is queried, the balances may not reconcile. As a slightly more complicated example, the UI for a decentralized


=== EIP-2929 ===
TITLE: Gas cost increases for state access opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-09-01
REQUIRES: 

SUMMARY:
Increase the gas cost of `SLOAD` (`0x54`) to 2100, and the `*CALL` opcode family (`0xf1`, `f2`, `f4`, `fA`), `BALANCE` `0x31` and the `EXT*` opcode family (`0x3b`, `0x3c`, `0x3f`) to 2600. Exempts (i) precompiles, and (ii) addresses and storage slots that have already been accessed in the same transaction, which get a decreased gas cost. Additionally reforms `SSTORE` metering and `SELFDESTRUCT` to ensure "de-facto storage loads" inherent in those opcodes are priced correctly.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | 12244000 | | `COLD_SLOAD_COST` | 2100 | | `COLD_ACCOUNT_ACCESS_COST` | 2600 | | `WARM_STORAGE_READ_COST` | 100 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. When executing a transaction, maintain a set `accessed_addresses: Set[Address]` and `accessed_storage_keys: Set[Tuple[Address, Bytes32]]` . The sets are transaction-context-wide, implemented identically to other transaction-scoped constructs such as the self-destruct-list and global `refund` counter. In particular, if a scope reverts, the access lists should be in the state they were in before that scope was entered. When a

MOTIVATION:
Generally, the main function of gas costs of opcodes is to be an estimate of the time needed to process that opcode, the goal being for the gas limit to correspond to a limit on the time needed to process a block. However, storage-accessing opcodes (`SLOAD`, as well as the `*CALL`, `BALANCE` and `EXT*` opcodes) have historically been underpriced. In the 2016 Shanghai DoS attacks, once the most serious client bugs were fixed, one of the more durably successful strategies used by the attacker was to simply send transactions that access or call a large number of accounts.

RATIONALE:
### Opcode costs vs charging per byte of witness data The natural alternative path to changing gas costs to reflect witness sizes is to charge per byte of witness data. However, that would take a longer time to implement, hampering the goal of providing short-term security relief. Furthermore, following that path faithfully would lead to extremely high gas costs to transactions that touch contract code, as one would need to charge for all 24576 contract code bytes; this would be an unacceptably high burden on developers. It is better to wait for [code merklization](https://medium.com/ewasm/evm-bytecode-merklization-2a8366ab0c90) to start trying to


=== EIP-7691 ===
TITLE: Blob throughput increase
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-04-17
REQUIRES: 

SUMMARY:
Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.

SPECIFICATION:
### Parameters | Constant | Value | |------------------------------------------|---------------------| | `MAX_BLOBS_PER_BLOCK_ELECTRA` | `9` | | `TARGET_BLOBS_PER_BLOCK_ELECTRA` | `6` | | `MAX_BLOB_GAS_PER_BLOCK` | `1179648` | | `TARGET_BLOB_GAS_PER_BLOCK` | `786432` | | `BLOB_BASE_FEE_UPDATE_FRACTION_PRAGUE` | `5007716` | `MAX_BLOBS_PER_BLOCK_ELECTRA` and `TARGET_BLOBS_PER_BLOCK_ELECTRA` are consumed by the consensus layer clients, and starting at `PECTRA_FORK_EPOCH` replace the respective old max and target values. `MAX_BLOB_GAS_PER_BLOCK`, `TARGET_BLOB_GAS_PER_BLOCK` and `BLOB_BASE_FEE_UPDATE_FRACTION_PRAGUE` are consumed by the execution layer clients, and starting at the epoch when this EIP is activated, replace the old max, target and update fraction values. Any references to `MAX_BLOB_GAS_PER_BLOCK` and `TARGET_BLOB_GAS_PER_BLOCK` in [EIP-4844](./eip-4844.md) should be updated to the

MOTIVATION:
Ethereum, with its rollup centric roadmap, scales by relying on L2. Since the Dencun fork, the blob gas target and maximum was set to 3/6 respectively. The blob gas limit was arrived at based on a series of big block tests performed on the Ethereum mainnet network as well as a series of testnets. The values were chosen cautiously, as it's extremely hard to predict the exact p2p behaviour of Ethereum mainnet. As we now have the Dencun upgrade live, we are able to use monitoring tools to check the network health. Initial monitoring indicates that we have

RATIONALE:
### Simplicity The EIP aims to minimize the amount of testing and implementation effort from the perspective of the client teams, to allow for more resources to be allocated to peerDAS and other scaling research. While this EIP may not achieve the new optimal blob limit, it offers a compromise for a short term increase. ### Update Fraction The original target and max values from [EIP-4844](./eip-4844.md) were at a 1:2 ratio. As a consequence, responsiveness to full and empty blob sections was symmetrical: * full blobs: basefee increases by ~12.5% * no blobs: basefee decreases by ~11.1% The


=== EIP-1829 ===
TITLE: Precompile for Elliptic Curve Linear Combinations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-03-06
REQUIRES: 

SUMMARY:
A precompile that takes a curve and computes a linear combination of curve points.

SPECIFICATION:
Given integers `m, α` and `β`, scalars `s_i`, and curve points `A_i` construct the elliptic curve ``` y² = x³ + α ⋅ x + β mod m ``` and compute the following ``` C = s₀ ⋅ A₀ + s₁ ⋅ A₁ + ⋯ + s_n ⋅ A_n ``` aka *linear combination*, *inner product*, *multi-multiplication* or even *multi-exponentiation*. ``` (Cx, Cy) := ecmul(m, α, β, s0, Ax0, As0, s1, Ax1, As1, ...) ``` ### Gas cost ``` BASE_GAS = ... ADD_GAS = ... MUL_GAS = ... ``` The total gas cost is `BASE_GAS` plus `ADD_GAS` for each

RATIONALE:
**Generic Field and Curve.** Many important optimizations are independent of the field and curve used. Some missed specific optimizations are: * Reductions specific to the binary structure of the field prime. * Precomputation of Montgomery factors. * Precomputation of multiples of certain popular points like the generator. * Special point addition/doubling [formulas][formulas] for `α = -3`, `α = -1`, `α = 0`, `β = 0`. [formulas]: https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html TODO: The special cases for `α` and `β` might be worth implementing and offered a gas discount. **Compressed Coordinates.** Compressed coordinates allow contract to work with only `x` coordinates and sign


=== EIP-8025 ===
TITLE: Optional Execution Proofs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-09-17
REQUIRES: 

SUMMARY:
Optional execution proofs allow beacon nodes to verify the validity of the execution payload within a beacon block without running an execution layer client. The execution proofs are sent over the consensus layer's peer-to-peer network.

SPECIFICATION:
This is a consensus layer change only. Validators will now be able to enable two new modes: - zkEVM Proof generating - Stateless validation When a proof generating node receives a beacon block, they will create the necessary proofs for the execution payload in the block and re-propagate them on the specified subnets. When a stateless validating node receives a beacon block, they will check to see if they have already received a valid execution proof for that execution payload from the specified subnet. The detailed specifications are in the consensus-specs repository. The key words "MUST", "MUST NOT",

MOTIVATION:
Optional execution proofs reduce the hardware and bandwidth requirements that are needed for an attester to verify a beacon block. Moreover, the cost to verify to a block no longer grows with the gas limit. Since these are optional, protocol upgrades cannot be based on the improvements in this EIP. This EIP allows us to safely test execution proofs without making it explicitly consensus critical.

RATIONALE:
<-- TODO -->


=== EIP-1482 ===
TITLE: Define a maximum block timestamp drift
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-10-09
REQUIRES: 

SUMMARY:
On the basis that both Geth and Parity implement the same timestamp validation requirements, this should be written into the reference specification.

SPECIFICATION:
The yellow paper should define a timestamp as: > A scalar value equal to the output of Unix’s time() at this block’s inception. For the purpose of block validation, it must be greater than the previous block's timestamp, and no more than 15 seconds greater than system time.

MOTIVATION:
There is a lack of clarity about how accurate timestamps in the block header must be. The yellow paper describes the timestamp as > A scalar value equal to the reasonable output of Unix’s time() at this block’s inception This causes [confusion](https://ethereum.stackexchange.com/questions/5924/how-do-ethereum-mining-nodes-maintain-a-time-consistent-with-the-network/5926#5926) about the safe use of the `TIMESTAMP` opcode (solidity's `block.timestamp` or `now`) in smart contract development. Differing interpretations of 'reasonable' may create a risk of consenus failures.

RATIONALE:
Both [Geth](https://github.com/ethereum/go-ethereum/blob/4e474c74dc2ac1d26b339c32064d0bac98775e77/consensus/ethash/consensus.go#L45) and [Parity](https://github.com/paritytech/parity-ethereum/blob/73db5dda8c0109bb6bc1392624875078f973be14/ethcore/src/verification/verification.rs#L296-L307) reject blocks with timestamp more than 15 seconds in the future. This establishes a defacto standard, which should be made explicit in the reference specification.


=== EIP-665 ===
TITLE: Add precompiled contract for Ed25519 signature verification
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-03-25
REQUIRES: 

SUMMARY:
Verification of Ed25519 cryptographic signatures is obviously possible in EVM bytecode. However, the gas cost will be very high, and computationally expensive, as such tight, wide word operations intensive code as required for Ed25519 is not a good fit for the EVM bytecode model. The addition of a native compiled function, in a precompiled contract, to the EVM solves both cost and performance problems.

SPECIFICATION:
If `block.number >= CONSTANTINOPLE_FORK_BLKNUM`, add a precompiled contract for Ed25519 signature verification (`ED25519VFY`). The proposal adds a new precompiled function `ED25519VFY` with the following input and output. `ED25519VFY` takes as **input 128 octets**: 1. **message**: the 32-octet message that was signed 2. **public key**: the 32-octet Ed25519 public key of the signer 3. **signature**: the 64-octet Ed25519 signature `ED25519VFY` returns as **output 4 octets**: * `0x00000000` if signature is valid * any non-zero value indicates a signature verification failure ### Address The address of `ED25519VFY` is **`0x9`.** ### Gas costs Gas cost for `ED25519VFY` is **2000**.

MOTIVATION:
Ed25519 and Ed448 (that is, EdDSA using Curve25519 or Curve448) are IETF recommendations ([RFC7748](https://tools.ietf.org/html/rfc7748)) with some attractive properties: * Ed25519 is intended to operate at around the 128-bit security level and Ed448 at around the 224-bit security level * EdDSA uses small public keys (32 or 57 octets) and signatures (64 or 114 octets) for Ed25519 and Ed448, respectively * Ed25519/Ed448 are designed so that fast, constant-time (timing attack resistant) and generally side-channel resistant implementations are easier to produce Despite being around only for some years, post-Snowden, these curves [have gained wide use](https://ianix.com/pub/ed25519-deployment.html) quickly in various protocols and

RATIONALE:
The proposed `ED25519VFY` function takes the signer public key as a call parameter, as with Ed25519, I don't believe it is possible to derive the signers public key from the signature and message alone. The proposed `ED25519VFY` function uses a zero return value to indicate success, since this allows for different errors to be distinguished by return value, as all non-zero return values signal a verification failure. `ECRECOVER` has a gas cost of 3000. Since Ed25519 is computationally cheaper, the gas price should be less.


=== EIP-170 ===
TITLE: Contract code size limit
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-11-04
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then if contract creation initialization returns data with length of **more than** `MAX_CODE_SIZE` bytes, contract creation fails with an out of gas error. ### Rationale Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a constant amount of gas, the call can trigger O(n) cost in terms of reading the code from disk, preprocessing the code for VM execution, and also adding O(n) data to the Merkle proof for the block's proof-of-validity. At current gas levels, this is acceptable even if suboptimal. At the

RATIONALE:
Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a constant amount of gas, the call can trigger O(n) cost in terms of reading the code from disk, preprocessing the code for VM execution, and also adding O(n) data to the Merkle proof for the block's proof-of-validity. At current gas levels, this is acceptable even if suboptimal. At the higher gas levels that could be triggered in the future, possibly very soon due to dynamic gas limit rules, this would become a greater concern—not nearly as serious as


=== EIP-1706 ===
TITLE: Disable SSTORE with gasleft lower than call stipend
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-01-15
REQUIRES: 1283

SUMMARY:
[EIP-1283](./eip-1283.md) significantly lowers the gas costs of writing to contract's storage. This created a danger of a new kind of reentrancy attacks on existing contracts as Solidity by default grants a 'stipend' of 2300 gas to simple transfer calls. This danger is easily mitigated if SSTORE is not allowed in low gasleft state, without breaking the backward compatibility and the original intention of this EIP.

SPECIFICATION:
Add the following condition to the SSTORE opcode gas cost calculation: * If *gasleft* is less than or equal to 2300, fail the current call frame with 'out of gas' exception.

MOTIVATION:
An attack that is described in [this article](https://medium.com/chainsecurity/constantinople-enables-new-reentrancy-attack-ace4088297d9). Explicitly specifying the call stipend as an invariant will have a positive effect on Ethereum protocol security: https://www.reddit.com/r/ethereum/comments/agdqsm/security_alert_ethereum_constantinople/ee5uvjt

RATIONALE:
In order to keep in place the implicit reentrancy protection of existing contracts, transactions should not be allowed to modify state if the remaining gas is lower then the 2300 stipend given to 'transfer'/'send' in Solidity. These are other proposed remediations and objections to implementing them: * Drop EIP-1283 and abstain from modifying SSTORE cost * EIP-1283 is an important update * It was accepted and implemented on test networks and in clients. * Add a new call context that permits LOG opcodes but not changes to state. * Adds another call type beyond existing regular/staticcall * Raise


=== EIP-3534 ===
TITLE: Restricted Chain Context Type Transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-20
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new EIP-2718 transaction type with the format `0x4 || rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`. This proposed `chainContext` element adds a constraint on the validity of a transaction to a chain segment meeting the referenced value(s). Four contexts are defined as subclasses of this type: - `segmentId` - `eligibleMinerList` - `ineligibleMinerList` - `expiry` These contexts can be used in arbitrary combinations. Annotated context value combinations are referenced by a composite integer prefix on the annotation.

SPECIFICATION:
### Parameters - `FORK_BLOCK_NUMBER` `TBD` - `TRANSACTION_TYPE_NUMBER` `0x4`. See EIP-2718. As of `FORK_BLOCK_NUMBER`, a new EIP-2718 transaction is introduced with `TransactionType` `TRANSACTION_TYPE_NUMBER`. The EIP-2718 `TransactionPayload` for this transaction is `rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`. The EIP-2718 `ReceiptPayload` for this transaction is `rlp([status, cumulativeGasUsed, logsBloom, logs])`. ### Definitions - `chainContext`. The transaction is only valid for blockchain data satisfying ALL OF the annotations. - `ANNOTATION_COMPOSITE_PREFIX`. A positive integer between `1` and `0xff` that represents the set of subclass annotations in the `chainContext` (_ie._ _which_ chain context subclasses should the provided values be

MOTIVATION:
Establish a protocol-based mechanism with which transactions are able to articulate constraints on eligible chain contexts. Generally, these constraints give the consumer (the transactor) an ability to express requirements about the transaction's relationship to blockchain data and its provenance. - Restrict transaction applicability to a chain context that is currently available and reasoned about under some subjective view. - Introduces a way for transactions to describe a dependency on their current view of a chain. - Restrict transaction applicability to a chain context following some foregoing block (and its transactions). - Introduces a way for transactions to describe

RATIONALE:
### Subclasses Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP. Their specification definitions allow arbitrary mutual (`AND`) combinations. This design is intended to form a proposal which offers a concrete set of specifics while doing so with enough flexibility for extension or modification later. #### `ANNOTATION_PREFIX` `ANNOTATION_PREFIX` values' use of octal-derived values, ie. `1, 2, 4, 8, 16, 32, 64, 128`, follows a conventional pattern of representing combinations from a limited set uniquely and succinctly, eg. Unix-style file permissions. This EIP defines four of the eight


=== EIP-7892 ===
TITLE: Blob Parameter Only Hardforks
TYPE: Informational 
STATUS: Last Call
CREATED: 2025-02-28
REQUIRES: 7840

SUMMARY:
This EIP introduces **Blob Parameter Only (BPO) Hardforks**, a lightweight mechanism for incrementally scaling Ethereum’s blob capacity through targeted hard forks that modify only blob-related parameters: `target`, `max`, and `baseFeeUpdateFraction`. Unlike traditional hard forks, which require extensive coordination and introduce broader protocol changes, BPO forks enable rapid, low-overhead scaling of blob capacity in response to **real-world demand and network conditions**.

SPECIFICATION:
### Definition BPO hardforks are defined as protocol upgrades that modify only blob-related parameters through configuration, without requiring any client-side code changes. The new parameters take effect immediately at the specified activation time. ### Blob schedule configuration The following protocol parameters are now managed by the blob schedule configuration: - **Blob Target (`target`)**: The expected number of blobs per block. - **Blob Limit (`max`)**: The maximum number of blobs per block. - **Blob Base Fee Update Fraction (`baseFeeUpdateFraction`)**: Determines how blob gas pricing adjusts per block. To ensure consistency, when a regular hardfork changes any of these parameters,

MOTIVATION:
Ethereum's scaling strategy relies on Layer 2 (L2) solutions for transaction execution while using Ethereum as a **data availability (DA) layer**. However, the demand for DA has increased rapidly, and the current approach of only modifying blob parameters in large, infrequent hard forks is **not agile enough** to keep up with L2 growth. The key motivations for BPO forks are as follows: 1. **Continuous Scaling** - L2 DA demand is growing rapidly, leading to ongoing saturation of blob capacity. - Large, infrequent blob parameter changes create high costs and inefficiencies. - BPO forks allow for more frequent, safer

RATIONALE:
### Why not just use regular hardforks? Full hard forks require extensive coordination, testing, and implementation changes beyond parameter adjustments. For example, in Lighthouse, a typical hard fork implementation requires thousands of lines of boilerplate before any protocol changes occur. BPO forks streamline this process by avoiding the need for this boilerplate code. ### Why specify parameters in the node configuration instead of code? Allowing blob parameters to be configured externally enables rapid experimentation, testing, and adjustments without requiring code changes across client implementations. Testing teams can investigate different parameters with minimal involvement from client implementers. ### Why


=== EIP-3540 ===
TITLE: EOF - EVM Object Format v1
TYPE: Standards Track Core
STATUS: Review
CREATED: 2021-03-16
REQUIRES: 3, 5, 4, 1, ,,  , 3, 8, 6, 0

SUMMARY:
We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the reserved byte introduced by [EIP-3541](./eip-3541.md). To summarise, EOF bytecode has the following layout: ``` magic, version, (section_kind, section_size_or_sizes)+, 0, <section contents> ```

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. In order to guarantee that every EOF-formatted contract in the state is valid, we need to prevent already deployed (and not validated) contracts from being recognized as such format. This is achieved by choosing a byte sequence for the *magic* that doesn't exist in any of the already deployed contracts. ### Remarks If code starts with the `MAGIC`, it is considered to be EOF

MOTIVATION:
On-chain deployed EVM bytecode contains no pre-defined structure today. Code is typically validated in clients to the extent of `JUMPDEST` analysis at runtime, every single time prior to execution. This poses not only an overhead, but also a challenge for introducing new or deprecating existing features. Validating code during the contract creation process allows code versioning without an additional version field in the account. Versioning is a useful tool for introducing or deprecating features, especially for larger changes (such as significant changes to control flow, or features like account abstraction). The format described in this EIP introduces a

RATIONALE:
EVM and/or account versioning has been discussed numerous times over the past years. This proposal aims to learn from them. See "Ethereum account versioning" on the Fellowship of Ethereum Magicians Forum for a good starting point. ### Execution vs. creation time validation This specification introduces creation time validation, which means: - All created contracts with *EOFn* prefix are valid according to version *n* rules. This is very strong and useful property. The client can trust that the deployed code is well-formed. - In the future, this allows to serialize `JUMPDEST` map in the EOF container and eliminate the


=== EIP-7998 ===
TITLE: Turn `randao_reveal` into a VRF
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-03
REQUIRES: 

SUMMARY:
This EIP proposes a modification to the data signed by a block proposer for the `randao_reveal`. The current `randao_reveal` is a BLS signature over the current epoch number, which is predictable. This proposal incorporates the RANDAO mix of the previous epoch and the current slot number into the signed data. This change transforms the `randao_reveal` into a Verifiable Random Function (VRF), making it unpredictable across epochs even for the revealer itself. This enhancement strengthens Ethereum's native randomness source and enables protocols such as Single Secret Leader Election (SSLE).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). The gist of the change is in `process_randao`, which now uses the RANDAO mix of the previous epoch and the current slot number to seed the `randao_reveal` signature. We are introducing a new SSZ-serializable container called `RandaoRevealSeed` containing that information. ### New SSZ Container A new SSZ `Container` is introduced to serve as the message for the `randao_reveal` signature post-fork. ```python class RandaoRevealSeed(Container): previous_mix:

MOTIVATION:
This change creates a secure, per-slot VRF output from the proposer, with several benefits: 1. it **paves the way for secret proposer election**, which would in turn reduce MEV and completely eliminate the well-known RANDAO bias attack vector; 2. it supports other proposals like [EIP-7956](./eip-7956.md) that rely on a source of verifiable randomness. Using a BLS signature as a VRF is sound under the Computational Diffie-Hellman (CDH) assumption, rather than Decisional Diffie-Hellman. The BLS verification process inherently proves the correctness of the VRF output without requiring a separate proof.

RATIONALE:
### Choice of VRF Input The `randao_reveal` is effectively transformed into `VRF(sk, message)` where the `message` is the SSZ serialization of the `RandaoRevealSeed` container. - `previous_mix`: Including the RANDAO mix from the previous epoch (`previous_mix`) is the core of this proposal. Since the previous epoch's final mix is not known until the end of that epoch, a proposer cannot compute their `randao_reveal` of future epochs, beforehand. - `slot`: Including the current `slot` number ensures that the `randao_reveal` is unique for each slot and unpredictable to other validators. Without it, a validator chosen to propose multiple times in an


=== EIP-2327 ===
TITLE: BEGINDATA opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-10-28
REQUIRES: 

SUMMARY:
It is common for smart contracts to efficiently store data directly in the contract bytecode. Examples include constructor arguments, constant variables, compiler metadata and the contract runtime during the init phase. Currently, such data is not distinguished from normal bytecode and is still being analysed for `JUMPDEST`s by EVM interpreters. This EIP introduces a new opcode `BEGINDATA` at byte `0xb6`, which marks the remainding bytecode as data, indicating to EVM interpreters, static analysis tools and chain explorers that the remaining bytes do not represent opcodes.

SPECIFICATION:
While computing the valid `JUMPDEST`s of a contract, halt analysis once the first `BEGINDATA` is encountered. In other words: A jump to any codelocation equal to or greater than the location of the first `BEGINDATA` causes a `BAD_JUMP_DESTINATION` error. If `BEGINDATA` is encountered during contract execution, it has the same semantics as `STOP`. It uses 0 gas. Bytes past `BEGINDATA` remain accessible via `CODECOPY` and `EXTCODECOPY`. `BEGINDATA` does not influence `CODESIZE` or `EXTCODESIZE`.

MOTIVATION:
The `BEGINDATA` opcode has been suggested before as part of the EIP `Subroutines and Static Jumps for the EVM` [EIP-615](./eip-615.md) as a way to determine the position of jumptables in contract bytecode. It is here introduced in its own right in order to exclude data from the `JUMPDEST` analysis of contracts, making it impossible to jump to data. This makes it easier for static analysis tools to analyse contracts, allows disassemblers, chain explorers and debuggers to not display data as a mess of INVALID opcodes and may even provide a marginal improvement in performance. It also helps scalability

RATIONALE:
The byte `0xb6` was chosen to align with [EIP-615](./eip-615.md). The choice to `STOP` if `BEGINDATA` is encountered is somewhat arbitrary. An alternative would be to be to abort the execution with an out-of-gas error.


=== EIP-141 ===
TITLE: Designated invalid EVM instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-09
REQUIRES: 

SUMMARY:
An instruction is designated to remain as an invalid instruction.

SPECIFICATION:
The opcode `0xfe` is the `INVALID` instruction. It can be used to abort the execution (i.e. duplicates as an `ABORT` instruction).

MOTIVATION:
The invalid instruction can be used as a distinct reason to abort execution.


=== EIP-7698 ===
TITLE: EOF - Creation transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-24
REQUIRES: 3540

SUMMARY:
Creation transactions (i.e. the ones with empty `to`) can be used to deploy EOF contracts by providing EOF initcontainer concatenated with `calldata` for initcontainer execution in transaction's `data`. Initcontainer execution is similar to its execution during `EOFCREATE` instruction, ending with `RETURNCODE` instruction. New account address calculation is based on sender's address and nonce.

SPECIFICATION:
Wherever not explicitly listed, the rules of EOF contract creation should be identical or analogous to those of legacy creation transaction. This includes but is not limited to: - behavior on `accessed_addresses` and address collision ([EIP-684](./eip-684.md) and [EIP-2929](./eip-2929.md)) - EVM execution frame created for the initcode - memory, account context etc. - nonce bumping of the account of newly created contract [EIP-161](./eip-161.md) - balance checking and transfer for the creation endowment ### Parameters | Constant | Value | | - | - | | `EOF_MAGIC` | Defined as `0xEF00` in [EIP-3540](./eip-3540.md) | | `MAX_CODE_SIZE` | Defined as `24576`

MOTIVATION:
Creation transaction is one of the three ways alongside creation instructions provided by legacy EVM to deploy new code. Given that legacy creation instructions (`CREATE` and `CREATE2`) are not allowed to deploy EOF code, supporting EOF in creation transactions is the only way to get the first EOF on-chain. The mechanism for providing constructor arguments to initcontainer is exactly the same as for deploying legacy code (just concatenating them with initcontainer), therefore existing deployment tooling can be used as is to deploy EOF.

RATIONALE:
### Irregular state change to deploy Creator Contract Originally it was proposed to deploy the first EOF contract via irregular state change. This contract would execute `TXCREATE` instruction and could be used then as an entry point to deploy any other EOF code. This would also require an introduction of `InitcodeTransaction`, required by `TXCREATE`. It was decided against this variant for the benefit of reduced scope of changes. ### Constructor arguments outside of initcontainer vs in data section Alternative mechanism for providing constructor arguments to initcontainer execution was considered, where they are concatenated with data section of the


=== EIP-7069 ===
TITLE: Revamped CALL instructions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-05-05
REQUIRES: 1, 5, 0, ,,  , 2, 1, 1, ,,  , 2, 1, 4, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 4, 0

SUMMARY:
Introduce three new call instructions, `EXTCALL`, `EXTDELEGATECALL` and `EXTSTATICCALL`, with simplified semantics. Introduce another instruction, `RETURNDATALOAD` for loading a word from return data into stack. Modify the behavior of `RETURNDATACOPY` instruction executed within EOF formatted code (as defined by [EIP-3540](./eip-3540.md)). The existing `*CALL` instructions are rejected by EOF validation. The new instructions do not allow specifying a gas limit, but rather rely on the "63/64th rule" ([EIP-150](./eip-150.md)) to limit gas. An important improvement is the rules around the "stipend" are simplified, and callers do not need to perform special calculation whether the value is sent or not. Furthermore,

SPECIFICATION:
| Name | Value | Comment | |------|-------|---------| | WARM_STORAGE_READ_COST | 100 | From [EIP-2929](./eip-2929.md) | | COLD_ACCOUNT_ACCESS | 2600 | From [EIP-2929](./eip-2929.md) | | CALL_VALUE_COST | 9000 | | | ACCOUNT_CREATION_COST | 25000 | | | MIN_RETAINED_GAS | 5000 | | | MIN_CALLEE_GAS | 2300 | | We introduce four new instructions: - `EXTCALL` (`0xf8`) with arguments `(target_address, input_offset, input_size, value)` - `EXTDELEGATECALL` (`0xf9`) with arguments `(target_address, input_offset, input_size)` - `EXTSTATICCALL` (`0xfb`) with arguments `(target_address, input_offset, input_size)` - `RETURNDATALOAD` (`0xf7`) with argument `offset` These four new instructions are undefined in legacy code and only available in EOF

MOTIVATION:
Observability of gas has been a problem for very long. The system of gas has been (and likely must be) flexible in adapting to changes to both how Ethereum is used as well as changes in underlying hardware. Unfortunately, in many cases compromises or workarounds had to be made to avoid affecting call instructions negatively, mostly due to the complex semantics and expectations of them. This change removes gas observability from the new instructions and opens the door for new classes of contracts that are not affected by repricings. Furthermore, the legacy call instructions are rejected within EOF

RATIONALE:
### Removing gas selectability One major change from the original `CALL` series of instructions is that the caller has no control over the amount of gas passed in as part of the call. The number of cases where such a feature is essential are probably better served by direct protocol integration. Removing gas selectability also introduces a valuable property that future revisions to the gas schedule will benefit from: you can always overcome Out of Gas (OOG) errors by sending more gas as part of the transaction (subject to the block gas limit). Previously when raising storage costs


=== EIP-684 ===
TITLE: Revert creation in case of collision
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-03-20
REQUIRES: 

SUMMARY:
This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by "creating" an account at that existing address.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. If a contract creation is attempted due to a creation transaction, the `CREATE` opcode, the `CREATE2` opcode, or any other reason, and the destination address already has either a nonzero nonce, or a nonzero code length, then the creation MUST throw as if the first byte in the init code were an invalid opcode. This change MUST apply retroactively for all existing blocks.

RATIONALE:
One of the core tenants of smart contracts is that its code will not change. However with sufficient computing power an attacker can change the code stored in an address to any other code, steal funds or execute other malicious activity.


=== EIP-7949 ===
TITLE: Genesis File Format
TYPE: Informational 
STATUS: Draft
CREATED: 2025-05-19
REQUIRES: 

SUMMARY:
This EIP defines a canonical structure for Ethereum genesis files (`genesis.json`) used to bootstrap Ethereum networks. The standard aligns with the de facto structure implemented by Geth (Go-Ethereum), and already adopted by other clients. It introduces a JSON Schema to ensure consistency and tool compatibility across clients.

SPECIFICATION:
The canonical genesis file MUST be a JSON object with the following top-level fields: ### Top-Level Fields | Field | Description | |-----------------|-----------------------------------------------------------------| | `config` | Chain configuration object. | | `alloc` | Map of addresses to pre-allocated balances and/or code/storage. | | `nonce` | Decimal or Hex nonce. | | `timestamp` | Decimal or Hex UNIX timestamp. | | `extraData` | Arbitrary extra data. | | `gasLimit` | Decimal or Hex block gas limit. | | `difficulty` | Decimal or Hex block difficulty. | | `mixhash` | Hex mix hash. | | `coinbase` | Hex address. |

MOTIVATION:
The lack of an official standard for the `genesis.json` file has led to incompatibilities, bugs and confusion, as well as added workload for those running multiple clients together in test networks. This EIP aims to reduce ambiguity by defining a consistent structure and enabling tooling through schema-based validation.

RATIONALE:
There are a growing number of EIPs that propose improvements to how a network is configured at genesis: [Add Blob Schedule to EL Config File](eip-7840) [Blob Parameter Only Hardforks](eip-7892) [eth_config JSON-RPC method](eip-7910) However, the root configuration element amended by these remains unspecified. Adopting a minimal schema to define that will make subsequent changes more accurate and concise.


=== EIP-1010 ===
TITLE: Uniformity Between 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B and 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-18
REQUIRES: 

SUMMARY:
As of the date of this EIP, the difference in balance between address `0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B` and address `0x15E55EF43efA8348dDaeAa455F16C43B64917e3c` is far from equitable or uniform, with the former having more than 365,000 ether more than the latter. The distribution of ether between these two addresses must be improved in order to protect the Ethereum economy from centralized control. This will be accomplished by transferring 100,000 ether from the former address to the latter. This is a properly motivated improvement in keeping with the core Ethereum philosophy of decentralization.

SPECIFICATION:
The balance of `0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B` will be decreased by 100,000 ether. The balance of `0x15E55EF43efA8348dDaeAa455F16C43B64917e3c` will be increased by 100,000 ether. No net change in the amount of extant ether will occur unless at the time of implementation the former address does not contain sufficient ether for such a deduction.

MOTIVATION:
This proposal is necessary because the Ethereum protocol does not allow the owner of an address which does not own an equitable amount of ether to claim their share of ether from an address which owns a dangerously centralized quantity. Rather than proposing an overly complicated generic mechanism for any user to claim ether to which they believe they are equitably entitled, this proposal will take the simple route of a one-time transfer of 100,000 ether from `0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B` to `0x15E55EF43efA8348dDaeAa455F16C43B64917e3c`. This avoids duplicating the effort of other proposals and provides a net improvement to the Ethereum project and

RATIONALE:
The value 100,000 was chosen after careful technically sound analysis of various economic theories developed over the past century. In spite of the fact that it is a convenient round number, it is actually the exact output of a complex statistical process iterated to determine the optimal distribution of ether between these addresses.


=== EIP-7916 ===
TITLE: SSZ ProgressiveList
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-24
REQUIRES: 

SUMMARY:
This EIP introduces a new Merkle tree shape for [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md) types that results in fewer hashes when only a small number of leaves is used. The new tree shape grows progressively with increased leaf count and no longer has a bounded capacity. It also offers forward compatibility: a given chunk index is always assigned the same stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/merkle-proofs.md#generalized-merkle-tree-index) regardless of leaf count. New types are defined to use the progressive Merkle tree shape: `ProgressiveList[type]` and `ProgressiveBitlist`. These new types represent lists of arbitrary length with stable merkleization, reducing hashing overhead for small lists and

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Progressive Merkle tree The [SSZ Merkleization specification)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md#merkleization) is extended with a helper function: - `merkleize_progressive(chunks, num_leaves=1)`: Given ordered `BYTES_PER_CHUNK`-byte chunks: - The merkleization depends on the number of input chunks and is defined recursively: - If `len(chunks) == 0`: the root is a zero value, `Bytes32()`. - Otherwise: compute the root using `hash(a, b)` - `a`: Recursively merkleize chunks beyond `num_leaves` using `merkleize_progressive(chunks[num_leaves:],

MOTIVATION:
Current SSZ `List[type, N]` types require a predefined capacity `N`, which leads to several issues: - Inefficient hashing: Lists often contain far fewer elements than their maximum capacity (e.g., [`Transaction`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/bellatrix/beacon-chain.md#custom-types)), resulting in unnecessary zero-padding and dozens of extra hash computations. This is exacerbated when nesting `List[type, N]`, e.g., in a design where each of up to `X` transactions has up to `Y` access lists, each with up to `Z` storage slots. - Arbitrary Limits: The capacity `N` is often chosen arbitrarily (e.g., [`MAX_BYTES_PER_TRANSACTION`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/bellatrix/beacon-chain.md#execution), [`MAX_TRANSACTIONS_PER_PAYLOAD`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/bellatrix/beacon-chain.md#execution)) and set to an artificially large value to anticipate future design space which are

RATIONALE:
### Why a recursive structure? - Efficiency: Small lists use fewer hashes (e.g., a 3-item list in a 16-element subtree wastes fewer hashes than a 1024-element `List[type, N]`). - Stability: Fixed subtree sizes ensure stable gindices, avoiding the need for dynamic depth adjustments or multiple queries. - Scalability: Recursive subtrees allow arbitrary growth without a hardcoded limit, constrained only by practical limits (e.g., network payload limit, validation rules). ### Why not dynamic depth? Dynamic-depth Merkleization destabilizes gindices: - Requires two-step queries (length then gindex), increasing latency and reorg risks. - Complicates proofs with semantic lookups. Mixing in successor


=== EIP-2976 ===
TITLE: Typed Transactions over Gossip
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-09-13
REQUIRES: 2718

SUMMARY:
[Typed Transactions](./eip-2718.md) can be sent over devp2p as `TransactionType || TransactionPayload`. The exact contents of the `TransactionPayload` are defined by the `TransactionType` in future EIPs, and clients may start supporting their gossip without incrementing the devp2p version. If a client receives a `TransactionType` that it doesn't recognize, it **SHOULD** disconnect from the peer who sent it. Clients **MUST NOT** send new transaction types before they believe the fork block is reached.

SPECIFICATION:
All changes specified below apply to all protocol/versions retroactively. ### Definitions * `||` is the byte/byte-array concatenation operator. * `|` is the type union operator. * `DEVP2P_VERSION = TBD` * `Transaction` is either `TypedTransaction` or `LegacyTransaction` * `TypedTransaction` is a byte array containing `TransactionType || TransactionPayload` * `TypedTransactionHash` is `keccak256(TypedTransaction)` * `TransactionType` is a positive unsigned 8-bit number between `0` and `0x7f` that represents the type of the transaction * `TransactionPayload` is an opaque byte array whose interpretation is dependent on the `TransactionType` and defined in future EIPs * `LegacyTransaction` is an array of the form `[nonce, gasPrice,

MOTIVATION:
[EIP-2718](./eip-2718.md) introduced new transaction types for blocks (which presents itself in the makeup of a block header's transaction root and receipts root). However, without a mechanism for gossiping these transactions, no one can actually include them in a block. By updating devp2p to support the gossip of Typed Transactions, we can benefit from these new transaction types. *Note: See [EIP-2718](./eip-2718.md) for additional motivations of Typed Transactions.*

RATIONALE:
### Why not specify each transaction type at the protocol layer? We could have chosen to make the protocol aware of the shape of the transaction payloads. The authors felt that it would be too much maintenance burden long term to have every new transaction type require an update to devp2p, so instead we merely define that typed transactions are supported. ### Why have peers disconnect if they receive an unknown transaction type? We could encourage peers to remain connected to peers that submit an unknown transaction type, in case the transaction is some new transaction type that


=== EIP-3 ===
TITLE: Addition of CALLDEPTH opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2015-11-19
REQUIRES: 


=== EIP-3541 ===
TITLE: Reject new contract code starting with the 0xEF byte
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-03-16
REQUIRES: 

SUMMARY:
Disallow new code starting with the `0xEF` byte to be deployed. Code already existing in the account trie starting with `0xEF` byte is not affected semantically by this change.

SPECIFICATION:
After `block.number == HF_BLOCK` new contract creation (via create transaction, `CREATE` or `CREATE2` instructions) results in an exceptional abort if the _code_'s first byte is `0xEF`. ### Remarks The *initcode* is the code executed in the context of the *create* transaction, `CREATE`, or `CREATE2` instructions. The *initcode* returns *code* (via the `RETURN` instruction), which is inserted into the account. See section 7 ("Contract Creation") in the Yellow Paper for more information. The opcode `0xEF` is currently an undefined instruction, therefore: *It pops no stack items and pushes no stack items, and it causes an exceptional abort when executed.*

MOTIVATION:
Contracts conforming to the EVM Object Format (EOF) are going to be validated at deploy time. In order to guarantee that every EOF-formatted contract in the state is valid, we need to prevent already deployed (and not validated) contracts from being recognized as such format. This will be achieved by choosing a byte sequence for the *magic* that doesn't exist in any of the already deployed contracts. To prevent the growth of the search space and to limit the analysis to the contracts existing before this fork, we disallow the starting byte of the format (the first byte

RATIONALE:
The `0xEF` byte was chosen because it resembles **E**xecutable **F**ormat. Contracts using unassigned opcodes are generally understood to be at risk of changing semantics. Hence using the unassigned `0xEF` should have lesser effects, than choosing an assigned opcode, such as `0xFD` (`REVERT`), `0xFE` (`INVALID)`, or `0xFF` (`SELFDESTRUCT`). Arguably while such contracts may not be very useful, they are still using valid opcodes. Analysis in May 2021, on `18084433` contracts in state, showed that there are 0 existing contracts starting with the `0xEF` byte, as opposed to 1, 4, and 12 starting with `0xFD`, `0xFE`, and `0xFF`, respectively.


=== EIP-8032 ===
TITLE: Tree-Depth-Based Storage Gas Pricing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-09-29
REQUIRES: 

SUMMARY:
This EIP introduces a mechanism to dynamically price SSTORE operations based on the storage size of a contract. A new optional depth field is added to the account RLP, which tracks an approximation of the storage trie's depth. The gas cost for SSTORE will be augmented by a factor that grows exponentially with this depth field, but only after it crosses a predefined activation threshold. This change aims to align the cost of state growth with the long-term burden it places on the network, thereby disincentivizing state bloat.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### Constants and parameters |Name|Value|Description| |-|:-:|-| |`FORK_TIMESTAMP`| TBD | Fork activation timestamp | |`EXP_FACTOR` | TBD | Exponent gas cost factor | |`LIN_FACTOR` | TBD | Linear gas cost factor | | `ACTIVATION_THRESHOLD` | TBD | Activation threshold, chosen to be at ~8GB of data. | ### Account tree and update rules change Account RLP descriptors receive an optional `depth` field, corresponding to the

MOTIVATION:
Ethereum's state size is a growing concern, as it directly impacts node synchronization times, hardware requirements, and overall network health. The current gas model for storage operations does not fully account for the long-term cost of maintaining that state indefinitely. This has led to a situation where it is economically viable to create contracts with vast amounts of storage ("state bloat"), which can be used for low-cost data anchoring or spam, imposing a negative externality on all network participants who must maintain this data. This proposal aims to address the state growth problem by creating a direct economic

RATIONALE:
The intent is to create friction in when growing the state size of a contract, thus limiting the number of such contracts. Going over the limit, some contract developers might want to use another contract to start fresh, which comes at the cost of paying for contract creation, and for any call into the previous instance of the contract. The depth of the tree is chosen over the leaf count, because the storage tree is balanced, owing to the fact that its keys are hashed. Therefore, checking the maximum depth of a write is a stochastic process that


=== EIP-6800 ===
TITLE: Ethereum state using a unified verkle tree
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-03-17
REQUIRES: 6780

SUMMARY:
Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase transition to Ethereum exclusively relying on Verkle trees to store execution state.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Verkle tree definition We define a Verkle tree here by providing the function to compute the root commitment given a set of 32-byte keys and 32-byte values. Algorithms for updating and inserting values are up to the implementer; the only requirement is that the root commitment after the update must continue to match the value computed from this specification. We will then define

MOTIVATION:
Verkle trees solve a key problem standing in the way of Ethereum being stateless-client-friendly: witness sizes. A witness accessing an account in today’s hexary Patricia tree is, in the average case, close to 3 kB, and in the worst case it may be three times larger. Assuming a worst case of 6000 accesses per block (15m gas / 2500 gas per access), this corresponds to a witness size of ~18 MB, which is too large to safely broadcast through a p2p network within a 12-second slot. Verkle trees reduce witness sizes to ~200 bytes per account in the

RATIONALE:
This implements all of the logic in transitioning to a Verkle tree, and at the same time reforms gas costs, but does so in a minimally disruptive way that does not require simultaneously changing the whole tree structure. Instead, we add a new Verkle tree that starts out empty, and only new changes to state and copies of accessed state are stored in the tree. The Patricia tree continues to exist, but is frozen. This sets the stage for a future hard fork that swaps the Patricia tree in-place with a Verkle tree storing the same data. Unlike


=== EIP-7685 ===
TITLE: General purpose execution layer requests
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-04-14
REQUIRES: 

SUMMARY:
This proposal defines a general purpose framework for storing contract-triggered requests. It extends the execution header with a single field to store the request information. Requests are later on exposed to the consensus layer, which then processes each one.

SPECIFICATION:
### Execution Layer #### Requests A `requests` object consists of a `request_type` byte prepended to an opaque byte array `request_data`. The `request_data` contains zero or more encoded request objects. ``` requests = request_type ++ request_data ``` Each request type will define its own `requests` object with its own `request_data` format. #### Block Header Extend the header with a new 32 byte commitment value `requests_hash`. While processing a block, multiple `requests` objects with different `request_type`s will be produced by the system, and accumulated in the block requests list. In order to compute the commitment, an intermediate hash list is

MOTIVATION:
The proliferation of smart contract controlled validators has caused there to be a demand for additional EL triggered behaviors. By allowing these systems to delegate administrative operations to their governing smart contracts, they can avoid intermediaries needing to step in and ensure certain operations occur. This creates a safer system for end users. By abstracting each individual request details from the EL, adding new request types is simpler and does not require an update on the execution block structure.

RATIONALE:
### Opaque byte array rather than an RLP array By having the bytes of `request_data` array from second byte on be opaque bytes, rather than an RLP (or other encoding) list, we can support different encoding formats for the request payload in the future such as SSZ, LEB128, or a fixed width format. ### Request source and validity This EIP makes no strict requirement where a request may come from nor when/how a request must be validated. This is to provide future protocol designers maximum flexibility. The authors' recommendations on source and validity of requests are: * The


=== EIP-7748 ===
TITLE: State conversion to Verkle Tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-07-23
REQUIRES: 7612

SUMMARY:
This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants | Parameter | value | Description | | ---------------------------- | ----- | -------------------------------------------------------------- | | `CONVERSION_START_TIMESTAMP` | `TBD` | Timestamp at which the conversion starts. | | `CONVERSION_STRIDE` | `TBD` | Maximum number of _conversion units_ to be converted per block | A _conversion unit_ is: - A contract storage slot. - An account data (e.g. balance, nonce, code-hash) and code (if

MOTIVATION:
The accounts state is too large to wait for transactions to organically move all of them to the VKT through the Overlay Tree. Thus, we need a strategy to convert all the state within a reasonable time. The state conversion completion allows removing the Overlay Tree abstraction introduced in [EIP-7612](./eip-7612.md) and to use directly the VKT for all state access.

RATIONALE:
### State conversion step position in block execution Performing the conversion step before the block txs execution has some benefits: - If the state conversion step is done after txs execution, there's a possibility that txs execution writes overlap with converted key-values, having to care about them becoming stale in the same block. With the proposed ordering, they can only become stale by writes of previous blocks. - It can reduce the complexity of optimizations, such as frontrunning the state conversion for the next block before it arrives. ### `CONVERSION_STRIDE` proposed value Performance benchmarks were done to achieve


=== EIP-7915 ===
TITLE: Adaptive mean reversion blob pricing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-23
REQUIRES: 4844

SUMMARY:
Reworks the excess blob gas update in `calc_excess_blob_gas()` so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The exponential moving average (EMA) is computed in the linear domain and stored as a header variable.

SPECIFICATION:
### Parameters | Constant | Value | Short description | | - | - | - | | `EMA_DECAY` | `2**18` | Reciprocal of the EMA decay rate (per slot) | | `MEAN_REVERSION_DEADBAND` | `64` | Fee ratio at which mean reversion effect accelerates | | `MEAN_REVERSION_FULLBAND` | `10**6` | Fee ratio at which mean reversion effect stops increasing | ### Functions The function `calc_excess_blob_gas()` from [EIP-4844](./eip-4844.md) is updated. A mean reversion weight `w` is computed based on the ratio between the long-run base fee and the current base fee. The weight influences the excess gas update by

MOTIVATION:
Demand for blobspace is fee-inelastic, leading to a blob base fee that may fluctuate excessively with minor shifts in aggregate demand. The lower end of the fee range of 1 wei is under current circumstances economically inconsequential, but can be reached after a period of blocks consuming fewer blobs than the target. During increases in demand, the existing fee mechanism requires sustained periods of near-full blocks to re-establish equilibrium. This exacerbates spikiness in resource consumption, which can hamper efficient scaling of throughput. Furthermore, users may intermittently need to compete in a first-price auction for inclusion, degrading UX. The

RATIONALE:
### Supply and demand Since the introduction of blobs, the reservation fee of the marginal consumer of blobs has periodically been very low. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a worse UX by blob consumers. The resulting spikiness in resource consumption is suboptimal for scaling blobspace. At a fundamental level, the issue is that Ethereum faces a fee-inelastic demand curve while operating a perfectly inelastic supply curve—with supply fixed at `TARGET_BLOB_GAS_PER_BLOCK`. When an equilibrium forms between fee-inelastic supply and


=== EIP-2566 ===
TITLE: Human Readable Parameters for Contract Function Execution
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-03-23
REQUIRES: 

SUMMARY:
When a dapp prompts a user to execute a smart contract function via a ProviderWallet, confirmation screens displayed in the ProviderWallet layer cannot display the human readable details of the function to be called and the arguments to be passed. This is because the Ethereum RPC method used for contract function execution (`eth_sendTransaction`) accepts information about what function to call in a non-human readable (and non-recoverable) format. As such, when a ProviderWallet receives this non-human readable information from a dapp, they are unable to display a human readable version since they never received one and cannot recover one

SPECIFICATION:
This EIP proposes increasing the set of Ethereum RPC methods to include a new method - `eth_sendTransactionToContractFunction`. This method parallels `eth_sendTransaction` with the only difference being the inclusion of the contract function's `abi` field. Parameters 1. `Object` - The transaction object * `from`: `DATA`, 20 Bytes - The address the transaction is sent from. * `to`: `DATA`, 20 Bytes - (optional when creating new contract) The address the transaction is directed to. * `gas`: `QUANTITY` - (optional, default: 90000) Integer of the gas provided for the transaction execution. It will return unused gas. * `gasPrice`: `QUANTITY` - (optional,

MOTIVATION:
### ProviderWallet Definition ProviderWallets like Metamask and Geth are hybrid software that combine an Ethereum API provider with an Ethereum wallet. This allows them to sign transactions on behalf of their users and also broadcast those signed transactions to the Ethereum network. ProviderWallets are used for both convenience and for the protection they give users through human readable confirmation prompts. ### Existing Solutions Much discussion has been made in the past few years on the topic of human readable Ethereum transaction data. Aragon's [Radspec](https://github.com/aragon/radspec) addresses this issue by requiring contract developers to amend their contract functions with human

RATIONALE:
This EIP's proposed `eth_sendTransactionToContractFunction` method is intended to parallel `eth_sendTransaction` as much as possible since both methods result in the same behaviour when executing a contract function. The newly introduced `abi` field is an element of the contract's ABI that corresponds to the intended function. The `data` field is the same `data` field from `eth_sendTransaction`. The `abi` field can be combined with values parsed from the `data` field to recreate human readable contract function execution information.


=== EIP-1702 ===
TITLE: Generalized Account Versioning Scheme
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-12-30
REQUIRES: 

SUMMARY:
This defines a method of hard forking while maintaining the exact functionality of existing account by allowing multiple versions of the virtual machines to execute in the same block. This is also useful to define future account state structures when we introduce the on-chain WebAssembly virtual machine.

SPECIFICATION:
### Account State Re-define account state stored in the world state trie to have 5 items: `nonce`, `balance`, `storageRoot`, `codeHash`, and `version`. The newly added field `version` is a 256-bit **scalar**. We use the definition of "scalar" from Yellow Paper. Note that this is the same type as `nonce` and `balance`, and it is equivalent to a RLP variable-sized byte array with no leading zero, of maximum length 32. When `version` is zero, the account is RLP-encoded with the first 4 items. When `version` is not zero, the account is RLP-encoded with 5 items. Account versions can also

MOTIVATION:
By allowing account versioning, we can execute different virtual machine for contracts created at different times. This allows breaking features to be implemented while making sure existing contracts work as expected. Note that this specification might not apply to all hard forks. We have emergency hard forks in the past due to network attacks. Whether they should maintain existing account compatibility should be evaluated in individual basis. If the attack can only be executed once against some particular contracts, then the scheme defined here might still be applicable. Otherwise, having a plain emergency hard fork might still be

RATIONALE:
This introduces account versioning via a new RLP item in account state. The design above gets account versioning by making the contract *family* always have the same version. In this way, versions are only needed to be provided by contract creation transaction, and there is no restrictions on formats of code for any version. If we want to support multiple newest VMs (for example, EVM and WebAssembly running together), then this will requires extensions such as 44-VERTXN and 45-VEROP. Alternatively, account versioning can also be done through: * **[26-VER](https://corepaper.org/ethereum/compatibility/versioning/#prefix-based-account-versioning)** and **[40-UNUSED](https://corepaper.org/ethereum/compatibility/forward/)**: This makes an account's versioning solely dependent


=== EIP-7251 ===
TITLE: Increase the MAX_EFFECTIVE_BALANCE
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-06-28
REQUIRES: 7, 0, 0, 2, ,,  , 7, 6, 8, 5

SUMMARY:
Increases the constant `MAX_EFFECTIVE_BALANCE`, while keeping the minimum staking balance `32 ETH`. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.

SPECIFICATION:
### Constants #### Execution layer | Name | Value | Comment | | - | - | - | | `CONSOLIDATION_REQUEST_TYPE` | `0x02` | The [EIP-7685](./eip-7685.md) type prefix for consolidation request | | `CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS` | `0x0000BBdDc7CE488642fb579F8B00f3a590007251` | Where to call and store relevant details about consolidation request mechanism | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | Address used to invoke system operation on contract | | `EXCESS_CONSOLIDATION_REQUESTS_STORAGE_SLOT` | `0` | | | `CONSOLIDATION_REQUEST_COUNT_STORAGE_SLOT` | `1` | | | `CONSOLIDATION_REQUEST_QUEUE_HEAD_STORAGE_SLOT` | `2` | Pointer to the head of the consolidation request message queue | | `CONSOLIDATION_REQUEST_QUEUE_TAIL_STORAGE_SLOT` | `3` | Pointer to

MOTIVATION:
As of October 3, 2023, there are currently over 830,000 validators participating in the consensus layer. The size of this set continues to grow due, in part, to the `MAX_EFFECTIVE_BALANCE`, which limits the stake of a single validator to `32 ETH`. This leads to large amounts of "redundant validators", which are controlled by a single entity, possibly running on the same beacon node, but with distinct BLS signing keys. The limit on the `MAX_EFFECTIVE_BALANCE` is technical debt from the original sharding design, in which subcommittees (not the attesting committee but the committee calculated in `is_aggregator`) needed to be

RATIONALE:
This EIP aims to reduce the total number of validators without changing anything about the economic security of the protocol. It provides a mechanism by which large node operators who control significant amounts of stake can consolidate into fewer validators. We analyze the reasoning behind each of the core features. ### Increasing the `MAX_EFFECTIVE_BALANCE`, while creating a `MIN_ACTIVATION_BALANCE` While increasing the `MAX_EFFECTIVE_BALANCE` to allow larger-stake validators, it is important to keep the lower bound of `32 ETH` (by introducing a new constant – `MIN_ACTIVATION_BALANCE`) to encourage solo-staking. ### Allowing for multiple validator indices to be combined through the


=== EIP-7549 ===
TITLE: Move committee index outside Attestation
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-11-01
REQUIRES: 

SUMMARY:
Move the committee's `index` field outside of the signed Attestation message to allow aggregation of equal consensus votes.

SPECIFICATION:
### Execution layer This requires no changes to the Execution Layer. ### Consensus layer - Set `index` field from `AttestationData` to a fixed value of zero - Move committee indexing data to the outer `Attestation` container with `committee_bits` - Increase the capacity of `aggregation_bits` to all committees in a slot The full specification of the proposed change can be found in [`/specs/electra/beacon-chain.md`](https://github.com/ethereum/consensus-specs/blob/2c1f677187e6534aec77057a7d1cc746a40d3630/specs/electra/beacon-chain.md).

MOTIVATION:
This proposal aims to make Casper FFG clients more efficient by reducing the average number of pairings needed to verify consensus rules. While all types of clients can benefit from this EIP, ZK circuits proving Casper FFG consensus will likely have the most impact. On a beacon chain network with at least 262144 active indices, it's necessary to verify a minimum of `ceil(32*64 * 2/3) = 1366` attestations to reach a 2/3 threshold. Participants cast two votes at once: LMD GHOST vote and Casper-FFG vote. However, the Attestation message contains three elements: 1. LMD GHOST vote `(beacon_block_root, slot)`.

RATIONALE:
### Deprecation strategy The `index` field in `AttestationData` can be deprecated by: 1. Removing the field 2. Preserving the field and setting it to zero 3. Changing the field type to Optional (from EIP-7495 StableContainer) This EIP chooses the second option to not complicate the inclusion of `AttesterSlashing` objects. While the `Attestation` container changes, `AttesterSlashing` includes indexed attestations without committee data. ### `MAX_ATTESTATIONS` value The maximum size of an attestation increases, with a bitfield 64 times larger on networks with maxed committees. `MAX_ATTESTATIONS` value is reduced to limit the beacon block size while still increasing the total capacity


=== EIP-2159 ===
TITLE: Common Prometheus Metrics Names for Clients
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-07-01
REQUIRES: 

SUMMARY:
Many Ethereum clients expose a range of metrics in a format compatible with Prometheus to allow operators to monitor the client's behaviour and performance and raise alerts if the chain isn't progressing or there are other indications of errors. While the majority of these metrics are highly client-specific, reporting on internal implementation details of the client, some are applicable to all clients. By standardizing the naming and format of these common metrics, operators are able to monitor the operation of multiple clients in a single dashboard or alerting configuration.

SPECIFICATION:
The table below defines metrics which may be captured by Ethereum clients which expose metrics to Prometheus. Clients may expose additional metrics however these should not use the `ethereum_` prefix. | Name | Metric type | Definition | JSON-RPC Equivalent | |----------------------------------|-------------|-------------------------------------------------------------------|---------------------------------------------------------------------| | ethereum_blockchain_height | Gauge | The current height of the canonical chain | `eth_blockNumber` | | ethereum_best_known_block_number | Gauge | The estimated highest block available | `highestBlock` of `eth_syncing` or `eth_blockNumber` if not syncing | | ethereum_peer_count | Gauge | The current number of peers connected | `net_peerCount` | | ethereum_peer_limit | Gauge | The maximum

MOTIVATION:
Using common names and meanings for metrics which apply to all clients allows node operators to monitor clusters of nodes using heterogeneous clients using a single dashboard and alerting configuration. Currently there are no agreed names or meanings, leaving client developers to invent their own making it difficult to monitor a heterogeneous cluster.

RATIONALE:
The defined metrics are independent of Ethereum client implementation but provide sufficient information to create an overview dashboard to support monitoring a group of Ethereum nodes. There is a similar, though more prescriptive, specification for beacon chain client metrics. The specific details of how to expose the metrics has been omitted as there is variance in existing implementations and standardising this does not provide any significant benefit.


=== EIP-2539 ===
TITLE: BLS12-377 curve operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-26
REQUIRES: 1, 1, 0, 9, ,,  , 2, 0, 4, 6

SUMMARY:
This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary to *efficiently* perform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and allow e.g. constant-size BLS signature aggregation. If `block.number >= X` we introduce *nine* separate precompiles to perform the following operations: - BLS12_377_G1ADD - to perform point addition on a curve defined over prime field - BLS12_377_G1MUL - to perform point multiplication on a curve defined over prime field -

SPECIFICATION:
Curve parameters: BLS12-377 curve is fully defined by the following set of parameters (coefficient `A=0` for all BLS12 curves): ``` Base field modulus = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001 B coefficient = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 Main subgroup order = 0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001 Extension tower: Fp2 construction: Fp quadratic non-residue = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508bffffffffffc Fp6/Fp12 construction: Fp2 cubic non-residue c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 Fp2 cubic non-residue c1 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 Twist parameters: Twist type: D B coefficient for twist c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 B coefficient for twist c1 = 0x010222f6db0fd6f343bd03737460c589dc7b4f91cd5fd889129207b63c6bf8000dd39e5c1ccccccd1c9ed9999999999a Generators: G1: X = 0x008848defe740a67c8fc6225bf87ff5485951e2caa9d41bb188282c8bd37cb5cd5481512ffcd394eeab9b16eb21be9ef Y = 0x01914a69c5102eff1f674f5d30afeec4bd7fb348ca3e52d96d182ad44fb82305c2fe3d3634a9591afd82de55559c8ea6 G2: X c0 = 0x018480be71c785fec89630a2a3841d01c565f071203e50317ea501f557db6b9b71889f52bb53540274e3e48f7c005196 X c1 = 0x00ea6040e700403170dc5a51b1b140d5532777ee6651cecbe7223ece0799c9de5cf89984bff76fe6b26bfefa6ea16afe Y c0 = 0x00690d665d446f7bd960736bcbb2efb4de03ed7274b49a58e458c282f832d204f2cf88886d8c7c2ef094094409fd4ddf Y

MOTIVATION:
Motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security. In addition it allows efficient one-time recursive proof aggregations, e.g. proofs about existence of BLS12-377 based signature.

RATIONALE:
Motivation section covers a total motivation to have operations over BLS12-377 curve available. We also extend a rationale for move specific fine points. ### Multiexponentiation as a separate call Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger algorithm) and (usually forgotten) by the fact that `CALL` operation in Ethereum is expensive (at the time of writing), so one would have to pay non-negigible overhead if e.g. for multiexponentiation of `100` points would have to call the multipication precompile `100` times and addition for `99` times (roughly


=== EIP-196 ===
TITLE: Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-02
REQUIRES: 

SUMMARY:
This EIP suggests to add precompiled contracts for addition and scalar multiplication on a specific pairing-friendly elliptic curve. This can in turn be combined with [EIP-197](./eip-197.md) to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).

SPECIFICATION:
If `block.number >= BYZANTIUM_FORK_BLKNUM`, add precompiled contracts for point addition (ADD) and scalar multiplication (MUL) on the elliptic curve "alt_bn128". Address of ADD: 0x6 Address for MUL: 0x7 The curve is defined by: ``` Y^2 = X^3 + 3 over the field F_p with p = 21888242871839275222246405745257275088696311157297823662689037894645226208583 ``` ### Encoding Field elements and scalars are encoded as 32 byte big-endian numbers. Curve points are encoded as two field elements `(x, y)`, where the point at infinity is encoded as `(0, 0)`. Tuples of objects are encoded as their concatenation. For both precompiled contracts, if the input is shorter

MOTIVATION:
Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive to fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced. Note that while fixing

RATIONALE:
The specific curve `alt_bn128` was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts. The feature of adding curve and field parameters to the inputs was considered but ultimately rejected since it complicates the specification: The gas costs are much harder to determine and it would be possible to call the contracts on something which is not an actual elliptic curve. A non-compact point encoding was chosen since it


=== EIP-2681 ===
TITLE: Limit account nonce to 2^64-1
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-04-25
REQUIRES: 

SUMMARY:
Limit account nonce to be between `0` and `2^64-1`.

SPECIFICATION:
Introduce two new restrictions retroactively from genesis: 1. Consider any transaction invalid, where the nonce exceeds or equals to `2^64-1`. 2. The `CREATE` and `CREATE2` instructions' execution ends with the result `0` pushed on stack, where the account nonce is `2^64-1`. Gas for initcode execution is not deducted in this case.

MOTIVATION:
Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way. Additionally it could prove beneficial to transaction formats, where some improvements are potentially sought by at least three other proposals. Lastly, this facilitates a minor optimisation in clients, because the nonce no longer needs to be kept as a 256-bit number.

RATIONALE:
1. It is unlikely for any nonce to reach or exceed the proposed limit. If one would want to reach that limit via external transactions, it would cost at least `21000 * (2^64-1) = 387_381_625_547_900_583_915_000` gas. 2. It must be noted that in the past, in the Morden testnet, each new account had a starting nonce of `2^20` in order to differentiate transactions from mainnet transactions. This mode of replay protection is out of fashion since [EIP-155](./eip-155.md) introduced a more elegant way using chain identifiers. 3. Most clients already consider the nonce field to be 64-bit, such as


=== EIP-7799 ===
TITLE: System logs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-29
REQUIRES: 1, 5, 5, 9, ,,  , 4, 8, 9, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 7, 0, 8, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### System logs list A new list is introduced to track all block level logs emitted from system interactions. The definition uses the `Log` SSZ type from [EIP-6466](./eip-6466.md). ```python system_logs = ProgressiveList[Log]( log_0, log_1, log_2, ...) ``` ### Priority fee processing [EIP-1559](./eip-1559.md) priority fees SHALL no longer be credited after each individual transaction. Instead, they SHALL be summed up and credited after all transactions

MOTIVATION:
With [EIP-7708](./eip-7708.md) wallets gain the ability to use eth_getLogs to track changes to their ETH balance. However, the ETH balance may change without an explicit transaction, through block production and withdrawals. By having such operations emit block-level system logs, eth_getLogs provides a complete picture of ETH balance changes.

RATIONALE:
Together with [EIP-7708](./eip-7708.md) this EIP provides the ability for wallets to compute the exact ETH balance from logs without requiring download of every single block header and all withdrawals. The block reward from priority fees no longer has to be summed up by processing all receipts and can be obtained from the system logs root, making it efficiently provable. Batched crediting of priority fees improves parallel execution of transactions, as a transaction can no longer start with insufficient fees and only become eligible for execution after incremental priority fees have been credited. ### Alternatives / Future - Instead


=== EIP-7708 ===
TITLE: ETH transfers emit a log
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-17
REQUIRES: 

SUMMARY:
All ETH-transfers, including transactions, `CALL` and `SELFDESTRUCT` emit a log.

SPECIFICATION:
### Parameters * `MAGIC`: `TBD` ### Functionality Whenever (i) a nonzero-value `CALL`, (ii) a nonzero-value-transferring `SELFDESTRUCT`, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i) `MAGIC`, (ii) the sender address, (iii) the recipient address. The log data is a big-endian 32-byte encoding of the transfer value. The `LOG` of a value-transferring transaction should be placed before any logs created by EVM execution. The other two `LOG`s are placed at the time that the value transfer executes.

MOTIVATION:
Logs are often used to track when balance changes of assets on Ethereum. Logs work for [ERC-20](./eip-20.md) tokens, but they do not work for ETH. ETH transfers from EOAs can be read from the transaction list in the block, but ETH transfers from smart contract wallets are not automatically logged anywhere. This has already led to problems in the past, eg. early exchanges would often not properly support deposits from smart contract wallets, or only support them with a much longer delay. This EIP proposes that we automatically generate a log every time a value-transferring `CALL` or `SELFDESTRUCT`

RATIONALE:
This is the simplest possible implementation that ensures that all ETH transfers are implemented in some kind of record that can be easily accessed through making RPC calls into a node, or through asking for a Merkle branch that is hashed into the block root. The log type is compatible with the ERC-20 token standard, but does not introduce any overly-specific ERC-20 features (eg. ABI encodings) into the specification. ### Open questions 1. Should withdrawals also trigger a log? If so, what should the sender address be specified as? 2. Should fee payments trigger a log? It would


=== EIP-7805 ===
TITLE: Fork-choice enforced Inclusion Lists (FOCIL)
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-01
REQUIRES: 

SUMMARY:
FOCIL implements a robust mechanism to preserve Ethereum’s censorship resistance properties by guaranteeing timely transaction inclusion. FOCIL (**Fo**rk-**c**hoice enforced **I**nclusion **L**ists) is built in a few simple steps: - In each slot, a set of validators is selected as inclusion list (IL) committee members. Each member builds and gossips one IL according to their subjective view of the mempool. - The proposer and all attesters of the next slot monitor, store and forward available ILs. - The proposer (or the builder if the block is not built locally by the proposer) includes transactions from all collected ILs in

SPECIFICATION:
### Execution Layer On the execution layer, an additional check is introduced for new payloads. After all of the transactions in the payload have been executed, we check whether any transaction from ILs, that is not already present in the payload, could be validly included (i.e. nonce and balance checks pass). If that is the case for any transaction, then an error is returned to the CL. Although the block is valid, the CL will not attest to it. Let `B` denote the current block. Let `S` denote the execution state following the execution of the last transaction

MOTIVATION:
In an effort to shield the Ethereum validator set from centralizing forces, the right to build blocks has been auctioned off to specialized entities known as *builders*. This has led to a few sophisticated builders dominating block production, leading to a deterioration of the network’s censorship resistance properties. To address this issue, research has focused on improving Ethereum's transaction inclusion guarantees by enabling validators to impose constraints on builders. This is achieved by force-including transactions in blocks via ILs. ### High-level Overview FOCIL is a committee-based, fork-choice enforced inclusion list (IL) design that improves upon previous IL mechanisms

RATIONALE:
### Core Properties - Committee-based: FOCIL relies on a committee of multiple validators, rather than a single proposer, to construct and broadcast ILs. This approach significantly reduces the surface for bribery and extortion attacks and strengthens censorship resistance. - Fork-choice enforced: FOCIL incorporates the force-inclusion mechanism into the fork-choice rule, an integral component of the consensus process, thereby preventing any actor from bypassing the system. Attesters vote only for blocks that include transactions from a set of ILs provided by the IL committee and that satisfy the IL constraints. Any block failing to meet these criteria will not


=== EIP-1276 ===
TITLE: Eliminate Difficulty Bomb and Adjust Block Reward on Constantinople Shift
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-31
REQUIRES: 

SUMMARY:
Starting with `CNSTNTNPL_FORK_BLKNUM` the client will calculate the difficulty without considering the current block number. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Remove Exponential Component of Difficulty Adjustment For the purposes of `calc_difficulty`, simply remove the exponential difficulty adjustment component, `epsilon`, i.e. the `int(2**((block.number // 100000) - 2))`. #### Adjust Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward = 2_000_000_000_000_000_000 if block.number >= CNSTNTNPL_FORK_BLKNUM else block.reward (2E18 wei, or 2,000,000,000,000,000,000 wei, or 2 ETH). Analogue, if an uncle is included in a block for `block.number >= CNSTNTNPL_FORK_BLKNUM` such that `block.number - uncle.number = k`, the uncle reward is new_uncle_reward = (8 - k) * new_block_reward / 8 This

MOTIVATION:
Block time has been played a most important role on blockchain ecosystem, and it is being adjusted by the logic of mining difficulty calculation that is already implemented on the node client as a part of proof-of-work consensus. Last year, average block time rapidly increased due to the wrong design of difficulty logic that is meant to be changed on the part of Casper upgrade, however, implementation of casper has been delayed therefore it was inevitable to delay the difficulty bomb in order to prevent the significant delay of processing transactions on ethereum network. Despite of the successful

RATIONALE:
This will completely remove the difficulty bomb on difficulty adjustment algorithm without delaying the difficulty bomb again, therefore it is possible to prevent network delay on the beginning of 2019. This EIP-1276 opposes directly the intent of [EIP-1234](./eip-1234.md) which should be also considered in discussions.


=== EIP-5478 ===
TITLE: CREATE2COPY Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-08-17
REQUIRES: 1, 0, 1, 4, ,,  , 2, 9, 2, 9

SUMMARY:
Adding a new opcode, `CREATE2COPY`, that is identical to `CREATE2` but with potentially much lower gas cost by accepting an additional argument `existing_contract_address` that already stored the code of the new contract.

SPECIFICATION:
### Parameters | Constant | Value | | ---------------------------- | ---------------- | | `FORK_BLKNUM` | TBD | | `CREATE_DATA_GAS_PER_BYTE` | 200 | | `COLD_ACCOUNT_ACCESS_COST` | 2600 | | `WARM_ACCOUNT_ACCESS_COST` | 100 | If `block.number >= FORK_BLKNUM`, a new opcode is added (`CREATE2COPY`) at `0xf6`, which takes 5 stack arguments: `endowment`, `memory_start`, `memory_length`, `salt`, `existing_contract_address`. `CREATE2COPY` behaves identically to `CREATE2` (`0xf5` as defined in [EIP-1014](./eip-1014.md)), except that the code hash of the creating contract MUST be the same as that of `existing_contract_address`. `CREATE2COPY` has the same `gas` schema as `CREATE2`, but replacing the data gas from `CREATE_DATA_GAS_PER_BYTE * CONTRACT_BYTES`

MOTIVATION:
This EIP aims to reduce the smart contract creation cost of account abstraction (AA) contracts that have identical code. The major cost of creating an AA contract is the contract creation cost, especially data gas. For example, creating an AA contract with 10,000 bytes will consume 2,000,000 data gas. Considering the code for each user's AA contract is the same, `CREATE2COPY` can reduce the data gas cost to 2600 (cold account) or even 100 (warm account) if the contract code already exists in the local storage.

RATIONALE:
TBD


=== EIP-6493 ===
TITLE: SSZ transaction signature scheme
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-24
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 6

SUMMARY:
This EIP defines a signature scheme for native [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md) encoded transactions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Transaction signature scheme Native SSZ transactions are based on the `TransactionPayload` and `Transaction` types defined in [EIP-6404](./eip-6404.md) and emit an [EIP-6466](./eip-6466.md) `Receipt`. To distinguish native SSZ transactions from those converted from RLP, native SSZ transactions do not set an RLP `TransactionType` in their `TransactionPayload`. All native SSZ transactions follow an identical scheme based on [`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md#merkleization) to compute their signing hash (`sig_hash`) and unique

MOTIVATION:
[EIP-6404](./eip-6404.md) introduces SSZ transactions by converting from RLP transactions. Defining a signature scheme for native SSZ transactions further reduces required conversions and unlocks the forward compatibility benefits of SSZ [`StableContainer`](./eip-7495.md).

RATIONALE:
The SSZ signature scheme reduces hashing overhead and ensures that `tx_hash` commitments are available on-chain. It also provides a flexible basis for future transaction functionality.


=== EIP-210 ===
TITLE: Blockhash refactoring
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-02-10
REQUIRES: 

SPECIFICATION:
If `block.number == CONSTANTINOPLE_FORK_BLKNUM`, then when processing the block, before processing any transactions set the code of BLOCKHASH_CONTRACT_ADDR to BLOCKHASH_CONTRACT_CODE. If `block.number >= CONSTANTINOPLE_FORK_BLKNUM`, then when processing a block, before processing any transactions execute a call with the parameters: * `SENDER`: SUPER_USER * `GAS`: 1000000 * `TO`: BLOCKHASH_CONTRACT_ADDR * `VALUE`: 0 * `DATA`: &lt;32 bytes corresponding to the block's prevhash&gt; If `block.number >= CONSTANTINOPLE_FORK_BLKNUM + 256`, then the BLOCKHASH opcode instead returns the result of executing a call (NOT a transaction) with the parameters: * `SENDER`: &lt;account from which the opcode was called&gt; * `GAS`: 1000000 * `TO`:

RATIONALE:
This removes the need for implementations to have an explicit way to look into historical block hashes, simplifying the protocol definition and removing a large component of the "implied state" (information that is technically state but is not part of the state tree) and thereby making the protocol more "pure". Additionally, it allows blocks to directly point to blocks far behind them, which enables extremely efficient and secure light client protocols.


=== EIP-3030 ===
TITLE: BLS Remote Signer HTTP API
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-09-30
REQUIRES: 

SUMMARY:
A [validator](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/validator.md) client contributes to the consensus of the Eth2 blockchain by signing proposals and attestations of blocks, using a BLS private key which must be available to this client at all times. The BLS remote signer API is designed to be consumed by validator clients, looking for a more secure avenue to store their BLS12-381 private key(s), enabling them to run in more permissive and scalable environments.

SPECIFICATION:
### `GET /upcheck` _**Responses**_ Success | <br> --- | --- Code | `200` Content | `{"status": "OK"}` --- ### `GET /keys` Returns the identifiers of the keys available to the signer. _**Responses**_ Success | <br> --- | --- Code | `200` Content | `{"keys": "[identifier]"}` --- ### `POST /sign/:identifier` URL Parameter | <br> --- | --- `:identifier` | `public_key_hex_string_without_0x` _**Request**_ JSON Body | <br> | <br> --- | --- | --- `bls_domain` | **Required** | The BLS Signature domain.<br>As defined in the [specification](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/beacon-chain.md#domain-types), in lowercase, omitting the `domain` prefix.<br>Supporting `beacon_proposer`, `beacon_attester`, and `randao`. `data` | **Required** | The

MOTIVATION:
Eth2 utilizes [BLS12-381](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/) signatures. Consensus on the eth2 Blockchain is achieved via the proposal and attestation of blocks from validator clients, using a BLS private key (_signing_ key) which must be available each time a message is signed: that is, at least once every epoch (6.4 minutes), during a small window of time within this epoch (a _slot_, i.e. 12 seconds), as each validator is expected to attest exactly once per epoch. The [eth2 specification](https://github.com/ethereum/eth2.0-specs) does not explicitly provide a directive on where this BLS private key must/should be stored, leaving this implementation detail to the client teams,

RATIONALE:
### UNIX philosophy: Simple API This API specification contains only three methods: one for **status**, one for **listing the available keys**, and one to **produce a signature**. There are no methods for authentication, key management, nor transport encryption. The following subsections discuss aspects to be considered by the client implementers relative to these subjects. #### Implementation of additional features From an API pipeline view, we have two nodes: The validator client (1) that makes requests to the remote signer (2). A more sophisticated chain can be built by introducing elements between these two nodes. Either by setting up


=== EIP-4863 ===
TITLE: Beacon chain push withdrawals
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-28
REQUIRES: 

SUMMARY:
Introduce a new [EIP-2718 transaction type](./eip-2718.md) to support validator withdrawals that are "pushed" from the beacon chain to the EVM. Add block validations to ensure the withdrawal transactions are sound with respect to withdrawal processing on the beacon chain.

SPECIFICATION:
| constants | value | units |--- |--- |--- | `FORK_TIMESTAMP` | TBD | | `WITHDRAWAL_TX_TYPE` | `0x3` | byte Beginning with the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** introduce the following extensions to transaction processing and block validation: ### New transaction type Define a new [EIP-2718](./eip-2718.md) transaction type with `TransactionType` `WITHDRAWAL_TX_TYPE`. The `TransactionPayload` is an RLP-encoded list `RLP([index, address, amount])` where the `index` is a 64-bit value uniquely labeling a specific withdrawal, the `address` refers to an execution layer account and the `amount` refers to an ether value given in units of wei. These values are provided

MOTIVATION:
This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM. The architecture is "push"-based, rather than "pull"-based, where withdrawals are required to be processed in the execution block as soon as they are dequeued from the beacon chain. This approach is more involved than "pull"-based alternatives (e.g. [EIP-4788](./eip-4788.md) + user-space withdrawal contract) with respect to the core protocol (by providing a new transaction type with special semantics) but does provide tighter integration of a critical feature into the protocol itself.

RATIONALE:
### Push vs pull approach This push approach gives validators a small subsidy with respect to processing, in lieu of needing to buy gas via normal EVM processing that would be required for a pull-based approach. This style also happens automatically when the requisite conditions are met on the beacon chain which is nicer UX for validators. ### Why a new transaction type? This EIP suggests a new transaction type as it has special semantics different from other existing types of EVM transactions. An entirely new transaction type firewalls off generic EVM execution from this type of processing


=== EIP-2803 ===
TITLE: Rich Transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-07-18
REQUIRES: 

SUMMARY:
If a transaction has a `to` of address `x`, then the `data` of the transaction will be treated as EVM bytecode and it will be executed from the context of the `CALLER` of the transaction (aka: the transaction signer).

SPECIFICATION:
A new reserved address is specified at `x`, in the range used for precompiles. When a transaction is sent to this address from an externally owned account, the payload of the transaction is treated as EVM bytecode, and executed with the signer of the transaction as the current account. For clarity: - The `ADDRESS` opcode returns the address of the EOA that signed the transaction. - The `BALANCE` opcode returns the balance of the EOA that signed the transaction. - Any `CALL` operations that send value take their value from the EOA that signed the transaction. - `CALL`

MOTIVATION:
Many Ethereum DApps presently require users to approve multiple transactions in order to produce one effect - for example, the common pattern of first approving a contract to spend a token, then calling that contract. This results in a poor user-experience, and complicates the experience of interacting with DApps. Making it possible for externally owned accounts to execute EVM bytecode directly allows a single transaction to execute multiple contract calls, allowing DApps to provide a streamlined experience, where every interaction results in at most one transaction. While this is in principle possible today using contract wallets, other UX

RATIONALE:
The intent of this EIP is for the new precompile to act in all ways possible like a `DELEGATECALL` from an externally owned account. Some changes are required to reflect the fact that the code being executed is not stored on chain, and for special cases such as `SELFDESTRUCT`, to prevent introducing new edge-cases such as the ability to zero-out an EOA's nonce. A precompile was used rather than a new EIP-2718 transaction type because a precompile allows us to have a rich transaction with any type of EIP-2718 transaction.


=== EIP-5793 ===
TITLE: eth/68 - Add tx type to tx announcement
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-10-18
REQUIRES: 2, 4, 6, 4, ,,  , 2, 4, 8, 1, ,,  , 4, 9, 3, 8

SUMMARY:
The Ethereum Wire Protocol defines request and response messages for exchanging data between clients. The `NewPooledTransactionHashes` message announces transactions available in the node. This EIP extends this announcement message such that beside the transaction hashes, the node sends the transaction types and their sizes (as defined in [EIP-2718](./eip-2718.md)) as well.

SPECIFICATION:
Modify the `NewPooledTransactionHashes (0x08)` message: * **(eth/67)**: `[hash_0: B_32, hash_1: B_32, ...]` * **(eth/68)**: `[types: B, [size_0: P, size_1: P, ...], [hash_0: B_32, hash_1: B_32, ...]]` The new `types` element refers to the transaction types of the announced hashes. Note the transaction types are packed as a 'byte array' instead of a list. The `size_0`, `size_1` etc. elements refer to the transaction sizes of the announced hashes.

MOTIVATION:
The `NewPooledTransactionHashes` message announces transaction hashes, allowing the peer to selectively fetch transactions it does not yet have. [EIP-4844](./eip-4844.md) introduces a new transaction type for blob transactions. Since these blob transactions are large, naively broadcasting them to `sqrt(peers)` could significantly increase bandwidth requirements. Adding the transaction type and the size to the announcement message will allow nodes to select which transactions they want to fetch and also allow them to load balance or throttle peers based on past behavior. The added metadata fields will also enable future - upgradeless - protocol tweaks to prevent certain transaction type (e.g.

RATIONALE:
This change will make the `eth` protocol future-proof for new transaction types that might not be relevant for all nodes. It gives the receiving node better control over the data it fetches from the peer as well as allow throttling the download of specific types. The `types` message element is a byte array because early implementations of this EIP erroneously implemented it that way. It was later decided to keep this behavior in order to minimize work.


=== EIP-4200 ===
TITLE: EOF - Static relative jumps
TYPE: Standards Track Core
STATUS: Review
CREATED: 2021-07-16
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Three new EVM jump instructions are introduced (`RJUMP`, `RJUMPI` and `RJUMPV`) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.

SPECIFICATION:
We introduce three new instructions on the same block number [EIP-3540](./eip-3540.md) is activated on: 1. `RJUMP` (0xe0) - relative jump 2. `RJUMPI` (0xe1) - conditional relative jump 3. `RJUMPV` (0xe2) - relative jump via jump table If the code is legacy bytecode, all of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*) If the code is valid EOF1: 1. `RJUMP relative_offset` sets the `PC` to `PC_post_instruction + relative_offset`. 2. `RJUMPI relative_offset` pops a value (`condition`) from the stack, and sets the `PC` to `PC_post_instruction + ((condition == 0) ? 0 : relative_offset)`.

MOTIVATION:
A recurring discussion topic is that EVM only has a mechanism for dynamic jumps. They provide a very flexible architecture with only 2 (!) instructions. This flexibility comes at a cost however: it makes analysis of code more complicated and it also (partially) resulted in the need to have the `JUMPDEST` marker. In a great many cases control flow is actually static and there is no need for any dynamic behaviour, though not every use case can be solved by static jumps. There are various ways to reduce the need for dynamic jumps, some examples: 1. With native

RATIONALE:
### Relative addressing We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code like `PUSHn PC ADD JUMPI`. We do not see any significant downside to relative addressing and it allows us to also deprecate the `PC` instruction. ### Immediate size The signed 16-bit immediate means that the largest jump distance possible is 32767. In the case the bytecode at `PC=0` starts with an `RJUMP`, it will be possible to


=== EIP-7723 ===
TITLE: Network Upgrade Inclusion Stages
TYPE: Meta 
STATUS: Last Call
CREATED: 2024-06-12
REQUIRES: 

SUMMARY:
Define the stages that EIPs go through in the process of planning network upgrades: `Proposed for Inclusion`, `Considered for Inclusion`, `Scheduled for Inclusion`, `Declined for Inclusion` and `Included`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All EIP statuses apply to a single network upgrade. EIPs must be `Proposed`, `Considered`, `Declined` or `Scheduled` separately for each network upgrade. While an EIP cannot be `Included` in two network upgrades, an EIP being `Declined for Inclusion` in a previous upgrade does not prevent it from being `Proposed`, `Considered`, `Declined` or `Scheduled` for inclusion in any future upgrade. The statuses below are generally

MOTIVATION:
This EIP proposes definitions for the various stages EIPs go through when planning network upgrades. It also provides context and guidelines around when and how EIPs should be moved from one stage to the next.

RATIONALE:
Formalizing the `Proposed for Inclusion`, `Considered for Inclusion`, `Scheduled for Inclusion`, `Declined for Inclusion` and `Included` stages provides better legibility to both protocol maintainers and the broader Ethereum community. The specification tries to minimize steps which **MUST** be followed to align with Ethereum's "rough consensus" governance model. Assuming it is adopted, the process outlined in this EIP should be used for at least one full network upgrade cycle before moving to `Last Call` and at least two full network upgrades cycles before moving to `Final`. This way, the EIP can be updated to reflect changes made to the


=== EIP-2364 ===
TITLE: eth/64: forkid-extended protocol handshake
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2019-11-08
REQUIRES: 2124

SUMMARY:
This EIP specifies the inclusion of the `forkid`, originally defined in [(EIP-2124)](./eip-2124.md), as a new field in the Ethereum wire protocol (`eth`) handshake. This change is implemented as a new version of the wire protocol, `eth/64`.

SPECIFICATION:
- Implement `forkid` generation and validation per [EIP-2124](./eip-2124.md). - Advertise a new `eth` protocol capability (version) at `eth/64`. - The old `eth/63` protocol should still be kept alive side-by-side, until `eth/64` is sufficiently adopted by implementors. - Redefine `Status (0x00)` for `eth/64` to add a trailing `forkid` field: - Old packet: `[protocolVersion, networkId, td, bestHash, genesisHash]` - New packet: `[protocolVersion, networkId, td, bestHash, genesisHash, forkid]`, where `forkid` is `[forkHash: [4]byte, forkNext: uint64]` (fields per [EIP-2124](./eip-2124.md) ). Whenever two peers connect using the `eth/64` protocol, the updated `Status` message must be sent as the protocol handshake, and each peer

MOTIVATION:
The [`forkid` (EIP-2124)](./eip-2124.md) was designed to permit two Ethereum nodes to quickly and cheaply decide if they are compatible or not, not only at a genesis/networking level, but also from the perspective of the currently passed network updates (i.e. forks). [EIP-2124](./eip-2124.md) only defines how the `forkid` is calculated and validated, but does not specify how the `forkid` should be exchanged between peers. This EIP specifies the inclusion of the `forkid` as a new field in the Ethereum wire protocol (`eth`) handshake (releasing a new version, `eth/64`). By cross-validating `forkid` during the handshake, incompatible nodes can disconnect before expensive

RATIONALE:
The specification is tiny since most parts are already specified in EIP-2124. `eth/63` is not specified as an EIP, but is maintained in the [ethereum/devp2p](https://github.com/ethereum/devp2p) Github repository. ### EIP-2124 mentions advertising the `forkid` in the discovery protocol too. How does that compare to advertising in the `eth` protocol? Why is the redundancy needed? Advertising and validating the `forkid` in the discovery protocol is a more optimal solution, as it can help avoid the cost of setting up the TCP connection and cryptographic RLPx stream, only to be torn down if `eth/64` rejects it. Compared to the `eth` protocol


=== EIP-1013 ===
TITLE: Hardfork Meta: Constantinople
TYPE: Meta 
STATUS: Final
CREATED: 2018-04-20
REQUIRES: 1, 4, 5, ,,  , 6, 0, 9, ,,  , 1, 0, 1, 4, ,,  , 1, 0, 5, 2, ,,  , 1, 2, 3, 4, ,,  , 1, 2, 8, 3

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Constantinople.

SPECIFICATION:
- Codename: Constantinople - Aliases: Metropolis/Constantinople, Metropolis part 2 - Activation: - `Block >= 7_280_000` on the Ethereum Mainnet - `Block >= 4,230,000` on the Ropsten testnet - `Block >= 9_200_000` on the Kovan testnet - `Block >= 3_660_663` on the Rinkeby testnet - Included EIPs: - [EIP-145](./eip-145.md): Bitwise shifting instructions in EVM - [EIP-1014](./eip-1014.md): Skinny CREATE2 - [EIP-1052](./eip-1052.md): EXTCODEHASH Opcode - [EIP-1234](./eip-1234.md): Delay difficulty bomb, adjust block reward - [EIP-1283](./eip-1283.md): Net gas metering for SSTORE without dirty maps


=== EIP-1767 ===
TITLE: GraphQL interface to Ethereum node data
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-02-14
REQUIRES: 

SUMMARY:
This EIP specifies a GraphQL schema for accessing data stored on an Ethereum node. It aims to provide a complete replacement to the read-only information exposed via the present JSON-RPC interface, while improving on usability, consistency, efficiency, and future-proofing.

SPECIFICATION:
### Node API Compatible nodes MUST provide a GraphQL endpoint available over HTTP. This SHOULD be offered on port 8547 by default. The path to the GraphQL endpoint SHOULD be '/graphql'. Compatible nodes MAY offer a GraphiQL interactive query explorer on the root path ('/'). ### Schema The GraphQL schema for this service is defined as follows: ``` # Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal. scalar Bytes32 # Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal. scalar Address # Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.

MOTIVATION:
The current JSON-RPC interface for Ethereum nodes has a number of shortcomings. It's informally and incompletely specified in areas, which has led to incompatibilities around issues such as representation of empty byte strings ("" vs "0x" vs "0x0"), and it has to make educated guesses about the data a user will request, which often leads to unnecessary work. For example, the `totalDifficulty` field is stored separately from the block header in common Ethereum node implementations, and many callers do not require this field. However, every call to `eth_getBlock` still retrieves this field, requiring a separate disk read, because

RATIONALE:
Ethereum nodes have been moving away from providing read-write functionality such as transaction and message signing, and from other services such as code compilation, in favor of a more 'unix-like' approach where each task is performed by a dedicated process. We have thus specified a core set of types and fields that reflects this trend, leaving out functionality that is presently, or intended to be, deprecated: - `eth_compile*` calls are deprecated, and hence not provided here. - `eth_accounts`, `eth_sign`, and `eth_sendTransaction` are considered by many to be deprecated, and are not provided here; callers should use local accounts


=== EIP-867 ===
TITLE: Standardized Ethereum Recovery Proposals
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-02-02
REQUIRES: 

SUMMARY:
This proposal identifies a common solution method that can be used to address certain classes of lost funds on the Ethereum blockchain. In particular, it is intended to address cases where there is no disagreement about the right outcome between directly affected parties, enabling timely and low-risk solutions to many issues that have already occurred or are likely to occur again as Ethereum grows. The solution method is divided into three parts: 1. Standards that will need to be met by any follow-on ERP in order to be considered for approval. 2. Recommendations for a common format for

SPECIFICATION:
This EIP describes a common format to be used for a subclass of EIPs, referred to as ethereum recovery proposals (ERPs), that propose an irregular state change required to address a fund recovery scenario that cannot be addressed using the standard protocol. Each ERP will reference this EIP will follow the guidelines set out here. The purpose of each ERP is (a) to clearly describe the issue to be corrected, (b) to describe why an irregular state change is both necessary and justified, and (c) to demonstrate that the proposed actions will achieve the ERP's objectives. Each ERP

MOTIVATION:
The issue of fund recovery on the Ethereum blockchain is often controversial. Frozen fund recovery proposals are almost never successful due to the relatively ad-hoc nature of such requests and the subjectivity that is often required to evaluate the merits. This EIP attempts to remove these barriers by providing both a standardized format for fund recovery EIPs and an objective standard by which to measure future proposals.

RATIONALE:
The primary consideration for the approach described above was to minimize the amount of risk associated with recovery actions that would otherwise not have a viable solution. A secondary consideration was to standardize the format used in the proposals for recovery actions. First, including a verification script guarantees that the way in which the recovery actions were determined is unambiguous. This does not mean that the recovery actions are necessarily correct, only that the logic used to determine them is fully specified and auditable. Second, requiring that the output of the verification script is directly interpretable by client


=== EIP-2844 ===
TITLE: Add DID related methods to the JSON-RPC
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-08-01
REQUIRES: 

SUMMARY:
This EIP describes three new methods to add to the JSON-RPC that enables wallets to support *Decentralized Identifiers* (DIDs) as well as *JSON Object Signing and Encryption* (JOSE). These standards enables wallets to support data decryption as well as authenticated data, both in standard formats using JOSE. With these new methods apps can request the DID from a users wallet, from which a DID document can be resolved. The DID document contains public keys that can be used for encryption and signature verification. This enables Alice to discover Bobs public keys by only knowing Bobs DID. This EIP

SPECIFICATION:
Three new JSON-RPC methods are specified under the new `did_*` prefix. ### Auth Authenticate the current rpc connection to the DID methods. Prompt the user to give permission to the current connection to access the user DID and the given `paths`. ##### Method: `did_authenticate` ##### Params: * `nonce` - a random string used as a challenge * `aud` - the intended audience of the authentication response * `paths` - an array of strings ##### Returns: A JWS with general serialization containing the following properties: * `nonce ` - the random string which was given as a challenge *

MOTIVATION:
There has been one main previous effort ([#130](https://github.com/ethereum/EIPs/issues/130), [#1098](https://github.com/ethereum/EIPs/pull/1098)) to add decryption to Ethereum wallets in a standard way. This previous approach used a non standard way to encode and represent data encrypted using `x25519-xsalsa20-poly1305`. While this approach does provide a functional way to add encryption support to wallets, it does not take into account similar work that has gone into standardizing the way encrypted data is represented, namely using [JOSE](https://datatracker.ietf.org/wg/jose/documents/). This is a standard from IETF for representing signed and encrypted objects. Another shortcoming of the previous approach is that it's impossible to retrieve the `x25519` public

RATIONALE:
This EIP chooses to rely on DIDs and JOSE since there is already support for these standards in many places, by current systems and new systems. By using DIDs and JOSE wallet implementers can also choose which signing and encryption algorithms that they want to support, since these formats are fairly agnostic to specific crypto implementations. ### Permission system A simple permission system is proposed where clients can request permissions though path prefixes, e.g. `/some/permission`. When decryption of a JWE is requested the wallet should check if the decrypted payload contains a `paths` property. If this property doesn't


=== EIP-5757 ===
TITLE: Process for Approving External Resources
TYPE: Meta 
STATUS: Final
CREATED: 2022-09-30
REQUIRES: 1

SUMMARY:
Ethereum improvement proposals (EIPs) occasionally link to resources external to this repository. This document sets out the requirements for origins that may be linked to, and the process for approving a new origin.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Definitions - **Link**: Any method of referring to a resource, including: markdown links, anchor tags (`<a>`), images, citations of books/journals, and any other method of referencing content not in the current resource. - **Resource**: A web page, document, article, file, book, or other media that contains content. - **Origin**: A publisher/chronicler of resources, like a standards body (eg. w3c) or a system of referring to documents (eg. Digital

RATIONALE:
### Unique Identifiers If it is impossible to uniquely identify a version of a resource, it becomes impractical to track changes, which makes it difficult to ensure immutability. ### Availability If it is possible to implement a standard without a linked resource, then the linked resource is unnecessary. If it is impossible to implement a standard without a linked resource, then that resource must be available for implementers. ### Free Access The Ethereum ecosystem is built on openness and free access, and the EIP process should follow those principles.


=== EIP-7701 ===
TITLE: Native Account Abstraction
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-01
REQUIRES: 

SUMMARY:
We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction. We further separate transaction validation for the purposes of authorization and the gas fee payment, allowing one contract to pay gas for a transaction that will be executed from another contract.

SPECIFICATION:
### Constants | Name | Value | |-----------------------------|-------------------| | `AA_TX_TYPE` | TBD | | `AA_ENTRY_POINT` | `address(0x7701)` | | `AA_BASE_GAS_COST` | 15000 | | `ROLE_SENDER_DEPLOYMENT` | `0xA0` | | `ROLE_SENDER_VALIDATION` | `0xA1` | | `ROLE_PAYMASTER_VALIDATION` | `0xA2` | | `ROLE_SENDER_EXECUTION` | `0xA3` | | `ROLE_PAYMASTER_POST_OP` | `0xA4` | ### New Transaction Type A new [EIP-2718](./eip-2718) transaction with type `AA_TX_TYPE` is introduced. Transactions of this type are referred to as "AA transactions". Their payload should be interpreted as: ``` AA_TX_TYPE || rlp([ chain_id, nonce, sender, sender_validation_data, deployer, deployer_data, paymaster, paymaster_data, sender_execution_data, max_priority_fee_per_gas, max_fee_per_gas, sender_validation_gas, paymaster_validation_gas, sender_execution_gas, paymaster_post_op_gas, access_list, authorization_list

MOTIVATION:
Native Account Abstraction allows custom validation logic of a transaction and custom gas payment logic, opening new use-cases and features for wallets and dApps. A more detailed motivation for this proposal can be found in the [README document](../assets/eip-7701/README.md).

RATIONALE:
A full list of rationales for the decisions made in this proposal can be found in the [README document](../assets/eip-7701/README.md).


=== EIP-868 ===
TITLE: Node Discovery v4 ENR Extension
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2018-02-02
REQUIRES: 8, ,,  , 7, 7, 8


=== EIP-1716 ===
TITLE: Hardfork Meta: Petersburg
TYPE: Meta 
STATUS: Final
CREATED: 2019-01-21
REQUIRES: 1, 0, 1, 3, ,,  , 1, 2, 8, 3

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork that removes [EIP-1283](./eip-1283.md) from [Constantinople](./eip-1013.md).

SPECIFICATION:
- Codename: Petersburg - Aliases: St. Petersfork, Peter's Fork, Constantinople Fix - Activation: - `Block >= 7_280_000` on the Ethereum Mainnet - `Block >= 4_939_394` on the Ropsten testnet - `Block >= 10_255_201` on the Kovan testnet - `Block >= 4_321_234` on the Rinkeby testnet - `Block >= 0` on the Görli testnet - Removed EIPs: - [EIP-1283](./eip-1283.md): Net gas metering for SSTORE without dirty maps If `Petersburg` and `Constantinople` are applied at the same block, `Petersburg` takes precedence: with the net effect of EIP-1283 being _disabled_. If `Petersburg` is defined with an earlier block number than `Constantinople`,


=== EIP-1418 ===
TITLE: Blockchain Storage Rent Payment
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-09-16
REQUIRES: 1559

SUMMARY:
At each block, deduct an amount of value ("rent") from every account based on the quantity of storage used by that account.

SPECIFICATION:
**Updated transaction type** A new transaction type is introduced. Whereas [EIP-1559](./eip-1559.md) introduced warm access for contract state, this new type introduces warm access for contract code. **New state variables (per account)** * **σ[a]_rent** -- an amount of value, in Wei, this is a signed value * **σ[a]_storageWords** -- number of words in storage **New constants** * **`RENT_WORD_COST`** -- The rent cost, in Wei, paid for each word-block * **`RENT_ACCOUNT_COST`** -- The rent cost, in Wei, paid for each account-block * **`FORK_BLOCK`** – When implementation starts **New opcodes** * **`RENTBALANCE(address)`** -- G_BALANCE -- Similar to `BALANCE` * This returns

MOTIVATION:
Ethereum is a public utility and we are underpricing the long-term costs of storage. Storage cost can be approximately modeled as bytes × time.


=== EIP-5065 ===
TITLE: Instruction for transferring ether
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-30
REQUIRES: 2929

SUMMARY:
Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to how `SELFDESTRUCT (0xFF)` transfers ether to the destination without making a call to it.

SPECIFICATION:
Introduce a new instruction, `AIRDROP` (`0xFG`) that transfers ether to the destination without making a call to it. ### Stack input address: the account to send ether to. value: value in wei to send to the account. ### Gas The total gas cost should be the sum of a static cost + address_access_cost + value_to_empty_account_cost. - Static cost: 6700 - Dynamic cost: 1. address_access_cost: If the target is not in `accessed_addresses`, charge `COLD_ACCOUNT_ACCESS_COST` gas, and add the address to `accessed_addresses`. Otherwise, charge `WARM_STORAGE_READ_COST` gas. Currently, `COLD_ACCOUNT_ACCESS_COST` is 2600 while `WARM_STORAGE_READ_COST` is 100. 2. value_to_empty_account_cost: If value is not

MOTIVATION:
From an architectural point of view, execution flow should never be handed over to an untrusted contract. Ethereum currently does not have any ideal way to transfer ether without transferring the flow of execution. People have come up with reentrancy guards and similar solutions to prevent some types of attacks but it's not an ideal solution. The only way to transfer ether from smart contracts without triggering a call is to create a dummy contract, send the precise amount of ether to it and then call `SELFDESTRUCT (0xFF)` from it.

RATIONALE:
This behavior is already possible by deploying a new contract that does `SELFDESTRUCT (0xFF)` but it is prohibitively expensive. In most scenarios, the contract author only wants to transfer ether rather than transferring control of the execution. ERC20 can be used as a case study for this where most users transfer funds without a post-transfer hook. This instruction allows contracts to safely pass ether to an untrusted address without worrying about reentrancy or other malicious things an untrusted contract can do on. The static gas cost is derived by subtracting the gas stipend (2300) from the positive_value_cost of


=== EIP-7002 ===
TITLE: Execution layer triggerable withdrawals
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-09
REQUIRES: 7685

SUMMARY:
Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials. These new execution layer exit messages are appended to the execution layer block and then processed by the consensus layer.

SPECIFICATION:
### Configuration | Name | Value | Comment | | - | - | - | | `WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS` | `0x00000961Ef480Eb55e80D19ad83579A64c007002` | Where to call and store relevant details about exit / partial withdrawal mechanism | | `WITHDRAWAL_REQUEST_TYPE` | `0x01` | The [EIP-7685](./eip-7685.md) type prefix for withdrawal request | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | Address used to invoke system operation on contract | `EXCESS_WITHDRAWAL_REQUESTS_STORAGE_SLOT` | 0 | | | `WITHDRAWAL_REQUEST_COUNT_STORAGE_SLOT` | 1 | | | `WITHDRAWAL_REQUEST_QUEUE_HEAD_STORAGE_SLOT` | 2 | Pointer to head of the withdrawal request message queue | | `WITHDRAWAL_REQUEST_QUEUE_TAIL_STORAGE_SLOT` | 3 | Pointer to the tail of

MOTIVATION:
Validators have two keys -- an active key and a withdrawal credential. The active key takes the form of a BLS key, whereas the withdrawal credential can either be a BLS key (0x00) or an execution layer address (0x01). The active key is "hot", actively signing and performing validator duties, whereas the withdrawal credential can remain "cold", only performing limited operations in relation to withdrawing and ownership of the staked ETH. Due to this security relationship, the withdrawal credential ultimately is the key that owns the staked ETH and any rewards. As currently specified, only the active key

RATIONALE:
### `validator_pubkey` field Multiple validators can utilize the same execution layer withdrawal credential, thus the `validator_pubkey` field is utilized to disambiguate which validator is being exited. Note, `validator_index` also disambiguates validators. The problem is that smart contracts of some staking pools are not aware of the indices, because the index becomes known only after validator has been created on the beacon chain, while the pubkey is available in advance. ### Message queue The contract maintains an in-state queue of withdrawal request messages to be dequeued each block into the block and thus into the execution layer. The number


=== EIP-2677 ===
TITLE: Limit size of `initcode`
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-05-18
REQUIRES: 

SUMMARY:
Enforce a maximum size limit (`max_initcode_size`) for `initcode`. If the size of `initcode` exceeds `max_initcode_size`, then contract creation fails with an out of gas error. Since [EIP-170](./eip-170.md) was implemented, there has been a size limit of `24576` (`0x6000`) on contract code. We propose to also limit the size of executable code to `2x` the above limit, i.e. `49152` (`0xc000`). This also leads to two nice properties: - instruction offset in code fits 16-bit value, - code size fits 16-bit value.

SPECIFICATION:
There are three situations where this is applicable: * `CREATE`, * `CREATE2`, * creation using a transaction with empty receiver. In all these (and future) cases, the EVM should fail with Out Of Gas error if the code has a length more than `max_initcode_size`.

MOTIVATION:
When a client executes `initcode`, the client has to perform a jumpdest analysis. In some cases, the client also performs a `hash` of the code: * To use as a key in a mapping containing result of a jumpdest analysis * To use for address calculation within `CREATE2`. The work performed during a jumpdest analysis scales linearly with the size of the code. Currently, a transaction can expand the memory once, and reuse the same memory segment (with minor modifications) to force the client to perform a lot of analysis/hashing, leading to slow block processing. Historically, this was

RATIONALE:
TBA


=== EIP-7904 ===
TITLE: General Repricing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-02-05
REQUIRES: 7883

SUMMARY:
This proposal revises the gas cost schedule for opcodes and data access, prioritizing computational complexity, while excluding network-related costs such as state persistence. The adjustments aim to enhance gas cost accuracy and rebalance the cost structure.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Parameters | Constant | Value | | ------------------------ | ----- | | `WARM_STORAGE_READ_COST` | `5` | | `BASE_OPCODE_COST` | `1` | | `FAST_OPCODE_COST` | `2` | | `MID_OPCODE_COST` | `3` | | `EXP_BASE_COST` | `2` | | `EXP_PER_BYTE_COST` | `4` | | `COPY_PER_WORD_COST` | `1` | ### Cost formulas | Name | Formula | Description | | ------------------- | ----------------------- | ---------------------------------------------------- |

MOTIVATION:
Gas costs compromise of two components: network (social) cost and computation cost. Network cost reflects the blockchain’s effort to maintain state, including adding transactions, storage, logs, calldata, and receipts, while computation cost represents the non-durable processing effort of smart contracts. The importance of adequate gas costs arises from the nature of computations done on the Ethereum blockchain, and has been discussed in many research papers. Moreover it is paramount from the perspective of security and network stability. Gas cost is a natural deterrent from abusing the network's capacity. On the other hand, the network needs to be affordable

RATIONALE:
### Gas Cost Estimator Project The [Gas Cost Estimator](../assets/eip-7904/gas-cost-estimator-report.pdf) project serves as the empirical foundation for this EIP. This project conducted extensive testing across seven widely-used EVM implementations to measure the actual computational effort required by various opcodes and operations. Conducted in a controlled environment to eliminate external variables, the tests produced accurate and reproducible [results](../assets/eip-7904/final_gas_schedule_comparison.csv). The [findings](../assets/eip-7904/gas-cost-estimator.pdf) highlight misalignments between the current gas cost schedule and the real-world computational complexity of EVM operations. By recalibrating gas costs based on these measurements, this EIP seeks to align pricing with computational reality, thereby improving Ethereum’s performance and resilience. This


=== EIP-3326 ===
TITLE: Wallet Switch Ethereum Chain RPC Method (`wallet_switchEthereumChain`)
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2021-03-04
REQUIRES: 1, 5, 5, ,,  , 6, 9, 5

SUMMARY:
The `wallet_switchEthereumChain` RPC method allows Ethereum applications ("dapps") to request that the wallet switches its active Ethereum chain, if the wallet has a concept thereof. The caller must specify a chain ID. The wallet application may arbitrarily refuse or accept the request. `null` is returned if the active chain was switched, and an error otherwise. Important cautions for implementers of this method are included in the [Security Considerations](#security-considerations) section.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### `wallet_switchEthereumChain` The method accepts a single object parameter with a `chainId` field. The method returns `null` if the wallet switched its active chain, and an error otherwise. The method presupposes that the wallet has a concept of a single "active chain". The active chain is defined as the chain that the wallet is forwarding RPC requests to. #### Parameters `wallet_switchEthereumChain` accepts a single object parameter, specified by the following

MOTIVATION:
All dapps require the user to interact with one or more Ethereum chains in order to function. Some wallets only supports interacting with one chain at a time. We call this the wallet's "active chain". `wallet_switchEthereumChain` enables dapps to request that the wallet switches its active chain to whichever one is required by the dapp. This enables UX improvements for both dapps and wallets.

RATIONALE:
The purpose `wallet_switchEthereumChain` is to provide dapps with a way of requesting to switch the wallet's active chain, which they would otherwise have to ask the user to do manually. The method accepts a single object parameter to allow for future extensibility at virtually no cost to implementers and consumers. For related work, see [EIP-3085: `wallet_addEthereumChain`](./eip-3085.md) and [EIP-2015: `wallet_updateEthereumChain`](./eip-2015.md). `wallet_switchEthereumChain` intentionally forgoes the chain metadata parameters included in those EIPs, since it is purely concerned with switching the active chain, regardless of RPC endpoints or any other metadata associated therewith.


=== EIP-3520 ===
TITLE: Transaction Destination Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-16
REQUIRES: 3508

SUMMARY:
This EIP introduces the following EVM instruction: `ENTRYPOINT`. This instruction is meant to provide access to the original recipient of the transaction, the `to` address, enabling new ways of introspection to be applied in conjunction with [EIP-3508](./eip-3508.md).

SPECIFICATION:
### ENTRYPOINT (`0x4a`) The `ENTRYPOINT` instruction uses 0 stack arguments and pushes the original `to` member of the transaction onto the stack. The address yielded by the instruction is a 160-bit value padded to 256-bits. The operation costs `G_base` to execute, similarly to `ORIGIN` (`0x32`). The address returned by the `ENTRYPOINT` opcode will be equivalent to the `to` address parameter specified in the nearest `AUTHCALL` up the stack. If there is no `AUTHCALL` in the stack then `ENTRYPOINT` will retrieve the original transaction's `to` field.

MOTIVATION:
It is undeniable that smart contracts are becoming more interconnected than ever. Up until this point, smart contracts have entirely relied on compliant interfaces and introspection to introduce a new step in the call chain of a complex multi-contract interaction. However, this presents a forwards-only approach which limits the types of interactions that can manifest. The purpose of this EIP is to provide a way via which a contract is able to identify the entry-point of a transaction on the blockchain and deduce what was the original intention of the transaction by applying introspection on the original transaction

RATIONALE:
### AUTHCALL (`0xf7`) Interaction The [EIP-3074](./eip-3074.md) introduced a new call instruction called `AUTHCALL` (`0xf7`) that will replace a transaction's `ORIGIN` (`0x32`) with the context variable `authorized`. The intention of `AUTHCALL` is to prevent discrimination between smart contracts and EOAs which `ORIGIN` initially facilitated. The `ENTRYPOINT` opcode by itself re-introduces discrimination into the system as it indirectly allows one to evaluate whether the smart contract code being executed is done so by an EOA by validating that `ENTRYPOINT == ADDRESS` where `ADDRESS` (`0x30`) retrieves the currently executing account address. Therefore, it is sensible also replace the values retrieved by


=== EIP-6466 ===
TITLE: SSZ receipts
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-08
REQUIRES: 6, 5, 8, ,,  , 2, 7, 1, 8, ,,  , 6, 4, 0, 4, ,,  , 7, 4, 9, 5, ,,  , 7, 7, 0, 2, ,,  , 7, 9, 1, 6, ,,  , 8, 0, 1, 6

SUMMARY:
This EIP defines a migration process of [EIP-2718](./eip-2718.md) Recursive-Length Prefix (RLP) receipts to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md)

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated here for reference. | Name | SSZ equivalent | | - | - | | [`Root`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/phase0/beacon-chain.md#custom-types) | `Bytes32` | | [`ExecutionAddress`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/bellatrix/beacon-chain.md#custom-types) | `Bytes20` | | [`GasAmount`](./eip-6404.md#normalized-transactions) | `uint64` | ### Logs Logs are represented as an SSZ `Container`. | Name | Value | Description | | - | -

MOTIVATION:
RLP receipts have a number of shortcomings: 1. **Limited proving support:** Due to receipt data being linearly hashed as part of the `receipts_root` Merkle-Patricia Trie (MPT), it is not possible to efficiently proof individual parts of receipts, such as logs. Requiring the full receipt data to be present can be prohibitive for smart contract based applications such as L2 fraud proofs or client applications verifying log data. 2. **Unnecessary statefulness:** [EIP-658](./eip-658.md) replaced the intermediate post-state `root` from receipts with a boolean `status` code. However, `cumulativeGasUsed` and `logIndex` are similarly stateful, unnecessarily complicating efforts to execute transactions in parallel.

RATIONALE:
### Forward compatibility All receipts share the same Merkle tree shape with a stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/merkle-proofs.md#generalized-merkle-tree-index) assigned to each field. Future transaction features can introduce additional receipt fields or drop existing fields without breaking verifiers. ### Verifier improvements Committing to `from`, `contract_address` and `authorities` in the receipt allows efficient verification without the expensive `ecrecover` mechanism. This allows future EIPs to change how these addresses are computed without breaking verifiers, e.g., when future signature schemes are introduced. ### Execution client improvements Execution Layer implementations no longer need access to the transaction and additional indices when serving receipts based


=== EIP-4895 ===
TITLE: Beacon chain push withdrawals as operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-03-10
REQUIRES: 

SUMMARY:
Introduce a system-level "operation" to support validator withdrawals that are "pushed" from the beacon chain to the EVM. These operations create unconditional balance increases to the specified recipients.

SPECIFICATION:
| constants | value | units |--- |--- |--- | `FORK_TIMESTAMP` | 1681338455 | Beginning with the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** introduce the following extensions to payload validation and processing: ### System-level operation: withdrawal Define a new payload-level object called a `withdrawal` that describes withdrawals that have been validated at the consensus layer. `Withdrawal`s are syntactically similar to a user-level transaction but live in a different domain than user-level transactions. `Withdrawal`s provide key information from the consensus layer: 1. a monotonically increasing `index`, starting from 0, as a `uint64` value that increments by 1 per withdrawal

MOTIVATION:
This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM. The architecture is "push"-based, rather than "pull"-based, where withdrawals are required to be processed in the execution layer as soon as they are dequeued from the consensus layer. Withdrawals are represented as a new type of object in the execution payload -- an "operation" -- that separates the withdrawals feature from user-level transactions. This approach is more involved than the prior approach introducing a new transaction type but it cleanly separates this "system-level" operation from regular transactions. The separation simplifies

RATIONALE:
### Why not a new transaction type? This EIP suggests a new type of object -- the "withdrawal operation" -- as it has special semantics different from other existing types of EVM transactions. Operations are initiated by the overall system, rather than originating from end users like typical transactions. An entirely new type of object firewalls off generic EVM execution from this type of processing to simplify testing and security review of withdrawals. ### Why no (gas) costs for the withdrawal type? The maximum number of withdrawals that can reach the execution layer at a given time is


=== EIP-3690 ===
TITLE: EOF - JUMPDEST Table
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-06-23
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Introduce a section in the EOF format ([EIP-3540](./eip-3540.md)) for storing the list of `JUMPDEST`s, validate the correctness of this list at the time of contract creation, and remove the need for `JUMPDEST`-analysis at execution time. In EOF contracts, the `JUMPDEST` instruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.

SPECIFICATION:
This feature is introduced on the very same block [EIP-3540](./eip-3540.md) is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps. *Remark:* We rely on the notation of *initcode*, *code* and *creation* as defined by [EIP-3540](./eip-3540.md), and extend validation rules of [EIP-3670](./eip-3670.md). ### EOF container changes 1. A new EOF section called `jumpdests` (`section_kind = 3`) is introduced. It contains a sequence of *n* unsigned integers *jumploc<sub>i</sub>*. 2. The *jumploc<sub>i</sub>* values are encoded with [unsigned LEB128](https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128). | description | encoding | |---------------------|-----------------| | jumploc<sub>0</sub> | unsigned LEB128 | | jumploc<sub>1</sub> | unsigned LEB128 | |

MOTIVATION:
Currently existing contracts require no validation of correctness, but every time they are executed, a list must be built containing all the valid jump-destinations. This is an overhead which can be avoided, albeit the effect of the overhead depends on the client implementation. With the structure provided by EIP-3540 it is easy to store and transmit a table of valid jump-destinations instead of using designated `JUMPDEST` (0x5b) opcodes in the code. The goal of this change is that we trade less complexity (and processing time) at execution time for more complexity at contract creation time. Through benchmarks we

RATIONALE:
### Jumpdests section is bounded The length of the `jumpdests` section is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any valid `jumpdests` section may not be more larger than 0x3000. ### Delta encoding Delta-encoding is very efficient for this job. From a quick analysis of a small set of contracts `JUMPDEST` opcodes are relatively close to each other. In the delta-encoding the values almost never exceed 128. Combined with any form of variable-length quantity (VLQ) where values < 128 occupy one byte,


=== EIP-7756 ===
TITLE: EOF/EVM Trace Specification
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2024-08-13
REQUIRES: 3, 1, 5, 5, ,,  , 4, 7, 5, 0

SUMMARY:
Updates the [EIP-3155](./eip-3155.md) JSON tracing specification to support EOF features.

SPECIFICATION:
To promote clarity and provide a cohesive specification, the entire tracing specification will be presented with alterations in-line rather than as a set of diffs on top of EIP-3155. Differences will be highlighted in the Backwards Compatibility section. The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", " RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Datatypes | Type | Explanation | JSON member example | |------------|----------------------------------------------------------------|----------------------------------------| | Number | JSON number | `"pc":0` | | Hex-Number | Hex-encoded number

MOTIVATION:
EIP-3155 defined a tracing standard for Legacy EVM operations. However, the EVM Object Format ([EIP-7692](./eip-7692.md)) adds a number of features that need to be reflected in debugging traces. The use of these traces has also moved out from state testing, including live block tracing and differential fuzzing, increasing the need to keep tracing up to date. This EIP has multiple goals: - Add members to the trace object to support new EOF features. - Support tracing contracts contained in an EOF container as well as uncontained "legacy" contracts in the same trace. - Clarify any previous ambiguities in

RATIONALE:
This EIP is an extension of the EIP-3155 tracing features that has been in use for years. Rather than dramatically re-boot the feature, the information was added to the existing traces. A "mini" trace was contemplated to allow for tracing to be included in tools such as `t8n` and to allow for more efficient RPC tracing calls, but that seemed sufficiently different that it would be a stand-alone EIP rather than an EIP that adds features to the existing tracing capabilities. The idea of moving to a JSON Schema was rejected to ensure maximum compatibility with existing clients.


=== EIP-100 ===
TITLE: Change difficulty adjustment to target mean block time including uncles
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-04-28
REQUIRES: 

SPECIFICATION:
Currently, the formula to compute the difficulty of a block includes the following logic: ``` python adj_factor = max(1 - ((timestamp - parent.timestamp) // 10), -99) child_diff = int(max(parent.difficulty + (parent.difficulty // BLOCK_DIFF_FACTOR) * adj_factor, min(parent.difficulty, MIN_DIFF))) ... ``` If `block.number >= BYZANTIUM_FORK_BLKNUM`, we change the first line to the following: ``` python adj_factor = max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99) ``` ### Rationale This new formula ensures that the difficulty adjustment algorithm targets a constant average rate of blocks produced including uncles, and so ensures a highly predictable issuance rate that

RATIONALE:
This new formula ensures that the difficulty adjustment algorithm targets a constant average rate of blocks produced including uncles, and so ensures a highly predictable issuance rate that cannot be manipulated upward by manipulating the uncle rate. A formula that accounts for the exact number of included uncles: ``` python adj_factor = max(1 + len(parent.uncles) - ((timestamp - parent.timestamp) // 9), -99) ``` can be fairly easily seen to be (to within a tolerance of ~3/4194304) mathematically equivalent to assuming that a block with `k` uncles is equivalent to a sequence of `k+1` blocks that all appear with


=== EIP-2003 ===
TITLE: EVMC modules for implementations of precompiled contracts
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-05-09
REQUIRES: 1352

SUMMARY:
[EVMC] specifies a generic API for Ethereum execution engines. This EIP specifies a way of providing implementations of Ethereum precompiled contracts using the [EVMC VM API].

SPECIFICATION:
For the complete [EVMC] specification visit the [EVMC documentation] first. This EIP is based on and is compatible with EVMC ABI version 6. The EVMC module with implementations of precompiled contracts SHOULD: 1. Advertise the [`EVMC_CAPABILITY_PRECOMPILES`] capability in the [`get_capabilities()`] method. 2. Implement the [`execute()`] method in the following way: 1. Validate the incoming execution request requirements: 1. The message kind ([`evmc_message::kind`]) is a call ([`EVMC_CALL`]). 2. The call destination address ([`evmc_message::destination`]) is within the range of precompiled contracts defined by [EIP-1352]. 3. There is no code provided (the `code` argument is `NULL` and `code_size` argument is `0`).

RATIONALE:
It is very unlikely that any precompile will need to access or modify a contract state. Not requiring the Client to implement the EVMC Host interface removes the big portion of work needed for full EVMC integration.


=== EIP-7823 ===
TITLE: Set upper bounds for MODEXP
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-11-11
REQUIRES: 198

SUMMARY:
Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.

SPECIFICATION:
Recap from [EIP-198](./eip-198.md): > At address `0x00……05`, add a precompile that expects input in the following format: > > `<length_of_BASE> <length_of_EXPONENT> <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>` We introduce an upper bound to the inputs of the precompile, each of the length inputs (`length_of_BASE`, `length_of_EXPONENT` and `length_of_MODULUS`) MUST be less than or equal to 8192 bits (1024 bytes). If any of these inputs are larger than the limit, the precompile execution stops, returns an error, and consumes all gas.

MOTIVATION:
The MODEXP precompile has been a source of numerous consensus bugs. Many of them were due to specifically crafted cases using impractical input lengths. Its pricing function is also quite complex given its nature of unbounded inputs. While we don't suggest to rework the pricing function, it may be possible in a future upgrade once the limits are in place. Furthermore this limitation makes it more feasible to have the precompile replaced with EVM code through features like EVMMAX.

RATIONALE:
### Limit This upper bound allows the existing use cases of MODEXP: 1. RSA verification with up to 8192 bit keys. Commonly used ones are 1024/2048/4096 bits. 2. Elliptic curve related use cases are usually less than 384 bits. ### EVMMAX Replacing the precompile with EVM code using an instruction set like EVMMAX would be made simpler with this limit: Common cases (256, 381, 1024, 2048) could be implemented in special fast paths, while a slow fallback could be provided for the rest. Or even special, frequently used, moduli could have their own paths. Furthermore one could consider


=== EIP-3508 ===
TITLE: Transaction Data Opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-16
REQUIRES: 

SUMMARY:
This EIP introduces the following three EVM instructions: `ORIGINDATALOAD`, `ORIGINDATASIZE`, and `ORIGINDATACOPY`. These three instructions are meant to provide access to the original transaction's `data` payload, enabling a gas-efficient way of accessing large data payloads in cross-contract calls.

SPECIFICATION:
### ORIGINDATALOAD (`0x47`), ORIGINDATASIZE (`0x48`) and ORIGINDATACOPY (`0x49`) These instructions are meant to operate similarly to their call-prefixed counterparts with the exception that they instead operate on the original `data` of a transaction instead of the current call's data. In detail: - ORIGINDATALOAD (`0x47`) performs similarly to CALLDATALOAD (`0x35`) - ORIGINDATASIZE (`0x48`) performs similarly to CALLDATASIZE (`0x36`) - ORIGINDATACOPY (`0x49`) performs similarly to CALLDATACOPY (`0x37`) As the data is retrieved once again from the execution environment, the costs for the three instructions will be `G_verylow`, `G_base` and `G_base + G_verylow * (number of words copied, rounded up)` respectively.

MOTIVATION:
As the Ethereum development scene matures, more ambitious and complex features are introduced into smart contracts more often than not requiring the utilization of complex and at times large data structures. Given the inherent limits of the EVM, however, transporting large data structures in between contracts is a costly task that can at times lead to even futile scenarios whereby the gas consumption of such an operation is impossible to execute within the gas limit bounds as well as without sacrificing a large chunk of ETH to facilitate its gas cost. The purpose of this EIP is to

RATIONALE:
### AUTHCALL (`0xf7`) Interaction The [EIP-3074](./eip-3074.md) that will be part of the London fork has introduced a new call instruction called `AUTHCALL` (`0xf7`) that will replace a transaction's `ORIGIN` (`0x32`) with the context variable `authorized`. The intention of `AUTHCALL` is to prevent discrimination between smart contracts and EOAs which `ORIGIN` initially facilitated and as a result, it is sensible also replace the values retrieved by the `ORIGINDATA*` opcodes to the ones used in the `AUTHCALL`. ### Naming Conventions The `ORIGIN`-prefixed instructions attempted to conform to the existing naming convention of `CALL`-prefixed instructions given the existence of the `ORIGIN`
