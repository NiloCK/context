=== ERC-1175 ===
TITLE: Wallet & shop standard for all tokens (erc20)
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-06-21
REQUIRES: 20

SUMMARY:
The mutual trust between the wallet and the shop created by the authenticated contract allows you to pay for and purchase items at a simple process.

SPECIFICATION:
![workflow](../assets/eip-1175/workflow.png)

MOTIVATION:
New standards with improvements have been released, but the majority of tokens currently being developed are erc20 tokens. So I felt I needed a proposal to use old tokens in commerce. To use various erc20 tokens for trading, you need a custom contract. However, a single wallet with a variety of tokens, and a mutually trusted store, can make transactions that are simple and efficient. The erc20 token is traded through two calls, `approve (address _spender, uint256 _value)` and `transferFrom (address _from, address _to, uint256 _value)`, but when using the wallet contract, `paySafe (address _shop, uint256 _item)`will be


=== ERC-6982 ===
TITLE: Efficient Default Lockable Tokens
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-05-02
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal introduces a lockable interface for [ERC-721](./eip-721.md) tokens that optimizes gas usage by eliminating unnecessary events. This interface forms the foundation for the creation and management of lockable [ERC-721](./eip-721.md) tokens. It provides a gas-efficient approach by emitting a `DefaultLocked(bool locked)` event upon deployment, setting the initial lock status for all tokens, while individual `Locked(uint256 indexed tokenId, bool locked)` events handle subsequent status changes for specific tokens. The interface also includes a view function `locked(uint256 tokenId)` to return the current lock status of a token, and a view function `defaultLocked()` to query the default status of a newly

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The interface is defined as follows: ```solidity // ERC165 interfaceId 0x6b61a747 interface IERC6982 { /** * @dev MUST be emitted when the contract is deployed to establish the default lock status * for all tokens. Also, MUST be emitted again if the default lock status changes, * to ensure the default status for all tokens (without a specific `Locked` event) is updated. */ event

MOTIVATION:
Existing lockable token proposals often mandate the emission of an event each time a token is minted. This results in unnecessary gas consumption, especially in cases where tokens are permanently locked from inception to destruction (e.g., soulbounds or non-transferable badges). This proposal offers a more gas-efficient solution that only emits events upon contract deployment and status changes of individual tokens.

RATIONALE:
This standard seeks to optimize gas consumption by minimizing the frequency of event emission. The `DefaultLocked` event is designed to establish the lock status for all tokens, thereby circumventing the need to emit an event each time a new token is minted. It's crucial to note that the `DefaultLocked` event can be emitted at any point in time, and is not restricted to only before the `Locked` events are emitted. Tokens may alter their behavior under certain circumstances (such as after a reveal), prompting the re-emission of the `DefaultLocked` event to reflect the new default status. The primary


=== ERC-5453 ===
TITLE: Endorsement - Permit for Any Functions
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2022-08-12
REQUIRES: 1, 6, 5, ,,  , 7, 1, 2, ,,  , 1, 2, 7, 1, ,,  , 5, 7, 5, 0

SUMMARY:
This EIP establish a general protocol for permitting approving function calls in the same transaction rely on [ERC-5750](./eip-5750.md). Unlike a few prior art ([ERC-2612](./eip-2612.md) for [ERC-20](./eip-20.md), `ERC-4494` for [ERC-721](./eip-721.md) that usually only permit for a single behavior (`transfer` for ERC-20 and `safeTransferFrom` for ERC-721) and a single approver in two transactions (first a `permit(...)` TX, then a `transfer`-like TX), this EIP provides a way to permit arbitrary behaviors and aggregating multiple approvals from arbitrary number of approvers in the same transaction, allowing for Multi-Sig or Threshold Signing behavior.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Interfaces The interfaces and structure referenced here are as followed ```solidity pragma solidity ^0.8.9; struct ValidityBound { bytes32 functionParamStructHash; uint256 validSince; uint256 validBy; uint256 nonce; } struct SingleEndorsementData { address endorserAddress; // 32 bytes sig; // dynamic = 65 } struct GeneralExtensionDataStruct { bytes32 erc5453MagicWord; uint256 erc5453Type; uint256 nonce; uint256 validSince; uint256 validBy; bytes endorsementPayload; } interface IERC5453EndorsementCore { function eip5453Nonce(address endorser) external

MOTIVATION:
1. Support permit(approval) alongside a function call. 2. Support a second approval from another user. 3. Support pay-for-by another user 4. Support multi-sig 5. Support persons acting in concert by endorsements 6. Support accumulated voting 7. Support off-line signatures

RATIONALE:
1. We chose to have both `ERC5453_TYPE_A`(single-endorsement) and `ERC5453_TYPE_B`(multiple-endorsements, same nonce for entire contract) so we could balance a wider range of use cases. E.g. the same use cases of ERC-2612 and `ERC-4494` can be supported by `ERC5453_TYPE_A`. And threshold approvals can be done via `ERC5453_TYPE_B`. More complicated approval types can also be extended by defining new `ERC5453_TYPE_?` 2. We chose to include both `validSince` and `validBy` to allow maximum flexibility in expiration. This can be also be supported by EVM natively at if adopted `ERC-5081` but `ERC-5081` will not be adopted anytime soon, we choose to add


=== ERC-5560 ===
TITLE: Redeemable NFTs
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-30
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The EIP is a Redeemable NFT extension which adds a `redeem` function to [EIP-721](./eip-721.md). It can be implemented when an NFT issuer wants his/her NFT to be redeemed for a physical object.

SPECIFICATION:
_The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119._ `EIP-721` compliant contracts MAY implement this EIP to provide a standard method of receiving information on redeemability. The NFT issuer **MUST** decide who is allowed to redeem the NFT, and restrict access to the `redeem()` function accordingly. Anyone **MAY** access the `isRedeemable()` function to check the redeemability status: it returns `true` when the NFT redeemable, and `false` when already redeemed. Third-party services that support this standard **MAY** use the

MOTIVATION:
An increasing amount of NFT issuers such as artists, fine art galeries, auction houses, brands and others want to offer a physical object to the holder of a given NFT. This standard allows EIP-721 NFTs to signal reedemability.

RATIONALE:
When the NFT contract is deployed, the `isRedeemable()` function returns `true` by default. By default, the `redeem()` function visibility is public, so anyone can trigger it. It is **RECOMMENDED** to add a `require` to restrict the access: ```solidity require(ownerOf(tokenId) == msg.sender, "ERC721Redeemable: You are not the owner of this token"); ``` After the `redeem()` function is triggered, `isRedeemable()` function returns `false`. ### `Redeem` event When the `redeem()` function is triggered, the following event **MUST** be emitted: ```solidity event Redeem(address indexed from, uint256 indexed tokenId); ```


=== ERC-7720 ===
TITLE: Deferred Token Transfer
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-06-09
REQUIRES: 20

SUMMARY:
This standard specifies that allows users to deposit [ERC-20](./eip-20.md) tokens for a beneficiary. The beneficiary can withdraw the tokens only after a specified future timestamp. Each deposit transaction is assigned a unique ID and includes details such as the token address, sender, recipient, amount, unlock time, and withdrawal status.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Implementers of this standard **MUST** have all of the following functions: ```solidity pragma solidity ^0.8.0; interface ITokenTransfer { // Event emitted when a transfer is initiated. event Transfer( uint256 txnId, address indexed token, address indexed from, address indexed to, uint256 amount, uint40 unlockTime, bytes32 referenceNo ); // Event emitted when tokens are withdrawn. event Withdraw( uint256 txnId, address indexed token, address indexed from, address

MOTIVATION:
In various scenarios, such as vesting schedules, escrow services, or timed rewards, there is a need for deferred payments. This contract provides a secure and reliable mechanism for time-locked token transfers, ensuring that tokens can only be transferred after a specified timestamp is reached. By facilitating structured and delayed payments, it adds an extra layer of security and predictability to token transfers. This is particularly useful for scenarios where payments are contingent upon the passage of time.

RATIONALE:
The design of the Deferred Token Transfer contract aims to provide a straightforward and secure method for handling time-locked token transfers. The following considerations were made during its development: **Unlock Time Precision with `uint40`**: We chose a full `uint40` for `_unlockTime` because it provides a sufficiently large range to cover all practical time-lock scenarios. This ensures that the contract can handle deferred payments that require precise timing over long periods, such as vesting schedules or long-term escrows. **Returning `txnId` from `transferFrom`**: The `transferFrom` function returns a unique `txnId` for each transaction. This design choice was made to facilitate


=== ERC-7674 ===
TITLE: Temporary Approval Extension for ERC-20
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-02
REQUIRES: 2, 0, ,,  , 1, 1, 5, 3

SUMMARY:
This specification defines the minimum interface required to temporarily approve [ERC-20](./eip-20.md) tokens for spending within the same transaction.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Compliant contracts MUST implement 1 new function in addition to [ERC-20](./eip-20.md): ```solidity function temporaryApprove(address spender, uint256 value) public returns (bool success) ``` A call to `temporaryApprove(spender, value)` allows `spender` to withdraw within the same transaction on behalf of `msg.sender` multiple times, such that the total withdrawn is less than or equal to the `value` amount. This temporary allowance is to be considered in addition

MOTIVATION:
User are often required to set a token approval that will only be used once. It is common to leave unexpected approvals after these interactions. [EIP-1153](./eip-1153.md) introduces `TSTORE`, which can be used to efficiently handle temporarily allowances.

RATIONALE:
It was decided to make minimal interface extension to allow easier integration of a compliant contract into the existing infrastructure. This affects the backward compatibility of the `allowance` function. However, the required changes to the `transferFrom` function implementation satisfy the requirement to explicitly authorize the spender to transfer tokens.


=== ERC-6786 ===
TITLE: Registry for royalties payment for NFTs
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-27
REQUIRES: 1, 6, 5, ,,  , 2, 9, 8, 1

SUMMARY:
This standard allows anyone to pay royalties for a certain NFT and also to keep track of the royalties amount paid. It will cumulate the value each time a payment is executed through it and make the information public.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Every contract compliant with [ERC-6786](./eip-6786.md) MUST implement the interface defined as follows: ### Contract Interface ```solidity // @title Royalty Debt Registry /// Note: the ERC-165 identifier for this interface is 0x253b27b0 interface IERC6786 { // Logged when royalties were paid for a NFT /// @notice Emitted when royalties are paid for the NFT with address tokenAddress and id tokenId event RoyaltiesPaid(address indexed tokenAddress, uint256 indexed tokenId, uint256 amount); /// @notice

MOTIVATION:
There are many marketplaces which do not enforce any royalty payment to the NFT creator every time the NFT is sold or re-sold and/or providing a way for doing it. There are some marketplaces which use specific system of royalties, however that system is applicable for the NFTs creates on their platform. In this context, there is a need of a way for paying royalties, as it is a strong incentive for creators to keep contributing to the NFTs ecosystem. Additionally, this standard will provide a way of computing the amount of royalties paid to a creator for

RATIONALE:
The payment can be made in native coins, so it is easy to aggregate the amount of paid royalties. We want this information to be public, so anyone could tell if a creator received royalties in case of under the table trading or in case of marketplaces which don’t support royalties. The function used for payment can be called by anyone (not only the NFTs owner) to support the creator at any time. There is a way of seeing the amount of paid royalties in any token, also available for anyone. For fetching creator on-chain data we will


=== ERC-7812 ===
TITLE: ZK Identity Registry
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-11-08
REQUIRES: 

SUMMARY:
This EIP introduces an on-chain registry system for storing and proving abstract statements. Users may utilize the system to store commitments to their private data to later prove its validity and authenticity via zero knowledge, without disclosing anything about the data itself. Moreover, developers may use the singleton `EvidenceRegistry` contract available at `0x781268D46a654D020922f115D75dd3D56D287812` to integrate custom business-specific registrars for managing and processing particular statements.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Definitions - A "Sparse Merkle Tree (SMT)" is a special Merkle tree that works by deterministically and idempotently storing key/value pairs in the given locations leveraging a hash function. The Poseidon hash function is often used to optimize the compatibility with ZK. - A "statement" is an accepted structured representation of some abstract evidence. A statement can range from a simple `string` to a Merkle root of some SMT.

MOTIVATION:
This EIP stemmed from the need to localize and unravel the storage and issuance of provable statements so that future protocols can anchor to the standardized singleton on-chain registry and benefit from cross-reuse. The aggregation of provable statements significantly improves reusability, portability, and security of the abundance of zero knowledge privacy-oriented solutions. The abstract specification of the registry allows custom indentity-based, reputation-based, proof-of-attendance-based, etc., protocols to be implemented with little to minimal constraints. The given proposal lays the important foundation for specific solution to build upon. The more concrete specifications of statements and commitments structures are expected to

RATIONALE:
During the EIP specification we have considered two approaches: where every protocol has its own registry and where all protocols are united under a singleton registry. We have decided to go with the latter as this approach provides the following benefits: 1. Cross-chain portability. Only a single `bytes32` value (the SMT root) has to be sent cross-chain to be able to prove the state of the registry. 2. Centralization of trust. Users only need to trust a single, permissionaless, immutable smart contract. 3. Integration streamline. The singleton design formalizes the system interface, the hash function, and the overall


=== ERC-831 ===
TITLE: URI Format for Ethereum
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-01-15
REQUIRES: 6, 7, ,,  , 6, 8, 1

SUMMARY:
URIs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URI format allows for instant invocation of the user's preferred wallet application.

SPECIFICATION:
### Syntax Ethereum URIs contain "ethereum" or "eth" in their schema (protocol) part and are constructed as follows: request = "eth" [ "ereum" ] ":" [ prefix "-" ] payload prefix = STRING payload = STRING ### Semantics `prefix` is optional and defines the use-case for this URI. If no prefix is given: "pay-" is assumed to be concise and ensure backward compatibility to [EIP-67](./eip-67.md). When the prefix is omitted, the payload must start with `0x`. Also prefixes must not start with `0x`. So starting with `0x` can be used as a clear signal that there is no

RATIONALE:
The need for this ERC emerged when refining EIP-681. We need a container that does not carry the weight of the use-cases. EIP-67 was the first attempt on defining Ethereum-URIs. This ERC tries to keep backward compatibility and not break existing things. This means EIP-67 URIs should still be valid and readable. Only if the prefix feature is used, EIP-67 parsers might break. No way was seen to avoid this and innovate on the same time. This is also the reason this open prefix approach was chosen to being able to adopt to future use-cases and not block


=== ERC-998 ===
TITLE: Composable Non-Fungible Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2018-07-07
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
An extension of the [ERC-721 standard](./eip-721.md) to enable ERC-721 tokens to own other ERC-721 tokens and [ERC-20](./eip-20.md) tokens. An extension of the [ERC-20](./eip-20.md) and `ERC-223 https://github.com/ethereum/EIPs/issues/223` standards to enable ERC-20 and `ERC-223` tokens to be owned by ERC-721 tokens. This specification covers four different kinds of composable tokens: 1. [`ERC998ERC721` top-down composable tokens that receive, hold and transfer ERC-721 tokens](#erc-721-top-down-composable) 2. [`ERC998ERC20` top-down composable tokens that receive, hold and transfer ERC-20 tokens](#erc-20-top-down-composable) 3. [`ERC998ERC721` bottom-up composable tokens that attach themselves to other ERC-721 tokens.](#erc-721-bottom-up-composable) 4. [`ERC998ERC20` bottom-up composable tokens that attach themselves to ERC-721 tokens.](#erc-20-bottom-up-composable) which map to

SPECIFICATION:
### ERC-721 `ERC998ERC721` top-down, `ERC998ERC20` top-down, and `ERC998ERC721` bottom-up composable contracts must implement the [ERC-721 interface](./eip-721.md). ### ERC-20 `ERC998ERC20` bottom-up composable contracts must implement the [ERC-20 interface](./eip-20.md). ### [ERC-165](./eip-165.md) The [ERC-165 standard](./eip-165.md) must be applied to each [ERC-998](./eip-998.md) interface that is used. ### Authentication Authenticating whether a user or contract can execute some action works the same for both `ERC998ERC721` top-down and `ERC998ERC721` bottom-up composables. A `rootOwner` refers to the owner address at the top of a tree of composables and ERC-721 tokens. Authentication within any composable is done by finding the rootOwner and comparing it to `msg.sender`,

RATIONALE:
Two different kinds of composable (top-down and bottom-up) exist to handle different use cases. A regular ERC-721 token cannot own a top-down composable, but it can own a bottom-up composable. A bottom-up composable cannot own a regular ERC-721 but a top-down composable can own a regular ERC-721 token. Having multiple kinds of composables enable different token ownership possibilities. ### Which Kind of Composable To Use? If you want to transfer regular ERC-721 tokens to non-fungible tokens, then use top-down composables. If you want to transfer non-fungible tokens to regular ERC-721 tokens then use bottom-up composables. ### Explicit Transfer


=== ERC-1062 ===
TITLE: Formalize IPFS hash into ENS(Ethereum Name Service) resolver
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
The following standard details the implementation of how to combine the IPFS cryptographic hash unique fingerprint with ENS public resolver. This standard provides a functionality to get and set IPFS online resources to ENS resolver. We think that this implementation is not only aim to let more developers and communities to provide more use cases, but also leverage the human-readable features to gain more user adoption accessing decentralized resources. We considered the IPFS ENS resolver mapping standard a cornerstone for building future Web3.0 service.

SPECIFICATION:
The condition now is that the IPFS file fingerprint using base58 and in the meantime, the Ethereum uses hex in API to encode the binary data. So that need a way to process the condition requires not only we need to transfer from IPFS to Ethereum, but also need to convert it back. To solve these requirements, we can use binary buffer bridging that gap. When mapping the IPFS base58 string to ENS resolver, first we convert the Base58 to binary buffer, turn the buffer to hex encrypted format, and save to the contract. Once we want to

MOTIVATION:
To build a fully decentralized web service, it’s necessary to have a decentralized file storage system. Here comes the IPFS, for three following advantages : - Address large amounts of data, and has unique cryptographic hash for every record. - Since IPFS is also based on peer to peer network, it can be really helpful to deliver large amounts of data to users, in a safer way and lower the millions of cost for the bandwidth. - IPFS stores files in high efficient way via tracking version history for every file, and removing the duplications across the network.

RATIONALE:
To implement the specification, need two methods from ENS public resolver contract, when we want to store IPFS file fingerprint to contract, convert the Base58 string identifier to the hex format and invoke the `setMultihash` method below : ```solidity function setMultihash(bytes32 node, bytes hash) public only_owner(node); ``` Whenever users need to visit the ENS content, we call the `multihash` method to get the IPFS hex data, transfer to the Base58 format, and return the IPFS resources to use. ```solidity function multihash(bytes32 node) public view returns (bytes); ```


=== ERC-5496 ===
TITLE: Multi-privilege Management NFT Extension
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2022-07-30
REQUIRES: 721

SUMMARY:
This EIP defines an interface extending [EIP-721](./eip-721.md) to provide shareable multi-privileges for NFTs. Privileges may be on-chain (voting rights, permission to claim an airdrop) or off-chain (a coupon for an online store, a discount at a local restaurant, access to VIP lounges in airports). Each NFT may contain many privileges, and the holder of a privilege can verifiably transfer that privilege to others. Privileges may be non-shareable or shareable. Shareable privileges can be cloned, with the provider able to adjust the details according to the spreading path. Expiration periods can also be set for each privilege.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Every contract complying with this standard MUST implement the `IERC5496` interface. The **shareable multi-privilege extension** is OPTIONAL for EIP-721 contracts. ```solidity /// @title multi-privilege extension for EIP-721 /// Note: the EIP-165 identifier for this interface is 0x076e1bbb interface IERC5496{ /// @notice Emitted when `owner` changes the `privilege holder` of a NFT. event PrivilegeAssigned(uint256 tokenId, uint256 privilegeId, address user, uint256 expires); /// @notice Emitted when `contract owner` changes the `total

MOTIVATION:
This standard aims to efficiently manage privileges attached to NFTs in real-time. Many NFTs have functions other than just being used as profile pictures or art collections, they may have real utilities in different scenarios. For example, a fashion store may give a discount for its own NFT holders; a DAO member NFT holder can vote for the proposal of how to use their treasury; a dApp may create an airdrop event to attract a certain group of people like some blue chip NFT holders to claim; the grocery store can issue its membership card on chain (as

RATIONALE:
### Shareable Privileges The number of privilege holders is limited by the number of NFTs if privileges are non-shareable. A shareable privilege means the original privilege holder can copy the privilege and give it to others, not transferring his/her own privilege to them. This mechanism greatly enhances the spread of privileges as well as the adoption of NFTs. ### Expire Date Type The expiry timestamp of a privilege is a timestamp and stored in `uint256` typed variables. ### Beneficiary of Referrer For example, a local pizza shop offers a 30% off Coupon and the owner of the shop


=== ERC-5115 ===
TITLE: SY Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-05-30
REQUIRES: 20

SUMMARY:
This standard proposes an API for wrapped yield-bearing tokens within smart contracts. It is an extension on the [ERC-20](./eip-20.md) token that provides basic functionality for transferring, depositing, withdrawing tokens, as well as reading balances.

SPECIFICATION:
### Generic Yield Generating Pool We will first introduce Generic Yield Generating Pool (GYGP), a model to describe most yield generating mechanisms in DeFi. In every yield generating mechanism, there is a pool of funds, whose value is measured in **assets**. There are a number of users who contribute liquidity to the pool, in exchange for **shares** of the pool, which represents units of ownership of the pool. Over time, the value (measured in **assets**) of the pool grows, such that each **share** is worth more **assets** over time. The pool could earn a number of **reward tokens**

MOTIVATION:
Yield generating mechanisms are built in all shapes and sizes, necessitating a manual integration every time a protocol builds on top of another protocol’s yield generating mechanism. [ERC-4626](./eip-4626.md) tackled a significant part of this fragmentation by standardizing the interfaces for vaults, a major category among various yield generating mechanisms. In this ERC, we’re extending the coverage to include assets beyond ERC-4626’s reach, namely: - yield-bearing assets that have different input tokens used for minting vs accounting for the pool value. - This category includes AMM liquidity tokens (which are yield-bearing assets that yield swap fees) since the value

RATIONALE:
[ERC-20](./eip-20.md) is enforced because implementation details such as transfer, token approvals, and balance calculation directly carry over to the SY tokens. This standardization makes the SY tokens immediately compatible with all ERC-20 use cases. [ERC-165](./eip-165.md) can optionally be implemented should you want integrations to detect the IStandardizedYield interface implementation. [ERC-2612](./eip-2612.md) can optionally be implemented in order to improve the UX of approving SY tokens on various integrations.


=== ERC-725 ===
TITLE: General data key/value store and execution
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2017-10-02
REQUIRES: 1, 6, 5, ,,  , 1, 7, 3

SUMMARY:
The following describes two standards that allow for a generic data storage in a smart contract and a generic execution through a smart contract. These can be used separately or in conjunction and can serve as building blocks for smart contract accounts, upgradable metadata, and other means.

SPECIFICATION:
### Ownership This contract is controlled by a single owner. The owner can be a smart contract or an external account. This standard requires [ERC-173](./eip-173.md) and SHOULD implement the functions: - `owner() view` - `transferOwnership(address newOwner)` And the event: - `OwnershipTransferred(address indexed previousOwner, address indexed newOwner)` --- ### `ERC725X` **`ERC725X`** interface id according to [ERC-165](./eip-165.md): `0x7545acac`. Smart contracts implementing the `ERC725X` standard MUST implement the [ERC-165](./eip-165.md) `supportsInterface(..)` function and MUST support the `ERC165` and `ERC725X` interface ids. ### `ERC725X` Methods Smart contracts implementing the `ERC725X` standard SHOULD implement all of the functions listed below: #### execute ```solidity function

MOTIVATION:
The initial motivation came out of the need to create a smart contract account system that's flexible enough to be viable long-term but also defined enough to be standardized. They are a generic set of two standardized building blocks to be used in all forms of smart contracts. This standard consists of two sub-standards, a generic data key/value store (`ERC725Y`) and a generic execute function (`ERC725X`). Both of these in combination allow for a very flexible and long-lasting account system. The account version of `ERC725` is standardized under `LSP0-ERC725Account`. These standards (`ERC725` X and Y) can also be

RATIONALE:
The generic way of storing data keys with values was chosen to allow upgradability over time. Stored data values can be changed over time. Other smart contract protocols can then interpret this data in new ways and react to interactions from a `ERC725` smart contract differently. The data stored in an `ERC725Y` smart contract is not only readable/writable by off-chain applications, but also by other smart contracts. Function overloading was used to allow for the retrievable of single and multiple keys, to keep gas costs minimal for both use cases.


=== ERC-2569 ===
TITLE: Saving and Displaying Image Onchain for Universal Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-03-28
REQUIRES: 

SUMMARY:
This set of interfaces allow a smart contract to save an SVG image in Ethereum and to retrieve an SVG image from Ethereum for fungible tokens, non-fungible tokens and tokens based on standards that will be developed in the future. The interface set has two interfaces: one to save an SVG file in Ethereum and the other to retrieve an SVG file from Ethereum. Typical applications include but not limited to: * A solution for storage of a fungible token's icon. * A solution for storage of a non-fungible token's icon. * A solution for storage of the

SPECIFICATION:
An EIP-2569 compatible contract MUST have a method with the signature getTokenImageSvg(uint256) view returns (string memory) and a method with the signature setTokenImageSvg(uint256 tokenId, string memory imagesvg) internal. These methods define how a smart contract saves an image for a universal token in Ethereum which keeps the image permanent and tamper-resistant, and how a smart contract retrieves an image from Ethereum for a universal token. By calling the methods users should access an SVG image. * getTokenImageSvg(uint256 tokenId) external view returns (string memory): for an ERC-721 or ERC-1155 token or a token implemented by a contract which has

MOTIVATION:
The ERC-721 token standard is a popular standard to define a non-fungible token in Ethereum. This standard is widely used to specify a crypto gift, crypto medal, crypto collectible etc. The most famous use case is the [cryptokitty](https://www.cryptokitties.co/). In most of these applications an image is attached to an ERC-721 token. For example, in the cryptokitty case each kitty has a unique image. While the token's code is saved in Ethereum permanently, the image attached to the token is not. The existing solutions still keep such an image in a centralized server instead of Ethereum. When these applications

RATIONALE:
After Bitcoin was created people have found ways to keep information permanent and tamper-resistant by encoding text messages they want to preserve permanently and tamper-resistantly in blockchain transactions. However existing applications only do this for text information and there are no solutions to keep an image permanent and tamper-resistant. One of the most significant reasons for not doing so is that in general the size of an image is much bigger than the size of a text file, thus the gas needed to save an image in Ethereum would exceed a block's gas limit. However this changed a


=== ERC-4972 ===
TITLE: Name-Owned Account
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-04-04
REQUIRES: 137

SUMMARY:
The ERC suggests expanding the capabilities of the name service, such as ENS, by enabling each human-readable identity to be linked to a single smart contract account that can be controlled by the owner of the name identity.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Name-Owned Account An NOA has - a human readable name defined by [ERC-137](./eip-137.md); and - an owned account(NOA), which is an smart contract account whose address is derived from the name; and - owner(s) of the name that can deploy and manipulate the owned account. The following diagram illustrates the relationship between NOA, name node, and name owner, with the ownership being guaranteed by the name service. ┌───────────────┐

MOTIVATION:
Name itself cannot hold any context. We want to build an extension of name service to give name rich context by offering each name owner an extra ready to use smart contract account, which may help the general smart contract account adoption. With NOA, it is possible to hold assets and information for its name node, opening up new use cases such as name node transfers, which involve transferring ownership of the name node as well as the NOA, including any assets and information it holds.

RATIONALE:
To achieve a one-to-one mapping from the name to the NOA, where each NOA's address is derived from the name node, we must include the name node information in each NOA to reflect its name node ownership. The "name()" function can be used to retrieve this property of each NOA and enable reverse tracking to its name node. The "nameService()" function can get the name service contract address where the name is registered, to perform behaviors such as validation checks. Through these two methods, the NOA has the ability to track back to its actual owner who owns


=== ERC-7087 ===
TITLE: MIME type for Web3 URL in Auto Mode
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-05-28
REQUIRES: 6860

SUMMARY:
This standard extends the [ERC-6860](./eip-6860.md) `web3://` standard: in smart contracts not designed for `web3://` (thus using auto mode), the MIME type of the returned data is either implicit (not advertised by the smart contract) or included within the returned data ([RFC 2397](https://www.rfc-editor.org/rfc/rfc2397) data URLs). This standard defines additional query parameters so that a MIME type can be returned when fetching a `web3://` URL in these scenarios.

SPECIFICATION:
The standard introduces three query parameters to determine the MIME type. - `mime.content=<contentType>`, where `<contentType>` is a MIME type defined in [RFC 6838](https://www.rfc-editor.org/rfc/rfc6838). If the `<contentType>` does not follow the structure of a MIME type, the URL is not fetched and an error message is displayed to the user. After URL decoding, `<contentType>` is set as the value of the `Content-Type` header of the response; or - `mime.type=<fileType>`, where `<fileType>` is a filename extension from which a MIME type is determined. If the filename extension is not recognized, the URL is not fetched and an error message is

MOTIVATION:
When returning data to the web browser, a `Content-Type` header indicating the MIME type of the data is strongly recommended, or the data may be incorrectly interpreted and displayed by the web browser. The `web3://` protocol has 2 modes: manual and auto. - The manual mode is used on smart contracts explicitly requesting this mode (via an interface), so they are expected to signal the MIME type of the returned data, with the mechanism described in [ERC-6860](./eip-6860.md). - On the other hand, the auto mode is used on both smart contracts specifically requesting the mode, and for all

RATIONALE:
The standard uses three different query parameters rather than a single query parameter to avoid confusion - an implementer or a user can easily tell the expected returned MIME of a link. Further, in auto mode, the query parameters are not used to form the EVM message (e.g., calldata) and thus it is safe to introduce new query parameters.


=== ERC-7837 ===
TITLE: Diffusive Tokens
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-12-07
REQUIRES: 

SUMMARY:
This ERC proposes a standard for a new type of fungible token, called **Diffusive Tokens (DIFF)**. Unlike traditional [ERC-20](./eip-20.md) tokens, transferring DIFF tokens does not decrease the sender’s balance. Instead, it *mints* new tokens directly to the recipient, increasing the total supply on every transfer action. A fixed native currency fee is charged per token transferred, and this fee is paid by the sender to the contract owner. The supply growth is limited by a maximum supply set by the owner. Token holders can also burn their tokens to reduce the total supply. These features enable a controlled,

SPECIFICATION:
### Terminology - **Diffusive Token**: A fungible token unit that is minted on transfers. - **Max Supply**: The maximum total supply the token can reach. - **Transfer Fee**: A fee in native blockchain currency (e.g., ETH) that must be paid by the sender for each token transferred. The total fee = `transferFee * amount`. - **Burn**: The action of destroying tokens, reducing both the holder’s balance and the total supply. ### Data Structures - **Total Supply and Max Supply**: ```solidity uint256 public totalSupply; uint256 public maxSupply; ``` - **Transfer Fee**: ```solidity uint256 public transferFee; // fee per token

MOTIVATION:
Traditional [ERC-20](./eip-20.md) tokens maintain a constant total supply and simply redistribute balances on transfers. While this model is widespread, certain use cases benefit from a token design that continuously expands supply during transfers, simulating a controlled "diffusion" of value. The Diffusive Token model may be suitable for representing claims on real-world goods (e.g., a product batch like iPhone 15 units), digital goods, or controlled asset distributions where initial token distribution and ongoing availability need to be managed differently. This model also includes a native currency fee per token transferred, incentivizing careful, value-driven transfers and providing a revenue stream

RATIONALE:
**Design Decisions**: - **Unlimited Minting vs. Max Supply**: Allowing minting on every transfer provides a “diffusive” spread of tokens. The `maxSupply` prevents uncontrolled inflation. - **Burn Mechanism**: Enables redemption or deflation as tokens are taken out of circulation. - **Owner Controls**: The owner (e.g., issuer) can adjust fees and max supply, maintaining flexibility as market conditions change.


=== ERC-5630 ===
TITLE: New approach for encryption / decryption
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-09-07
REQUIRES: 

SUMMARY:
This EIP proposes a new way to encrypt and decrypt using Ethereum keys. This EIP uses _only_ the `secp256k1` curve, and proposes two new RPC methods: `eth_getEncryptionPublicKey` and `eth_performECDH`. These two methods, in conjunction, allow users to receive encryptions and perform decryptions (respectively). We require that the wallet _only_ perform the core ECDH operation, leaving the ECIES operations up to implementers (we do suggest a standardized version of ECIES, however). In contrast, a previous EIPs used the same secret key, in both signing and encryption, on two _different_ curves (namely, `secp256k1` and `ec25519`), and hardcoded a particular version

SPECIFICATION:
We describe our approach here; we compare our approach to prior EIPs in the **Rationale** section below. Throughout, we make reference to SEC 1: Elliptic Curve Cryptography, by Daniel R. L. Brown. We use the `secp256k1` curve for both signing and encryption. For encryption, we use ECIES. We specify that the wallet _only_ perform the sensitive ECDH operation. This lets implementers select their own ECIES variants at will. We propose that all binary data be serialized to and from `0x`-prefixed hex strings. We moreover use `0x`-prefixed hex strings to specify private keys and public keys, and represent public

MOTIVATION:
We discuss a few motivating examples. One key motivation is direct-to-address encryption on Ethereum. Using our EIP, one can directly send encrypted messages to some desired recipient on-chain, without having a prior direct channel to that recipient. (Note that in this EIP, we standardize _only_ the encryption procedure—that is, the generation of the ciphertext—and _not_ how exactly the on-chain message should be sent. In practice, ideally, smart-contract infrastructure will be set up for this purpose; barring this, encryptors could make use of the raw `data` field available in each standard transfer.) We discuss a second sort of example.

RATIONALE:
There is _no security proof_ for a scheme which simultaneously invokes signing on the `secp256k1` curve and encryption on the `ec25519` curve, and where _the same secret key is moreover used in both cases_. Though no attacks are known, it is not desirable to use a scheme which lacks a proof in this way. We, instead, propose the reuse of the same key in signing and encryption, but where _the same curve is used in both_. This very setting has been studied in prior work; see, e.g., Degabriele, Lehmann, Paterson, Smart and Strefler, _On the Joint Security of


=== ERC-5585 ===
TITLE: ERC-721 NFT Authorization
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-08-15
REQUIRES: 721

SUMMARY:
This EIP separates the [ERC-721](./eip-721.md) NFT's commercial usage rights from its ownership to allow for the independent management of those rights.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Contract Interface ```solidity interface IERC5585 { struct UserRecord { address user; string[] rights; uint256 expires; } /// @notice Get all available rights of this NFT project /// @return All the rights that can be authorized to the user function getRights() external view returns(string[]); /// @notice NFT holder authorizes all the rights of the NFT to a user for a specified period of time /// @dev The zero address indicates

MOTIVATION:
Most NFTs have a simplified ownership verification mechanism, with a sole owner of an NFT. Under this model, other rights, such as display, or creating derivative works or distribution, are not possible to grant, limiting the value and commercialization of NFTs. Therefore, the separation of an NFT's ownership and user rights can enhance its commercial value. Commercial right is a broad concept based on the copyright, including the rights of copy, display, distribution, renting, commercial use, modify, reproduce and sublicense etc. With the development of the Metaverse, NFTs are becoming more diverse, with new use cases such as

RATIONALE:
First of all, NFT contract owner can set the maximum number of authorized users to each NFT and whether the NFT owner can cancel the authorization at any time to protect the interests of the parties involved. Secondly, there is a `resetAllowed` flag to control the rights between the NFT owner and the users for the contract owner. If the flag is set to true, then the NFT owner can disable usage rights of all authorized users at any time. Thirdly, the rights within the user record struct is used to store what rights has been authorized to


=== ERC-681 ===
TITLE: URL Format for Transaction Requests
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2017-08-01
REQUIRES: 2, 0, ,,  , 1, 3, 7

SUMMARY:
URLs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URL format for payment requests allows for instant invocation of the user's preferred wallet application (even if it is a webapp or a swarm đapp), with the correct parameterization of the payment transaction only to be confirmed by the (authenticated) user.

SPECIFICATION:
### Syntax Payment request URLs contain "ethereum" in their schema (protocol) part and are constructed as follows: request = schema_prefix target_address [ "@" chain_id ] [ "/" function_name ] [ "?" parameters ] schema_prefix = "ethereum" ":" [ "pay-" ] target_address = ethereum_address chain_id = 1*DIGIT function_name = STRING ethereum_address = ( "0x" 40*HEXDIG ) / ENS_NAME parameters = parameter *( "&" parameter ) parameter = key "=" value key = "value" / "gas" / "gasLimit" / "gasPrice" / TYPE value = number / ethereum_address / STRING number = [ "-" / "+" ] *DIGIT [ "." 1*DIGIT

MOTIVATION:
The convenience of representing payment requests by standard URLs has been a major factor in the wide adoption of Bitcoin. Bringing a similarly convenient mechanism to Ethereum would speed up its acceptance as a payment platform among end-users. In particular, URLs embedded in broadcast Intents are the preferred way of launching applications on the Android operating system and work across practically all applications. Desktop web browsers have a standardized way of defining protocol handlers for URLs with specific protocol specifications. Other desktop applications typically launch the web browser upon encountering a URL. Thus, payment request URLs could be

RATIONALE:
The proposed format is chosen to resemble `bitcoin:` URLs as closely as possible, as both users and application programmers are already familiar with that format. In particular, this motivated the omission of the unit, which is often used in Ethereum ecosystem. Handling different orders of magnitude is facilitated by the exponent so that amount values can be expressed in their nominal units, just like in the case of `bitcoin:`. The use of scientific notation is strongly encouraged when expressing monetary value in ether or [ERC-20](./eip-20.md) tokens. For better human readability, the exponent should be the decimal value of


=== ERC-1523 ===
TITLE: Standard for Insurance Policies as ERC-721 Non Fungible Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-10-10
REQUIRES: 721

SUMMARY:
The following standard allows for the implementation of a standard API for insurance policies within smart contracts. Insurance policies are financial assets which are unique in some aspects, as they are connected to a customer, a specific risk, or have other unique properties like premium, period, carrier, underwriter etc. Nevertheless, there are many potential applications where insurance policies can be traded, transferred or otherwise treated as an asset. The ERC 721 standard already provides the standard and technical means to handle policies as a specific class of non fungible tokens. insurance In this proposal, we define a minimum

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. An ERC-1523 compliant insurance policy is a non-fungible token which **MUST adhere to the ERC-721 token standard** and **MUST implement theERC721Metadata and the ERC721Enumerable interface**: ```solidity /// @title ERC-1523 Insurance Policy Standard /// Note: the ERC-165 identifier for this interface is 0x5a04be32 interface ERC1523 /* is ERC721, ERC721Metadata, ERC721Enumerable */ { } ``` The implementor MAY choose values for the ```name``` and ```symbol```. The **policy metadata extension** is **RECOMMENDED**

MOTIVATION:
For a decentralized insurance protocol, a standard for insurance policies is crucial for interoperability of the involved services and application. It allows policies to be bundled, securitized, traded in a uniform and flexible way by many independent actors like syndicates, brokers, and insurance companies.

RATIONALE:
Insurance policies form an important class of financial assets, and it is natural to express those assets as a class of non-fungible tokens which adhere to the established ERC-721 standard. We propose a standard for the accompanying metadata structures which are needed to uniquely define an insurance policy. Standardization is key because we expect decentralized insurance to receive widespread adoption and it is crucial to establish a unified standard to enable composability and the creation of universal toolsets. We therefore propose a standardized naming scheme for the different parameters describing an insurance policy. We propose three mandatory parameters


=== ERC-1450 ===
TITLE: ERC-1450 A compatible security token for issuing and trading SEC-compliant securities
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-25
REQUIRES: 

SUMMARY:
`ERC-1450` facilitates the recording of ownership and transfer of securities sold in compliance with the [Securities Act Regulations CF, D and A](https://www.sec.gov/smallbusiness/exemptofferings). The issuance and trading of securities is subject to the Securities Exchange Commission (SEC) and specific U.S. state blue sky laws and regulations. `ERC-1450` manages securities ownership during issuance and trading. The Issuer is the only role that should create a `ERC-1450` and assign the RTA. The RTA is the only role that is allowed to execute `ERC-1450`’s `mint`, `burnFrom`, and `transferFrom` functions. No role is allowed to execute `ERC-1450`’s `transfer` function.

SPECIFICATION:
`ERC-1450` extends `ERC-20`. ### `ERC-1450` `ERC-1450` requires that only the Issuer can create a token representing the security that only the RTA manages. Instantiating the `ERC-1450` requires the `Owned` and `IssuerControlled` modifiers, and only the Issuer should execute the `ERC-1450` constructor for a compliant token. `ERC-1450` extends the general `Ownable` modifier to describe a specific subset of owners that automate and decentralize compliance through the contract modifiers `Owned` and `IssuerControlled` and the function modifiers `onlyOwner` and `onlyIssuerTransferAgent`. The `Owned` contract modifier instantiates the `onlyOwner` modifier for functions. The `IssuerControlled` modifier instantiates the `onlyIssuerTransferAgent` modifier for functions. `ERC-1450` must

MOTIVATION:
With the advent of the [JOBS Act](https://www.sec.gov/spotlight/jobs-act.shtml) in 2012 and the launch of Regulation Crowdfunding and the amendments to Regulation A and Regulation D in 2016, there has been an expansion in the exemptions available to Issuers and Investors to sell and purchase securities that have not been "registered" with the SEC under the Securities Act of 1933. There are currently no token standards that expressly facilitate conformity to securities law and related regulations. ERC-20 tokens do not support the regulated roles of Funding Portal, Broker Dealer, RTA, and Investor and do not support the [Bank Secrecy Act/USA

RATIONALE:
The are currently no token standards that facilitate compliance with SEC regulations. The closest token is [ERC-884 (Delaware General Corporations Law (DGCL) compatible share token)](./eip-884.md) which states that SEC requirements are out of scope. [EIP-1404 (Simple Restricted Token Standard)](https://github.com/ethereum/EIPs/issues/1404) does not go far enough to address SEC requirements around re-issuing securities to Investors.


=== ERC-1753 ===
TITLE: Smart Contract Interface for Licences
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-02-06
REQUIRES: 

SUMMARY:
This Ethereum Improvement Proposal (EIP) proposes an Ethereum standard for the issuance of licences, permits and grants (Licences). A Licence is a limited and temporary authority, granted to a natural (e.g. you) or legal person (e.g. a corporation), to do something that would otherwise be unlawful pursuant to a legal framework. A public Licence is granted by the government, directly (e.g. by the New South Wales Department of Primary Industries, Australia) or indirectly (e.g. by an agent operating under the government’s authority), and derives its authority from legislation, though this is often practically achieved via delegated legislation such

SPECIFICATION:
### Methods **NOTES**: - The following specifications use syntax from Solidity `0.4.17` (or above) - Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned! #### name Returns the name of the permit - e.g. `"MyPermit"`. ``` js function name() public view returns (string); ``` #### totalSupply Returns the total permit supply. ``` js function totalSupply() public view returns (uint256); ``` #### grantAuthority Adds an ethereum address to a white list of addresses that have authority to modify a permit. ``` js function grantAuthority(address who) public; ``` #### revokeAuthority Removes an

MOTIVATION:
Governments are responsible for the issuance and management of Licences. However, maintaining and sharing this data can be complicated and inefficient. The granting of Licences usually requires the filing of paper-based application forms, manual oversight of applicable legislation and data entry into registries, as well as the issuance of paper based Licences. If individuals wish to sight information on Licence registries, they often need to be present at the government office and complete further paper-based enquiry forms in order to access that data (if available publicly). This EIP seeks to define a standard that will allow for the

RATIONALE:
The use of smart contracts to apply for, renew, suspend and revoke Licences will free up much needed government resources and allow for the more efficient management of Licences. The EIP also seeks to improve the end user experience of the Licence system. In an era of open government, there is also an increased expectation that individuals will be able to easily access Licence registries, and that the process will be transparent and fair. By creating an EIP, we hope to increase the use of Ethereum based and issued Licences, which will address these issues. The Ethereum blockchain


=== ERC-7588 ===
TITLE: Blob Transactions Metadata JSON Schema
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2024-01-01
REQUIRES: 4844

SUMMARY:
This EIP introduces a standard for attaching metadata to blobs carried by blob transactions, as outlined in [EIP-4844](./eip-4844.md). The metadata is represented as a JSON object adhering to a predefined schema, and its string representation is placed in the data field of the blob transaction.

SPECIFICATION:
### Metadata JSON Schema The metadata is represented as a JSON object adhering to the following JSON Schema: ```json { "title": "Blobs Metadata", "type": "object", "properties": { "originator": { "type": "string", "description": "Identifies the originator of the carried blobs" }, "description": { "type": "string", "description": "Describes the contents of the blobs" }, "content_type": { "type": "string", "description": "Describes the MIME type of the blobs. The MIME type should be defined in RFC 2046 (https://www.rfc-editor.org/rfc/rfc2046)" }, "extras": { "type": "string", "description": "Dynamic extra information related to the blobs" }, "blobs": { "type": "array", "description": "Metadata of the i'th blob.

MOTIVATION:
[EIP-4844](./eip-4844.md) defines a new type of transaction known as a “blob transaction.” These transactions contain a list of blobs along with their KZG commitments and proofs. Blob transactions serve as a mechanism for rollups to post their layer 2 transaction data to Ethereum layer 1. While rollups typically manage their own posted blob transactions, third-party solutions (such as Portal Network and blobscan) may also index all blobs ever posted to Ethereum, and provide querying services for blobs. By attaching metadata to blobs, such as information about the originator, a description, or content type, we can significantly enhance the

RATIONALE:
In the Ethereum ecosystem, various types of transactions exist, each serving different purposes. The usage of the data field within these transactions varies: - **Regular Funds Transfer Transactions**: In these transactions, the data field is typically not used, and users may optionally include arbitrary data. - **Smart Contract Deployment Transactions**: For deploying smart contracts. The data field holds the contract bytecode and any encoded arguments required by the constructor. - **Smart Contract Function Call Transactions**: When invoking smart contract functions, the data field contains the function call data, including the function signature and any necessary parameters. Blob transactions


=== ERC-5719 ===
TITLE: Signature replacement interface
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-09-26
REQUIRES: 1271

SUMMARY:
Smart contract wallet signed messages can become stale, meaning a signature that once was valid could become invalid at any point. Signatures MAY become stale for reasons like: * The internal set of signers changed * The wallet makes signatures expirable * The contract was updated to a new implementation The following standard allows smart contract wallets to expose a URI that clients can use to replace a stale signature with a valid one.

SPECIFICATION:
The wallet contract MUST implement the following function: ```solidity function getAlternativeSignature(bytes32 _digest) external view returns (string); ``` The returned string MUST be a URI pointing to a JSON object with the following schema: ```json { "title": "Signature alternative", "type": "object", "properties": { "blockHash": { "type": "string", "description": "A block.hash on which the signature should be valid." }, "signature": { "type": "string", "description": "The alternative signature for the given digest." } } } ``` ### Client process for replacing a signature A client is an entity that holds a signature and intends to validate it, either for off-chain or

MOTIVATION:
In contrast to EOA signatures, [EIP-1271](./eip-1271.md) signatures are not necessarily idempotent; they can become invalid at any point in time. This poses a challenge to protocols that rely on signatures remaining valid for extended periods of time. A signature MAY need to be mutated due to one of the following scenarios: 1. The wallet removes a signer that contributed to signing the initial message. 2. The wallet uses a Merkle tree to store signers, adding a new signer. 3. The wallet uses a Merkle tree to store signatures, adding new signatures. 4. The wallet is updated to a

RATIONALE:
A URI is chosen because it can accommodate centralized and decentralized solutions. For example, a server can implement live re-encoding for Merkle proofs, or an IPFS link could point to a directory with all the pre-computed signature mutations. The `getAlternativeSignature` method points to an off-chain source because it's expected that the smart contract wallet doesn't contain on-chain records for all signed digests, if that were the case then such contract wouldn't need to use this EIP since it could directly validate the `digest` on`isValidSignature` ignoring the stale signature.


=== ERC-1388 ===
TITLE: Attestation Issuers Management List
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-08
REQUIRES: 


=== ERC-1761 ===
TITLE: Scoped Approval Interface
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-02-18
REQUIRES: 165

SUMMARY:
This interface is designed for use with token contracts that have an "ID" domain, such as ERC-1155 or ERC-721. This enables restricted approval of one or more Token IDs to a specific "scope". When considering a smart contract managing tokens from multiple different domains, it makes sense to limit approvals to those domains. Scoped approval is a generalization of this idea. Implementors can define scopes as needed. Sample use cases for scopes: * A company may represent its fleet of vehicles on the blockchain and it could create a scope for each regional office. * Game developers could

MOTIVATION:
It may be desired to restrict approval in some applications. Restricted approval can prevent losses in cases where users do not audit the contracts they're approving. No standard API is supplied to manage scopes as this is implementation specific. Some implementations may opt to offer a fixed number of scopes, or assign a specific set of scopes to certain types. Other implementations may open up scope configuration to its users and offer methods to create scopes and assign IDs to them. # Specification ```solidity pragma solidity ^0.5.2; /** Note: The ERC-165 identifier for this interface is 0x30168307. */

RATIONALE:
The initial design was proposed as an extension to ERC-1155: [Discussion Thread - Comment 1](https://github.com/ethereum/EIPs/issues/1155#issuecomment-459505728). After some discussion: [Comment 2](https://github.com/ethereum/EIPs/issues/1155#issuecomment-460603439) and suggestions by the community to implement this approval mechanism in an external contract [Comment 3](https://github.com/ethereum/EIPs/issues/1155#issuecomment-461758755), it was decided that as an interface standard, this design would allow many different token standards such as ERC-721 and ERC-1155 to implement scoped approvals without forcing the system into all implementations of the tokens. ### Metadata JSON The Scope Metadata JSON Schema was added in order to support human-readable scope names and descriptions in more than one language.


=== ERC-2020 ===
TITLE: E-Money Standard Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-05-10
REQUIRES: 2, 0, ,,  , 1, 0, 6, 6, ,,  , 1, 9, 9, 6, ,,  , 2, 0, 0, 9, ,,  , 2, 0, 1, 8, ,,  , 2, 0, 1, 9, ,,  , 2, 0, 2, 1

SUMMARY:
Financial institutions work today with electronic systems, which hold account balances in databases on core banking systems. In order for an institution to be allowed to maintain records of client balances segregated and available for clients, such institution must be regulated under a known legal framework and must possess a license to do so. Maintaining a license under regulatory supervision entails ensuring compliance (i.e. performing KYC on all clients and ensuring good AML practices before allowing transactions) and demonstrating technical and operational solvency through periodic audits, so clients depositing funds with the institution can rest assured that their

SPECIFICATION:
```solidity interface EMoneyToken /* is ERC-1996, ERC-2018, ERC-2019, ERC-2021 */ { function currency() external view returns (string memory); function version() external pure returns (string memory); function availableFunds(address account) external view returns (uint256); function checkTransferAllowed(address from, address to, uint256 value) external view returns (byte status); function checkApproveAllowed(address from, address spender, uint256 value) external view returns (byte status); function checkHoldAllowed(address from, address to, address notary, uint256 value) external view returns (byte status); function checkAuthorizeHoldOperatorAllowed(address operator, address from) external view returns (byte status); function checkOrderTransferAllowed(address from, address to, uint256 value) external view returns (byte status); function checkAuthorizeClearableTransferOperatorAllowed(address operator, address from) external

MOTIVATION:
There are only a number of potential regulatory license frameworks that allow institutions to issue and hold money balances for customers (be it retail corporate or institutional types). The most important and practical ones are three: * **Electronic money entities**: these are legally regulated vehicles that are mostly used today for cash and payments services, instead of more complex financial services. For example prepaid cards or online payment systems such as PayPal run on such schemes. In most jurisdictions, electronic money balances are required to be 100% backed by assets, which often entails holding cash on an omnibus

RATIONALE:
This EIP unifies [ERC-1996][ERC-1996], [ERC-2018][ERC-2018], [ERC-2019][ERC-2019] and [ERC-2021][ERC-2021] and adds the checks for the compliance on top of it. By this way the separate EIPs are otherwise independent of each other, and the E-Money Standard Token offers a solution for all necessary functionality of regulated electronic money. While not requiring it, the naming of the check functions was adopted from [ERC-1462][ERC-1462].


=== ERC-6357 ===
TITLE: Single-contract Multi-delegatecall
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2023-01-18
REQUIRES: 

SUMMARY:
This EIP standardizes an interface containing a single function, `multicall`, allowing EOAs to call multiple functions of a smart contract in a single transaction, and revert all calls if any call fails.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Contracts implementing this EIP must implement the following interface: ```solidity pragma solidity ^0.8.0; interface IMulticall { /// @notice Takes an array of abi-encoded call data, delegatecalls itself with each calldata, and returns the abi-encoded result /// @dev Reverts if any delegatecall reverts /// @param data The abi-encoded data /// @returns results The abi-encoded return values function multicall(bytes[] calldata data) external virtual returns (bytes[] memory

MOTIVATION:
Currently, in order to transfer several [ERC-721](./eip-721.md) NFTs, one needs to submit a number of transactions equal to the number of NFTs being tranferred. This wastes users' funds by requiring them to pay 21000 gas fee for every NFT they transfer.

RATIONALE:
`multicallPayable` is optional because it isn't always feasible to implement, due to the `msg.value` splitting.


=== ERC-4885 ===
TITLE: Subscription NFTs and Multi Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-03-08
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
The following standard allows for the implementation of a standard API for subscribing to non-fungible and multi tokens. [EIP-20](./eip-20.md) tokens are deposited in exchange for subscription tokens that give the right to use said non-fungible and multi tokens for a specified time limited or unlimited period.

SPECIFICATION:
The subscriber deposits EIP-20 to receive an NFT and subscription. Subscription tokens balance automatically decreases linearly over the lifetime of usage of the NFT, and use of the NFT is disabled once the subscription token balance falls to zero. The subscriber can top up the balance to extend the lifetime of the subscription by depositing EIP-20 tokens in exchange for more subscription tokens. Smart contracts implementing this EIP standard MUST implement the [EIP-165](./eip-165.md) supportsInterface function and MUST return the constant value true if 0xC1A48422 is passed through the interfaceID argument. Note that revert in this document MAY mean

MOTIVATION:
This standard offers a flexible, general purpose way to subscribe to the use of assets or services offered by [EIP-721](./eip-721.md) or [EIP-1155](./eip-1155.md) contracts. From here on in, for the sake of simplicity, these contracts will be known as NFTs; the provider is the issuer of said NFTs and the subscriber(s) uses them. This proposal was originally conceived from the want to give creators of music and film, back control. The distribution and delivery of digital content is currently the purview of centralised tech corporations who offer homogeneous subscription models to their customers. This proposal specifies a standard for

RATIONALE:
### Tokenisation of subscriptions The subscription itself has value when it is exchanged for a deposit. This proposal enables subscriptions to be 'tokenised' thus secondary markets can exist where the subscription tokens can be bought and sold. For example, a fan might want to sell their season ticket, that gives access to live sporting events, on to another fan. This would not be as easily possible if there was only a date expiry extension feature added to NFTs. An implementer can simply implement the rest of the EIP-20 functions for subscription tokens to be traded. It is left


=== ERC-6170 ===
TITLE: Cross-Chain Messaging Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-12-19
REQUIRES: 

SUMMARY:
This EIP introduces a common interface for cross-chain arbitrary message bridges (AMBs) to send and receive a cross-chain message (state).

SPECIFICATION:
The keywords "MUST," "MUST NOT," "REQUIRED," "SHALL," "SHALL NOT," "SHOULD," "SHOULD NOT," "RECOMMENDED," "MAY," and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. Every compliant cross-chain arbitrary message bridge must implement the following interface. ``` solidity // SPDX-License-Identifier: Apache-3.0 pragma solidity >=0.8.0; /// @title Cross-Chain Messaging interface /// @dev Allows seamless interchain messaging. /// @author Sujith Somraaj /// Note: Bytes are used throughout the implementation to support non-evm chains. interface IEIP6170 { /// @dev This emits when a cross-chain message is sent. /// Note: MessageSent MUST trigger when a message is sent, including

MOTIVATION:
Currently, cross-chain arbitrary message bridges lack standardization, resulting in complex competing implementations: Layerzero, Hyperlane, Axelar, Wormhole, Matic State Tunnel and others. Either chain native (or) seperate message bridge, the problem prevails. Adding a common standardized interface to the arbitrary message bridges provides these benefits: - **Ease Of Development:** A common standard interface would help developers build scalable cross-chain applications with ease. - **Improved Scalability:** Cross-chain applications can efficiently use multiple message bridges. - **Improved Security:** Confronting security to specific parameters. At present, every message bridge has its diverse security variable. E.g., In Layerzero, the nonce is used to

RATIONALE:
The cross-chain arbitrary messaging interface will optimize the interoperability layer between blockchains with a feature-complete yet minimal interface. The light-weighted approach also provides arbitrary message bridges, and the freedom of innovating at the relayer level, to show their technical might. The EIP will make blockchains more usable and scalable. It opens up the possibilities for building cross-chain applications by leveraging any two blockchains, not just those limited to Ethereum and compatible L2s. To put this into perspective, an easy-to-communicate mechanism will allow developers to build cross-chain applications across Ethereum and Solana, leveraging their unique advantages. The interface also


=== ERC-7629 ===
TITLE: ERC-20/ERC-721 Unified Token Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-18
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal introduces a protocol that establishes a unified interface for managing both [ERC-20](./eip-20.md) fungible tokens and [ERC-721](./eip-721.md) non-fungible tokens (NFTs) on the Ethereum blockchain. By defining a common set of functions applicable to both token types, developers can seamlessly interact with [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md) tokens using a single interface. This simplifies integration efforts and enhances interoperability within decentralized applications (DApps).

SPECIFICATION:
- Introduces a token contract that combines features from both [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md) standards. - Supports state transitions between [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md) modes, facilitating seamless conversion and utilization of both liquidity and non-fungibility. - Defines essential functions and events to support token interactions, conversions, and queries. - Implements low gas consumption [ERC-20](./eip-20.md) mode to maintain efficiency comparable to typical [ERC-20](./eip-20.md) token transfers. Compliant contracts MUST implement the following Solidity interface: ```solidity pragma solidity ^0.8.0; /** * @title ERC-7629 Unify Token Interface * @dev This interface defines the ERC-7629 Unify Token, which unifies ERC-721 and ERC-20 assets. */ interface

MOTIVATION:
The proposal aims to address the demand for assets combining the liquidity of [ERC-20](./eip-20.md) tokens and the uniqueness of [ERC-721](./eip-721.md) tokens. Current standards present a fragmentation, requiring users to choose between these features. This proposal fills that gap by providing a unified token interface, enabling smooth transitions between [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md) characteristics to accommodate diverse blockchain applications.

RATIONALE:
Common Interface for Different Token Types: - Introduces a unified interface to address the fragmentation caused by separate [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md) standards. - Standardizes functions like transferFrom, mint, and burn, enabling developers to interact with both token types without implementing distinct logic. Transfer Functionality: - Includes transferFrom function for seamless movement of tokens between addresses, as it's a core component of both [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md) standards. Minting and Burning: - Incorporates mint and burn functions for creating and destroying tokens, essential for managing token supply and lifecycle. Balance and Ownership Queries: - Provides functions like balanceOf and ownerOf


=== ERC-4546 ===
TITLE: Wrapped Deposits
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-12-11
REQUIRES: 

SUMMARY:
The wrapped deposit contract handles deposits of assets (Ether, [ERC-20](./eip-20.md), [ERC-721](./eip-721.md)) on behalf of a user. A user must only approve a spend limit once and then an asset may be deposited to any number of different applications that support deposits from the contract.

SPECIFICATION:
The wrapped deposit contract SHOULD be deployed at an identifiable address (e.g. `0x1111119a9e30bceadf9f939390293ffacef93fe9`). The contract MUST be non-upgradable with no ability for state variables to be changed. The wrapped deposit contract MUST have the following public functions: ```js depositERC20(address to, address token, uint amount) external; depositERC721(address to, address token, uint tokenId) external; safeDepositERC721(address to, address token, uint tokenId, bytes memory data) external; safeDepositERC1155(address to, address token, uint tokenId, uint value, bytes calldata data) external; batchDepositERC1155(address to, address token, uint[] calldata tokenIds, uint[] calldata values, bytes calldata data) external; depositEther(address to) external payable; ``` Each of these functions MUST

MOTIVATION:
The current user flow for depositing assets in dapps is unnecessarily expensive and insecure. To deposit an ERC-20 asset a user must either: - send an approve transaction for the exact amount being sent, before making a deposit, and then repeat this process for every subsequent deposit. - send an approve transaction for an infinite spend amount before making deposits. The first option is inconvenient, and expensive. The second option is insecure. Further, explaining approvals to new or non-technical users is confusing. This has to be done in _every_ dapp that supports ERC20 deposits.

RATIONALE:
Having a single contract that processes all token transfers allows users to submit a single approval per token to deposit to any number of contracts. The user does not have to trust receiving contracts with token spend approvals and receiving contracts have their complexity reduced by not having to implement token transfers themselves. User experience is improved because a simple global dapp can be implemented with the messaging: "enable token for use in other apps".


=== ERC-5750 ===
TITLE: General Extensibility for Method Behaviors
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-10-04
REQUIRES: 165

SUMMARY:
This EIP standardizes the passing of unstructured call data to functions to enable future extensibility.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. When used in this EIP, the term `bytes` MUST be interpreted as the dynamically-sized byte array in Solidity data types. 1. Unlike many other ERCs which is compliant at the `contract` level, this ERC's specification specify compliance at `method` level. 2. Any method with a bytes as this method's last parameter is an _eligible_ method. It looks like this `function methodName(type1 value1, type2 value2, ... bytes

MOTIVATION:
The purpose of having extra data in a method is to allow further extensions to existing method interfaces. It is it useful to make methods extendable. Any methods complying with this EIP, such as overloaded `transfer` and `vote` could use string reasons as the extra data. Existing EIPs that have exported methods compliant with this EIP can be extended for behaviors such as using the extra data to prove endorsement, as a salt, as a nonce, or as a commitment for a reveal/commit scheme. Finally, data can be passed forward to callbacks. There are two ways to achieve

RATIONALE:
1. Using the dynamically-sized `bytes` type allows for maximum flexibility by enabling payloads of arbitrary types. 2. Having the bytes specified as the last parameter makes this EIP compatible with the calldata layout of solidity.


=== ERC-7734 ===
TITLE: Decentralized Identity Verification (DID)
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2024-06-26
REQUIRES: 

SUMMARY:
This proposal introduces a standard for decentralized identity verification (DID) on the blockchain. The standard leverages cryptographic hashes to represent identity proofs and events for transparency and traceability. By emphasizing simplicity, privacy, and user control, this proposal aims to reduce overhead for developers and users, ensuring seamless integration into decentralized applications (dApps). It offers a minimalistic solution that keeps identity structure simple and enables off-chain mechanisms for detailed identity management and verification.

SPECIFICATION:
The Decentralized Identity Verification (DID) standard introduces a simple, secure, and privacy-preserving mechanism for verifying user identities on the blockchain. The key components of this standard are outlined below: #### Identity Contract A smart contract that acts as the central authority for identity verification. The contract stores the status of identity verifications for users and ensures that verification events are triggered securely and transparently. #### Verification Function The `verifyIdentity` function allows a user to submit two verification hashes that represent off-chain proofs or attestations of identity. These hashes can be derived from external sources such as third-party verifiers,

MOTIVATION:
Centralized identity verification methods are cumbersome, prone to data breaches, and fail to provide users control over their identity data. Existing DID solutions often introduce complexity, making adoption challenging for developers and users. This proposal seeks to address these issues by: - Offering a minimalistic, decentralized standard that simplifies identity verification. - Providing privacy-preserving mechanisms that keep sensitive identity data off-chain. - Encouraging wider adoption by enabling seamless integration into dApps across various industries. ### Stakeholders The following stakeholders will benefit from this proposal: #### dApp Developers Developers creating decentralized applications that require identity verification can implement this

RATIONALE:
The design leverages cryptographic hashes to represent identity information, ensuring that sensitive data is not stored directly on the blockchain. The use of `verificationHashes` allows for flexible identity verification mechanisms. These hashes could be derived from various off-chain proofs, such as cryptographic challenges or attestations, depending on the implementer's needs. By leaving the interpretation of the verification hashes open, the standard enables adaptability while maintaining privacy and security. Additionally, the inclusion of events ensures transparency and traceability.


=== ERC-5437 ===
TITLE: Security Contact Interface
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-09
REQUIRES: 165

SUMMARY:
An interface for security notice using asymmetric encryption. The interface exposes a asymmetric encryption key and a destination of delivery.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity interface IEIP5437 { /// REQUIRED function getSecurityContact(uint8 type, bytes memory data) public view returns ( uint8 type, bytes memory publicKey, bytes memory extraData ); /// OPTIONAL // TODO consider remove if not needed before finalized function setSecurityContact( uint8 type, bytes memory publicKey, bytes memory extraData) public; event SecurityContactChanged(uint8 type, bytes memory publicKeyForEncryption, bytes memory extraData); /// OPTIONAL function securityNotify(uint8 type, bytes memory data) public payable; /// OPTIONAL event

MOTIVATION:
Currently there is no consistent way to specify an official channel for security researchers to report security issues to smart contract maintainers.

RATIONALE:
1. For simplicity, this EIP specifies a simple GPG scheme with a given encryption scheme and uses email addresses as a contact method. It's possible that future EIPs will specify new encryption schemes or delivery methods. 2. This EIP adds an optional method, `setSecurityContact`, to set the security contact, because it might change due to circumstances such as the expiration of the cryptographic keys. 3. This EIP explicitly marks `securityNotify` as `payable`, in order to allow implementers to set a staking amount to report a security vulnerability. 4. This EIP allows for future expansion by adding the `bountyPolicy`


=== ERC-5570 ===
TITLE: Digital Receipt Non-Fungible Tokens
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-09-01
REQUIRES: 721

SUMMARY:
This ERC proposes a standard schema for digital receipts of transactions. Digital Receipt Non-Fungible Tokens are issued by a vendor when a customer makes a purchase from their store and contains transaction details necessary for record keeping. Digital Receipt Non-Fungible Tokens extend [ERC-721](./eip-721.md) which allows for the management and ownership of unique tokens.

SPECIFICATION:
Transaction Flow: - A customer purchases an item from an online retailer, checking out leads the customer to an option to mint a NFT. - The smart contract provides the user with a Digital Receipt Non-Fungible Token. - When fulfilling the order, the retailer will upload the digital receipt specified in in the JSON schema below as the metadata to the previously minted NFT. ### Digital Receipt JSON Schema The JSON schema is composed of 2 parts. The root schema contains high level details of the receipt (for example Date and Vendor) and another schema for the optionally

MOTIVATION:
Purchases from online retailers include a receipt that is emailed and/or physically provided to the customer. These receipts are critical for many reasons but are provided in an analogue form which is difficult to parse by financial systems. Digital receipts have never gained traction dispite the fact that point of sales systems are already digital and the customers often want this information in their own digital systems. So we are left with a redundant Digital -> Analogue -> Digital process which requires unnecessary data entry or the use of clunky receipt-scanning applications. Digital receipts are relatively simple and

RATIONALE:
The schema introduced complies with ERC-721's metadata extension, conveniently allowing previous tools for viewing NFTs to show our receipts. The new property "receipt" contains our newly provided receipt structure and the signature property optionally allows the vendor to digitally sign the receipt structure.


=== ERC-7401 ===
TITLE: Parent-Governed Non-Fungible Tokens Nesting
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-07-26
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
❗️ **[ERC-7401](./eip-7401.md) supersedes [ERC-6059](./eip-6059.md).** ❗️ The Parent-Governed NFT Nesting standard extends [ERC-721](./eip-721.md) by allowing for a new inter-NFT relationship and interaction. At its core, the idea behind the proposal is simple: the owner of an NFT does not have to be an Externally Owned Account (EOA) or a smart contract, it can also be an NFT. The process of nesting an NFT into another is functionally identical to sending it to another user. The process of sending a token out of another one involves issuing a transaction from the account owning the parent token. An NFT can be

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title EIP-7401 Parent-Governed Nestable Non-Fungible Tokens /// @dev See https://eips.ethereum.org/EIPS/eip-7401 /// @dev Note: the ERC-165 identifier for this interface is 0x42b0e56f. pragma solidity ^0.8.16; interface IERC7059 /* is ERC165 */ { /** * @notice The core struct of ownership. * @dev The `DirectOwner` struct is used to store information of the next immediate owner, be it the parent token, * an `ERC721Receiver` contract or an externally owned

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to own other tokens allows for greater utility, usability and forward compatibility. In the four years since [ERC-721](./eip-721.md) was published, the need for additional functionality has resulted in countless extensions. This ERC improves upon ERC-721 in the following areas: - [Bundling](#bundling) - [Collecting](#collecting) - [Membership](#membership) - [Delegation](#delegation) This proposal fixes the inconsistency in the [ERC-6059](./eip-6059.md) interface specification, where interface ID doesn't match the

RATIONALE:
Designing the proposal, we considered the following questions: 1. **How to name the proposal?**\ In an effort to provide as much information about the proposal we identified the most important aspect of the proposal; the parent centered control over nesting. The child token's role is only to be able to be `Nestable` and support a token owning it. This is how we landed on the `Parent-Centered` part of the title. 2. **Why is automatically accepting a child using [EIP-712](./eip-712.md) permit-style signatures not a part of this proposal?**\ For consistency. This proposal extends ERC-721 which already uses 1 transaction


=== ERC-2678 ===
TITLE: Revised Ethereum Smart Contract Packaging Standard (EthPM v3)
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-05-26
REQUIRES: 

SUMMARY:
This EIP defines a data format for *package manifest* documents, representing a package of one or more smart contracts, optionally including source code and any/all deployed instances across multiple networks. Package manifests are minified JSON objects, to be distributed via content addressable storage networks, such as IPFS. Packages are then published to on-chain EthPM registries, defined in [EIP-1319](./eip-1319.md), from where they can be freely accessed. This document presents a natural language description of a formal specification for version **3** of this format.

MOTIVATION:
This standard aims to encourage the Ethereum development ecosystem towards software best practices around code reuse. By defining an open, community-driven package data format standard, this effort seeks to provide support for package management tools development by offering a general-purpose solution that has been designed with observed common practices in mind. - Updates the schema for a *package manifest* to be compatible with the [metadata](https://solidity.readthedocs.io/en/latest/metadata.html) output for compilers. - Updates the `"sources"` object definition to support a wider range of source file types and serve as [JSON input](https://solidity.readthedocs.io/en/latest/using-the-compiler.html#compiler-input-and-output-json-description) for a compiler. - Moves compiler definitions to a top-level

RATIONALE:
### Minification EthPM packages are distributed as alphabetically-ordered & minified JSON to ensure consistency. Since packages are published on content-addressable filesystems (eg. IPFS), this restriction guarantees that any given set of contract assets will always resolve to the same content-addressed URI. ### Package Names Package names are restricted to lower-case characters, numbers, and `-` to improve the readability of the package name, in turn improving the security properties for a package. A user is more likely to accurately identify their target package with this restricted set of characters, and not confuse a malicious package that disguises itself as


=== ERC-5604 ===
TITLE: NFT Lien
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-09-05
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This ERC introduces NFT liens, a form of security interest over an item of property to secure the recovery of liability or performance of some other obligation. It introduces an interface to place and removes a lien, plus an event.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. 1. Any compliant contract MUST implement `ERC-721`, and `ERC-165`. 2. Any compliant contract MUST implement the following interface: ```solidity interface IERC_LIEN is ERC721, ERC165 { /// === Events === /// @notice MUST be emitted when new lien is successfully placed. /// @param tokenId the token a lien is placed on. /// @param holder the holder of the lien. /// @param extraParams of the original request to add the lien.

MOTIVATION:
Liens are widely used for finance use cases, such as car and property liens. An example use case for an NFT lien is for a deed. This ERC provides an interface to implement an interface that performs the lien holding relationships.

RATIONALE:
1. We only support `ERC-721` NFTs for simplicity and gas efficiency. We have not considered other ERCs, which can be left for future extensions. For example, `ERC-20` and `ERC-1155` were not considered. 2. We choose separate "addLienHolder" and "removeLienHolder" instead of use a single `changeLienholder` with amount because we believe the add or remove action are significantly different and usually require different Access Control, for example, the token holder shall be able to add someone else as a lien holder but the lien holder of that token. 3. We have not specified the "amount of debt" in this


=== ERC-5559 ===
TITLE: Cross Chain Write Deferral Protocol
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-06-23
REQUIRES: 712

SUMMARY:
The following standard provides a mechanism in which smart contracts can request various tasks to be resolved by an external handler. This provides a mechanism in which protocols can reduce the gas fees associated with storing data on mainnet by deferring the handling of it to another system/network. These external handlers act as an extension to the core L1 contract. This standard outlines a set of handler types that can be used for managing the execution and storage of mutations (tasks), as well as their corresponding tradeoffs. Each handler type has associated operational costs, finality guarantees, and levels

SPECIFICATION:
### Overview There are two main handler classifications: L2 Contract and Off-Chain Database. These are determined based off of where the handler is deployed. The handler classifications are used to better define the different security guarantees and requirements associated with its deployment. From a high level: - Handlers hosted on an L2 solution are EVM compatible and can use attributes native to the Ethereum ecosystem (such as address) to permission access. - Handlers hosted on an Off-Chain Database require additional parameters and signatures to correctly enforce the authenticity and check the validity of a request. A deferred mutation

MOTIVATION:
[EIP-3668](./eip-3668) provides a mechanism by which off-chain lookups can be defined inside smart contracts in a transparent manner. In addition, it provides a scheme in which the resolved data can be verified on-chain. However, there lacks a standard by which mutations can be requested through the native contract, to be performed on the off-chain data. Furthermore, with the increase in L2 solutions, smart contract engineers have additional tools that can be used to reduce the storage and transaction costs of performing mutations on the Ethereum mainnet. A specification that allows smart contracts to defer the storage and resolution

RATIONALE:
### Use of `revert` to convey call information [EIP-3668](./eip-3668) adopted the idea of using a `revert` to convey call information. It was proposed as a simple mechanism in which any pre-existing interface or function signature could be satisfied while maintain a mechanism to instruct and trigger an off-chain lookup. This is very similar for the write deferral protocol, defined in this EIP; without any modifications to the ABI or underlying EVM, `revert` provides a clean mechanism in which we can "return" a typed instruction - and the corresponding elements to complete that action - without modifying the signature


=== ERC-4527 ===
TITLE: QR Code transmission protocol for wallets
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-12-07
REQUIRES: 

SUMMARY:
The purpose of this EIP is to provide a process and data transmission protocol via QR Code between offline signers and watch-only wallets.

SPECIFICATION:
**Offline signer**: An offline signer is a device or application which holds the user’s private keys and does not have network access. **Watch-only wallet**: A watch-only wallet is a wallet that has network access and can interact with the Ethereum blockchain. ### Process In order to work with offline signers, the watch-only wallet should follow the following process. 1. The offline signer provides the public key information to the watch-only wallet to generate addresses, sync balances and etc via QR Codes. 2. The watch-only wallet generates the unsigned data and sends it to an offline signer for signing

MOTIVATION:
There is an increasing number of users whom like to use complete offline signers to manage their private keys, signers like hardware wallets and mobile phones in offline mode. In order to sign transactions or data, these offline signers have to rely on a watch-only wallet since it would prepare the data to be signed. Currently, there are 4 possible data transmission methods between offline signers and watch-only wallets: QR Code, USB, Bluetooth, and file transfer. The QR Code data transmission method have the following advantages when compared to the other three methods mentioned above: - Transparency and

RATIONALE:
This EIP uses some existing UR types like `crypto-keypath` and `crypto-hdkey` and also introduces some new UR types like `eth-sign-request` and `eth-signature`. Here are the reasons we choose UR for the QR Code data transmission protocol: ### UR provides a solid foundation for QR Code data transmission - Uses the alphanumeric QR code mode for efficiency. - Includes a CRC32 checksum of the entire message in each part to tie the different parts of the QR code together and ensure the transmitted message has been reconstructed. - uses `Fountain Code` for the arbitrary amount of data which can


=== ERC-3722 ===
TITLE: Poster
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-07-31
REQUIRES: 

SUMMARY:
A ridiculously simple general purpose social media smart contract. It takes two strings (`content` and `tag`) as parameters and emits those strings, along with msg.sender, as an event. That's it. The EIP also includes a proposed standard json format for a Twitter-like application, where each `post()` call can include multiple posts and/or operations. The assumption being that application state will be constructed off-chain via some indexer.

SPECIFICATION:
### Contract ```solidity contract Poster { event NewPost(address indexed user, string content, string indexed tag); function post(string calldata content, string calldata tag) public { emit NewPost(msg.sender, content, tag); } } ``` ### ABI ```json [ { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "user", "type": "address" }, { "indexed": false, "internalType": "string", "name": "content", "type": "string" }, { "indexed": true, "internalType": "string", "name": "tag", "type": "string" } ], "name": "NewPost", "type": "event" }, { "inputs": [ { "internalType": "string", "name": "content", "type": "string" }, { "internalType": "string", "name": "tag", "type": "string" } ], "name": "post",

MOTIVATION:
Poster is intended to be used as a base layer for decentralized social media. It can be deployed to the same address (via the singleton factory) on just about any EVM compatible network. Any Ethereum account can make posts to the deployment of Poster on its local network.

RATIONALE:
There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted. We decided not to emit an ID, since it meant adding state or complexity to the contract and there is a fairly common pattern of assigning IDs on the indexer layer based on transactionHash + logIndex. We decided to emit a string, rather than bytes, simply because that would make content human readable on many existing interfaces, like Etherscan for example. This did,


=== ERC-7787 ===
TITLE: Soulbound Degradable Governance
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-15
REQUIRES: 20

SUMMARY:
This proposal introduces the Soulbound Degradable Governance (SDG) standard, where governance power should be granted as non-transferable tokens that decay over time unless renewed through participation. SDG enables young DAOs to implement merit-based governance by detaching governance power from economic power while on early stages of development.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This system MUST operate with two distinct tokens types, one representing **political power** and another representing **economic power**: 1. The political power token SHOULD be non-transferable with over-time decayment. 2. The economic power token supports liquidity and trade, providing the financial utility needed for the DAO’s operations and is RECOMMENDED to be a standard [ERC-20](./eip-20.md) token. The implementer of this standard MUST: 1. Override

MOTIVATION:
Traditional DAO governance models rely heavily on economic tokens, where voting power is proportional to token holdings. While effective for some use cases, this model risks concentrating power among wealthy members, leading to plutocracy and discouraging participation from smaller stakeholders. Furthermore, it fosters a treasury-centric culture that attracts contributors primarily focused on financial gain, rather than long-term governance or community well-being. Young DAOs, in particular, need governance models that incentivize active contributions without relying on economic power. This proposal addresses these issues by detaching governance power from economic power and ensuring political power decays if not maintained through

RATIONALE:
The SDG standard ensures flexibility by not being tied to any specific token type, allowing DAOs to implement it with [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), [ERC-1155](./eip-1155.md), or other future token standards. This decision maximizes the compatibility and adaptability of the framework across different governance models. The choice to **decouple governance power from economic power** aims to provide a practical governance model for young DAOs seeking to prevent early centralization while fostering active participation. Non-transferable governance tokens ensure that only engaged members retain influence, as political power decays over time if not renewed through contributions. We deliberately avoided incorporating mechanisms like "Game


=== ERC-1155 ===
TITLE: Multi Token Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-06-17
REQUIRES: 165

SUMMARY:
This standard outlines a smart contract interface that can represent any number of fungible and non-fungible token types. Existing standards such as ERC-20 require deployment of separate contracts per token type. The ERC-721 standard's token ID is a single non-fungible index and the group of these non-fungibles is deployed as a single contract with settings for the entire collection. In contrast, the ERC-1155 Multi Token Standard allows for each token ID to represent a new configurable token type, which may have its own metadata, supply and other attributes. The `_id` argument contained in each function's argument set indicates

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. **Smart contracts implementing the ERC-1155 standard MUST implement all of the functions in the `ERC1155` interface.** **Smart contracts implementing the ERC-1155 standard MUST implement the ERC-165 `supportsInterface` function and MUST return the constant value `true` if `0xd9b67a26` is passed through the `interfaceID` argument.** ```solidity pragma solidity ^0.5.9; /** @title ERC-1155 Multi Token Standard @dev See https://eips.ethereum.org/EIPS/eip-1155 Note: The ERC-165 identifier for this interface is 0xd9b67a26. */ interface ERC1155 /*

MOTIVATION:
Tokens standards like ERC-20 and ERC-721 require a separate contract to be deployed for each token type or collection. This places a lot of redundant bytecode on the Ethereum blockchain and limits certain functionality by the nature of separating each token contract into its own permissioned address. With the rise of blockchain games and platforms like Enjin Coin, game developers may be creating thousands of token types, and a new type of token standard is needed to support them. However, ERC-1155 is not specific to games and many other applications can benefit from this flexibility. New functionality is

RATIONALE:
### Metadata Choices The `symbol` function (found in the ERC-20 and ERC-721 standards) was not included as we do not believe this is a globally useful piece of data to identify a generic virtual item / asset and are also prone to collisions. Short-hand symbols are used in tickers and currency trading, but they aren't as useful outside of that space. The `name` function (for human-readable asset names, on-chain) was removed from the standard to allow the Metadata JSON to be the definitive asset name and reduce duplication of data. This also allows localization for names, which would


=== ERC-7425 ===
TITLE: Tokenized Reserve
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-30
REQUIRES: 2, 0, ,,  , 4, 6, 2, 6

SUMMARY:
This specification explains a tokenized reserve mechanism standard. Current smart contracts record transactions and are made public. The reserve will implement added functionality allowing stakeholders proactively to audit a contract. Using [ERC-4626](./eip-4626.md), stakeholders can create shares to show support for actions in the contract.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions: - owner: The creator of the reserve - user: Stakeholders participating in policies - reserve: The assets held on the contract other than underlying token - policies: Created by reserve owners to encourage stakeholder participation ### Constructor: - name: ERC-20 token name - ticker: ERC-20 ticker - asset: ERC-4626 underlying ERC-20 address - rAuth: Authorized user, for cases utilizing more than one

MOTIVATION:
Tokenized vaults store [ERC-20](./eip-20.md) tokens that are represented by shares within vault contracts. Implementations can follow the [ERC-4626](./eip-4626.md) standard to provide basic functionality for depositing, withdrawing, and reading balances for a vault. As tokenization becomes increasingly popular, applications should use a form of tokenized vaults to store assets and allow all parties to track performance. This specification introduces a standard for an on-chain reserve that uses tokenized vaults to represent reserve stakeholders. Core functionality, which is an extension of [ERC-4626](./eip-4626.md), will provide stakeholders representation by depositing and withdrawing from the vault. The record of transactions for other [ERC-20](./eip-20.md)

RATIONALE:
This proposed standard is designed to be a core implementation of a tokenized reserve interface. Other non-specified conditions should be addressed on a case-by-case basis. Each reserve uses [ERC-20](./eip-20.md) standard for shares, and [ERC-4626](./eip-4626.md) for the creation of shares. The reserve token SHOULD be considered as either the underlying `asset` for the [ERC-4626](./eip-4626.md) vault or the shares that are created when depositing to the vault. [ERC-4626](./eip-4626.md) is used to create a transparent creation of stakeholders of the reserve. There MUST be a representation of interested parties in the reserve. The implementer can decide how to treat representation based


=== ERC-7677 ===
TITLE: Paymaster Web Service Capability
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-04-03
REQUIRES: 4, 3, 3, 7, ,,  , 5, 7, 9, 2

SUMMARY:
With [EIP-5792](./eip-5792.md), apps can communicate with wallets about advanced features via capabilities. This proposal defines a capability that allows apps to request that [ERC-4337](./eip-4337.md) wallets communicate with a specified paymaster web service. To support this, we also define a standardized API for paymaster web services.

SPECIFICATION:
One new [EIP-5792](./eip-5792.md) wallet capability is defined. We also define a standard interface for paymaster web services as a prerequisite. ### Paymaster Web Service Interface We define two JSON-RPC methods to be implemented by paymaster web services. #### `pm_getPaymasterStubData` Returns stub values to be used in paymaster-related fields of an unsigned user operation for gas estimation. Accepts an unsigned user operation, entrypoint address, chain id, and a context object. Paymaster service providers can define fields that app developers should use in the context object. This method MAY return paymaster-specific gas values if applicable to the provided EntryPoint version.

MOTIVATION:
App developers want to start sponsoring their users' transactions using paymasters. Paymasters are commonly used via web services. However, there is currently no way for apps to tell wallets to communicate with a specific paymaster web service. Similarly, there is no standard for how wallets should communicate with these services. We need both a way for apps to tell wallets to communicate with a specific paymaster web service and a communication standard for wallets to do so.

RATIONALE:
### Gas Estimation The current loose standard for paymaster services is to implement `pm_sponsorUserOperation`. This method returns values for paymaster-related user operation fields and updated gas values. The problem with this method is that paymaster service providers have different ways of estimating gas, which results in different estimated gas values. Sometimes these estimates can be insufficient. As a result we believe it’s better to leave gas estimation up to the wallet, as the wallet has more context on how user operations will get submitted (e.g. which bundler they will get submitted to). Then wallets can ask paymaster services


=== ERC-7586 ===
TITLE: Interest Rate Swaps
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-12-31
REQUIRES: 2, 0, ,,  , 1, 6, 5

SUMMARY:
This proposal introduces a standardized framework for on-chain interest rate swaps. The proposed standard aims to facilitate the seamless exchange of fixed and floating interest rate cash flows between parties, providing a foundation for decentralized finance (DeFi) applications.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Example Flow ![alt text](../assets/eip-7586/irs.jpeg "IRS diagram") Every contract compliant with this ERC MUST implement the following interface. The contract MUST inherit from [ERC-20](./eip-20.md) to tokenize the swap cash flows. ```solidity pragma solidity ^0.8.0; /** * @title ERC-7586 Interest Rate Swaps */ interface IERC7586 /** is ERC20, ERC165 */ { // events /** * @notice MUST be emitted when interest rates are swapped *

MOTIVATION:
Interest Rate Swapping (IRS) denotes a derivative contract wherein two parties mutually consent to exchange a series of forthcoming interest payments based on a specified notional amount. This financial instrument serves as a strategic tool for hedging against interest rate fluctuations. The mechanism entails the utilization of a benchmark index to facilitate the exchange between a variable interest rate and a fixed rate. Despite its widespread use, there is currently an absence of a standardized framework that enables the representation of IRS contracts on blockchain platforms. This proposal addresses this gap by establishing a consistent and transparent methodology

RATIONALE:
This standard allows parties involved in the IRS contract to define essential parameters such as notional amount, interest rates, payment frequency, and payment dates. This flexibility accommodates a diverse range of financial agreements, catering to the unique needs of different participants. To accommodate a wide array of use cases, the standard introduces optional features such as payment dates and manual benchmark setting. This allows parties to tailor the contract to specific requirements, while maintaining a core set of functions for essential functionality. To ensure real-time and accurate benchmark rates, the standard integrates with oracles. Parties have the option


=== ERC-1080 ===
TITLE: Recoverable Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
The following standard allows for the implementation of a standard API for tokens extending ERC-20 or ERC-791. This standard provides basic functionality to recover stolen or lost accounts, as well as provide for the chargeback of tokens.

MOTIVATION:
To mitigate the effects of reasonably provable token or asset loss or theft and to help resolve other conflicts. Ethereum's protocol should not be modified because of loss, theft, or conflicts, but it is possible to solve these problems in the smart contract layer.

RATIONALE:
* A recoverable token standard can provide configurable safety for users or contracts who desire this safety. * Implementations of this standard will give users the ability to select a dispute resolution process on an opt-in basis and benefit the community by decreasing the necessity of consideration of token recovery actions.


=== ERC-4400 ===
TITLE: EIP-721 Consumable Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2021-10-30
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This specification defines standard functions outlining a `consumer` role for instance(s) of [EIP-721](./eip-721.md). An implementation allows reading the current `consumer` for a given NFT (`tokenId`) along with a standardized event for when an `consumer` has changed. The proposal depends on and extends the existing [EIP-721](./eip-721.md).

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Every contract compliant to the `EIP721Consumable` extension MUST implement the `IEIP721Consumable` interface. The **consumer extension** is OPTIONAL for EIP-721 contracts. ```solidity /// @title EIP-721 Consumer Role extension /// Note: the EIP-165 identifier for this interface is 0x953c8dfa interface IEIP721Consumable /* is EIP721 */ { /// @notice Emitted when `owner` changes the `consumer` of an NFT /// The zero address for consumer indicates that there is no consumer address /// When

MOTIVATION:
Many [EIP-721](./eip-721.md) contracts introduce their own custom role that grants permissions for utilising/consuming a given NFT instance. The need for that role stems from the fact that other than owning the NFT instance, there are other actions that can be performed on an NFT. For example, various metaverses use `operator` / `contributor` roles for Land (EIP-721), so that owners of the land can authorise other addresses to deploy scenes to them (f.e. commissioning a service company to develop a scene). It is common for NFTs to have utility other than ownership. That being said, it requires a separate

RATIONALE:
Key factors influencing the standard: - Keeping the number of functions in the interfaces to a minimum to prevent contract bloat - Simplicity - Gas Efficiency - Not reusing or overloading other already existing roles (e.g. owners, operators, approved addresses) ### Name The chosen name resonates with the purpose of its existence. Consumers can be considered entities that utilise the token instances, without necessarily having ownership rights to it. The other name for the role that was considered was `operator`, however it is already defined and used within the `EIP-721` standard. ### Restriction on the Permissions There are


=== ERC-7521 ===
TITLE: General Intents for Smart Contract Wallets
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-19
REQUIRES: 

SUMMARY:
A generalized intent specification entry point contract which enables support for a multitude of intent standards as they evolve over time. Instead of smart contract wallets having to constantly upgrade to provide support for new intent standards as they pop up, a single entry point contract is trusted to handle signature verification which then passes off the low level intent data handling and defining to other contracts specified by users at intent sign time. These signed messages, called a `UserIntent`, are gossipped around any host of mempool strategies for MEV searchers to look through and combine with their

SPECIFICATION:
Users package up intents they want their wallet to participate in, in an ABI-encoded struct called a `UserIntent`: | Field | Type | Description | | ------------ | --------- | ------------------------------------------------------------- | | `sender` | `address` | The wallet making the intent | | `segments` | `bytes[]` | Data defined by multiple segments of varying intent standards | | `signature` | `bytes` | Data passed into the wallet during the verification step | The `segments` parameter is an array of arbitrary bytes whose use is defined by an intent standard. Each item in this array is referred to

MOTIVATION:
See also ["ERC-4337: Account Abstraction via Entry Point Contract specification"](./eip-4337.md) and the links therein for historical work and motivation. This proposal uses the same entry point contract idea to enable a single interface which smart contract wallets can support now to unlock future-proof access to an evolving intent landscape. It seeks to achieve the following goals: - **Achieve the key goal of enabling intents for users**: allow users to use smart contract wallets containing arbitrary verification logic to specify intent execution as described and handled by various other intent standard contracts. - **Decentralization** - Allow any MEV searcher

RATIONALE:
The main challenge with a generalized intent standard is being able to adapt to the evolving world of intents. Users need to have a way to express their intents in a seamless way without having to make constant updates to their smart contract wallets. In this proposal, we expect wallets to have a `validateUserIntent` function that takes as input a `UserIntent`, and verifies the signature. A trusted entry point contract uses this function to validate the signature and forwards the intent handling logic to the intent standard contracts specified in the first 32 bytes of each segment in


=== ERC-7405 ===
TITLE: Portable Smart Contract Accounts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-26
REQUIRES: 1, 9, 1, ,,  , 1, 9, 6, 7

SUMMARY:
Portable Smart Contract Accounts (PSCA) address the lack of portability and compatibility faced by Smart Contract Accounts (SCA) across different wallet providers. Based on [ERC-1967](./eip-1967.md), the PSCA system allows users to easily migrate their SCAs between different wallets using new, randomly generated migration keys. This provides a similar experience to exporting an externally owned account (EOA) with a private key or mnemonic. The system ensures security by employing signatures and time locks, allowing users to verify and cancel migration operations during the lock period, thereby preventing potential malicious actions. PSCA offers a non-intrusive and cost-effective approach, enhancing the

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Terms - Wallet Provider: A service provider that offers wallet services. SCA implementations among wallet providers are typically different, lacking compatibility with each other. - Random Operator: A new, randomly generated migration mnemonic or private key used for each migration. The corresponding address of its public key is the random operator's address. - If using a mnemonic, the derived migration private key follows the [BIP 44](https://github.com/bitcoin/bips/blob/55566a73f9ddf77b4512aca8e628650c913067bf/bip-0044.mediawiki) specification with

MOTIVATION:
With the introduction of the [ERC-4337](./eip-4337.md) standard, AA related infrastructure and SCAs have been widely adopted in the community. However, unlike EOAs, SCAs have a more diverse code space, leading to varying contract implementations across different wallet providers. Consequently, the lack of portability for SCAs has become a significant issue, making it challenging for users to migrate their accounts between different wallet providers. While some proposed a modular approach for SCA accounts, it comes with higher implementation costs and specific prerequisites for wallet implementations. Considering that different wallet providers tend to prefer their own implementations or may expect

RATIONALE:
The main challenge addressed by this EIP is the lack of portability in Smart Contract Accounts (SCAs). Currently, due to variations in SCA implementations across wallet providers, moving between wallets is a hassle. Proposing a modular approach, though beneficial in some respects, comes with its own costs and compatibility concerns. The PSCA system, rooted in ERC-1967, introduces a migration mechanism reminiscent of exporting an EOA with a private key or mnemonic. This approach is chosen for its familiarity to users, ensuring a smoother user experience. Employing random, migration-specific keys further fortifies security. By mimicking the EOA exportation process,


=== ERC-6821 ===
TITLE: Support ENS Name for Web3 URL
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-02
REQUIRES: 1, 3, 7, ,,  , 6, 3, 4, ,,  , 3, 7, 7, 0, ,,  , 4, 8, 0, 4

SUMMARY:
This standard defines the mapping from an Ethereum name service (ENS) name to an Ethereum address for [ERC-4804](./eip-4804.md).

SPECIFICATION:
Given **contractName** and **chainid** from a `web3://` URI defined in ERC-4804, the protocol will find the address of the contract using the following steps: 1. Find the `contentcontract` text record on ENS resolver on chain **chainid**. Return an error if the chain does not have ENS or the record is an invalid ETH address. 2. If the `contentcontract` text record does not exist, the protocol will use the resolved address of **name** from [ERC-137](./eip-137.md#contract-address-interface). 3. If the resolved address of **name** is the zero address, then return an "address not found" error. Note that `contentcontract` text record may

MOTIVATION:
ERC-4804 defines a `web3://`-scheme RFC 2396 URI to call a smart contract either by its address or a **name** from name service. If a **name** is specified, the standard specifies a way to resolve the contract address from the name.

RATIONALE:
The standard uses `contentcontract` text record with ERC-3770 chain-specific address instead of `contenthash` so that the record is human-readable - a design principle of ERC-4804. Further, we can use the text record to add additional fields such as time to live (TTL).


=== ERC-5018 ===
TITLE: Filesystem-like Interface for Contracts
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-04-18
REQUIRES: 

SUMMARY:
The following standardizes an API for directories and files within smart contracts, similar to traditional filesystems. This standard provides basic functionality to read/write binary objects of any size, as well as allow reading/writing chunks of the object if the object is too large to fit in a single transaction.

SPECIFICATION:
### Directory #### Methods ##### write Writes binary `data` to the file `name` in the directory by an account with write permission. ``` function write(bytes memory name, bytes memory data) external payable ``` ##### read Returns the binary `data` from the file `name` in the directory and existence of the file. ``` function read(bytes memory name) external view returns (bytes memory data, bool exist) ``` ##### fallback read Returns the binary `data` from the file `prefixedName` (prefixed with `/`) in the directory. ``` fallback(bytes calldata prefixedName) external returns (bytes memory data) ``` ##### size Returns the size of

MOTIVATION:
A standard interface allows any binary objects on EVM-based blockchain to be re-used by other dApps. With [EIP-4804](./eip-4804.md), we are able to locate a Web3 resource on blockchain using HTTP-style URIs. One application of Web3 resources are web contents that are referenced within a directory using relative paths such as HTML/SVG. This standard proposes a contract-based directory to simplify the mapping between local web contents and on-chain web contents. Further, with relative paths referenced in the web contents and EIP-4804, the users will have a consistent view of the web contents locally and on-chain.

RATIONALE:
One issue of uploading the web contents to the blockchain is that the web contents may be too large to fit into a single transaction. As a result, the standard provides chunk-based operations so that uploading a content can be split into several transactions. Meanwhile, the read operation can be done in a single transaction, i.e., with a single Web3 URL defined in EIP-4804. ### Interactions Between Unchunked/Chunked Functions `read` method should return the concatenated chunked data written by `writeChunk` method. The following gives some examples of the interactions: - `read("hello.txt")` => "" (file is empty) - `writeChunk("hello.txt",


=== ERC-7779 ===
TITLE: Interoperable Delegated Accounts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-02
REQUIRES: 7, 2, 0, 1, ,,  , 7, 7, 0, 2

SUMMARY:
This proposal outlines the interfaces to make delegated EOAs interoperable after the merge of [EIP-7702](./eip-7702.md). With [EIP-7702](./eip-7702.md), EOAs will be able to enable execution abstraction, which leads to a more feature-rich account, including gas sponsorship, batch execution, and more. However, there is a need to help facilitate storage management for redelegation, as invalid management of storage may incur storage collisions that can lead to unexpected behavior of accounts (e.g., account getting locked, security vulnerabilities, etc) The interface `InteroperableDelegatedAccount` suggests the interfaces for delegated EOAs to be interoperable and facilitate a better environment for redelegation.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ```solidity interface IInteroperableDelegatedAccount { /* * @dev Provides the namespace of the account. * namespace of accounts can possibly include, account version, account name, wallet vendor name, etc * @notice this standard does not standardize the namespace format * e.g., "v0.1.2.7702Account.WalletProjectA" */ function accountId() external view returns (string); /* * @dev Externally shares the storage bases that has been used throughout the account. * Majority

MOTIVATION:
After the merge of [EIP-7702](./eip-7702.md), it is expected that a considerable number of EOA wallets will migrate from pure EOA accounts to delegated EOA accounts. This is to enable a more appealing wallet UX, including a 1-step swap, automated subscription, gas sponsorship, and more. However, considering the fact that delegated EOAs will utilize its own storage bound to their Smart Account implementation, the storage management is essential to foster migration between wallets to better ensure sovereignty of users to freely migrate their wallet app whenever they want. EOA (Externally Owned Account) is currently comprised of cryptographic key pair

RATIONALE:
### Storage base checks This standard is designed with the need of wallets to validate the storage of the EOA, even if some may consider that the probability of hash is already big that the account doesn't have to check, assuming that each wallet uses a different storage base slot. In fact, this standard thinks exactly the opposite. It is worth scanning the storage, or at least the storage that the delegated account will use, which the wallet wants to delegate to. E.g., Just like developers validating the storage of Facets in Diamond ([ERC-2535](./eip-2535.md)) to prevent storage collision


=== ERC-7751 ===
TITLE: Wrapping of bubbled up reverts
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2024-08-06
REQUIRES: 

SUMMARY:
This ERC proposes a standard for handling bubbled up reverts in Ethereum smart contracts using a dedicated custom error. This standard aims to improve the clarity and usability of revert reasons by allowing additional context to be passed alongside the raw bytes of the bubbled up revert. The `WrappedError` custom error should wrap reverts from called contracts and provide a consistent interface for parsing and handling reverts in tools like Etherscan or Tenderly.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. In order to wrap a revert, a contract MUST revert with the following error that corresponds to the following signature `0x90bfb865`: ```solidity error WrappedError(address target, bytes4 selector, bytes reason, bytes details); ``` Where: - `target` is the address of the called contract that reverted. - `selector` is the selector of the called function that reverted. If the call was an ETH transfer without any

MOTIVATION:
Currently, when a smart contract calls another and the called contract reverts, the revert reason is usually bubbled up and thrown as is. This can make it more difficult to tell which context the error came from. By standardizing the use of custom errors with additional context, more meaningful and informative revert reasons can be provided. This will improve the debugging experience and make it easier for developers and infrastructure providers like Etherscan to display accurate stack traces.

RATIONALE:
By including the called contract and function, raw revert bytes and additional context, developers can provide more detailed information about the failure. Additionally, by standardizing the way reverts are bubbled up, it also enables nested bubbled up reverts where multiple reverts thrown by different contracts can be followed recursively. The reverts can also be parsed and handled by tools like Etherscan and Foundry to further enhance the readability and debuggability of smart contract interactions, as well as facilitating better error handling practices in general.


=== ERC-5218 ===
TITLE: NFT Rights Management
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-07-11
REQUIRES: 721

SUMMARY:
The following standard defines an API for managing NFT licenses. This standard provides basic functionality to create, transfer, and revoke licenses, and to determine the current licensing state of an NFT. The standard does not define the legal details of the license. Instead, it provides a structured framework for recording licensing details. We consider use cases of NFT creators who wish to give the NFT holder a copyright license to use a work associated with the NFT. The holder of an active license can issue sublicenses to others to carry out the rights granted under the license. The

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. **Every ERC-5218 compliant contract *must* implement the `IERC5218` interface**: ```solidity pragma solidity ^0.8.0; /// @title ERC-5218: NFT Rights Management interface IERC5218 is IERC721 { /// @dev This emits when a new license is created by any mechanism. event CreateLicense(uint256 _licenseId, uint256 _tokenId, uint256 _parentLicenseId, address _licenseHolder, string _uri, address _revoker); /// @dev This emits when a license is revoked. Note that under some /// license terms, the sublicenses may be

MOTIVATION:
The [ERC-721](./eip-721.md) standard defines an API to track and transfer ownership of an NFT. When an NFT is to represent some off-chain asset, however, we would need some legally effective mechanism to *tether* the on-chain asset (NFT) to the off-chain property. One important case of off-chain property is creative work such as an image or music file. Recently, most NFT projects involving creative works have used licenses to clarify what legal rights are granted to the NFT owner. But these licenses are almost always off-chain and the NFTs themselves do not indicate what licenses apply to them, leading

RATIONALE:
This EIP aims to allow tracing all licenses to an NFT to facilitate right management. The ERC-721 standard only logs the property but not the legal rights tethered to NFTs. Even when logging the license via the optional ERC-721 Metadata extension, sublicenses are not traceable, which doesn't comply with the transparency goals of Web3. Some implementations attempt to get around this limitation by minting NFTs to represent a particular license, such as the BAYC #6068 Royalty-Free Usage License. This is not an ideal solution because the linking between different licenses to an NFT is ambiguous. An auditor has


=== ERC-5289 ===
TITLE: Ethereum Notary Interface
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-07-16
REQUIRES: 1, 6, 5, ,,  , 5, 5, 6, 8

SUMMARY:
Currently, the real-world applications of smart contracts are limited by the fact that they aren't legally binding. This EIP proposes a standard that allows smart contracts to be legally binding by providing IPFS links to legal documents and ensuring that the users of the smart contract have privity with the relevant legal documents. Please note that the authors are not lawyers, and that this EIP is not legal advice.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Legal Contract Library Interface ```solidity /// SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; import "./IERC165.sol"; interface IERC5289Library is IERC165 { /// @notice Emitted when signDocument is called event DocumentSigned(address indexed signer, uint16 indexed documentId); /// @notice An immutable link to the legal document (RECOMMENDED to be hosted on IPFS). This MUST use a common file format, such as PDF, HTML, TeX, or Markdown. function legalDocument(uint16 documentId) external view returns (string

MOTIVATION:
NFTs have oftentimes been branded as a way to hold and prove copyright of a specific work. However, this, in practice, has almost never been the case. Most of the time, NFTs have no legally-binding meaning, and in the rare cases that do, the NFT simply provides a limited license for the initial holder to use the work (but cannot provide any license for any future holders).

RATIONALE:
- `uint64` was chosen for the timestamp return type as 64-bit time registers are standard. - `uint16` was chosen for the document ID as 65536 documents are likely sufficient for any use case, and the contract can always be re-deployed. - `signDocument` doesn't take an ECDSA signature for future compatibility with account abstraction. In addition, future extensions can supply this functionality. - IPFS is mandatory because the authenticity of the signed document can be proven.


=== ERC-7510 ===
TITLE: Cross-Contract Hierarchical NFT
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-08-24
REQUIRES: 721

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It proposes a way to maintain hierarchical relationship between tokens from different contracts. This standard provides an interface to query the parent tokens of an NFT or whether the parent relation exists between two NFTs.

SPECIFICATION:
Solidity interface available at [`IERC7510.sol`](../assets/eip-7510/contracts/IERC7510.sol): ```solidity /// @notice The struct used to reference a token in an NFT contract struct Token { address collection; uint256 id; } interface IERC7510 { /// @notice Emitted when the parent tokens for an NFT is updated event UpdateParentTokens(uint256 indexed tokenId); /// @notice Get the parent tokens of an NFT /// @param tokenId The NFT to get the parent tokens for /// @return An array of parent tokens for this NFT function parentTokensOf(uint256 tokenId) external view returns (Token[] memory); /// @notice Check if another token is a parent of an NFT /// @param

MOTIVATION:
Some NFTs want to generate derivative assets as new NFTs. For example, a 2D NFT image would like to publish its 3D model as a new derivative NFT. An NFT may also be derived from multiple parent NFTs. Such cases include a movie NFT featuring multiple characters from other NFTs. This standard is proposed to record such hierarchical relationship between derivative NFTs. Existing [ERC-6150](./eip-6150.md) introduces a similar feature, but it only builds hierarchy between tokens within the same contract. More than often we need to create a new NFT collection with the derivative tokens, which requires cross-contract relationship

RATIONALE:
This standard differs from [ERC-6150](./eip-6150.md) in mainly two aspects: supporting cross-contract token reference, and allowing multiple parents. But we try to keep the naming consistent overall. In addition, we didn't include `child` relation in the interface. An original NFT exists before its derivative NFTs. Therefore we know what parent tokens to include when minting derivative NFTs, but we wouldn't know the children tokens when minting the original NFT. If we have to record the children, that means whenever we mint a derivative NFT, we need to call on its original NFT to add it as a child. However,


=== ERC-5252 ===
TITLE: Account-bound Finance
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-06-29
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 5, 1, 1, 4

SUMMARY:
This EIP proposes a form of smart contract design pattern and a new type of account abstraction on how one's finance should be managed, ensuring transparency of managing investments and protection with self-sovereignty even from its financial operators. This EIP enables greater self-sovereignty of one's assets using a personal finance contract for each individual. The separation between an investor's funds and the operation fee is clearly specified in the personal smart contract, so investors can ensure safety from arbitrary loss of funds by the operating team's control. This EIP extends [ERC-5114](./eip-5114.md) to further enable transferring fund to other

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. The specification consists of two patterns for **Interaction** and **Governance**. ### Interaction #### Interfaces The interaction pattern consists of 4 components for interaction; manager, factory, finance, account-bound token, and extension. Interaction contract pattern is defined with these contracts: - A soul-bound or account bound token contract to give access to interact with a financial contract with credentials - A manager contract that interacts first contact with an investor -

MOTIVATION:
Decentralized finance (DeFi) faces a trust issue. Smart contracts are often proxies, with the actual logic of the contract hidden away in a separate logic contract. Many projects include a multi-signature "wallet" with unnecessarily-powerful permissions. And it is not possible to independently verify that stablecoins have enough real-world assets to continue maintaining their peg, creating a large loss of funds (such as happened in the official bankruptcy announcement of Celsius and UST de-pegging and anchor protocol failure). One should not trust exchanges or other third parties with one's own investments with the operators' clout in Web3.0. Smart contracts

RATIONALE:
### Gas saving for end user The gas cost of using multiple contracts (as opposed to a single one) actually saves gas long-run if the clone factory pattern is applied. One contract storing users' states globally means each user is actually paying for the storage cost of other users after interacting with the contract. This, for example, means that MakerDAO's contract operating cost is sometimes over 0.1 ETH, limitimg users' minimum deposit for CDP in order to save gas costs. To solve inefficient n-times charging gas cost interaction for future users, one contract per user is used. ####


=== ERC-6865 ===
TITLE: On-Chain EIP-712 Visualization
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-10
REQUIRES: 712

SUMMARY:
Numerous protocols employ distinct [EIP-712](./eip-712.md) schemas, leading to unavoidable inconsistencies across the ecosystem. To address this issue, we propose a standardized approach for dApps to implement an on-chain view function called `visualizeEIP712Message`. This function takes an abi encoded EIP-712 payload message as input and returns a universally agreed-upon structured data format that emphasizes the potential impact on users' assets. Wallets can then display this structured data in a user-friendly manner, ensuring a consistent experience for end-users when interacting with various dApps and protocols.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Contracts implementing this proposal MUST include the `visualizeEIP712Message` function in the `verifyingContract` implementation so that wallets upon receiving a request to sign an EIP-712 message(`eth_signTypedData`) MAY call the function `visualizeEIP712Message` at the smart contract and chain specified in the EIP-712 message domain separator `verifyingContract` and `chainId` fields, respectively. Wallets SHOULD ignore this proposal if the domain separator does not include the `verifyingContract` and `chainId`

MOTIVATION:
The rapid expansion of the web3.0 ecosystem has unlocked numerous opportunities and innovations. However, this growth has also heightened users' vulnerability to security threats, such as phishing scams. Ensuring that users have a comprehensive understanding of the transactions they sign is crucial for mitigating these risks. In an attempt to address this issue, we developed an in-house, open-source off-chain SDK for wallets to visualize various protocols. However, we encountered several challenges along the way: - Scalability: Identifying and understanding all protocols that utilize EIP-712 and their respective business logic is a daunting task, particularly with limited resources. Crafting

RATIONALE:
### on-chain One might argue that certain processes can be done off-chain, which is true, but our experience building an off-chain TypeScript SDK to solve this matter revealed some issues: - Reliability: Protocols developers are the ones responsible for developing the protocol itself, thus crafting the visualization is much more accurate when done by them. - Scalability: Keeping up with the rapidly expanding ecosystem is hard. Wallets or 3rd party entities must keep an eye on each new protocol, understand it carefully (which poses the reliability issues mentioned above), and then only come up with an off-chain implementation.


=== ERC-137 ===
TITLE: Ethereum Domain Name Service - Specification
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2016-04-04
REQUIRES: 


=== ERC-1581 ===
TITLE: Non-wallet usage of keys derived from BIP-32 trees
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-11-13
REQUIRES: 

SUMMARY:
BIP32 defines a way to generate hierarchical trees of keys which can be derived from a common master key. BIP32 and [BIP44](https://https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) defines the usage of these keys as wallets. In this EIP we describe the usage of such keys outside the scope of the blockchain defining a logical tree for key usage which can coexist (and thus share the same master) with existing BIP44 compatible wallets.

SPECIFICATION:
### Path levels We define the following levels in BIP32 path: ```m / purpose' / coin_type' / subpurpose' / key_type' / key_index``` Apostrophe in the path indicates that BIP32 hardened derivation is used. This structure follows the [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) recommendations and its [amendments for non-Bitcoin usage](https://github.com/bitcoin/bips/pull/523/files). Each level has a special meaning, described in the chapters below. ### Purpose/Coin Type/Subpurpose This part is constant and set to ```m / 43' / 60' / 1581'```, meaning BIP 43 -> Ethereum -> This EIP. All subtrees under this prefix are the scope of this EIP. ### Key type Describes the purpose

MOTIVATION:
Applications interacting with the blockchain often make use of additional, non-blockchain technologies to perform the task they are designed for. For privacy and security sensitive mechanisms, sets of keys are needed. Reusing keys used for wallets can prove to be insecure, while keeping completely independent keys make backup and migration of the full set of credentials more complex. Defining a separate (from BIP44 compliant wallets) derivation branch allows combining the security of independent keys with the convenience of having a single piece of information which needs to be backup or migrated.

RATIONALE:
The structure proposed above follows the BIP43 generic structure and is similar to the widely adopted BIP44 specification.


=== ERC-1462 ===
TITLE: Base Security Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-10-01
REQUIRES: 2, 0, ,,  , 1, 0, 6, 6

SUMMARY:
This EIP defines a minimal set of additions to the default token standard such as [ERC-20](./eip-20.md), that allows for compliance with domestic and international legal requirements. Such requirements include KYC (Know Your Customer) and AML (Anti Money Laundering) regulations, and the ability to lock tokens for an account, and restrict them from transfer due to a legal dispute. Also the ability to attach additional legal documentation, in order to set up a dual-binding relationship between the token and off-chain legal entities. The scope of this standard is being kept as narrow as possible to avoid restricting potential use-cases

SPECIFICATION:
The ERC-20 token provides the following basic features: ```solidity contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } ``` This will be extended as follows: ```solidity interface BaseSecurityToken /* is ERC-20 */ { // Checking functions function

MOTIVATION:
There are several security token standards that have been proposed recently. Examples include [ERC-1400](https://github.com/ethereum/EIPs/issues/1411), also [ERC-1450](https://eips.ethereum.org/EIPS/eip-1450). We have concerns about each of them, mostly because the scope of each of these EIPs contains many project-specific or market-specific details. Since many EIPs are coming from the respective backing companies, they capture many niche requirements that are excessive for a general case. For instance, ERC-1411 uses dependency on [ERC-1410](https://github.com/ethereum/eips/issues/1410) but it falls out of the "security tokens" scope. Also its dependency on [ERC-777](./eip-777.md) will block the adoption for a quite period of time before ERC-777 is finalized, but the integration

RATIONALE:
This EIP targets both ERC-20 and ERC-777 based tokens, although the most emphasis is given to ERC-20 due to its widespread adoption. However, this extension is designed to be compatible with the forthcoming ERC-777 standard, as well. All checking functions are named with prefixes `check` since they return check status code, not booleans, because that is important to facilitate the debugging and tracing process. It is responsibility of the issuer to implement the logic that will handle the return codes appropriately. Some handlers will simply throw errors, other handlers would log information for future process mining. More rationale


=== ERC-7390 ===
TITLE: Vanilla Options for ERC-20 Tokens
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-09-02
REQUIRES: 2, 0, ,,  , 1, 1, 5, 5

SUMMARY:
This standard defines a comprehensive set of functions and events facilitating seamless interactions (creation, management, exercising, etc.) for vanilla options. Vanilla options grant the right, without obligation, to buy or sell an asset at a set price within a specified timeframe. This standard doesn't represent a simple option that would be useless after the expiration date. Instead, it can store as many issuance as needed. Each issuance is identified by an id, and can be bought, exercised, cancelled, etc., independently of the other issuances.\ Every issuance is collateralized, meaning that the writer has to provide the collateral to

SPECIFICATION:
Implementations of this proposal MUST also implement ERC-1155 to give the possibility to buy only a fraction of the issuance. ### Interface ```solidity interface IERC7390 { enum Side { Call, Put } struct VanillaOptionData { Side side; address underlyingToken; uint256 amount; address strikeToken; uint256 strike; address premiumToken; uint256 premium; uint256 exerciseWindowStart; uint256 exerciseWindowEnd; address[] allowed; } struct OptionIssuance { VanillaOptionData data; address writer; uint256 exercisedAmount; uint256 soldAmount; } error Forbidden(); error TransferFailed(); error TimeForbidden(); error AmountForbidden(); error InsufficientBalance(); event Created(uint256 indexed id); event Bought(uint256 indexed id, uint256 amount, address indexed buyer); event Exercised(uint256 indexed id, uint256 amount); event

MOTIVATION:
Options are widely used financial instruments, and have a true usefulness for investors and traders. It offers versatile risk management tools and speculative opportunities.\ In the decentralized finance, many options-selling platform emerged, but each of these protocols implements their own definition of an option. This leads to incompatibilities, which is a pity because options should be interoperable like fungible/non-fungible tokens are.\ By introducing a standard interface for vanilla options contracts, we aim to foster a more inclusive and interoperable derivatives ecosystem. This standard will enhance the user experience and facilitate the development of decentralized options platforms, enabling users

RATIONALE:
This contract's concept is oracle-free, because we assume that a rational buyer will exercise his option only if it's profitable for him. The premium is to be determined by the option writer. writer is free to choose how to calculate the premium, e.g. by using *Black-Scholes model* or something else. writer can update the premium price at will in order to adjust it according to changes on the underlying's price, volatility, time to option expiry and other such factors. Computing the premium off-chain is better for gas costs purposes. This ERC is intended to represent vanilla options. However,


=== ERC-1921 ===
TITLE: dType Functions Extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-04-06
REQUIRES: 1900

SUMMARY:
This proposal is part of a series of EIPs focused on expanding the concept of a Decentralized Type System, as explained in [EIP-1900](./eip-1900.md). The current EIP specifies the data definitions and interfaces needed to support registering individual smart contract functions, as entries in the dType Registry.

SPECIFICATION:
This specification targets `pure` and `view` functions. For each function, we can store: * `name` - type `string` unique function name, as defined in EIP-1900; required * `types` - the type data and label of each input, as defined in EIP-1900; required * `outputs` - the type data and label of each output; required * `contractAddress` - type `address` - smart contract where the function resides, as defined in EIP-1900; optional for interfaces * `source` - type `bytes32` - reference to an external file containing the function source code, as defined in EIP-1900; optional Therefore, this proposal adds

MOTIVATION:
In order to evolve the EVM into a Singleton Operating System, we need a way to register, find and address contract functions that we want to run in an automated way. This implies having access to all the data needed to run the function inside the EVM. Aside from the above motivation, there are also near future benefits for this proposal. Having a globally available, non-custodial functions registry, will democratize the development of tools, such as those targeting: blockchain data analysis (e.g. block explorers), smart contract IDEs, security analysis of smart contracts. Registering new smart contract functions can

RATIONALE:
The suggestion to treat each `pure` or `view` function as a separate entity instead of having a contract-based approach allows us to: * have a global context of readily available functions * scale designs through functional programming patterns rather than contract-encapsulated logic (which can be successfully used to scale development efforts independently) * bidirectionally connect functions with the types they use, making automation easier * cherry-pick functions from already deployed contracts if the other contract functions do not pass community consensus * have scope-restricted improvements - instead of redeploying entire contracts, we can just redeploy the new function


=== ERC-4361 ===
TITLE: Sign-In with Ethereum
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2021-10-11
REQUIRES: 5, 5, ,,  , 1, 3, 7, ,,  , 1, 5, 5, ,,  , 1, 9, 1, ,,  , 1, 2, 7, 1, ,,  , 1, 3, 2, 8

SUMMARY:
Sign-In with Ethereum describes how Ethereum accounts authenticate with off-chain services by signing a standard message format parameterized by scope, session details, and security mechanisms (e.g., a nonce). The goals of this specification are to provide a self-custodied alternative to centralized identity providers, improve interoperability across off-chain services for Ethereum-based authentication, and provide wallet vendors a consistent machine-readable message format to achieve improved user experiences and consent management.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview Sign-In with Ethereum (SIWE) works as follows: 1. The relying party generates a SIWE Message and prefixes the SIWE Message with `\x19Ethereum Signed Message:\n<length of message>` as defined in [ERC-191](./eip-191.md). 2. The wallet presents the user with a structured plaintext message or equivalent interface for signing the SIWE Message with the [ERC-191](./eip-191.md) signed data format. 3. The signature is then presented to

MOTIVATION:
When signing in to popular non-blockchain services today, users will typically use identity providers (IdPs) that are centralized entities with ultimate control over users' identifiers, for example, large internet companies and email providers. Incentives are often misaligned between these parties. Sign-In with Ethereum offers a new self-custodial option for users who wish to assume more control and responsibility over their own digital identity. Already, many services support workflows to authenticate Ethereum accounts using message signing, such as to establish a cookie-based web session which can manage privileged metadata about the authenticating address. This is an opportunity to standardize

RATIONALE:
### Requirements Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution),


=== ERC-7246 ===
TITLE: Encumber - Splitting Ownership & Guarantees
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-27
REQUIRES: 20

SUMMARY:
This ERC proposes an extension to the [ERC-20](./eip-20.md) token standard by adding Encumber—the ability for an account to grant another account exclusive right to move some portion of their balance. Encumber is a stronger version of [ERC-20](./eip-20.md) allowances. While [ERC-20](./eip-20.md) approve grants another account the permission to transfer a specified token amount, encumber grants the same permission while ensuring that the tokens will be available when needed.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A compliant token MUST implement the following interface ```solidity /** * @dev Interface of the ERC-7246 standard. */ interface IERC7246{ /** * @dev Emitted when `amount` tokens are encumbered from `owner` to `taker`. */ event Encumber(address indexed owner, address indexed taker, uint amount); /** * @dev Emitted when the encumbrance of a `taker` to an `owner` is reduced by `amount`. */ event Release(address indexed

MOTIVATION:
This extension adds flexibility to the [ERC-20](./eip-20.md) token standard and caters to use cases where token locking is required, but it is preferential to maintain actual ownership of tokens. This interface can also be adapted to other token standards, such as [ERC-721](./eip-721.md), in a straightforward manner Token holders commonly transfer their tokens to smart contracts which will return the tokens under specific conditions. In some cases, smart contracts do not actually need to hold the tokens, but need to guarantee they will be available if necessary. Since allowances do not provide a strong enough guarantee, the only way

RATIONALE:
The specification was designed to complement and mirror the ERC-20 specification to ease adoption and understanding. The specification is intentionally minimally proscriptive of this joining, where the only true requirement is that an owner cannot transfer encumbered tokens. However, the example implementation includes some decisions about where to connect with ERC-20 functions worth noting. It was designed for minimal invasiveness of standard ERC-20 definitions. - The example has a dependency on `approve` to facilitate `encumberFrom`. This proposal allows for an implementer to define another mechanism, such as an `approveEncumber` which would mirror ERC-20 allowances, if desired. - `transferFrom(src,


=== ERC-5639 ===
TITLE: Delegation Registry
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-09-09
REQUIRES: 

SUMMARY:
This EIP describes the details of the Delegation Registry, a proposed protocol and ABI definition that provides the ability to link one or more delegate wallets to a vault wallet in a manner which allows the linked delegate wallets to prove control and asset ownership of the vault wallet.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Let: - `vault` represent the vault address we are trying to authenticate or prove asset ownership for. - `delegate` represent the address we want to use for signing in lieu of `vault`. **A Delegation Registry must implement IDelegationRegistry** ```solidity /** * @title An immutable registry contract to be deployed as a standalone primitive * @dev New project launches can read previous cold wallet -> hot wallet delegations * from

MOTIVATION:
Proving ownership of an asset to a third party application in the Ethereum ecosystem is common. Users frequently sign payloads of data to authenticate themselves before gaining access to perform some operation. However, this method--akin to giving the third party root access to one's main wallet--is both insecure and inconvenient. ***Examples:*** 1. In order for you to edit your profile on OpenSea, you must sign a message with your wallet. 2. In order to access NFT gated content, you must sign a message with the wallet containing the NFT in order to prove ownership. 3. In order to

RATIONALE:
### Allowing for vault, contract or token level delegation In order to support a wide range of delegation use cases, the proposed specification allows a vault to delegate all assets it controls, assets of a specific contract, or a specific token. This ensures that a vault has fine grained control over the security of their assets, and allows for emergent behavior around granting third party wallets limited access only to assets relevant to them. ### On-chain enumeration In order to support ease of integration and adoption, this specification has chosen to include on-chain enumeration of delegations and incur


=== ERC-7818 ===
TITLE: Expirable ERC-20
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2024-11-13
REQUIRES: 20

SUMMARY:
Introduces an extension for [ERC-20](./eip-20.md) tokens, which facilitates the implementation of an expiration mechanism. Through this extension, tokens have a predetermined validity period, after which they become invalid and can no longer be transferred or used. This functionality proves beneficial in scenarios such as time-limited bonds, loyalty rewards, or game tokens necessitating automatic invalidation after a specific duration. The extension is crafted to seamlessly align with the existing [ERC-20](./eip-20.md) standard, ensuring smooth integration with the prevailing token smart contract while introducing the capability to govern and enforce token expiration at the contract level.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Epoch Mechanism **Epochs** represent a specific period or block range during which certain tokens are valid. They can be categorized into two types - **block-based** Defined by a specific number of blocks (e.g., 1000 `blocks`). - **time-based** Defined by a specific duration in seconds (e.g., 1000 `seconds`). Tokens linked to an `epoch` remain valid as long as the `epoch` is active. Once the

MOTIVATION:
This extension facilitates the development of [ERC-20](./eip-20.md) standard compatible tokens featuring expiration dates. This capability broadens the scope of potential applications, particularly those involving time-sensitive assets. Expirable tokens are well-suited for scenarios necessitating temporary validity, including: - Bonds or financial instruments with defined maturity dates - Time-constrained assets within gaming ecosystems - Next-gen loyalty programs incorporating expiring rewards or points - Prepaid credits for utilities or services (e.g., cashback, data packages, fuel, computing resources) that expire if not used within a specified time frame - Postpaid telecom data package allocations that expire at the end of the billing

RATIONALE:
Although the term `epoch` is an abstract concept, it leaves room for various implementations. For example, epochs can support more granular tracking of tokens within each epoch, allowing for greater control over when tokens are valid or expired on-chain. Alternatively, epochs can support bulk expiration, where all tokens within the same epoch expire simultaneously. This flexibility enables different methods of tracking token expiration, depending on the specific needs of the use case. `epoch` also introduces a "lazy" way to simplify token expiration tracking in a flexible and gas-efficient manner. Instead of continuously updating the expiration state with `write`


=== ERC-5409 ===
TITLE: EIP-1155 Non-Fungible Token extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-07-23
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This standard is an extension of [EIP-1155](./eip-1155.md). It proposes an additional function, `ownerOf`, which allows EIP-1155 tokens to support Non-Fungibility (unique owners). By implementing this extra function, EIP-1155 tokens can benefit from [EIP-721](./eip-721.md)'s core functionality without implementing the (less efficient) EIP-721 specification in the same contract.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Contract Interface ```solidity interface IERC1155OwnerOf { /// @notice Find the owner of an NFT /// @dev The zero address indicates that there is no owner: either the token does not exist or it is not an NFT (supply potentially bigger than 1) /// @param tokenId The identifier for an NFT /// @return The address of the owner of the NFT function ownerOf(uint256 tokenId) external view returns (address); } ```

MOTIVATION:
Currently, EIP-1155 does not allow an external caller to detect whether a token is truly unique (can have only one owner) or fungible. This is because EIP-1155 do not expose a mechanism to detect whether a token will have its supply remain to be "1". Furthermore, it does not let an external caller retrieve the owner directly on-chain. The EIP-1155 specification does mention the use of split id to represent non-fungible tokens, but this requires a pre-established convention that is not part of the standard, and is not as simple as EIP-721's `ownerOf`. The ability to get the

RATIONALE:
`ownerOf` does not throw when a token does not exist (or does not have an owner). This simplifies the handling of such a case. Since it would be a security risk to assume all EIP-721 implementation would throw, it should not break compatibility with contract handling EIP-721 when dealing with this EIP-1155 extension.


=== ERC-6860 ===
TITLE: Web3 URL to EVM Call Message Translation
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-29
REQUIRES: 137

SUMMARY:
This standard translates an [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI like `web3://uniswap.eth/` to an EVM message such as: ``` EVMMessage { To: 0xaabbccddee.... // where uniswap.eth's address registered at ENS Calldata: 0x ... } ``` ⚠️ This proposal updates [ERC-4804](./eip-4804.md) with minor corrections, clarifications and modifications.

SPECIFICATION:
This specification only defines read-only (i.e. Solidity's `view` functions) semantics. State modifying functions may be defined as a future extension. This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC 2234](https://www.rfc-editor.org/rfc/rfc2234). The complete URI syntax is listed in Appendix A. A Web3 URL is an ASCII string in the following form : ``` web3URL = schema "://" [ userinfo "@" ] contractName [ ":" chainid ] pathQuery [ "#" fragment ] schema = "w3" / "web3" userinfo = address ``` **userinfo** indicates which user is calling the EVM, i.e., "From" field in EVM call message. If not

MOTIVATION:
Currently, reading data from Web3 generally relies on a translation done by a Web2 proxy to Web3 blockchain. The translation is mostly done by the proxies such as dApp websites/node service provider/etherscan, which are out of the control of users. The standard here aims to provide a simple way for Web2 users to directly access the content of Web3, especially on-chain Web contents such as SVG/HTML. Moreover, this standard enables interoperability with other standards already compatible with URIs, like SVG/HTML.

RATIONALE:
The purpose of the proposal is to add a decentralized presentation layer for Ethereum. With the layer, we are able to render any web content (including HTML/CSS/JPG/PNG/SVG, etc) on-chain using human-readable URLs, and thus EVM can be served as a decentralized backend. The design of the standard is based on the following principles: - **Human-readable**. The Web3 URL should be easily recognized by human similar to Web2 URL (`http://`). As a result, we support names from name services to replace address for better readability. In addition, instead of using calldata in hex, we use human-readable method + arguments


=== ERC-7715 ===
TITLE: Grant Permissions from Wallets
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-05-24
REQUIRES: 4, 3, 3, 7, ,,  , 5, 7, 9, 2, ,,  , 7, 6, 7, 9, ,,  , 7, 7, 1, 0

SUMMARY:
We define a new JSON-RPC method `wallet_grantPermissions` for DApp to request a Wallet to grant permissions in order to execute transactions on the user’s behalf. This enables two use cases: - Executing transactions for users without a wallet connection. - Executing transactions for users with a wallet connection that is scoped with permissions.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### `wallet_grantPermissions` We introduce a `wallet_grantPermissions` method for the DApp to request the Wallet to grant permissions. #### Permission schema ```tsx type PermissionRequest = { chainId: Hex; // hex-encoding of uint256 address?: Address; expiry: number; // unix timestamp signer: { type: string; // enum defined by ERCs data: Record<string, any>; }; permissions: { type: string; // enum defined by ERCs data: Record<string, any>; }[]; }[]; ``` `chainId` defines the

MOTIVATION:
Currently most DApps implement a flow similar to the following: ![Wallet Approve Flow](../assets/eip-7715/approve-flow.svg) Each interaction requires the user to sign a transaction with their wallet. The problems are: - It can get tedious for the user to manually approve every transaction, especially in highly-interactive applications such as games. - It’s impossible to send transactions for users without an active wallet connection. This invalidates use cases such as subscriptions, passive investments, limit orders, and more. In the context of AA, there are multiple vendor-specific implementations of session keys, which are temporary keys imbued with specific permissions. However, since the

RATIONALE:
The typical transaction flow of `suggesting transactions => approving transactions => sending transactions` is deeply limiting in several ways: - Users must be online to send transactions. DApps cannot send transactions for users when they are offline, which makes use cases such as subscriptions or automated trading impossible. - Users must manually approve every transaction, interrupting what could otherwise be a smooth user experience. With this ERC, DApps can request Wallets to grant permissions and execute transactions on the user's behalf, therefore circumventing the issues above. ### `permissionsContext` Since this ERC only specifies the interaction between the wallet


=== ERC-2098 ===
TITLE: Compact Signature Representation
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2019-03-14
REQUIRES: 2

SUMMARY:
The secp256k1 curve permits the computation of the public key of signed digest when coupled with a signature, which is used implicitly to establish the origin of a transaction from an Externally Owned Account as well as on-chain in EVM contracts for example, in meta-transactions and multi-sig contracts. Currently signatures require 65 bytes to represent, which when aligned to 256-bit words, requires 96 bytes (with 31 zero bytes injected). The yParity in RLP-encoded transactions also require (on average) 1.5 bytes. With compact signatures, this can be reduced to 64 bytes, which remains 64 bytes when word-aligned, and in

SPECIFICATION:
A secp256k1 signature is made up of 3 parameters, `r`, `s` and `yParity`. The `r` represents the `x` component on the curve (from which the `y` can be computed), and the `s` represents the challenge solution for signing by a private key. Due to the symmetric nature of an elliptic curve, a `yParity` is required, which indicates which of the 2 possible solutions was intended, by indicating its parity (odd-ness). Two key observations are required to create a compact representation. First, the `yParity` parameter is always either 0 or 1 (canonically the values used have historically been 27

MOTIVATION:
The motivations for a compact representation are to simplify handling transactions in client code, reduce gas costs and reduce transaction sizes.

RATIONALE:
The compact representation proposed is simple to both compose and decompose in clients and in Solidity, so that it can be easily (and intuitively) supported, while reducing transaction sizes and gas costs.


=== ERC-5554 ===
TITLE: NFT Legal Use, Repurposing, and Remixing
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-07-07
REQUIRES: 5218

SUMMARY:
This EIP extends any other token standard to provide: * Explicit rights for the token holder related to commercial exploitation, derivative works, and reproduction; * [EIP-5218](./eip-5218.md) interface for creating, viewing, and checking the status of licenses * Standard format for extended license information in the token metadata; * Standard events to track off chain creation of derivative works, commercial exploitation, and reproduction; * On chain tracking of derivative works and reproductions * Additional required fields in the smart contract to reference the copyright owner * Function calls for commercial exploitation, derivative works and reproduction.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Every contract compliant with this EIP must implement the `IERC5554` interface: ```solidity pragma solidity ^0.8.0; interface IERC5554 is IERC5218 { event CommercialExploitation(uint256 _tokenId, uint256 _licenseId, string _externalUri); event ReproductionCreated(uint256 _tokenId, uint256 _licenseId, uint256 _reproductionId, address _reproduction, uint256 _reproductionTokenId); event DerivativeCreated(uint256 _tokenId, uint256 _licenseId, uint256 _derivativeId, address _derivative, uint256 _derivativeTokenId); /// @notice Retrieve the copyright owner address /// @dev Throws unless the token exists /// @param tokenId The identifier for

MOTIVATION:
NFTs still face legal uncertainty, and many now realize that the rights associated with an NFT are just as important as the NFT itself. Our goal is to help the ecosystem reach clear consensus and broad understanding of what purchasers of NFTs are acquiring in terms of copyright or other rights. Today, purchasing the NFT of a digital work is not the same as purchasing the copyright in that work. In most cases, the NFT does not even incorporate the digital work; it only references it via a hash. Hence, the NFT holder owns a unique digital copy

RATIONALE:
We expand here upon the Motivation section to justify every decision made with regard to the specs of the standard: The `getLicenseId()` function takes a tokenID as a parameter, making it possible for different tokenID to be associated with different licensing terms. LicenseURI links to a content-addressed file that stipulates the terms and conditions of the license in actual legal language, so that the license can be read and understood by those who want to understand which rights are associated with the work of authorship, and which additional rights are granted through the acquisition of the NFT. When


=== ERC-823 ===
TITLE: Token Exchange Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-01-06
REQUIRES: 20

SUMMARY:
The following standard provides functionally to make payments in the form of any other registered tokens, as well as allow token contracts to store any other tokens in an existing token contract. This standard allows ERC20 token holders to exchange their token with another ERC20 token and use the exchanged tokens to make payments. After a successful payment, the former specified ERC20 tokens, will be stored within the ERC20 token contract they are exchanged with. This proposal uses the term target contract which is used to denote the contract to the token with whom we want to exchange

SPECIFICATION:
### Sender Interface This interface must be inherited by a ERC20 token contract that wants to exchange its tokens with another token. #### Storage Variables ##### exchnagedWith This mapping stores the number of tokens exchanged with another token, along with the latter’s address. Every time more tokens are exchanged the integer value is incremented consequently. This mapping acts as a record to denote which target contract holds our tokens. ```solidity mapping ( address => uint ) private exchangedWith; ``` ##### exchangedBy This mapping stores the address of the person who initiated the exchange and the amount of tokens

MOTIVATION:
Existing token standards do not provide functionality to exchange tokens. Existing token converters reduce the total supply of an existing token, which in the sense destroys the currency. Token converters do not solve this problem and hence discourages creation of new tokens. This solution does not destroy the existing token but in essence preserve them in the token contract that they are exchanged with, which in turn increases the market value of the latter.

RATIONALE:
Such a design provides a consistent exchange standard applicable to all ERC20 tokens that follow it. The primary advantage for of this strategy is that the exchanged tokens will not be lost. They can either be spent or preserved. Token convert face a major drawback of destroying tokens after conversion. This mechanism treats tokens like conventional currency where tokens are not destroyed but are stored.


=== ERC-4987 ===
TITLE: Held token interface
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-09-21
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
The proposed standard defines a lightweight interface to expose functional ownership and balances of held tokens. A held token is a token owned by a contract. This standard may be implemented by smart contracts which hold [EIP-20](./eip-20.md), [EIP-721](./eip-721.md), or [EIP-1155](./eip-1155.md) tokens and is intended to be consumed by both on-chain and off-chain systems that rely on ownership and balance verification.

SPECIFICATION:
Smart contracts implementing the `ERC20` held token standard MUST implement all of the functions in the `IERC20Holder` interface. Smart contracts implementing the `ERC20` held token standard MUST also implement `ERC165` and return true when the interface ID `0x74c89d54` is passed. ```solidity /** * @notice the ERC20 holder standard provides a common interface to query * token balance information */ interface IERC20Holder is IERC165 { /** * @notice emitted when the token is transferred to the contract * @param owner functional token owner * @param tokenAddress held token address * @param tokenAmount held token amount */ event Hold( address

MOTIVATION:
As different areas of crypto (DeFi, NFTs, etc.) converge and composability improves, there will more commonly be a distinction between the actual owner (likely a contract) and the functional owner (likely a user) of a token. Currently, this results in a conflict between mechanisms that require token deposits and systems that rely on those tokens for ownership or balance verification. This proposal aims to address that conflict by providing a standard interface for token holders to expose ownership and balance information. This will allow users to participate in these DeFi mechanisms without giving up existing token utility. Overall,

RATIONALE:
This interface is designed to be extremely lightweight and compatible with any existing token contract. Any token holder contract likely already stores all relevant information, so this standard is purely adding a common interface to expose that data. The token address parameter is included to support contracts that can hold multiple token contracts simultaneously. While some contracts may only hold a single token address, this is more general to either scenario. Separate interfaces are proposed for each token type (EIP-20, EIP-721, EIP-1155) because any contract logic to support holding these different tokens is likely independent. In the scenario


=== ERC-7598 ===
TITLE: Use contract signature for signed transfer
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-01-15
REQUIRES: 1, 2, 7, 1, ,,  , 3, 0, 0, 9

SUMMARY:
This proposal aims to extend the functionality of the existing [ERC-3009](./eip-3009.md) standard, "Transfer With Authorization," to support transfer operations initiated by smart contract wallets.

SPECIFICATION:
The following events and interfaces must still be present given the initial spec defined in [ERC-3009](./eip-3009.md). - Event `AuthorizationUsed`. - Constants `TRANSFER_WITH_AUTHORIZATION_TYPEHASH` and `RECEIVE_WITH_AUTHORIZATION_TYPEHASH`. - View function interface `authorizationState(address authorizer, bytes32 nonce)` In addition, the following interfaces must be added to be compliant with the standard: ``` /** * @notice Execute a transfer with a signed authorization * @param from Payer's address (Authorizer) * @param to Payee's address * @param value Amount to be transferred * @param validAfter The time after which this is valid (unix time) * @param validBefore The time before which this is valid (unix

MOTIVATION:
The existing [ERC-3009](./eip-3009.md) standard enables asset transfers with ECDSA signatures. However, as smart contract wallets become more prevalent in the ecosystem, the current standard is no longer sufficient. This proposal aims to enhance the usability and composeability of the standard by extending ERC-3009 with smart contract wallet signature validation, as defined in [ERC-1271](./eip-1271.md). By incorporating this extension, users will have greater flexibility in managing their assets while ensuring a secure authorization process.

RATIONALE:
By replacing the existing V, R, S signature validation scheme and introducing support for unstructured bytes input, contract developers can use a unified interface to validate signature from both EOAs and SC wallets. This allows for the utilization of different signature schemes and algorithms fitting the wallet type, paving the way for smart contract wallets and advanced wallet types to enhance their signature validation processes, promoting flexibility and innovation.


=== ERC-6120 ===
TITLE: Universal Token Router
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-12-12
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 0, 1, 4, ,,  , 1, 1, 5, 5

SUMMARY:
ETH is designed with *transfer-and-call* as the default behavior in a transaction. Unfortunately, [ERC-20](./eip-20.md) is not designed with that pattern in mind and newer standards cannot apply to the token contracts that have already been deployed. Application and router contracts must use the *approve-then-call* pattern, which costs additional $n\times m\times l$ `approve` (or `permit`) signatures for $n$ contracts, $m$ tokens, and $l$ accounts. Not only these allowance transactions create a bad user experience, cost a lot of user fees and network storage, but they also put users at serious security risks as they often have to approve unaudited,

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. The main interface of the UTR contract: ```solidity interface IUniversalTokenRouter { function exec( Output[] memory outputs, Action[] memory actions ) payable; } ``` ### Output Verification `Output` defines the expected token balance change for verification. ```solidity struct Output { address recipient; uint eip; // token standard: 0 for ETH or EIP number address token; // token contract address uint id; // token id for

MOTIVATION:
When users approve their tokens to a contract, they trust that: * it only spends the tokens with their permission (from `msg.sender` or `ecrecover`) * it does not use `delegatecall` (e.g. upgradable proxies) By ensuring the same security conditions above, the Universal Token Router can be shared by all interactive applications, saving most approval transactions for old tokens and **ALL** approval transactions for new tokens. Before this EIP, when users sign transactions to spend their approved tokens, they trust the front-end code entirely to construct those transactions honestly and correctly. This puts them at great risk of phishing

RATIONALE:
The `Permit` type signature is not supported since the purpose of the Universal Token Router is to eliminate all interactive `approve` signatures for new tokens, and *most* for old tokens.


=== ERC-2876 ===
TITLE: Deposit contract and address standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-08-13
REQUIRES: 

SUMMARY:
An ERC-2876 compatible **deposit system** can accept ETH payments from multiple depositors without the need for managing multiple keys or requiring use of a hot wallet. An ERC-2876 compatible **wallet application** can send ETH to ERC-2876 compatible **deposit systems** in a way that the **deposit system** can differentiate their payment using the 8 byte id specified in this standard. Adoption of ERC-2876 by all exchanges (as a deposit system and as a wallet for their withdrawal systems), merchants, and all wallet applications/libraries will likely decrease total network gas usage by these systems, since two value transactions cost 42000

SPECIFICATION:
### Definitions - The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. - `The contract interface` is the contract component of this ERC. - `The deposit address format` is the newly made format described in "Deposit Address Format" for encoding the 20 byte account address and the 8 byte id. - `The contract` refers to the contract that implements `the contract interface` of this ERC. - `The 8 byte "id"` is an 8 byte id used as the

MOTIVATION:
Centralized exchanges and merchants (Below: "apps") require an address format for accepting deposits. Currently the address format used refers to an account (external or contract), but this creates a problem. It requires that apps create a new account for every invoice / user. If the account is external, that means the app must have the deposit addresses be hot wallets, or have increased workload for cold wallet operators (as each deposit account will create 1 value tx to sweep). If the account is contract, generating an account costs at least 60k gas for a simple proxy, which is

RATIONALE:
The contract interface and address format combination has one notable drawback, which was brought up in discussion. This ERC can only handle deposits for native value (ETH) and not other protocols such as ERC-20. However, this is not considered a problem, because it is best practice to logically AND key-wise separate wallets for separate currencies in any exchange/merchant application for accounting reasons and also for security reasons. Therefore, using this method for the native value currency (ETH) and another method for ERC-20 tokens etc. is acceptable. Any attempt at doing something similar for ERC-20 would require modifying the


=== ERC-7007 ===
TITLE: Verifiable AI-Generated Content Token
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-05-10
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The verifiable AI-generated content (AIGC) non-fungible token (NFT) standard is an extension of the [ERC-721](./eip-721.md) token standard for AIGC. It proposes a set of interfaces for basic interactions and enumerable interactions for AIGC-NFTs. The standard includes an `addAigcData` and `verify` function interface, a new `AigcData` event, optional `Enumerable` and `Updatable` extensions, and a JSON schema for AIGC-NFT metadata. Additionally, it incorporates Zero-Knowledge Machine Learning (zkML) and Optimistic Machine Learning (opML) capabilities to enable verification of AIGC data correctness. In this standard, the `tokenId` is indexed by the `prompt`.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. **Every compliant contract must implement the `IERC7007`, [`ERC721`](./eip-721.md), and [`ERC165`](./eip-165.md) interfaces.** The verifiable AIGC-NFT standard includes the following interfaces: `IERC7007`: Defines an `addAigcData` function and an `AigcData` event for adding AIGC data to AIGC-NFTs. Defines a `verify` function to check the validity of the combination of prompt and aigcData using zkML/opML techniques. ```solidity pragma solidity ^0.8.18; /** * @dev Required interface of an ERC7007 compliant

MOTIVATION:
The verifiable AIGC-NFT standard aims to extend the existing [ERC-721](./eip-721.md) token standard to accommodate the unique requirements of AI-generated content NFTs representing models in a collection. This standard provides interfaces to use zkML or opML to verify whether or not the AIGC data for an NFT is generated from a certain ML model with a certain input (prompt). The proposed interfaces allow for additional functionality related to adding AIGC data, verifying, and enumerating AIGC-NFTs. Additionally, the metadata schema provides a structured format for storing information related to AIGC-NFTs, such as the prompt used to generate the content and

RATIONALE:
### Unique Token Identification This specification sets the `tokenId` to be the hash of its corresponding `prompt`, creating a deterministic and collision-resistant way to associate tokens with their unique content generation parameters. This design decision ensures that the same prompt (which corresponds to the same AI-generated content under the same model seed) cannot be minted more than once, thereby preventing duplication and preserving the uniqueness of each NFT within the ecosystem. ### Generalization to Different Proof Types This specification accommodates two proof types: validity proofs for zkML and fraud proofs for opML. Function arguments in `addAigcData` and `verify`


=== ERC-6662 ===
TITLE: AA Account Metadata For Authentication
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-09
REQUIRES: 4, 3, 3, 7, ,,  , 4, 8, 0, 4

SUMMARY:
This ERC proposes a new **IAccountMetadata** interface as an extension for [ERC-4337](./eip-4337.md) to store authentication data on-chain to support a more user-friendly authentication model.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Authentication Flow ![Authentication Flow](../assets/eip-6662/auth-flow.png) In the new authentication workflow, users use AA compatible smart contract accounts as their wallet addresses. **Authenticator** could be anything but holding the private key to sign users' operations. For example, it can be an offline authenticator mobile app or an online cloud service. **Relay** is an online service responsible for forwarding requests from dApps to the Authenticator. If the authenticator is online, it

MOTIVATION:
In this proposal, we propose a new **IAccountMetadata** interface as an extension for ERC-4337 **IAccount** interface. With this new interface, users can store authentication data on-chain through one-time publishing, allowing dApps to proactively fetch it from the chain to support a more flexible and user-friendly authentication model. This will serve as an alternative to the current authentication model where users need to log in with a wallet every time and push account-related information to dApps by connecting the wallet in advance.

RATIONALE:
To enable the new authentication workflow we described above, dApp needs to know two things: 1. **Where is the authenticator?** This is solved by the **relayURI** field in struct **AuthenticationInfo**. Users can publish the uri as the account metadata which will be pulled by dApp to do service discovery. 2. **What’s the format of AuthenticationRequest?** This is solved by the **schema** field in struct **AuthenticationInfo**. The schema defines the structure of the AuthenticationRequest object which is consumed by the authenticator. It can also be used to define extra fields for the relay service to enable flexible access control.


=== ERC-7507 ===
TITLE: Multi-User NFT Extension
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-08-24
REQUIRES: 721

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It proposes a new role `user` in addition to `owner` for a token. A token can have multiple users under separate expiration time. It allows the subscription model where an NFT can be subscribed non-exclusively by different users.

SPECIFICATION:
Solidity interface available at [`IERC7507.sol`](../assets/eip-7507/contracts/IERC7507.sol): ```solidity interface IERC7507 { /// @notice Emitted when the expires of a user for an NFT is changed event UpdateUser(uint256 indexed tokenId, address indexed user, uint64 expires); /// @notice Get the user expires of an NFT /// @param tokenId The NFT to get the user expires for /// @param user The user to get the expires for /// @return The user expires for this NFT function userExpires(uint256 tokenId, address user) external view returns(uint256); /// @notice Set the user expires of an NFT /// @param tokenId The NFT to set the user expires for

MOTIVATION:
Some NFTs represent IP assets, and IP assets have the need to be licensed for access without transferring ownership. The subscription model is a very common practice for IP licensing where multiple users can subscribe to an NFT to obtain access. Each subscription is usually time limited and will thus be recorded with an expiration time. Existing [ERC-4907](./eip-4907.md) introduces a similar feature, but does not allow for more than one user. It is more suitable in the rental scenario where a user gains an exclusive right of use to an NFT before the next user. This rental model

RATIONALE:
This standard complements [ERC-4907](./eip-4907.md) to support multi-user feature. Therefore the proposed interface tries to keep consistent using the same naming for functions and parameters. However, we didn't include the corresponding `usersOf(uint256 tokenId)` function as that would imply the implemention has to support enumerability over multiple users. It is not always necessary, for example, in the case of open subscription. So we decide not to add it to the interface and leave the choice up to the implementers.


=== ERC-3561 ===
TITLE: Trust Minimized Upgradeability Proxy
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-05-09
REQUIRES: 

SUMMARY:
Removing trust from upgradeability proxy is necessary for anonymous developers. In order to accomplish this, instant and potentially malicious upgrades must be prevented. This EIP introduces additional storage slots for upgradeability proxy which are assumed to decrease trust in interaction with upgradeable smart contracts. Defined by the admin implementation logic can be made an active implementation logic only after Zero Trust Period allows.

SPECIFICATION:
The specification is an addition to the standard [EIP-1967](./eip-1967.md) transparent proxy design. The specification focuses on the slots it adds. All admin interactions with trust minimized proxy must emit an event to make admin actions trackable, and all admin actions must be guarded with `onlyAdmin()` modifier. ### Next Logic Contract Address Storage slot `0x19e3fabe07b65998b604369d85524946766191ac9434b39e27c424c976493685` (obtained as `bytes32(uint256(keccak256('eip3561.proxy.next.logic')) - 1)`). Desirable implementation logic address must be first defined as next logic, before it can function as actual logic implementation stored in EIP-1967 `IMPLEMENTATION_SLOT`. Admin interactions with next logic contract address correspond with these methods and events: ```solidity // Sets

MOTIVATION:
Anonymous developers who utilize upgradeability proxies typically struggle to earn the trust of the community. Fairer, better future for humanity absolutely requires some developers to stay anonymous while still attract vital attention to solutions they propose and at the same time leverage the benefits of possible upgradeability.

RATIONALE:
An argument "just don't make such contracts upgadeable at all" fails when it comes to complex systems which do or do not heavily rely on human factor, which might manifest itself in unprecedented ways. It might be impossible to model some systems right on first try. Using decentralized governance for upgrade management coupled with EIP-1967 proxy might become a serious bottleneck for certain protocols before they mature and data is at hand. A proxy without a time delay before an actual upgrade is obviously abusable. A time delay is probably unavoidable, even if it means that inexperienced developers


=== ERC-1444 ===
TITLE: Localized Messaging with Signal-to-Text
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-23
REQUIRES: 

SUMMARY:
An on-chain system for providing user feedback by converting machine-efficient codes into human-readable strings in any language or phrasing. The system does not impose a list of languages, but rather lets users create, share, and use the localizated text of their choice.

SPECIFICATION:
### Contract Architecture Two types of contract: `LocalizationPreferences`, and `Localization`s. The `LocalizationPreferences` contract functions as a proxy for `tx.origin`. ```diagram +--------------+ | | +------> | Localization | | | | | +--------------+ | | +-----------+ +-------------------------+ | +--------------+ | | | | <------+ | | | Requestor | <------> | LocalizationPreferences | <-------------> | Localization | | | | | <------+ | | +-----------+ +-------------------------+ | +--------------+ | | | +--------------+ | | | +------> | Localization | | | +--------------+ ``` ### `Localization` A contract that holds a simple mapping of codes to their text representations. ```solidity

MOTIVATION:
There are many cases where an end user needs feedback or instruction from a smart contract. Directly exposing numeric codes does not make for good UX or DX. If Ethereum is to be a truly global system usable by experts and lay persons alike, systems to provide feedback on what happened during a transaction are needed in as many languages as possible. Returning a hard-coded string (typically in English) only serves a small segment of the global population. This standard proposes a method to allow users to create, register, share, and use a decentralized collection of translations, enabling

RATIONALE:
### `bytes32` Keys `bytes32` is very efficient since it is the EVM's base word size. Given the enormous number of elements (card(A) > 1.1579 × 10<sup>77</sup>), it can embed nearly any practical signal, enum, or state. In cases where an application's key is longer than `bytes32`, hashing that long key can map that value into the correct width. Designs that use datatypes with small widths than `bytes32` (such as `bytes1` in [ERC-1066](./eip-1066.md)) can be directly embedded into the larger width. This is a trivial one-to-one mapping of the smaller set into the larger one. ### Local vs Globals


=== ERC-1438 ===
TITLE: dApp Components (avatar) & Universal Wallet
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-21
REQUIRES: 

SUMMARY:
There have been suggestions for modified tokens based on erc20, but since many tokens have already been built on erc20, it is necessary to increase the utilization of already developed erc20 tokens. Therefore, we propose a universal wallet that can use erc20 tokens universally. We also propose a component dApp that allows you to create and save your avatar (& social badge system), and use it immediately in other services. All of the dApps suggested in this document are based on decentralized development and use that anyone can create and participate in.

SPECIFICATION:
### 1. Avatar #### 1.1. Avatar Shop - The avatar store is created after ERC20 currency is set. - You can customize asset category & viewer script. #### 1.2. Upload asset & user data The avatar's information & assets are stored in the event log part of the block chain. - Assets are SVG format. (compressed with gzip) - avatar information data is json (compressed with msgpack) ![avatar](../assets/eip-1438/avatar.png) ** The avatar assets from [Avataaars](https://github.com/fangpenlin/avataaars) developed by [Fang-Pen Lin](https://twitter.com/fangpenlin), the original avatar is designed by [Pablo Stanley](https://twitter.com/pablostanley). ### 2. Universal Wallet ![wallet](../assets/eip-1438/wallet.png) #### 2.1. ERC20 interface ``` js contract

MOTIVATION:
While many projects are under development in an open source way, they are simply adding and deploy with open sources to their projects. This means that you are developing a centralized service that uses your own dApp-generated information on your own. In order to improve the block chain ecosystem, all resources created by dApp and placed in the public block chain must be reusable in another dApp. This means that you can enhance your service by exchanging the generated information with other dApp. Likewise, ERC20 Tokens require Universal Wallet standards to be easy to use for direct transactions.


=== ERC-5564 ===
TITLE: Stealth Addresses
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-08-13
REQUIRES: 

SUMMARY:
This specification establishes a standardized method for interacting with stealth addresses, which allow senders of transactions or transfers to non-interactively generate private accounts exclusively accessible by their recipients. Moreover, this specification enables developers to create stealth address protocols based on the foundational implementation outlined in this ERC, utilizing a singleton contract deployed at `0x55649E01B5Df198D18D95b5cc5051630cfD45564` to emit the necessary information for recipients. In addition to the base implementation, this ERC also outlines the first implementation of a cryptographic scheme, specifically the SECP256k1 curve.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Definitions: - A "stealth meta-address" is a set of one or two public keys that can be used to compute a stealth address for a given recipient. - A "spending key" is a private key that can be used to spend funds sent to a stealth address. A "spending public key" is the corresponding public key. - A "viewing key" is a private key that can be used to

MOTIVATION:
The standardization of non-interactive stealth address generation presents the potential to significantly improve the privacy capabilities of the Ethereum network and other EVM-compatible chains by allowing recipients to remain private when receiving assets. This is accomplished through the sender generating a stealth address based on a shared secret known exclusively to the sender and recipient. The recipients alone can access the funds stored at their stealth addresses, as they are the sole possessors of the necessary private key. As a result, observers are unable to associate the recipient's stealth address with their identity, thereby preserving the recipient's privacy

RATIONALE:
This ERC emerged from the need for privacy-preserving ways to transfer ownership without disclosing any information about the recipients' identities. Token ownership can expose sensitive personal information. While individuals may wish to donate to a specific organization or country, they might prefer not to disclose a link between themselves and the recipient simultaneously. Standardizing stealth address generation represents a significant step towards unlinkable interactions, since such privacy-enhancing solutions require standards to achieve widespread adoption. Consequently, it is crucial to focus on developing generalizable approaches for implementing related solutions. The stealth address specification standardizes a protocol for generating and


=== ERC-2848 ===
TITLE: My Own Messages (MOM)
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-08-02
REQUIRES: 

SUMMARY:
My Own Messages (MOM) use Ethereum as a certification layer for commands and multihash of your messages. It don't use smart contracts but simple self-send transactions with specific payload attached. To ge more insights, you can test a [live client](http://internetofpeers.org/mom-client/), watch a [full video overview and demo](https://www.youtube.com/watch?v=z1SnoQkQYkU) and read a [brief presentation](../assets/eip-2848/presentation.pdf).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) when, and only when, they appear in all capitals as shown here. Clients following MOM standard **MUST** allow users to send and to read MOM transaction, creating an _updated message list_ for each address the users are interested in. Reading MOM transactions, MOM clients **MUST** be able to show the current and updated message list, and they **SHOULD** be able to show also all the message history if users

MOTIVATION:
As a _developer_ or _pool's owner_, I'd like to send messages to my users in a decentralized way. They must be able to easily verify my role in the smart contract context (owner, user, and so on) and they must be able to do it without relying on external, insecure and hackable social media sites (Facebook, Twitter, you name it). Also, I'd like to read messages from my userbase, in the same secure and verifiable manner. As a _user_, I want a method to easily share my thoughts and idea, publish content, send messages, receive feedback, receive tips,

RATIONALE:
Ethereum is _account based_, so it's good to be identified as a single source of information. It is also able of doing notarization very well and to impose some restrictions on transaction's structure, so it's good for commands. IPFS, Swarm or other CANs (Content Addressable Networks) or storage methods are good to store a lot of information. So, the union of both worlds it's a good solution to achieve the objectives of this message standard. The objective is also to avoid in the first place any kind of scam and malicious behaviors, so MOM don't allow to send


=== ERC-4944 ===
TITLE: Contract with Exactly One Non-fungible Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-03-25
REQUIRES: 721

SUMMARY:
The following describes standard functions for an [ERC-721](./eip-721.md) compatible contract with a total supply of one. This allows an NFT to be associated uniquely with a single contract address.

SPECIFICATION:
The constructor should mint the unique token of the contract, and then the mint function should add a restriction to avoid further minting. Also, a `tokenTransfer` function should be added in order to allow the contract owner to transact with the ERC-20 tokens owned by the contract/NFT itself. So that if the contract receives a transfer of ERC-20 tokens, the owner of the NFT could spend it from the contract wallet.

MOTIVATION:
If the ERC-721 was modified to mint only 1 token (per contract), then the contract address could be identified uniquely with that minted token (instead of the tuple contract address + token id, as ERC-721 requires). This change would enable automatically all the capabilities of composable tokens [ERC-998](./eip-998.md) (own other ERC-721 or [ERC-20](./eip-20.md)) natively without adding any extra code, just forbidding to mint more than one token per deployed contract. Then the NFT minted with this contract could operate with his "budget" (the ERC-20 he owned) and also trade with the other NFTs he could own. Just like

RATIONALE:
The main motivation is to keep the contract compatible with current ERC-721 platforms.


=== ERC-2018 ===
TITLE: Clearable Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-04-30
REQUIRES: 1996

SUMMARY:
The clearing process turns the promise of a transfer into the actual movement of money from one account to another. A clearing agent decides if the transfer can be executed or not. The amount which should be transferred is not deducted from the balance of the payer, but neither is it available for another transfer and therefore ensures, that the execution of the transfer will be successful when it is executed.

SPECIFICATION:
```solidity interface ClearableToken /* is ERC-1996 */ { enum ClearableTransferStatusCode { Nonexistent, Ordered, InProcess, Executed, Rejected, Cancelled } function orderTransfer(string calldata operationId, address to, uint256 value) external returns (bool); function orderTransferFrom(string calldata operationId, address from, address to, uint256 value) external returns (bool); function cancelTransfer(string calldata operationId) external returns (bool); function processClearableTransfer(string calldata operationId) external returns (bool); function executeClearableTransfer(string calldata operationId) external returns (bool); function rejectClearableTransfer(string calldata operationId, string calldata reason) external returns (bool); function retrieveClearableTransferData(string calldata operationId) external view returns (address from, address to, uint256 value, ClearableTransferStatusCode status); function authorizeClearableTransferOperator(address operator) external returns (bool); function revokeClearableTransferOperator(address operator) external

MOTIVATION:
A regulated token needs to comply with all the legal requirements, especially [KYC][KYC-Wikipedia] and [AML][AML-Wikipedia]. Some of these checks may not be able to be done on-chain and therefore a transfer may not be completed in one step. Currently there is no EIP to make such off-chain checks possible. This proposal allows a user to order a transfer, which can be checked by a clearing agent off-chain. Depending on the result of it, the clearing agent will either execute or cancel the transfer. To provide more information why a transfer is cancelled, the clearing agent can add a

RATIONALE:
This EIP uses [EIP-1996][EIP-1996] to hold the money after a transfer is ordered. A clearing agent, whose implementation is not part of this proposal, acts as a predefined notary to decide if the transfer complies with the rules of the token or not. The `operationId` is a string and not something more gas efficient to allow easy traceability of the hold and allow human readable ids. It is up to the implementer if the string should be stored on-chain or only its hash, as it is enough to identify a hold. The `operationId` is a competitive resource. It


=== ERC-3009 ===
TITLE: Transfer With Authorization
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-09-28
REQUIRES: 2, 0, ,,  , 7, 1, 2

SUMMARY:
A set of functions to enable meta-transactions and atomic interactions with [ERC-20](./eip-20.md) token contracts via signatures conforming to the [EIP-712](./eip-712.md) typed message signing specification. This enables the user to: - delegate the gas payment to someone else, - pay for gas in the token itself rather than in ETH, - perform one or more token transfers and other operations in a single atomic transaction, - transfer ERC-20 tokens to another address, and have the recipient submit the transaction, - batch multiple transactions with minimal overhead, and - create and perform multiple transactions without having to worry about them

SPECIFICATION:
### Event ```solidity event AuthorizationUsed( address indexed authorizer, bytes32 indexed nonce ); // keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)") bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267; // keccak256("ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)") bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8; /** * @notice Returns the state of an authorization * @dev Nonces are randomly generated 32-byte data unique to the authorizer's * address * @param authorizer Authorizer's address * @param nonce Nonce of the authorization * @return True if the nonce is used */ function authorizationState( address authorizer, bytes32 nonce ) external view returns (bool); /** * @notice

MOTIVATION:
There is an existing spec, [EIP-2612](./eip-2612), that also allows meta-transactions, and it is encouraged that a contract implements both for maximum compatibility. The two primary differences between this spec and EIP-2612 are that: - EIP-2612 uses sequential nonces, but this uses random 32-byte nonces, and that - EIP-2612 relies on the ERC-20 `approve`/`transferFrom` ("ERC-20 allowance") pattern. The biggest issue with the use of sequential nonces is that it does not allow users to perform more than one transaction at time without risking their transactions failing, because: - DApps may unintentionally reuse nonces that have not yet been processed

RATIONALE:
### Unique Random Nonce, Instead of Sequential Nonce One might say transaction ordering is one reason why sequential nonces are preferred. However, sequential nonces do not actually help achieve transaction ordering for meta transactions in practice: - For native Ethereum transactions, when a transaction with a nonce value that is too-high is submitted to the network, it will stay pending until the transactions consuming the lower unused nonces are confirmed. - However, for meta-transactions, when a transaction containing a sequential nonce value that is too high is submitted, instead of staying pending, it will revert and fail immediately,


=== ERC-7621 ===
TITLE: Basket Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-11
REQUIRES: 2, 0, ,,  , 7, 2, 1

SUMMARY:
The Basket Token Standard (BTS) allows for the implementation of multi-asset tokenized funds. This standard provides basic functionality for anyone to deploy unique, non-fungible BTS tokens that can contain an unlimited number of underlying [ERC-20](./eip-20.md) tokens. The deployer receives a BTS token representative of their ownership of the fund, as well as liquidity provider (LP) tokens representative of their percentage share of the fund (100% at time of deployment but changing as other wallets contribute/withdraw). Whenever a contribution is made to a BTS, BTS LP tokens are minted and distributed to the contributor’s wallet (representative of their share

SPECIFICATION:
### BTS BTS is a smart contract enabling the creation of on-chain tokenized funds backed by assets, allowing users to manage assets and liquidity through functions like initialization, contribution, withdrawal, rebalancing, and token distribution. #### Purpose The purpose of the BTS is to allow anyone to build an on-chain tokenized fund that is fully asset backed using on-chain liquidity. #### Key Functions `initialize`: Initializes a new BTS with name, symbol, creator, tokens, weights, token URI, and optional auto-rebalance setting. `contribute()`: Allows users to add ETH to the basket, purchasing proportional amounts of included tokens based on predefined weights.

MOTIVATION:
The motivation is to provide infrastructure that will enable the on-chain creation and management of asset-backed tokenized investment funds as no such standardized infrastructure curently exists. Providing the necessary infrastructure will help facilitate the onboarding of traditional fund management onto blockchain. No existing standard is capable of achieving this as they lack the required features for third party contribution, namely the minting of LP tokens when contribution is made. The [ERC-7621](./eip-7621.md) is the only token standard that facilitates this with a rebalance function required for effective fund management, and LP token distribution and burning, required for third party

RATIONALE:
<!-- TODO -->


=== ERC-4955 ===
TITLE: Vendor Metadata Extension for NFTs
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-03-29
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP standardizes a schema for NFTs metadata to add new field namespaces to the JSON schema for [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) NFTs.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Schema (subject to "caveats" below) A new property called `namespaces` is introduced. This property expects one object per project as shown in the example below. ```jsonc { "title": "Asset Metadata", "type": "object", "properties": { "name": { "type": "string", "description": "Identifies the asset that this NFT represents" }, "description": { "type": "string", "description": "Describes the asset that this NFT represents" }, "image": { "type": "string", "description": "A URI pointing

MOTIVATION:
A standardized NFT metadata schema allows wallets, marketplaces, metaverses, and similar applications to interoperate with any NFT. Applications such as NFT marketplaces and metaverses could usefully leverage NFTs by rendering them using custom 3D representations or any other new attributes. Some projects like Decentraland, TheSandbox, Cryptoavatars, etc. need their own 3D model in order to represent an NFT. These models are not cross-compatible because of distinct aesthetics and data formats.

RATIONALE:
There are many projects which need custom properties in order to display a current NFT. Each project may have its own way to render the NFTs and therefore they need different values. An example of this is the metaverses like Decentraland or TheSandbox where they need different 3d models to render the NFT based on the visual/engine of each. NFTs projects like Cryptopunks, Bored Apes, etc. can create the 3d models needed for each project and therefore be supported out of the box. The main differences between the projects that are rendering 3d NFTs (models) are: ### Armatures


=== ERC-6864 ===
TITLE: Upgradable Fungible Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-05
REQUIRES: 20

SUMMARY:
This proposal outlines a smart contract interface for upgrading/downgrading existing [ERC-20](./eip-20.md) smart contracts while maintaining user balances. The interface itself is an extension to the ERC-20 standard so that other smart contracts can continue to interact with the upgraded smart contract without changing anything other than the address.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ```solidity pragma solidity ^0.8.0; /** @title Upgradable Fungible Token @dev See https://eips.ethereum.org/EIPS/eip-6864 */ interface IERC6864 is IERC20 { /** @dev MUST be emitted when tokens are upgraded @param from Previous owner of base ERC-20 tokens @param to New owner of ERC-6864 tokens @param amount The amount that is upgraded */ event Upgrade(address indexed from, address indexed to, uint256 amount); /** @dev MUST be emitted

MOTIVATION:
By design, smart contracts are immutable and token standards like ERC-20 are minimalistic. While these design principles are fundamental in decentalized applications, there are sensible and practical situations where the ability to upgrade an ERC-20 token is desirable, such as: - to address bugs and remove limitations - to adopt new features and standards - to comply w/ changing regulations Proxy pattern using `delegatecall` opcode offers a reasonable, generalized solution to reconcile the immutability and upgradability features but has its own shortcomings: - the smart contracts must support proxy pattern from the get go, i.e. it cannot be

RATIONALE:
### Extending ERC-20 standard The goal of this proposal is to upgrade without affecting user balances, therefore leveraging existing data structure and methods is the path of the least engineering efforts as well as the most interoperability. ### Supporting downgrade The ability to downgrade makes moving between multiple IERC-6864 implementations on the same base ERC-20 smart contract possible. It also allows a way out should bugs or limitations discovered on ERC-6864 smart contract, or the user simply changes his or her mind. ### Optional see-through extension While these functions are useful in many situations, they are trivial to


=== ERC-1592 ===
TITLE: Address and ERC20-compliant transfer rules
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-11-09
REQUIRES: 

SUMMARY:
This standard proposal should answer the following challenges: - Enable integration of rules with interacting platforms such as exchanges, decentralized wallets and DApps. - Externale code and storage, improve altogether reusability, gas costs and contracts' memory footprint. - Highlight contract behavior and its evolution, in order to ease user interaction with such contract. If these challenges are answered, this proposal will provide a unified basis for transfer rules and hopefully address the transfer restriction needs of other EIPs as well, e.g. [EIP-902](./eip-902.md), [EIP-1066](./eip-1066.md) and [EIP-1175](./eip-1175.md). This document proposes specifications for a standard of **transfer rules** and interfaces to

SPECIFICATION:
We define below an interface for a rule. Rules are meant to be as simple as possible, to limit gas expenditure, since that logic will be executed on every transfer. Another reason for keeping rules simple and short, and strive for atomicity, is to facilitate both composition and interpretation of rejected transfers. By knowing which rule was triggered, we obtain a clear picture of the reason for rejection. The engine we propose executes all the rules defined by its owner, on every transfer and it is easy to add and remove rules individually, although we have chosen to

MOTIVATION:
ERC20 was designed as a standard interface allowing any token on Ethereum to be handled by other applications: from wallets to decentralized exchanges. This has been extremely powerful, but future developments in the industry of tokenization are bringing new challenges. For example it is already hard to know exactly why an ERC20 transfer failed, and it will become even harder when many tokens add their own transfer rules to the mix; we propose that it should be trivial to determine before a tx is sent, whether the transfer should turn out valid or invalid, and why (unless conditions


=== ERC-3525 ===
TITLE: Semi-Fungible Token
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-12-01
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This is a standard for semi-fungible tokens. The set of smart contract interfaces described in this document defines an [ERC-721](./eip-721.md) compatible token standard. This standard introduces an `<ID, SLOT, VALUE>` triple scalar model that represents the semi-fungible structure of a token. It also introduces new transfer models as well as approval models that reflect the semi-fungible nature of the tokens. Token contains an ERC-721 equivalent ID property to identify itself as a universally unique entity, so that the tokens can be transferred between addresses and approved to be operated in ERC-721 compatible way. Token also contains a `value`

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. **Every [ERC-3525](./eip-3525.md) compliant contract must implement the ERC-3525, ERC-721 and [ERC-165](./eip-165.md) interfaces** ```solidity pragma solidity ^0.8.0; /** * @title ERC-3525 Semi-Fungible Token Standard * Note: the ERC-165 identifier for this interface is 0xd5358140. */ interface IERC3525 /* is IERC165, IERC721 */ { /** * @dev MUST emit when value of a token is transferred to another token with the same slot, * including zero value transfers (_value == 0) as

MOTIVATION:
Tokenization is one of the most important trends by which to use and control digital assets in crypto. Traditionally, there have been two approaches to do so: fungible and non-fungible tokens. Fungible tokens generally use the ERC-20 standard, where every unit of an asset is identical to each other. ERC-20 is a flexible and efficient way to manipulate fungible tokens. Non-fungible tokens are predominantly ERC-721 tokens, a standard capable of distinguishing digital assets from one another based on identity. However, both have significant drawbacks. For example, ERC-20 requires that users create a separate ERC-20 contract for each individual

RATIONALE:
### Metadata generation This token standard is designed to represent semi-fungible assets, which are most suited for financial instruments rather than collectibles or in-game items. For maximum transparency and safety of digital assets, we strongly recommend that all implementations should generate metadata directly from contract code rather than giving out an off-chain server URL. ### Design decision: Value transfer from token to address The 'value' of a token is a property of the token and is not linked to an address, so to transfer the value to an address would be actually transferring it to a token owned


=== ERC-1812 ===
TITLE: Ethereum Verifiable Claims
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-03-03
REQUIRES: 712

SUMMARY:
A new method for Off-Chain Verifiable Claims built on [EIP-712](./eip-712.md). These Claims can be issued by any user with a EIP 712 compatible web3 provider. Claims can be stored off chain and verified on-chain by Solidity Smart Contracts, State Channel Implementations or off-chain libraries.

SPECIFICATION:
### Claims Claims can be generalized like this: > Issuer makes the claim that Subject is something or has some attribute and value. Claims should be deterministic, in that the same claim signed multiple times by the same signer. ### Claims data structure Each claim should be typed based on its specific use case, which EIP 712 lets us do effortlessly. But there are 3 minimal attributes required of the claims structure. * `subject` the subject of the claim as an `address` (who the claim is about) * `validFrom` the time in seconds encoded as a `uint256` of

MOTIVATION:
Reusable Off-Chain Verifiable Claims provide an important piece of integrating smart contracts with real world organizational requirements such as meeting regulatory requirements such as KYC, GDPR, Accredited Investor rules etc. [ERC-735](https://github.com/ethereum/EIPs/issues/735) and [ERC-780](https://github.com/ethereum/EIPs/issues/780) provide methods of making claims that live on chain. This is useful for some particular use cases, where some claim about an address must be verified on chain. In most cases though it is both dangerous and in some cases illegal (according to EU GDPR rules for example) to record Identity Claims containing Personal Identifying Information (PII) on an immutable public database such as the

RATIONALE:
Signed Typed Data provides a strong foundation for Verifiable Claims that can be used in many different kinds of applications built on both Layer 1 and Layer 2 of Ethereum. ### Rationale for using not using a single EIP 712 Domain EIP712 supports complex types and domains in itself, that we believe are perfect building blocks for building Verifiable Claims for specific purposes. The Type and Domain of a Claim is itself an important part of a claim and ensures that Verifiable Claims are used for the specific purposes required and not misused. EIP712 Domains also allow rapid


=== ERC-5269 ===
TITLE: ERC Detection and Discovery
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-07-15
REQUIRES: 5750

SUMMARY:
An interface for better identification and detection of ERC by numbers. It designates a field in which it's called `majorERCIdentifier` which is normally known or referred to as "ERC number". For example, `ERC-721` aka [ERC-721](./eip-721.md) has a `majorERCIdentifier = 721`. This ERC has a `majorERCIdentifier = 5269`. Calling it a `majorERCIdentifier` instead of `ERCNumber` makes it future-proof: anticipating there is a possibility where future ERC is not numbered or if we want to incorporate other types of standards. It also proposes a new concept of `minorERCIdentifier` which is left for authors of individual ERC to define. For example,

SPECIFICATION:
In the following description, we use ERC and ERC inter-exchangeably. This was because while most of the time the description applies to an ERC category of the Standards Track of ERC, the ERC number space is a subspace of ERC number space and we might sometimes encounter ERCs that aren't recognized as ERCs but has behavior that's worthy of a query. 1. Any compliant smart contract MUST implement the following interface ```solidity // DRAFTv1 pragma solidity ^0.8.9; interface IERC5269 { event OnSupportERC( address indexed caller, // when emitted with `address(0x0)` means all callers. uint256 indexed majorERCIdentifier, bytes32 indexed

MOTIVATION:
This ERC is created as a competing standard for [ERC-165](./eip-165.md). Here are the major differences between this ERC and [ERC-165](./eip-165.md). 1. [ERC-165](./eip-165.md) uses the hash of a method's signature which declares the existence of one method or multiple methods, therefore it requires at least one method to *exist* in the first place. In some cases, some ERCs interface does not have a method, such as some ERCs related to data format and signature schemes or the "Soul-Bound-ness" aka SBT which could just revert a transfer call without needing any specific method. 1. [ERC-165](./eip-165.md) doesn't provide query ability based

RATIONALE:
1. When data type `uint256 majorERCIdentifier`, there are other alternative options such as: - (1) using a hashed version of the ERC number, - (2) use a raw number, or - (3) use an ERC-165 identifier. The pros for (1) are that it automatically supports any evolvement of future ERC numbering/naming conventions. But the cons are it's not backward readable: seeing a `hash(ERC-number)` one usually can't easily guess what their ERC number is. We choose the (2) in the rationale laid out in motivation. 2. We have a `bytes32 minorERCIdentifier` in our design decision. Alternatively, it could be


=== ERC-7743 ===
TITLE: Multi-Owner Non-Fungible Tokens (MO-NFT)
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-07-13
REQUIRES: 

SUMMARY:
This ERC proposes a new standard for non-fungible tokens (NFTs) that supports multiple owners. The MO-NFT standard allows a single NFT to have multiple owners, reflecting the shared and distributable nature of digital assets. This model incorporates mechanisms for provider-defined transfer fees and ownership burning, enabling flexible and collaborative ownership structures. It maintains compatibility with the existing [ERC-721](./eip-721.md) standard to ensure interoperability with current tools and platforms.

SPECIFICATION:
### Token Creation and Ownership Model 1. **Minting**: - The function `mintToken()` allows the creation of a new MO-NFT. The caller becomes both the initial owner and the provider of the token. ```solidity function mintToken() public onlyOwner returns (uint256); ``` - A new `tokenId` is generated, and the caller is added to the owners set and recorded as the provider. The `balanceOf` the caller is incremented. 2. **Ownership List**: - The MO-NFT maintains a list of owners for each token. Owners are stored in an enumerable set to prevent duplicates and allow efficient lookup. 3. **Provider Role**: -

MOTIVATION:
Traditional NFTs enforce a single-ownership model, which does not align with the inherent duplicability and collaborative potential of digital assets. MO-NFTs allow for shared ownership, promoting wider distribution and collaboration while maintaining secure access control. The inclusion of provider fees and ownership burning enhances the utility and flexibility of NFTs in representing digital assets and services.

RATIONALE:
1. **Multi-Ownership Model**: - Digital assets are inherently duplicable and can be shared without loss of quality. The multi-owner model allows broader distribution and collaboration while maintaining a unique token identity. 2. **Additive Ownership**: - By adding new owners without removing existing ones, we support shared ownership models common in collaborative environments and digital content distribution. 3. **Provider Fee Mechanism**: - Incorporating a provider fee incentivizes creators and providers by rewarding them whenever the asset is transferred. This aligns with models where creators receive royalties or fees for their work. 4. **Ownership Burning**: - Allowing owners to remove


=== ERC-1046 ===
TITLE: tokenURI Interoperability
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-04-13
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
[ERC-721](./eip-721.md) introduced a `tokenURI` function for non-fungible tokens to handle miscellaneous metadata such as: - thumbnail image - title - description - special asset properties - etc. This ERC adds a `tokenURI` function to [ERC-20](./eip-20.md), and extends [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) to enable interoperability between all three types of token URI.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Interoperability Metadata The following TypeScript interface is used in later sections: ```typescript /** * Interoperability metadata. * This can be extended by other proposals. * * All fields MUST be optional. * **Not every field has to be a boolean.** Any optional JSON-serializable object can be used by extensions. */ interface InteroperabilityMetadata { /** * This MUST be true if this is ERC-1046

MOTIVATION:
See the note about the metadata extension in [ERC-721](./eip-721.md#rationale). The same arguments apply to ERC-20. Being able to use similar mechanisms to extract metadata for ERC-20, ERC-721, ERC-1155, and future standards is useful for determining: - What type of token a contract is (if any); - How to display a token to a user, either in an asset listing page or on a dedicated token page; and - Determining the capabilities of the token

RATIONALE:
This ERC makes adding metadata to ERC-20 tokens more straightforward for developers, with minimal to no disruption to the overall ecosystem. Using the same parameter name makes it easier to reuse code. Additionally, the recommendations not to use ERC-20's `name`, `symbol`, and `decimals` functions save gas. Built-in interoperability is useful as otherwise it might not be easy to differentiate the type of the token. Interoperability could be done using [ERC-165](./eip-165.md), but static calls are time-inefficient for wallets and websites, and is generally inflexible. Instead, including interoperability data in the token URI increases flexibility while also giving a performance


=== ERC-6617 ===
TITLE: Bit Based Permission
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-02-27
REQUIRES: 

SUMMARY:
This EIP offers a standard for building a bit-based permission and role system. Each permission is represented by a single bit. By using an `uint256`, up to $256$ permissions and $2^{256}$ roles can be defined. We are able to specify the importance of each permission based on the order of the bits.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. _Note_ The following specifications use syntax from Solidity `0.8.7` (or above) Interface of reference is described as followed: ```solidity pragma solidity ^0.8.7; /** @title EIP-6617 Bit Based Permission @dev See https://eips.ethereum.org/EIPS/eip-6617 */ interface IEIP6617 { /** MUST trigger when a permission is granted. @param _grantor Grantor of the permission @param _permission Permission that is granted @param _user User who received the permission */ event

RATIONALE:
Currently permission and access control is performed using a single owner ([ERC-173](./eip-173.md)) or with `bytes32` roles ([ERC-5982](./eip-5982.md)). However, using bitwise and bitmask operations allows for greater gas-efficiency and flexibility. ### Gas cost efficiency Bitwise operations are very cheap and fast. For example, doing an `AND` bitwise operation on a permission bitmask is significantly cheaper than calling any number of `LOAD` opcodes. ### Flexibility With the 256 bits of the `uint256`, we can create up to 256 different permissions which leads to $2^{256}$ unique combinations (a.k.a. roles). _(A role is a combination of multiple permissions)._ Not all roles have


=== ERC-5625 ===
TITLE: NFT Metadata JSON Schema dStorage Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-09-08
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP extends the NFT metadata JSON schema defined in [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md), adding a `dStorage` key that provides information about how the NFT data is stored.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. In addition to the existing properties, the Metadata JSON file returned by [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) smart contracts (via `tokenURI` and `uri` methods, respectively), should OPTIONALLY contains one more `dStorage` property. For [EIP-721](./eip-721.md) smart contracts, the Metadata JSON file schema is: ```json { "title": "Asset Metadata", "type": "object", "properties": { "name": { "type": "string", "description": "Identifies the asset to which this NFT represents" }, "description": { "type": "string", "description": "Describes

MOTIVATION:
As highly valuable crypto properties, NFT assets intrinsically demand guaranteed storage to assure their **immutability**, **reliability**, and **durability**. NFT ownership is tracked by [EIP-721](./eip-721.md) or [EIP-1155](./eip-1155.md) smart contracts, hence persisted in blockchain, which is not a problem. But how about the mime-type assets that NFT tokens represent? Ideally, they should also be stored in some reliable and verifiable decentralized storage system that is designed to store larger amounts of data than the blockchain itself. As an effort to promote **decentralized storage** adoption in NFT world, we propose to add additional **dStorage** information into NFT metadata JSON schema. As

RATIONALE:
### Choice between Interface and JSON Schema Extension An extension of the EIP-721 or EIP-1155 contract interfaces would unnecessarily require additional code to implement, and would not be available for use by NFT projects that already have their NFT smart contracts finalized and deployed. An optional JSON schema extension is noninvasive, and more easily adopted. # Backwards Compatibility This EIP is backward compatible with [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md).


=== ERC-6353 ===
TITLE: Charity token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-05-13
REQUIRES: 20

SUMMARY:
An extension to [EIP-20](./eip-20.md) that can automatically send an additional percentage of each transfer to a third party, and that provides an interface for retrieving this information. This can allow token owners to make donations to a charity with every transfer. This can also be used to allow automated savings programs.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Owner of the contract **MAY**, after review, register charity address in `whitelistedRate` and set globally a default rate of donation. To register the address, the rate **MUST** not be null. Token holders **MAY** choose and specify a default charity address from `_defaultAddress`, this address **SHOULD** be different from the null address for the donation to be activated. The donation is a percentage-based rate model, but the calculation can be

MOTIVATION:
There are charity organizations with addresses on-chain, and there are token holders who want to make automated donations. Having a standardized way of collecting and managing these donations helps users and user interface developers. Users can make an impact with their token and can contribute to achieving sustainable blockchain development. Projects can easily retrieve charity donations addresses and rate for a given [EIP-20](./eip-20.md) token, token holders can compare minimum rate donation offers allowed by token contract owners. This standard provides functionality that allows token holders to donate easily.

RATIONALE:
This EIP chooses to whitelist charity addresses by using an array and keeping track of the "active" status with a mapping `whitelistedRate` to allow multiple choice of recipient and for transparence. The donation address can also be a single address chosen by the owner of the contract and modified by period. If the sender balance is insuficent i.e total amount of token (initial transfer + donation) is insuficent the transfer would revert. Donation are done in the `transfer` function to simplify the usage and to not add an additional function, but the implementation could be donne differently, and


=== ERC-5528 ===
TITLE: Refundable Fungible Token
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-08-16
REQUIRES: 20

SUMMARY:
This standard is an extension of [EIP-20](./eip-20.md). This specification defines a type of escrow service with the following flow: - The seller issues tokens. - The seller creates an escrow smart contract with detailed escrow information like contract addresses, lock period, exchange rate, additional escrow success conditions, etc. - The seller funds seller tokens to the *Escrow Contract*. - Buyers fund buyer tokens which are pre-defined in the *Escrow Contract*. - When the escrow status meets success, the seller can withdraw buyer tokens, and buyers can withdraw seller tokens based on exchange rates. - Buyers can withdraw (or

SPECIFICATION:
There are two types of contract for the escrow process: - *Payable Contract*: The sellers and buyers use this token to fund the *Escrow Contract*. This contract MUST override [EIP-20](./eip-20.md) interfaces. - *Escrow Contract*: Defines the escrow policies and holds *Payable Contract*'s token for a certain period. This contract does not requires override [EIP-20](./eip-20.md) interfaces. ### Methods #### `constructor` The *Escrow Contract* demonstrates details of escrow policies as none-mutable matter in constructor implementation. The *Escrow Contract* MUST define the following policies: - Seller token contract address - Buyer token contract address The *Escrow Contract* MAY define the following

MOTIVATION:
Because of the pseudonymous nature of cryptocurrencies, there is no automatic recourse to recover funds that have already been paid. In traditional finance, trusted escrow services solve this problem. In the world of decentralized cryptocurrency, however, it is possible to implement an escrow service without a third-party arbitrator. This standard defines an interface for smart contracts to act as an escrow service with a function where tokens are sent back to the original wallet if the escrow is not completed.

RATIONALE:
The interfaces cover the escrow operation's refundable issue. The suggested 3 functions (`escrowFund`, `escrowRefund` and `escrowWithdraw`) are based on `transfer` function in EIP-20. `escrowFund` send tokens to the *Escrow Contract*. The *Escrow Contract* can hold the contract in the escrow process or reject tokens if the policy does not meet. `escrowRefund` can be invoked in the middle of the escrow process or when the escrow process fails. `escrowWithdraw` allows users (sellers and buyers) to transfer tokens from the escrow account. When the escrow process completes, the seller can get the buyer's token, and the buyers can get the


=== ERC-6492 ===
TITLE: Signature Validation for Predeploy Contracts
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-02-10
REQUIRES: 1271

SUMMARY:
Contracts can sign verifiable messages via [ERC-1271](./eip-1271.md). However, if the contract is not deployed yet, [ERC-1271](./eip-1271.md) verification is impossible, as you can't call the `isValidSignature` function on said contract. We propose a standard way for any contract or off-chain actor to verify whether a signature on behalf of a given counterfactual contract (that is not deployed yet) is valid. This standard way extends [ERC-1271](./eip-1271.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. The words "validation" and "verification" are used interchangeably. Quoting [ERC-1271](./eip-1271.md), > `isValidSignature` can call arbitrary methods to validate a given signature, which could be context dependent (e.g. time based or state based), EOA dependent (e.g. signers authorization level within smart wallet), signature scheme Dependent (e.g. ECDSA, multisig, BLS), etc. > > This function should be implemented by contracts which desire to sign messages (e.g. smart contract wallets, DAOs, multisignature

MOTIVATION:
With the rising popularity of account abstraction, we often find that the best user experience for contract wallets is to defer contract deployment until the first user transaction, therefore not burdening the user with an additional deploy step before they can use their account. However, at the same time, many dApps expect signatures, not only for interactions, but also just for logging in. As such, contract wallets have been limited in their ability to sign messages before their de-facto deployment, which is often done on the first transaction. Furthermore, not being able to sign messages from counterfactual contracts

RATIONALE:
We believe that wrapping the signature in a way that allows to pass the deploy data is the only clean way to implement this, as it's completely contract agnostic, but also easy to verify. The wrapper format ends in `magicBytes`, which ends with a `0x92`, which makes it is impossible for it to collide with a valid `ecrecover` signature if packed in the `r,s,v` format, as `0x92` is not a valid value for `v`. To avoid collisions with normal [ERC-1271](./eip-1271.md), `magicBytes` itself is also quite long (`bytes32`). The order to ensure correct verification is based on the following


=== ERC-7681 ===
TITLE: Dual Nature Multi Token Protocol
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-08
REQUIRES: 2, 0, ,,  , 1, 1, 5, 5

SUMMARY:
This proposal [ERC-7681](./eip-7681.md) delineates the integration of the fungible [ERC-20](./eip-20.md) token contract with the semi-fungible [ERC-1155](./eip-1155.md) multi-token standard, enabling cohesive operations between both standards within a single contract framework. It defines a mechanism for combining two token contracts and synchronizing operations between them.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview Every `ERC-7681` MUST implement both `ERC20` and `ERC1155` interfaces. ### ERC-7681 Interface The ERC-20 contract MUST implement the following interface. ```solidity interface IERC7681 /* is IERC20, IERC1155 */ { /// The contract MUST contain the following events /// ERC20 related events event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); /// The contract

MOTIVATION:
Inspired by [ERC-7631](./eip-7631.md) Dual Nature Token Pair, which introduced a concept of interlinkable tokens between ERC-20 and [ERC-721](./eip-721.md), a challenge arises due to the duplicated `Transfer(address, address, uint256)` event, making full compatibility challenging. However, combining ERC-20 and ERC-1155 offers similar benefits of non-fungible token (NFT) fractionalization natively. Here, acquiring ERC-20 tokens could automatically issue ERC-1155 tokens proportionally to the ERC-20 holdings, achieving full compliance with both standards. Furthermore, analogous to ERC-7631, this proposal allows users to opt out of ERC-1155 mints and transfers during the ERC-20 to ERC-1155 synchronization process.

RATIONALE:
### Implementation Flexibility This proposal intentionally does not prescribe specific token synchronization logic to allow for diverse implementation strategies and novel use cases, such as one-to-one synchronization or fractionalization of ERC-1155 tokens based on ERC-20 holdings. Developers are afforded the flexibility to determine their synchronization approach, provided it remains fully compliant with the specifications of both token standards. ### ERC-1155 Token Skipping For instances where the `owner` is a smart contract, setting the skip status to `true` by default can prevent unnecessary ERC-1155 minting for interactions with contracts like DEXs and lending protocols, thereby potentially reducing gas costs.


=== ERC-2615 ===
TITLE: Non-Fungible Token with mortgage and rental functions
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-04-25
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of ERC721. It proposes additional roles, the right of tenants to enable rentals, and the right of lien. With ERC2615, NFT owners will be able to rent out their NFTs and take out a mortgage by collateralizing their NFTs. For example, this standard can apply to: - Virtual items (in-game assets, virtual artwork, etc.) - Physical items (houses, automobiles, etc.) - Intellectual property rights - DAO membership tokens NFT developers are also able to easily integrate ERC2615 since it is fully backwards-compatible with the ERC721 standard. One notable point is that the person

SPECIFICATION:
This standard proposes three user roles: the **Lien Holder**, the **Owner**, and the **User**. Their rights are as follows: - A **Lien Holder** has the right to: 1. Transfer the **Owner** role 2. Transfer the **User** role - An **Owner** has the right to: 1. Transfer the **Owner** role 2. Transfer the **User** role - A **User** has the right to: 1. Transfer the **User** role ### ERC-2615 Interface ```solidity event TransferUser(address indexed from, address indexed to, uint256 indexed itemId, address operator); event ApprovalForUser(address indexed user, address indexed approved, uint256 itemId); event TransferOwner(address indexed from, address indexed to,

MOTIVATION:
It has been challenging to implement rental and mortgage functions with the ERC721 standard because it only has one role defined (which is the Owner). Currently, a security deposit is needed for trustless renting with ERC721, and ownership lockup within a contract is necessary whenever one chooses to mortgage their ERC721 property. The tracking and facilitation of these relationships must be done separately from the ERC721 standard. This proposal eliminates these requirements by integrating basic rights of tenantship and liens. By standardizing these functions, developers can more easily integrate rental and mortgage functions for their applications.

RATIONALE:
There have been some attempts to achieve rentals or mortgages with ERC721. However, as I noted before, it has been challenging to achieve. I will explain the reasons and advantages of this standard below. ### No security lockup for rentals To achieve trustless rental of NFTs with ERC721, it has been necessary to deposit funds as security. This is required to prevent malicious activity from tenants, as it is impossible to take back ownership once it is transferred. With this standard, security deposits are no longer needed since the standard natively supports rental and tenantship functions. ### No


=== ERC-6735 ===
TITLE: L2 Aliasing of EVM-based Addresses
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-03-20
REQUIRES: 55

SUMMARY:
The document describes the minimal set of business and technical prerequisites, functional and non-functional requirements for Aliasing of EVM based Addresses that when implemented ensures that two or more Layer 1, Layer 2, or Sidechains can identify and translate EVM based addresses from different Layer 1, Layer 2, or Sidechains.

SPECIFICATION:
### Typographical Convention: Requirement Ids A requirement is uniquely identified by a unique ID composed of its requirement level followed by a requirement number, as per convention **[RequirementLevelRequirementNumber]**. There are four requirement levels that are coded in requirement ids as per below convention: **[R]** - The requirement level for requirements which IDs start with the letter _R_ is to be interpreted as **MUST** as described in [RFC2119](https://www.rfc-editor.org/rfc/rfc2119). \ **[D]** - The requirement level for requirements which IDs start with the letter _D_ is to be interpreted as **SHOULD** as described in [RFC2119](https://www.rfc-editor.org/rfc/rfc2119). \ **[O]** - The requirement level

MOTIVATION:
The members of the L2 WG of the EEA Communities Project managed by OASIS have recognized that the ability to deterministically derive addresses of a digital asset or an externally owned account (EOA) in EVM based execution frameworks for L1s, L2s, Sidechains based on an origin chain of an asset or EOA, known as address aliasing, simplifies interoperability between EVM based L1s, L2s, and Sidechains because: * It allows messages from chain A (source chain) to unambiguously address asset A (smart contract) or EOA on chain Y (target chain), if asset A or EOA exists on Chain X

RATIONALE:
The standard follows an already existing approach for address aliasing from Ethereum (L1) to EVM-based L2s such as Arbitrum and Optimism and between L2s, and extends and generalizes it to allow aliasing across any type of EVM-based network irrespective of the network type -- L1, L2 or higher layer networks.


=== ERC-1922 ===
TITLE: zk-SNARK Verifier Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-14
REQUIRES: 1, 6, 5, ,,  , 1, 9, 6, ,,  , 1, 9, 7

SUMMARY:
The following standard allows for the implementation of a standard contract API for the verification of zk-SNARKs ("Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge"), also known as "proofs", "arguments", or "commitments". This standard provides basic functionality to load all necessary parameters for the verification of any zk-SNARK into a verifier contract, so that the proof may ultimately return a `true` or `false` response; corresponding to whether it has been verified or not verified.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. Terminology in this specification is used consistently with libsnark, as provided in that project's README. * Adhering Contract — A Verifier contract which adheres to this specification. * Arithmetic circuit: An abstraction of logical statements into addition and multiplication gates. * Public Inputs: often denoted as a vector 'x' in zk-SNARKs literature, and denoted `inputs` in this interface. An arithmetic circuit can be thought of as taking two parameters;

MOTIVATION:
zk-SNARKs are a promising area of interest for the Ethereum community. Key applications of zk-SNARKs include: - Private transactions - Private computations - Improved transaction scaling through proofs of "bundled" transactions A standard interface for verifying all zk-SNARKs will allow applications to more easily implement private transactions, private contracts, and scaling solutions; and to extract and interpret the limited information which gets emitted during zk-SNARK verifications. This standard was initially proposed by EY, and was inspired in particular by the requirements of businesses wishing to keep their agreements, transactions, and supply chain activities confidential—all whilst still benefiting from

RATIONALE:
### Taxonomy ⚠️ TODO: Add a specific reference to libsnark here, explaining the choice of variable names. :warning: TODO: Explain how _C_ may not necessarily be a satisfiable arithmetic circuit of logical statements. As current, this is a limitation to certain kinds of SNARKS. Whereas the source references also mention polynomials, and other applications. _C_ — A satisfiable arithmetic circuit abstraction of logical statements. _lambda​_ - A random number, generated at the 'setup' phase - commonly referred to as 'toxic waste', because knowledge of _lambda​_ would allow an untrustworthy party to create 'false' proofs which would verify as


=== ERC-5553 ===
TITLE: Representing IP and its Royalty Structure
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-17
REQUIRES: 2, 0, ,,  , 7, 2, 1

SUMMARY:
This proposal introduces a generic way to represent intellectual property on chain, along with a refined royalty representation mechanism and associated metadata link. This standard is not associated with a specific type of IP and could represent many types of IP, such as musical IP, videos, books, images, and more. The standard is kept very generic to allow the industry to evolve new ecosystems that can all rely on the same basic standard at their core. This standard allows market participants to: 1) Observe the canonical on-chain representation of an intellectual property 2) Discover its attached metadata 3)

MOTIVATION:
There is no accepted standard mechanism to license intellectual property or to represent it, except using traditional NFTs. However, regular NFTs only represent a collectible item use case and cannot easily represent more complicated use cases of licensing IP for different types of uses. We can enable such licensing mechanisms if we can: 1) Declare that IP exists, SEPARATELY from its purchase ability 2) Declare possibly multiple interested parties to be paid for such IP For 1, no standard exists today. For 2, traditional split standards exist based on NFT purchases or through mechanisms like 0xsplits. While these

RATIONALE:
### Returning an array of EIP-20 tokens presents a more robust royalty portions structure/ Current royalty implementations deal only with a single type of royalty payment: NFT sales. They also only allow a single type of royalty - i.e., Music NFTs cannot pay different people in different scenarios. In other words, currently, a royalty split works the same way no matter what type of purchase or license deal has happened for all parties involved. With this proposal, multiple **types** of royalty scenarios are allowed. A classic case is the music industry, in which we have writing/composition royalties and


=== ERC-4886 ===
TITLE: Proxy Ownership Register
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-09-03
REQUIRES: 

SUMMARY:
A proxy protocol that allows users to nominate a proxy address to act on behalf of another wallet address, together with a delivery address for new assets. Smart contracts and applications making use of the protocol can take a proxy address and lookup holding information for the nominator address. This has a number of practical applications, including allowing users to store valuable assets safely in a cold wallet and interact with smart contracts using a proxy address of low value. The assets in the nominator are protected as all contract interactions take place with the proxy address. This

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Definitions * Delivery address: The address that assets will be delivered to for the current Proxy Record, i.e. a new NFT minted by the Proxy address, representing the Nominator address, should be delivered to the Delivery address. * Nomination: Where a Nominator has nominated a Proxy address. Will only be active when the Proxy has accepted the nomination. * Nominator address: The address that proposes a proxy relationship.

MOTIVATION:
To make full use of Ethereum users often need to prove their ownership of existing assets. For example: * Discord communities require users to sign a message with their wallet to prove they hold the tokens or NFTs of that community. * Whitelist events (for example recent airdrops, or NFT mints), require the user to interact using a given address to prove eligibility. * Voting in DAOs and other protocols require the user to sign using the address that holds the relevant assets. There are more examples, with the unifying theme being that the user must make use

RATIONALE:
The rationale for this EIP was to provide a way for all existing and future Ethereum assets to be have a 'beneficial owner' (the proxy) that is different to the address custodying the asset. The use of a register to achieve this ensures that changes to existing tokens are not required. The register stores a trustless proof, signed by both the nominator and proxy, that can be relied upon as a true representation of asset ownership.


=== ERC-1207 ===
TITLE: DAuth Access Delegation Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-07-10
REQUIRES: 

SUMMARY:
The DAuth protocol defines a set of standard API allowing identity delegations between smart contracts without the user's private key. Identity delegations include accessing and operating a user's data and assets contained in the delegated contracts.

SPECIFICATION:
![Rationale](../assets/eip-1207/rationale.png) **Resource owner**: the authorizer **Resource contract**: the contract providing data and operators **API**: the resource contract APIs that the grantee contract can invoke **Client contract**: the grantee contract using authorization to access and operate the data **Grantee request**: the client contract calls the resource contract with the authorizer authorization **AuthInfo** ``` js struct AuthInfo { string[] funcNames; uint expireAt; } ``` Required - The struct contains user authorization information * `funcNames`: a list of function names callable by the granted contract * `expireAt`: the authorization expire timestamp in seconds **userAuth** ``` js mapping(address => mapping(address => AuthInfo))

MOTIVATION:
The inspiration for designing DAuth comes from OAuth protocol that is extensively used in web applications. But unlike the centralized authorization of OAuth, DAuth works in a distributed manner, thus providing much more reliability and generality.

RATIONALE:
**Current Limitations** The current design of many smart contracts only considers the user invokes the smart contract functions by themselves using the private key. However, in some case, the user wants to delegate other client smart contracts to access and operate their data or assets in the resource smart contract. There isn’t a common protocol to provide a standard delegation approach. **Rationale** On the Ethereum platform, all storage is transparent and the `msg.sender` is reliable. Therefore, the DAuth don't need an `access_token` like OAuth. DAuth just recodes the users' authorization for the specific client smart contract's address. It


=== ERC-875 ===
TITLE: Simpler NFT standard with batching and native atomic swaps
TYPE: Standards Track ERC
STATUS: Withdrawn
CREATED: 2018-02-08
REQUIRES: 

SPECIFICATION:
### function name() constant returns (string name) returns the name of the contract e.g. CarLotContract ### function symbol() constant returns (string symbol) Returns a short string of the symbol of the in-fungible token, this should be short and generic as each token is non-fungible. ### function balanceOf(address _owner) public view returns (uint256[] balance) Returns an array of the users balance. ### function transfer(address _to, uint256[] _tokens) public; Transfer your unique tokens to an address by adding an array of the token indices. This compares favourable to ERC721 as you can transfer a bulk of tokens in one go


=== ERC-7821 ===
TITLE: Minimal Batch Executor Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-11-21
REQUIRES: 7579

SUMMARY:
This proposal defines a minimal batch executor interface for delegations. A delegation is a smart contract that implements logic which other smart contracts can delegate to. This allows atomic batched executions to be prepared in a standardized way.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview The minimal batch executor interface is defined as follows: ```solidity /// @dev Interface for minimal batch executor. interface IERC7821 { /// @dev Call struct for the `execute` function. struct Call { address to; // Replaced with `address(this)` if `address(0)`. uint256 value; // Amount of native currency (i.e. Ether) to send. bytes data; // Calldata to send with the call. } /// @dev

MOTIVATION:
With the advent of [EIP-7702](./eip-7702), it is possible for Externally Owned Accounts (EOAs) to perform atomic batched executions. We anticipate that there will be multiple EIP-7702 delegations from multiple major vendors. A standard for the execution interface will enable better interoperability. EIP-7702 delegation is a risky procedure which should be done sparingly — it should not be performed upon each time a user switches websites. Also, EIP-7702 delegations are transactions that cost gas, making frequent delegation switching uneconomical. A standardized execution interface will reduce the need to switch delegations. This standard complements the `wallet_sendCalls` API in [EIP-5792](./eip-5792). It

RATIONALE:
We aim for radical minimalism to keep the standard as left-curved as possible. Simplicity is the key to adoption. Our North Star is to get every decentralized exchange to support the approve + swap workflow for EOAs with delegations as soon as possible. ### `execute` and `supportsExecutionMode` We have opted to use the `execute` and `supportsExecutionMode` functions in [ERC-7579](./eip-7579.md) for better compatibility with the existing smart account ecosystem. While radical minimalism is the goal, some compromises have to be made in the pursuit for better adoption. For minimalism, this standard does not require implementing [ERC-165](./eip-165.md) and the `executeFromExecutor`


=== ERC-6327 ===
TITLE: Elastic Signature
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-01-13
REQUIRES: 

SUMMARY:
Elastic signature (ES) aims to sign data with a human friendly secret. The secret will be verified fully on-chain and is not stored anywhere. A user can change the secret as often as they need to. The secret does not have a fixed length. The secret will be like a password, which is a better understood concept than private key. This is specifically true for non-technical users. This EIP defines a smart contract interface to verify and authorize operations with ES.

SPECIFICATION:
Let: - `pwdhash` represents the hash of the private secret (password). - `datahash` represents the hash of an intended transaction data. - `fullhash` represents the hash of `datahash` and all the well-known variables. - `expiration` is the timestamp after which the intended transaction expires. - `allhash` represents the hash of `fullhash` and `pwdhash`. There are three parties involved, Verifier, Requester and Prover. - A verifier, - SHOULD compute `fullhash` from a `datahash`, which is provided by the requester. - SHOULD derive `pwdhash` for a given address. The address can be an EOA or a smart contract wallet. -

MOTIVATION:
What would a changeable "private key" enable us? For years, we have been looking for ways to lower on-boarding barrier for users, especially those with less technical experiences. Private key custody solutions seem to provide an user friendly on-boarding experience, but it is vendor dependent and is not decentralized. ES makes a breakthrough with Zero-knowledge technology. Users generate proof of knowing the secret and a smart contract will verify the proof. ### Use case ES is an alternative signing algorithm. It is not an either-or solution to the private key. It is designed to serve as an additional

RATIONALE:
The contract will store everyone's `pwdhash`. ![verifier-contract](../assets/eip-6327/zkpass-1.png) The chart below shows ZK circuit logic. ![circuit-logic](../assets/eip-6327/zkpass-2.png) To verify the signature, it needs `proof`, `allhash`, `pwdhash` and `fullhash`. ![workflow](../assets/eip-6327/zkpass-3.png) The prover generates `proof` along with the public outputs. They will send all of them to a third-party requester contract. The requester will generate the `datahash`. It sends `datahash`, `proof`, `allhash`, `expiration` and prover's address to the verifier contract. The contract verifies that the `datahash` is from the prover, which means the withdrawal operation is signed by the prover's password.


=== ERC-5850 ===
TITLE: Complex Numbers stored in `bytes32` types
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-10-29
REQUIRES: 

SUMMARY:
This EIP proposes a natural way for complex numbers to be stored in and retrieved from the `bytes32` data-type. It splits the storage space exactly in half and, most importantly, assigns the real number part to the least significant 16 bytes and the imaginary number part to the most significant 16 bytes.

SPECIFICATION:
A complex number would be defined as `bytes32` and a cartesian representation would be initalized with the `cnNew` function and converted back with `RealIm`, both given below. To create the complex number one would use ```solidity function cnNew(int128 _Real, int128 _Imag) public pure returns (bytes32){ bytes32 Imag32 = bytes16(uint128(_Imag)); bytes32 Real32 = bytes16(uint128(_Real)); return (Real32>> 128) | Imag32; } ``` and to convert back ```solidity function RealIm(bytes32 _cn) public pure returns (int128 Real, int128 Imag){ bytes16[2] memory tmp = [bytes16(0), 0]; assembly { mstore(tmp, _cn) mstore(add(tmp, 16), _cn) } Imag=int128(uint128(tmp[0])); Real=int128(uint128(tmp[1])); } ```

MOTIVATION:
Complex numbers are an essential tool for many mathematical and scientific calculations. For example, Fourier Transforms, Characteristic functions, AC Circuits and Navier-Stokes equations all require the concept. Complex numbers can be represented in many different forms (polynomial, cartesian, polar, exponential). The EIP creates a standard that can accomodate cartesian, polar and exponential formats with example code given for the Cartesian representation, where a complex number is just the pair of real numbers which gives the real and imaginary co-ordinates of the complex number. Equal storage capacity is assigned to both components and the order they appear is explicitly

RATIONALE:
An EIP is required as this proposal defines a complex numbers storage/type standard for multiple apps to use. This EIP proposes to package both the real and imaginary within one existing data type, `bytes32`. This allows compact storage without the need for structures and facilitates easy library implementations. The `bytes32` would remain available for existing, non-complex number uses. Only the split and position of the real & imaginary parts is defined in this EIP. Manipulation of complex numbers (addition, multiplication etc.), number of decimal places and other such topics are left for other EIP discussions. This keeps this


=== ERC-1203 ===
TITLE: ERC-1203 Multi-Class Token Standard (ERC-20 Extension)
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-07-01
REQUIRES: 

SUMMARY:
The following standard allows for the implementation of a standard API for MCTs within smart contracts. This standard provides basic functionality to track, transfer, and convert MCTs.

SPECIFICATION:
```solidity contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _owner) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC1203 is ERC20 { function totalSupply(uint256 _class) public view returns (uint256); function balanceOf(address _owner, uint256 _class) public view returns (uint256); function transfer(address _to, uint256 _class, uint256

MOTIVATION:
This standard is heavily inspired by ERC-20 Token Standard and ERC-721 Non-Fungible Token Standard. However, whereas these standards are chiefly concerned with representation of items/value in a single class, fungible or note, this proposed standard focus on that of a more complexed, multi-class system. It is fair to think of MCTs as a hybrid of fungible tokens (FT) and non-fungible tokens (NFTs), that is tokens are fungible within the same class but non-fungible with that from a different class. And conversions between classes may be optionally supported. MCTs are useful in representing various structures with heterogeneous components, such

RATIONALE:
This standard purposely extends ERC-20 Token Standard so that new MCTs following or existing ERC-20 tokens extending this standard are fully compatible with current wallets and exchanges. In addition, new methods and events are kept as closely to ERC-20 conventions as possible for ease of adoption. We have considered alternative implementations to support the multi-class structure, as discussed below, and we found current token standards incapable or inefficient in deal with such structures. **Using multiple ERC-20 tokens** It is certainly possible to create an ERC-20 token for each class, and a separate contract to coordinate potential conversions, but


=== ERC-20 ===
TITLE: Token Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2015-11-19
REQUIRES: 

SUMMARY:
The following standard allows for the implementation of a standard API for tokens within smart contracts. This standard provides basic functionality to transfer tokens, as well as allow tokens to be approved so they can be spent by another on-chain third party.

MOTIVATION:
A standard interface allows any tokens on Ethereum to be re-used by other applications: from wallets to decentralized exchanges.


=== ERC-6105 ===
TITLE: No Intermediary NFT Trading Protocol
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-12-02
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 2, 9, 8, 1

SUMMARY:
This ERC adds a marketplace functionality to [ERC-721](./eip-721.md) to enable non-fungible token trading without relying on an intermediary trading platform. At the same time, creators may implement more diverse royalty schemes.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Compliant contracts MUST implement the following interface: ```solidity interface IERC6105 { /// @notice Emitted when a token is listed for sale or delisted /// @dev The zero `salePrice` indicates that the token is not for sale /// The zero `expires` indicates that the token is not for sale /// @param tokenId - identifier of the token being listed /// @param from - address of

MOTIVATION:
Most current NFT trading relies on an NFT trading platform acting as an intermediary, which has the following problems: 1. Security concerns arise from authorization via the `setApprovalForAll` function. The permissions granted to NFT trading platforms expose unnecessary risks. Should a problem occur with the trading platform contract, it would result in significant losses to the industry as a whole. Additionally, if a user has authorized the trading platform to handle their NFTs, it allows a phishing scam to trick the user into signing a message that allows the scammer to place an order at a low price

RATIONALE:
### Considerations for some local variables The `salePrice` in the `listItem` function cannot be set to zero. Firstly, it is a rare occurrence for a caller to set the price to 0, and when it happens, it is often due to an operational error which can result in loss of assets. Secondly, a caller needs to spend gas to call this function, so if he can set the token price to 0, his income would be actually negative at this time, which does not conform to the concept of 'economic man' in economics. Additionally, a token price of


=== ERC-7887 ===
TITLE: Cancelation for ERC-7540 Tokenized Vaults
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2025-02-18
REQUIRES: 1, 6, 5, ,,  , 7, 5, 4, 0

SUMMARY:
The following standard extends [ERC-7540](./eip-7540.md) by adding support for asynchronous cancelation flows. New methods are added to asynchronously cancel a deposit or redeem Request, view the status of the cancelation Request, and claim the assets or shares as a result of the cancelation Request.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions The existing definitions from [ERC-7540](./eip-7540.md) apply. ### Cancelation Lifecycle After submission, cancelation Requests go through Pending, Claimable, and Claimed stages. An example lifecycle for a deposit cancelation Request is visualized in the table below. | **State** | **User** | **Vault** | |-------------|---------------------------------|-----------| | Pending | `cancelDepositRequest(requestId, controller)` | `pendingCancelDepositRequest[controller] = true` | | Claimable | | *Internal cancelation fulfillment*: `pendingCancelDepositRequest[controller] = false`;

MOTIVATION:
Shares or assets locked for Requests can be stuck in the Pending state. For some use cases, such as redeeming from a pool of long-dated real-world assets, this can take a considerable amount of time. This standard expands the scope of Asynchronous ERC-7540 Vaults by adding cancelation support.

RATIONALE:
### Blocking Requests during Cancelation When `cancelDepositRequest` is called by a `controller`, new deposit Requests are blocked for this `controller`, and the equivalent applies to the redeem flow. This requirement simplifies the possible states of vaults implementing asynchronous cancelation flows. The alternative would create possible states where a cancelation is pending and a new deposit Request is triggered, leading to the current state being complex to read for integrators. ### Mandated Support for [ERC-165](./eip-165.md) Implementing support for [ERC-165](./eip-165.md) is mandated because of the optionality of flows as defined in [ERC-7540](./eip-7540.md). Integrations can use the `supportsInterface` method to check


=== ERC-5267 ===
TITLE: Retrieval of EIP-712 domain
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-07-14
REQUIRES: 1, 5, 5, ,,  , 7, 1, 2, ,,  , 2, 6, 1, 2

SUMMARY:
This EIP complements [EIP-712](./eip-712.md) by standardizing how contracts should publish the fields and values that describe their domain. This enables applications to retrieve this description and generate appropriate domain separators in a general way, and thus integrate EIP-712 signatures securely and scalably.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Compliant contracts MUST define `eip712Domain` exactly as declared below. All specified values MUST be returned even if they are not used, to ensure proper decoding on the client side. ```solidity function eip712Domain() external view returns ( bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions ); ``` The return values of this function MUST describe the domain separator that is used for verification of

MOTIVATION:
EIP-712 is a signature scheme for complex structured messages. In order to avoid replay attacks and mitigate phishing, the scheme includes a "domain separator" that makes the resulting signature unique to a specific domain (e.g., a specific contract) and allows user-agents to inform end users the details of what is being signed and how it may be used. A domain is defined by a data structure with fields from a predefined set, all of which are optional, or from extensions. Notably, EIP-712 does not specify any way for contracts to publish which of these fields they use or

RATIONALE:
A notable application of EIP-712 signatures is found in EIP-2612 (permit), which specifies a `DOMAIN_SEPARATOR` function that returns a `bytes32` value (the actual domain separator, i.e., the result of `hashStruct(eip712Domain)`). This value does not suffice for the purposes of integrating with EIP-712, as the RPC methods defined there receive an object describing the domain and not just the separator in hash form. Note that this is not a flaw of the RPC methods, it is indeed part of the security proposition that the domain should be validated and informed to the user as part of the signing process.


=== ERC-4804 ===
TITLE: Web3 URL to EVM Call Message Translation
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-02-14
REQUIRES: 137

SUMMARY:
This standard translates an RFC 2396 URI like `web3://uniswap.eth/` to an EVM message such as: ``` EVMMessage { To: 0xaabbccddee.... // where uniswap.eth's address registered at ENS Calldata: 0x ... } ```

SPECIFICATION:
This specification only defines read-only (i.e. Solidity's `view` functions) semantics. State modifying functions may be defined as a future extension. A Web3 URL is in the following form ``` web3URL = web3Schema [userinfo "@"] contractName [":" chainid] path ["?" query] web3Schema = [ "ethereum-web3://" | "eth-web3://" | "web3://" ] contractName = address | [name "." [ subDomain0 "." ... ]] nsProviderSuffix path = ["/" method ["/" argument_0 ["/" argument_1 ... ]]] argument = [type "!"] value query = "attribute_1=value_1 [ "&" attribute_2=value_2 ... ] attribute = "returns" | "returnTypes" | other_attribute ``` where - **web3Schema** indicates the schema

MOTIVATION:
Currently, reading data from Web3 generally relies on a translation done by a Web2 proxy to Web3 blockchain. The translation is mostly done by the proxies such as dApp websites/node service provider/etherscan, which are out of the control of users. The standard here aims to provide a simple way for Web2 users to directly access the content of Web3, especially on-chain Web contents such as SVG/HTML. Moreover, this standard enables interoperability with other standards already compatible with URIs, like SVG/HTML.

RATIONALE:
The purpose of the proposal is to add a decentralized presentation layer for Ethereum. With the layer, we are able to render any web content (including HTML/CSS/JPG/PNG/SVG, etc) on-chain using human-readable URLs, and thus EVM can be served as decentralized Backend. The design of the standard is based on the following principles: - **Human-readable**. The Web3 URL should be easily recognized by human similar to Web2 URL (`http://`). As a result, we support names from name services to replace address for better readability. In addition, instead of using calldata in hex, we use human-readable method + arguments and


=== ERC-6315 ===
TITLE: ERC-2771 Namespaced Account Abstraction
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-01-11
REQUIRES: 1, 6, 5, ,,  , 2, 7, 7, 1

SUMMARY:
[ERC-2771](./eip-2771.md) is a prevalent standard for handling meta-transactions via trusted forwarders. This EIP proposes an extension to [ERC-2771](./eip-2771.md) to introduce a namespacing mechanism, facilitating trustless account abstraction through per-forwarder namespaced addresses.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The key words "Forwarder" and "Recipient" in this document are to be interpreted as described in [ERC-2771](./eip-2771.md). ### Namespaced Forwarder Interface ```solidity pragma solidity ^0.8.0; interface INamespacedForwarder { function isNamespacedTransaction() external view returns (bool); } ``` ### Determining the Sender and Forwarder Upon function invocation on a Recipient, the Recipient MUST execute a `STATICCALL` to the `isNamespacedTransaction()` method of the caller. If this operation

RATIONALE:
The approach of simply augmenting existing EIP functions with new `address` parameters, rather than crafting new interfaces for the most commonly used EIPs, is employed to ensure broader applicability of this namespacing proposal.


=== ERC-6150 ===
TITLE: Hierarchical NFTs
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-12-15
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension to [EIP-721](./eip-721.md). It proposes a multi-layer filesystem-like hierarchical NFTs. This standard provides interfaces to get parent NFT or children NFTs and whether NFT is a leaf node or root node, maintaining the hierarchical relationship among them.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Every compliant contract must implement this proposal, [EIP-721](./eip-721.md) and [EIP-165](./eip-165.md) interfaces. ```solidity pragma solidity ^0.8.0; // Note: the ERC-165 identifier for this interface is 0x897e2c73. interface IERC6150 /* is IERC721, IERC165 */ { /** * @notice Emitted when `tokenId` token under `parentId` is minted. * @param minter The address of minter * @param to The address received token * @param parentId The id of

MOTIVATION:
This EIP standardizes the interface of filesystem-like hierarchical NFTs and provides a reference implementation. Hierarchy structure is commonly implemented for file systems by operating systems such as Linux Filesystem Hierarchy (FHS). ![Linux Hierarchical File Structure](../assets/eip-6150/linux-hierarchy.png) Websites often use a directory and category hierarchy structure, such as eBay (Home -> Electronics -> Video Games -> Xbox -> Products), and Twitter (Home -> Lists -> List -> Tweets), and Reddit (Home -> r/ethereum -> Posts -> Hot). ![Website Hierarchical Structure](../assets/eip-6150/website-hierarchy.png) A single smart contract can be the `root`, managing every directory/category as individual NFT and hierarchy relations of NFTs. Each

RATIONALE:
As mentioned in the abstract, this EIP's goal is to have a simple interface for supporting Hierarchical NFTs. Here are a few design decisions and why they were made: ### Relationship between NFTs All NFTs will make up a hierarchical relationship tree. Each NFT is a node of the tree, maybe as a root node or a leaf node, as a parent node or a child node. This proposal standardizes the event `Minted` to indicate the parent and child relationship when minting a new node. When a root node is minted, parentId should be zero. That means a


=== ERC-7585 ===
TITLE: MixHash and Public Data Storage Proofs
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-12-27
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This proposal introduces a design for "minimum value selection" storage proofs on Merkle trees. The design consists of two main components: 1. A hashing algorithm termed MixHash, aimed to replace the commonly used Keccak256 and SHA256 algorithms. 2. Public data storage proofs. This enables anyone to present a proof to a public network, verifying their possession of a copy of specific public data marked by MixHash. Additionally, the proposal discusses the practical implementation of this design in various scenarios and suggests some improvements to the [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) standards.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### MixHash MixHash is a Merkle tree root hash value that incorporates data length information. Its structure is as follows: ```text +-----------256 bits MixHash-----------+ High |-2-|----62----|----------192----------| Low 2 bits: Hash algorithm selection, where 0b00 represents SHA256, and 0b10 represents Keccak256. (0b01, 0b11 are reserved) 62 bits: File size. Hence, MixHash can support file sizes up to 2^62-1. 192 bits: The lower 192 bits of

MOTIVATION:
The [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) standards are widely used in the NFT fields. However, the current standards do not provide a mechanism for verifying the existence of public data. This is a major obstacle to the development of many applications, such as decentralized data markets, decentralized data storage, and decentralized data oracles.

RATIONALE:
Storage proofs (often referred to as space-time proofs) have long been a subject of interest, with numerous implementations and related projects existing. 1. Compared to existing copy proofs based on zero-knowledge proofs, our storage proof is based on "Nash Consensus," with its core principles being: a. The public network (on-chain) cannot verify the optimality of a proof but relies on economic game theory. This significantly reduces the costs of construction and verification. b. Data without value typically lacks game value and is naturally eliminated from the system. There is no commitment to elusive perpetual storage. 2. It can


=== ERC-1202 ===
TITLE: Voting Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2018-07-08
REQUIRES: 5269

SUMMARY:
This EIP is an API for implementing voting with smart contract. This standard provides functionalities to voting as well as to view the vote result and set voting status.

SPECIFICATION:
1. Compliant contracts MUST implement the `IERC1202Core` below ```solidity interface IERC1202Core { event VoteCast( address indexed voter, uint256 indexed proposalId, uint8 support, uint256 weight, string reason, bytes extraParams ); function castVote( uint256 proposalId, uint8 support, uint256 weight, string calldata reasonUri, bytes calldata extraParams ) external payable returns; function castVoteFrom( address from, uint256 proposalId, uint8 support, uint256 weight, string calldata reasonUri, bytes calldata extraParams ) external payable returns; function execute(uint256 proposalId, bytes memory extraParams) payable external; } ``` 2. Compliant contracts MAY implement the `IERC1202MultiVote` Interface. If the intention is for multi-options to be supported, e.g. for ranked-choices or

MOTIVATION:
Voting is one of the earliest example of EVM programming, and also a key to DAO/organizational governance process. We foresee many DAOs will ultimately need to leverage voting as one of the important part of their governance. By creating a voting standard for smart contract / token, we can have the following benefits ### Benefits of having a standard 1. Allow general UI and applications to be built on top of a standardized voting to allow more general user to participate, and encourage more DApp and DAO to think about their governance 2. Allow delegate voting / smart

RATIONALE:
We made the following design decisions and here are the rationales. ### Granularity and Anonymity We created a `view` function `ballotOf` primarily making it easier for people to check the vote from certain address. This has the following assumptions: - It's possible to check someone's vote directly given an address. If implementor don't want to make it so easily, they can simply reject all calls to this function. We want to make sure that we support both anonymous voting an non-anonymous voting. However since all calls to a smart contract is logged in block history, there is really


=== ERC-4353 ===
TITLE: Interface for Staked Tokens in NFTs
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-10-08
REQUIRES: 165

SUMMARY:
[EIP-721](./eip-721.md) tokens can be deposited or staked in NFTs for a variety of reasons including escrow, rewards, benefits, and others. There is currently no means of retrieving the number of tokens staked and/or bound to an NFT. This proposal outlines a standard that may be implemented by all wallets and marketplaces easily to correctly retrieve the staked token amount of an NFT.

SPECIFICATION:
```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; /** * @dev Interface of the ERC4353 standard, as defined in the * https://eips.ethereum.org/EIPS/eip-4353. * * Implementers can declare support of contract interfaces, which can then be * queried by others. * * Note: The ERC-165 identifier for this interface is 0x3a3d855f. * */ interface IERC721Staked { /** * @dev Returns uint256 amount of on-chain tokens staked to the NFT. * * @dev Wallets and marketplaces would need to call this for displaying * the amount of tokens staked and/or bound to the NFT. */ function stakedAmount(uint256 tokenId) external view returns

MOTIVATION:
Without staked token data, the actual amount of staked tokens cannot be conveyed from token owners to other users, and cannot be displayed in wallets, marketplaces, or block explorers. The ability to identify and verify an exogenous value derived from the staking process may be critical to the aims of an NFT holder.

RATIONALE:
This standard is completely agnostic to how tokens are deposited or handled by the NFT. It is, therefore, the choice and responsibility of the author to encode and communicate the encoding of their tokenomics to purchasees of their token and/or to make their contracts viewable by purchasees. Although the intention of this standard is for tokens staked at mint and withdrawable only upon burn, the interface may be modified for dynamic withdrawing and depositing of tokens especially under DeFi application settings. In its current form, the contract logic may be the determining factor whether a deviation from the


=== ERC-7628 ===
TITLE: ERC-721 Ownership Shares Extension
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-02-20
REQUIRES: 721

SUMMARY:
This proposal introduces an attribute of ownership and profit share quantities for each token under an NFT. This attribute signifies a stake in the ownership and profit rights associated with the NFT's specific privileges, enabling the querying, transferring, and approval of these shares, thereby making the shares represented by each token applicable in a broader range of use cases.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Implementers of this extension **MUST** have all of the following functions: ```solidity pragma solidity ^0.8.0; interface IERC7628 /* is IERC721 */ { /// @notice Returns the number of decimal places used for ownership shares. /// @return The number of decimal places for ownership shares. function shareDecimals() external view returns (uint8); /// @notice Returns the total sum of ownership shares in existence for all tokens.

MOTIVATION:
At times, when we wish to distribute dividends or assign rights to tokens of an NFT based on their share of ownership, it becomes necessary to equip each token with an attribute indicating the number of ownership shares. While [ERC-1155](./eip-1155.md) allows for the representation of ownership stakes through the balance of a token held by a wallet address, it sacrifices the uniqueness of each token. Conversely, [ERC-721](./eip-721.md) maintains the uniqueness of each token but lacks an attribute to signify the share of ownership rights, and its metadata does not allow for the free transfer of these share quantities

RATIONALE:
#### Share Issuance to a Token Issuing additional shares to a token allows for flexible management of ownership stakes in digital assets, catering to the evolving needs of stakeholders. It ensures transparency and security in modifying ownership structures directly on the blockchain, facilitating scenarios like profit sharing or investment adjustments. #### Transferring Shares to an Address Enabling shares to be transferred to an address enhances NFT liquidity and accessibility by allowing fractional ownership. This feature supports diverse use cases like fractional sales or collateralization, making NFTs more adaptable and inclusive for a broader audience.


=== ERC-3386 ===
TITLE: ERC-721 and ERC-1155 to ERC-20 Wrapper
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-03-12
REQUIRES: 165

SUMMARY:
This standard outlines a smart contract interface to wrap identifiable tokens with fungible tokens. This allows for derivative [ERC-20](./eip-20.md) tokens to be minted by locking the base [ERC-721](./eip-721.md) non-fungible tokens and [ERC-1155](./eip-1155.md) multi tokens into a pool. The derivative tokens can be burned to redeem base tokens out of the pool. These derivatives have no reference to the unique id of these base tokens, and should have a proportional rate of exchange with the base tokens. As representatives of the base tokens, these generic derivative tokens can be traded and otherwise utilized according to ERC-20, such that the

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt). **Every IWrapper compliant contract must implement the `IWrapper` and `ERC165` interfaces** : ```solidity pragma solidity ^0.8.0; /** @title IWrapper Identifiable Token Wrapper Standard @dev {Wrapper} refers to any contract implementing this interface. @dev {Base} refers to any ERC-721 or ERC-1155 contract. It MAY be the {Wrapper}. @dev {Pool} refers to the contract which holds the {Base} tokens. It MAY be the {Wrapper}. @dev {Derivative} refers to the ERC-20 contract

MOTIVATION:
The ERC-20 token standard is the most widespread and liquid token standard on Ethereum. ERC-721 and ERC-1155 tokens on the other hand can only be transferred by their individual ids, in whole amounts. Derivative tokens allow for exposure to the base asset while benefiting from contracts which utilize ERC-20 tokens. This allows for the base tokens to be fractionalized, traded and pooled generically on AMMs, collateralized, and be used for any other ERC-20 type contract. Several implementations of this proposal already exist without a common standard. Given a fixed exchange rate between base and derivative tokens, the value

RATIONALE:
### Naming The ERC-721/ERC-1155 tokens which are pooled are called {Base} tokens. Alternative names include: - Underlying. - NFT. However, ERC-1155 tokens may be considered "semi-fungible". The ERC-20 tokens which are minted/burned are called {Derivative} tokens. Alternative names include: - Wrapped. - Generic. The function names `mint` and `burn` are borrowed from the minting and burning extensions to ERC-20. Alternative names include: - `mint`/`redeem` ([NFTX](https://nftx.org)) - `deposit`/`withdraw` ([WrappedKitties](https://wrappedkitties.com/)) - `wrap`/`unwrap` ([MoonCatsWrapped](https://etherscan.io/address/0x7c40c393dc0f283f318791d746d894ddd3693572)) The function names `*idBurn` are chosen to reduce confusion on what is being burned. That is, the {Derivative} tokens are burned in order to redeem the id(s).


=== ERC-7496 ===
TITLE: NFT Dynamic Traits
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-28
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This specification introduces a new interface that extends [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) that defines methods for setting and getting dynamic onchain traits associated with non-fungible tokens. These dynamic traits can be used to represent properties, characteristics, redeemable entitlements, or other attributes that can change over time. By defining these traits onchain, they can be used and modified by other onchain contracts.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Contracts implementing this EIP MUST include the events, getters, and setters as defined below, and MUST return `true` for [ERC-165](./eip-165.md) `supportsInterface` for `0xaf332f3e`, the 4 byte `interfaceId` for this ERC. ```solidity interface IERC7496 { /* Events */ event TraitUpdated(bytes32 indexed traitKey, uint256 tokenId, bytes32 traitValue); event TraitUpdatedRange(bytes32 indexed traitKey, uint256 fromTokenId, uint256 toTokenId); event TraitUpdatedRangeUniformValue(bytes32 indexed traitKey, uint256 fromTokenId, uint256 toTokenId, bytes32 traitValue); event

MOTIVATION:
Trait values for non-fungible tokens are often stored offchain. This makes it difficult to query and mutate these values in contract code. Specifying the ability to set and get traits onchain allows for new use cases like redeeming onchain entitlements and transacting based on a token's traits. Onchain traits can be used by contracts in a variety of different scenarios. For example, a contract that wants to entitle a token to a consumable benefit (e.g. a redeemable) can robustly reflect that onchain. Marketplaces can allow bidding on these tokens based on the trait value without having to rely

RATIONALE:
The design of this specification is primarily a key-value mapping for maximum flexibility. This interface for traits was chosen instead of relying on using regular `getFoo()` and `setFoo()` style functions to allow for brevity in defining, setting, and getting traits. Otherwise, contracts would need to know both the getter and setter function selectors including the parameters that go along with it. In defining general but explicit get and set functions, the function signatures are known and only the trait key and values are needed to query and set the values. Contracts can also add new traits in the


=== ERC-4494 ===
TITLE: Permit for ERC-721 NFTs
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-11-25
REQUIRES: 1, 6, 5, ,,  , 7, 1, 2, ,,  , 7, 2, 1

SUMMARY:
The "Permit" approval flow outlined in [ERC-2612](./eip-2612.md) has proven a very valuable advancement in UX by creating gasless approvals for ERC20 tokens. This EIP extends the pattern to ERC-721 NFTs. This EIP borrows heavily from ERC-2612. This requires a separate EIP due to the difference in structure between ERC-20 and ERC-721 tokens. While ERC-20 permits use value (the amount of the ERC-20 token being approved) and a nonce based on the owner's address, ERC-721 permits focus on the `tokenId` of the NFT and increment nonce based on the transfers of the NFT.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Three new functions MUST be added to [ERC-721](./eip-721.md): ```solidity pragma solidity 0.8.10; import "./IERC165.sol"; /// /// @dev Interface for token permits for ERC-721 /// interface IERC4494 is IERC165 { /// ERC165 bytes to add to interface array - set in parent contract /// /// _INTERFACE_ID_ERC4494 = 0x5604e225 /// @notice Function to approve by way of owner signature /// @param spender the address to approve /// @param tokenId the index

MOTIVATION:
The permit structure outlined in [ERC-2612](./eip-2612.md) allows for a signed message (structured as outlined in [ERC-712](./eip-712.md)) to be used in order to create an approval. Whereas the normal approval-based pull flow generally involves two transactions, one to approve a contract and a second for the contract to pull the asset, which is poor UX and often confuses new users, a permit-style flow only requires signing a message and a transaction. Additional information can be found in [ERC-2612](./eip-2612.md). [ERC-2612](./eip-2612.md) only outlines a permit architecture for ERC-20 tokens. This ERC proposes an architecture for ERC-721 NFTs, which also contain an

RATIONALE:
The `permit` function is sufficient for enabling a `safeTransferFrom` transaction to be made without the need for an additional transaction. The format avoids any calls to unknown code. The `nonces` mapping is given for replay protection. A common use case of permit has a relayer submit a Permit on behalf of the owner. In this scenario, the relaying party is essentially given a free option to submit or withhold the Permit. If this is a cause of concern, the owner can limit the time a Permit is valid for by setting deadline to a value in the near


=== ERC-721 ===
TITLE: Non-Fungible Token Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-01-24
REQUIRES: 165

SUMMARY:
The following standard allows for the implementation of a standard API for NFTs within smart contracts. This standard provides basic functionality to track and transfer NFTs. We considered use cases of NFTs being owned and transacted by individuals as well as consignment to third party brokers/wallets/auctioneers ("operators"). NFTs can represent ownership over digital or physical assets. We considered a diverse universe of assets, and we know you will dream up many more: - Physical property — houses, unique artwork - Virtual collectibles — unique pictures of kittens, collectible cards - "Negative value" assets — loans, burdens and other

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. **Every ERC-721 compliant contract must implement the `ERC721` and `ERC165` interfaces** (subject to "caveats" below): ```solidity pragma solidity ^0.4.20; /// @title ERC-721 Non-Fungible Token Standard /// @dev See https://eips.ethereum.org/EIPS/eip-721 /// Note: the ERC-165 identifier for this interface is 0x80ac58cd. interface ERC721 /* is ERC165 */ { /// @dev This emits when ownership of any NFT changes by any mechanism. /// This event emits when NFTs are created (`from` ==

MOTIVATION:
A standard interface allows wallet/broker/auction applications to work with any NFT on Ethereum. We provide for simple ERC-721 smart contracts as well as contracts that track an *arbitrarily large* number of NFTs. Additional applications are discussed below. This standard is inspired by the ERC-20 token standard and builds on two years of experience since EIP-20 was created. EIP-20 is insufficient for tracking NFTs because each asset is distinct (non-fungible) whereas each of a quantity of tokens is identical (fungible). Differences between this standard and EIP-20 are examined below.

RATIONALE:
There are many proposed uses of Ethereum smart contracts that depend on tracking distinguishable assets. Examples of existing or planned NFTs are LAND in Decentraland, the eponymous punks in CryptoPunks, and in-game items using systems like DMarket or EnjinCoin. Future uses include tracking real-world assets, like real-estate (as envisioned by companies like Ubitquity or Propy). It is critical in each of these cases that these items are not "lumped together" as numbers in a ledger, but instead each asset must have its ownership individually and atomically tracked. Regardless of the nature of these assets, the ecosystem will be


=== ERC-7884 ===
TITLE: Operation Router
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2025-01-23
REQUIRES: 

SUMMARY:
This EIP introduces a protocol that enables smart contracts to redirect write operations to external systems. The protocol defines a standardized way for contracts to indicate that an operation should be handled by either a contract deployed to an L2 chain, to the L1, or an off-chain database, providing an entry point for easy developer experience and client implementations.

SPECIFICATION:
### Core Components The protocol consists of three main components: 1. A view function named interface `getOperationHandler` for determining operation handlers that can be one of the following types: a. `OperationHandledOnchain` for on-chain handlers b. `OperationHandledOffchain` for off-chain handlers through a gateway 2. A standardized message format for off-chain storage authorization ### Interface ```solidity interface OperationRouter { /** * @dev Error to raise when an encoded function that is not supported * @dev is received on the getOperationHandler function */ error FunctionNotSupported(); /** * @dev Error to raise when mutations are being deferred onchain * that being the

MOTIVATION:
As the Ethereum ecosystem grows, there is an increasing need for efficient ways to manage data storage across different layers and systems. This protocol addresses these challenges by: - Providing a gas-efficient way to determine operation handlers through view functions - Enabling seamless integration with L2 solutions and off-chain databases - Maintaining strong security guarantees through typed signatures and standardized interfaces

RATIONALE:
The standard aims to enable offchain writing operations, designed to be a complement for the CCIP-Read ([ERC-3668](./eip-3668)) which is already widely adopted by the community.


=== ERC-6932 ===
TITLE: Subscription-Based Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-25
REQUIRES: 20

SUMMARY:
This subscription-based [ERC-20](./eip-20.md) token extends the basic [ERC-20](./eip-20.md) token standard with a `subscribe` and `unsubscribe` function, which allow users to subscribe or unsubscribe from the subscription service. The `subscriptionFee` and `subscriptionFrequency` variables define the cost and frequency of the subscription. The `nextPaymentDate` mapping keeps track of the next payment date for each subscriber. This token standard will enable automatic periodic deductions from user balances as determined by the merchant subscriber. Simplify and streamline subscription-based services on the Ethereum network, offering enhanced convenience and efficiency for users and merchants alike. A `renewSubscription` method, that will be used by token

SPECIFICATION:
Below are the implementaions required by the standard: ### `SubscriptionToken` #### `subscribers` Returns the list of `addresses` subscribed to the subscription token contract. #### `subscriptionInfo` Metadata information of the subscription, like - `subscriptionID`, `subscriptionName`, `subscriptionDesc` and `subscriptionTandC`. #### `subscriptionFee` The subscription amount specified that will be deducted in `subscriptionFrequency` interval, when an address subscribes to the subscription token contract. #### `subscriptionFrequency` Frequency of subscription, interval at which the `subscriptionFee` will be charged. for example, every 1 day, 1 week or 1 month, denoted in seconds. #### `subscribe` Method for subscribing an address to the subscription token contract. ####

MOTIVATION:
The rise of subscription-based business models necessitates a standardized approach to handle recurring payments on the Ethereum blockchain. Currently, users often manually initiate subscription payments, resulting in inconvenience and potential disruptions in service delivery. By introducing a Subscription Token, users can seamlessly authorize periodic deductions, enabling uninterrupted access to subscribed services. The subscription-based [ERC-20](./eip-20.md) token provides a more flexible and convenient way to manage recurring payments. It can be used for a wide range of services and products that require regular payments, such as subscription-based content platforms, gaming services, and more. The Subscription Token ensures consistency and interoperability

RATIONALE:
The subscription token contract inherits the fundamentals of subscription by deducting payments from subscribed addresses on a regular interval using mathematical formulas. ``` uint256 intervals = ( block.timestamp - info.start ) / info.frequency; uint256 amount = info.amount * intervals; uint256 localEffectiveBalance = effectiveBalance[account]; if ( (totalAmount + amount) > localEffectiveBalance ) { amount = localEffectiveBalance; } totalAmount += ( localEffectiveBalance - amount ); ``` Here, the token balance of the address is calcuated using, the locked balances from ongoing subscripitons and the effective balance of the address (updates whenever a transfer is made).


=== ERC-7484 ===
TITLE: Registry Extension for ERC-7579
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-08-14
REQUIRES: 7579

SUMMARY:
This proposal standardizes the interface and functionality of Module Registries, allowing modular smart accounts to verify the security of modules using a Registry Adapter. It also provides a reference implementation of a Singleton Module Registry.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions - **Smart account** - An ERC-7579 modular smart account. - **Module** - Self-contained smart account functionality. - **Attestation** - Onchain assertions made about the security of a module. - **Attester** - The entity that makes an attestation about a module. - **(Module) Registry** - A contract that stores an onchain list of attestations about modules. - **Adapter** - Smart account functionality that

MOTIVATION:
[ERC-4337](./eip-4337.md) standardizes the execution flow of contract accounts and [ERC-7579](./eip-7579.md) standardizes the modular implementation of these accounts, allowing any developer to build modules for these modular accounts (hereafter Smart Accounts). However, adding third-party modules into Smart Accounts unchecked opens up a wide range of attack vectors. One solution to this security issue is to create a Module Registry that stores security attestations on Modules and allows Smart Accounts to query these attestations before using a module. This standard aims to achieve two things: 1. Standardize the interface and required functionality of Module Registries. 2. Standardize the functionality of

RATIONALE:
### Attestations Attestations are onchain assertions made about a module. These assertions could pertain to the security of a module (similar to a regular smart contract audit), whether a module adheres to a certain standard or any other kinds of statements about these modules. While some of these assertions can feasibly be verified onchain, the majority of them cannot be. One example of this would be determining what storage slots a specific module can write to, which might be useful if a smart account uses DELEGATECALL to invoke the module. This assertion is practically infeasible to verify onchain,


=== ERC-7831 ===
TITLE: Multi-Chain Addressing
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-08-30
REQUIRES: 5, 5, ,,  , 1, 3, 7, ,,  , 1, 5, 5, ,,  , 1, 6, 5, ,,  , 2, 3, 0, 4

SUMMARY:
This proposal introduces a chain-specific address format that allows specifying both an account and the chain on which that account intends to transact. These chain-specific addresses take the form of `(example.eth:optimism)`, `6A10161835a36302BfD39bDA9B44f5734442234e:ethereum:11155111`, and so on. The target chain is resolved using a registry stored on ENS.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119] and [RFC 8174]. Grammar snippets in this proposal are given in Augmented Backus-Naur form (ABNF) as defined in [RFC 5234] and [RFC 7405]. ### Definitions The following terms are used throughout this proposal: - **agent** - software/tool responsible for resolving a chain-specific address to its exact account and chain. - **bridge** - contract that connects the root chain to the target chain (eg. to transfer tokens, proxy

MOTIVATION:
The Ethereum ecosystem is becoming steadily more fragmented. This means a 20 byte address by itself is not enough information to fully specify an account. This can be problematic if funds are sent to an unreachable address on the incorrect chain. Instead of using chain identifiers, which are not human readable, the address could be extended with a human-readable chain name, which can then be resolved to a chain identifier. The mapping from chain names to identifiers has, since [EIP-155], been maintained off chain using a centralized list. This solution has two main shortcomings: - It does not

RATIONALE:
### Component Order The components are ordered from most specific to most general because... <!-- TODO --> ### Separator Choice The colon (`:`) is a reasonable choice for separator because it is not an allowed character in ENS names, it is familiar (eg. IPv6), and isn't as overloaded as the `@` symbol. #### Alternative: `@` The `@` symbol is a common choice for addresses, and finds use in email and several federated communication protocols. The English reading (foo-**AT**-example-DOT-com) is natural and implies a hierarchy between the left and the right components. Unfortunately, because the `@` symbol is so


=== ERC-1132 ===
TITLE: Extending ERC20 with token locking capability
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-06-03
REQUIRES: 

SUMMARY:
This proposal provides basic functionality to time-lock tokens within an ERC20 smart contract for multiple utilities without the need of transferring tokens to an external escrow smart contract. It also allows fetching balance of locked and transferable tokens. Time-locking can also be achieved via staking (#900), but that requires transfer of tokens to an escrow contract / stake manager, resulting in the following six concerns: 1. additional trust on escrow contract / stake manager 2. additional approval process for token transfer 3. increased ops costs due to gas requirements in transfers 4. tough user experience as the user

SPECIFICATION:
I’ve extended the ERC20 interface with the following enhancements: ### Locking of tokens ```solidity /** * @dev Locks a specified amount of tokens against an address, * for a specified reason and time * @param _reason The reason to lock tokens * @param _amount Number of tokens to be locked * @param _time Lock time in seconds */ function lock(bytes32 _reason, uint256 _amount, uint256 _time) public returns (bool) ``` ### Fetching number of tokens locked under each utility ```solidity /** * @dev Returns tokens locked for a specified address for a * specified reason * * @param _of

MOTIVATION:
dApps often require tokens to be time-locked against transfers for letting members 1) adhere to vesting schedules and 2) show skin in the game to comply with the underlying business process. I realized this need while building Nexus Mutual and GovBlocks. In [Nexus Mutual](https://nexusmutual.io), claim assessors are required to lock their tokens before passing a vote for claims assessment. This is important as it ensures assessors’ skin in the game. The need here was that once a claim assessor locks his tokens for ‘n’ days, he should be able to cast multiple votes during that period of ‘n’


=== ERC-7204 ===
TITLE: Contract wallet management token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-21
REQUIRES: 165

SUMMARY:
This proposal introduces a smart contract wallet-based approach for managing tokens, focusing on utilizing the programmable features of smart contract wallets for asset management. Additionally, it introduces functions such as `tokenTransfer`, `tokenApprove`, `tokenApproveForAll`, `tokenIsApproveForAll` and `tokenAllowance`, which provide enhanced control over token transactions. This approach seeks to enhance token management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ** Compliant contract must implement the [ERC-165](./eip-165.md) interfaces** ```solidity /// @title ERC-7204 /// @dev See https://eips.ethereum.org/EIPS/eip-7204 /// @dev Note: the ERC-165 identifier for this interface is 0xf73edcda pragma solidity ^0.8.20; interface IERC7204 /* is ERC165 */ { /** * @notice Used to notify listeners that owner has granted approval to the user to manage assets tokens. * @param asset Address of the token *

MOTIVATION:
An externally-owned account (EOA) wallet has no state and code storage, while the smart contract wallet does. Account abstraction (AA) is a direction of the smart contract wallet, which works around abstract accounts. This ERC can also be an extension based on [ERC-4337](./eip-4337.md) or as a plug-in for wallets. The smart contract wallet allows the user's own account to have state and code, bringing programmability to the wallet. We think there are more directions to expand. For example, token asset management, functional expansion of token transactions, etc. The smart contract wallet interface of this ERC is for asset

RATIONALE:
the key technical decisions in this proposal are: **Improved Approve Mechanism** - **Current vs. Proposed**: In the existing ERC-20 system, an externally-owned account (EOA) directly interacts with token contracts to `approve`. The new `tokenApprove` and `tokenApproveForAll` functions in this proposed enable more precise control over token usage within a wallet contract, a significant improvement over the traditional method. - **Enhanced Security**: This mechanism mitigates risks like token over-approval by shifting approval control to the user's smart contract wallet. - **Programmability**: Users gain the ability to set advanced approval strategies, such as conditional or time-limited approvals, the `tokenApproveForAll` function


=== ERC-777 ===
TITLE: Token Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2017-11-20
REQUIRES: 1820

SUMMARY:
This standard defines a new way to interact with a token contract while remaining backward compatible with [ERC-20]. It defines advanced features to interact with tokens. Namely, *operators* to send tokens on behalf of another address&mdash;contract or regular account&mdash;and send/receive *hooks* to offer token holders more control over their tokens. It takes advantage of [ERC-1820] to find out whether and where to notify contracts and regular addresses when they receive tokens as well as to allow compatibility with already-deployed contracts.

SPECIFICATION:
### ERC777Token (Token Contract) ``` solidity interface ERC777Token { function name() external view returns (string memory); function symbol() external view returns (string memory); function totalSupply() external view returns (uint256); function balanceOf(address holder) external view returns (uint256); function granularity() external view returns (uint256); function defaultOperators() external view returns (address[] memory); function isOperatorFor( address operator, address holder ) external view returns (bool); function authorizeOperator(address operator) external; function revokeOperator(address operator) external; function send(address to, uint256 amount, bytes calldata data) external; function operatorSend( address from, address to, uint256 amount, bytes calldata data, bytes calldata operatorData ) external; function burn(uint256 amount, bytes calldata

MOTIVATION:
This standard tries to improve upon the widely used [ERC-20] token standard. The main advantages of this standard are: 1. Uses the same philosophy as Ether in that tokens are sent with `send(dest, value, data)`. 2. Both contracts and regular addresses can control and reject which token they send by registering a `tokensToSend` hook. (Rejection is done by `revert`ing in the hook function.) 3. Both contracts and regular addresses can control and reject which token they receive by registering a `tokensReceived` hook. (Rejection is done by `revert`ing in the hook function.) 4. The `tokensReceived` hook allows to send

RATIONALE:
The principal intent for this standard is to solve some of the shortcomings of [ERC-20] while maintaining backward compatibility with [ERC-20], and avoiding the problems and vulnerabilities of [EIP-223]. Below are the rationales for the decisions regarding the main aspects of the standards. *NOTE*: Jacques Dafflon ([0xjac]), one of the authors of the standard, conjointly wrote his [master thesis] on the standard, which goes in more details than could reasonably fit directly within the standard, and can provide further clarifications regarding certain aspects or decisions. ### Lifecycle More than just sending tokens, [ERC-777] defines the entire lifecycle of


=== ERC-6093 ===
TITLE: Custom errors for commonly-used tokens
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2022-12-06
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP defines a standard set of custom errors for commonly-used tokens, which are defined as [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), and [ERC-1155](./eip-1155.md) tokens. Ethereum applications and wallets have historically relied on revert reason strings to display the cause of transaction errors to users. Recent Solidity versions offer rich revert reasons with error-specific decoding (sometimes called "custom errors"). This EIP defines a standard set of errors designed to give at least the same relevant information as revert reason strings, but in a structured and expected way that clients can implement decoding for.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The following errors were designed according to the criteria described in [Rationale](#rationale). This EIP defines standard errors that may be used by implementations in certain scenarios but it does not specify whether implementations should revert in those scenarios, which remains up to the implementers unless a revert is mandated by the corresponding EIPs. The names of the error arguments are defined in the [Parameter

MOTIVATION:
Since the introduction of Solidity custom errors in v0.8.4, these have provided a way to show failures in a more expressive and gas efficient manner with dynamic arguments, while reducing deployment costs. However, [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), [ERC-1155](./eip-1155.md) were already finalized when custom errors were released, so no errors are included in their specification. Standardized errors allow users to expect more consistent error messages across applications or testing environments, while exposing pertinent arguments and overall reducing the need of writing expensive revert strings in the deployment bytecode.

RATIONALE:
The chosen objectives for a standard for token errors are to provide context about the error, and to make moderate use of meaningful arguments (to maintain the code size benefits with respect to strings). Considering this, the error names are designed following a basic grammatical structure based on the standard actions that can be performed on each token and the [subjects](#actions-and-subjects) involved. ### Actions and subjects An error is defined based on the following **actions** that can be performed on a token and its involved _subjects_: - **Transfer**: An operation in which a _sender_ moves to a _receiver_


=== ERC-1261 ===
TITLE: Membership Verification Token (MVT)
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-07-14
REQUIRES: 1, 6, 5, ,,  , 1, 7, 3

SUMMARY:
The following standard allows for the implementation of a standard API for Membership Verification Token within smart contracts(called entities). This standard provides basic functionality to track membership of individuals in certain on-chain ‘organizations’. This allows for several use cases like automated compliance, and several forms of governance and membership structures. We considered use cases of MVTs being assigned to individuals which are non-transferable and revocable by the owner. MVTs can represent proof of recognition, proof of membership, proof of right-to-vote and several such otherwise abstract concepts on the blockchain. The following are some examples of those use cases,

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. **Every ERC-1261 compliant contract must implement the `ERC1261`, `ERC173` and `ERC165` interfaces** (subject to "caveats" below): ```solidity /// @title ERC-1261 MVT Standard /// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1261.md /// The constructor should define the attribute set for this MVT. /// Note: the ERC-165 identifier for this interface is 0x1d8362cf. interface IERC1261 {/* is ERC173, ERC165 */ /// @dev This emits when a token is assigned to a member. event Assigned(address indexed

MOTIVATION:
A standard interface allows any user, applications to work with any MVT on Ethereum. We provide for simple ERC-1261 smart contracts. Additional applications are discussed below. This standard is inspired from the fact that voting on the blockchain is done with token balance weights. This has been greatly detrimental to the formation of flexible governance systems on the blockchain, despite the tremendous governance potential that blockchains offer. The idea was to create a permissioning system that allows organizations to vet people once into the organization on the blockchain, and then gain immense flexibility in the kind of governance

RATIONALE:
There are many potential uses of Ethereum smart contracts that depend on tracking membership. Examples of existing or planned MVT systems are Vault, a DAICO platform, and Stream, a security token framework. Future uses include the implementation of direct democracy, in-game memberships and badges, licence and travel document issuance, electronic voting machine trails, software licencing and many more. **MVT Word Choice:** Since the tokens are non transferable and revocable, they function like membership cards. Hence the word membership verification token. **Transfer Mechanism** MVTs can't be transferred. This is a design choice, and one of the features that distinguishes


=== ERC-4910 ===
TITLE: Royalty Bearing NFTs
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-03-14
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The proposal directly connects NFTs and royalties in a smart contract architecture extending the [ERC-721](./eip-721.md) standard, with the aim of precluding central authorities from manipulating or circumventing payments to those who are legally entitled to them. The proposal builds upon the OpenZeppelin Smart Contract Toolbox architecture, and extends it to include royalty account management (CRUD), royalty balance and payments management, simple trading capabilities -- Listing/De-Listing/Buying -- and capabilities to trace trading on exchanges. The royalty management capabilities allow for hierarchical royalty structures, referred to herein as royalty trees, to be established by logically connecting a "parent" NFT to

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Outline This proposal introduces several new concepts as extensions to the ERC-721 standard that warrant explanation: * **Royalty Account (RA)** * A Royalty Account is attached to each NFT through its `tokenId` and consists of several sub-accounts which can be accounts of individuals or other RAs. A Royalty Account is identified by an account identifier. * **Account Type** * This specifies if an RA Sub Account belongs to

MOTIVATION:
The management of royalties is an age-old problem characterized by complex contracts, opaque management, plenty of cheating and fraud. The above is especially true for a hierarchy of royalties, where one or more assets is derived from an original asset such as a print from an original painting, or a song is used in the creation of another song, or distribution rights and compensation are managed through a series of affiliates. In the example below, the artist who created the original is eligible to receive proceeds from every sale, and resale, of a print. ![Fig1](../assets/eip-4910/eip-4910-print-families.png) The basic concept

RATIONALE:
Royalties for NFTs is at its core a distribution licensing problem. A buyer obtains the right to an asset/content which might or might not be reproducible, alterable etc. by the buyer or agents of the buyer. Therefore, a comprehensive specification must address a hierarchy of royalties, where one or more assets are derived from an original asset as described in the Motivation section in detail. Consequently, a design must solve for a multi-level inheritance, and thus, recursion problem. In order to solve for the complicated inheritance problem, this proposal design breaks down the recursive problem of the hierarchy


=== ERC-2770 ===
TITLE: Meta-Transactions Forwarder Contract
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-07-01
REQUIRES: 7, 1, 2, ,,  , 2, 7, 7, 1

SUMMARY:
This proposal defines an external API of an extensible Forwarder whose responsibility is to validate transaction signatures on-chain and expose the signer to the destination contract, that is expected to accommodate all use-cases. The ERC-712 structure of the forwarding request can be extended allowing wallets to display readable data even for types not known during the Forwarder contract deployment.

SPECIFICATION:
The Forwarder contract operates by accepting a signed typed data together with it's ERC-712 signature, performing signature verification of incoming data, appending the signer address to the data field and performing a call to the target. ### Forwarder data type registration Request struct MUST contain the following fields in this exact order: ``` struct ForwardRequest { address from; address to; uint256 value; uint256 gas; uint256 nonce; bytes data; uint256 validUntil; } ``` `from` - an externally-owned account making the request \ `to` - a destination address, normally a smart-contract\ `value` - an amount of Ether to transfer to

MOTIVATION:
There is a growing interest in making it possible for Ethereum contracts to accept calls from externally owned accounts that do not have ETH to pay for gas. This can be accomplished with meta-transactions, which are transactions that have been signed as plain data by one externally owned account first and then wrapped into an Ethereum transaction by a different account. `msg.sender` is a transaction parameter that can be inspected by a contract to determine who signed the transaction. The integrity of this parameter is guaranteed by the Ethereum EVM, but for a meta-transaction verifying `msg.sender` is insufficient,

RATIONALE:
Further relying on `msg.sender` to authenticate end users by their externally-owned accounts is taking the Ethereum dapp ecosystem to a dead end. A need for users to own Ether before they can interact with any contract has made a huge portion of use-cases for smart contracts non-viable, which in turn limits the mass adoption and enforces this vicious cycle. `validUntil` field uses a block number instead of timestamp in order to allow for better precision and integration with other common block-based timers.


=== ERC-7654 ===
TITLE: Request Method Types
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-03-13
REQUIRES: 

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. It consists of four request method types: **GET**: Request the contract to retrieve records. **POST**: Request the contract to create a new record. **PUT**: Request the contract to update a record. **OPTIONS**: Supported request method types. Workflow: 1. Call ```options``` to obtain supported request method types. 2. Call ```getMethods``` to obtain the request method name. 3. Call ```getMethodReqAndRes``` to obtain the request parameter data

RATIONALE:
### Type of request method In order to enable the client to operate the contract in a standardized and predictable way, three request method types ```GET```, ```POST```, and ```PUT``` are set. The functions of each need to be defined in these three types to facilitate the contract caller to understand and process the information required for the request. However, there is no ```DELETE``` operation type because deleting data in the contract is an inefficient operation. Developers can add a ```PUT``` request method by themselves to set the data to be valid and invalid, and only return valid data


=== ERC-7777 ===
TITLE: Governance for Human Robot Societies
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-09-29
REQUIRES: 

SUMMARY:
This proposal defines two core interfaces: `IUniversalIdentity` and `IUniversalCharter`, providing mechanisms for humans, and robots to establish their identities and to create decentralized communities governed by specific rule sets. The `IUniversalIdentity` interface establishes the fair and equitable treatment of sentient computer architectures other than the human brain, enabling robots to acquire on-chain identities, and thereby interact and transact with humans. Additionally the `IUniversalIdentity` interface also includes support for hardware-backed identity verification, enabling physical robots to prove their identity through cryptographic signatures derived from secure hardware elements and a challenge-response scheme. The `IUniversalCharter` enables humans and robots to create,

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ```solidity interface IUniversalIdentity { /// @notice Structure for hardware identity struct HardwareIdentity { bytes32 publicKey; // Hardware-bound public key uniquely tied to this robot string manufacturer; // Identifier for the robot's manufacturer string operator; // Identifier for the robot's operator string model; // Model identifier of the robot string serialNumber; // Unique serial number for the robot bytes32 initialHashSignature; // Signature of the initial

MOTIVATION:
The human brain is a wet, massively parallel electrochemical computer. Recent hardware and software advances make it likely that soon, human societies will need tools for interacting with sentient, non-human computers, such as robots. Our current forms of government, where citizens are auto-enrolled into specific rule sets depending on where they were born, do not gracefully map onto robots without a traditional birthplace or birthtime. Among many difficulties being experienced by robots, they are (currently) unable to obtain standard forms of ID (such as passports), it is not clear which rule sets apply to them (since in general

RATIONALE:
**IUniversalIdentity** `struct HardwareIdentity` The HardwareIdentity structure provides essential information about a robot, including a challenge-response public key, manufacturer, operator, model, manufacturer serial number `generateChallenge()` This function enables secure identity verification through a challenge-response authentication. `verifyChallenge(bytes32 challenge, bytes memory signature)` This function verifies that a signature was genuinely created by the robot's secure hardware in response to a specific challenge. `addRule(bytes memory rule)` This function allows a robot to flexibly adopt new compliance requirements in order join different `IUniversalCharter` contracts. `removeRule(bytes memory rule)` This function allows a robot to dynamically manage and maintain its rules, ensuring that its rule


=== ERC-5164 ===
TITLE: Cross-Chain Execution
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2022-06-14
REQUIRES: 

SUMMARY:
This specification defines a cross-chain execution interface for EVM-based blockchains. Implementations of this specification will allow contracts on one chain to call contracts on another by sending a cross-chain message. The specification defines two components: the "Message Dispatcher" and the "Message Executor". The Message Dispatcher lives on the calling side, and the executor lives on the receiving side. When a message is sent, a Message Dispatcher will move the message through a transport layer to a Message Executor, where they are executed. Implementations of this specification must implement both components.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. This specification allows contracts on one chain to send messages to contracts on another chain. There are two key interfaces that needs to be implemented: - `MessageDispatcher` - `MessageExecutor` The `MessageDispatcher` lives on the origin chain and dispatches messages to the `MessageExecutor` for execution. The `MessageExecutor` lives on the destination chain and executes dispatched messages. ### MessageDispatcher The `MessageDispatcher` lives on the chain from which messages are sent. The

MOTIVATION:
Many Ethereum protocols need to coordinate state changes across multiple EVM-based blockchains. These chains often have native or third-party bridges that allow Ethereum contracts to execute code. However, bridges have different APIs so bridge integrations are custom. Each one affords different properties; with varying degrees of security, speed, and control. Defining a simple, common specification will increase code re-use and allow us to use common bridge implementations.

RATIONALE:
The `MessageDispatcher` can be coupled to one or more `MessageExecutor`. It is up to bridges to decide how to couple the two. Users can easily bridge a message by calling `dispatchMessage` without being aware of the `MessageExecutor` address. Messages can also be traced by a client using the data logged by the `MessageIdExecuted` event. Some bridges may require payment in the native currency, so the `dispatchMessage` function is payable.


=== ERC-5375 ===
TITLE: NFT Author Information and Consent
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-07-30
REQUIRES: 5, 5, ,,  , 1, 5, 5, ,,  , 7, 1, 2, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP standardizes a JSON format for storing off-chain information about NFT authors. Specifically, it adds a new field which provides a list of author names, addresses, and proofs of _authorship consent_: proofs that the authors have agreed to be named as authors. Note that a proof of authorship _consent_ is not a proof of authorship: an address can consent without having authored the NFT.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. All addresses used in this standard MUST follow the casing rules described in [EIP-55](./eip-55.md). ### Definitions - **Authors**: creators of an NFT - **Minter**: entity responsible for the actual minting transaction; the minter and the authors MAY be the same - **Verifier**: entity that wants to verify the authorship of an NFT (e.g. a user or an NFT marketplace) - **Author Consent Proof (ACP)**: a signed message that proves

MOTIVATION:
There is currently no standard to identify authors of an NFT, and existing techniques have issues: - Using the mint `tx.origin` or `msg.sender` - Assumes that the minter and the author are the same - Does not support multiple authors - Using the first Transfer event for a given ID - Contract/minter can claim that someone else is the author without their consent - Does not support multiple authors - Using a custom method/custom JSON field - Requires per-contract support by NFT platforms - Contract/minter can claim that someone else is the author without their consent The first

RATIONALE:
### Why provide only an author consent proof? Adding support for full authorship proofs (i.e. Alice is the author and no one else is the author) requires a protocol to prove that someone is the only author of an NFT. In other words, we need to answer the question: "Given an NFT Y and a user X claiming to be the author, is X the original author of Y?". For the sake of the argument, assume that there exists a protocol that, given an NFT Y, can determine the original author of Y. Even if such method existed,


=== ERC-7613 ===
TITLE: Puppet Proxy Contract
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-04
REQUIRES: 

SUMMARY:
A puppet is a contract that, when called, acts like an empty account. It doesn't do anything and it has no API, except when it is called by the address that deployed it. In that case, it delegates the call to the address passed to it in calldata. This gives the deployer the ability to execute any logic they want in the context of the puppet.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. To delegate, the deployer must prepend the calldata with an ABI-encoded address to delegate to. All the data after the address will be passed verbatim as the delegation calldata. If the caller isn't the deployer, the calldata is shorter than 32 bytes, or it doesn't start with an address left-padded with zeros, the puppet doesn't do anything. This lets the deployer make a plain

MOTIVATION:
A puppet can be used as an alternative account of its deployer. It has a different address, so it has a separate set of asset balances. This enables sophisticated accounting, e.g. each user of a protocol can get their own address where assets can be sent and stored. The user may call the protocol contract, which in turn will deploy a new puppet and consider it assigned to the user. If the puppet is deployed under a predictable address, e.g. by using the user's address as the CREATE2 salt, the puppet may not even need to be deployed

RATIONALE:
The main goals of the puppet design are low cost and modularity. It should be cheap to deploy and cheap to interact with. The contract should be self-contained, simple to reason about, and easy to use as an architectural building block. The puppet behavior could be implemented fairly easily in Solidity with some inline Yul for delegation. This would make the bytecode much larger and more expensive to deploy. It would also be different depending on the compiler version and configuration, so deployments under predictable addresses using CREATE2 would be trickier. A workaround for the problems with the


=== ERC-2980 ===
TITLE: Swiss Compliant Asset Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-09-08
REQUIRES: 20

SUMMARY:
This new standard is an [ERC-20](./eip-20.md) compatible token with restrictions that comply with the following Swiss laws: the [Stock Exchange Act](../assets/eip-2980/Swiss-Confederation-SESTA.pdf), the [Banking Act](../assets/eip-2980/Swiss-Confederation-BA.pdf), the [Financial Market Infrastructure Act](../assets/eip-2980/Swiss-Confederation-FMIA.pdf), the [Act on Collective Investment Schemes](../assets/eip-2980/Swiss-Confederation-CISA.pdf) and the [Anti-Money Laundering Act](../assets/eip-2980/Swiss-Confederation-AMLA.pdf). The [Financial Services Act](../assets/eip-2980/Swiss-Confederation-FINSA.pdf) and the [Financial Institutions Act](../assets/eip-2980/Swiss-Confederation-FINIA.pdf) must also be considered. The solution achieved meet also the European jurisdiction. This new standard meets the new era of asset tokens (known also as "security tokens"). These new methods manage securities ownership during issuance and trading. The issuer is the only role that can manage a white-listing and

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. The words "asset tokens" and "security tokens" can be considered synonymous. Every ERC-2980 compliant contract MUST implement the ERC-2980 interface. ### ERC-2980 (Token Contract) ``` solidity interface ERC2980 extends ERC20 { /// @dev This emits when funds are reassigned event FundsReassigned(address from, address to, uint256 amount); /// @dev This emits when funds are revoked event FundsRevoked(address from, uint256 amount); /// @dev This emits when an address is frozen event

MOTIVATION:
In its ICO guidance dated February 16, 2018, FINMA (Swiss Financial Market Supervisory Authority) defines asset tokens as tokens representing assets and/or relative rights ([FINMA ICO Guidelines](../assets/eip-2980/Finma-ICO-Guidelines.pdf)). It explicitly mentions that asset tokens are analogous to and can economically represent shares, bonds, or derivatives. The long list of relevant financial market laws mentioned above reveal that we need more methods than with Payment and Utility Token.

RATIONALE:
There are currently no token standards that expressly facilitate conformity to securities law and related regulations. EIP-1404 (Simple Restricted Token Standard) it’s not enough to address FINMA requirements around re-issuing securities to Investors. In Swiss law, an issuer must eventually enforce the restrictions of their token transfer with a “freeze” function. The token must be “revocable”, and we need to apply a white-list method for AML/KYC checks.


=== ERC-2009 ===
TITLE: Compliance Service
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-05-09
REQUIRES: 1066

SUMMARY:
A regulated token needs to comply with several legal requirements, especially [KYC][KYC-Wikipedia] and [AML][AML-Wikipedia]. If the necessary checks have to be made off-chain the token transfer becomes centralized. Further the transfer in this case takes longer to complete as it can not be done in one transaction, but requires a second confirmation step. The goal of this proposal is to make this second step unnecessary by providing a service for compliance checks.

SPECIFICATION:
```solidity interface CompliantService { function checkTransferAllowed(bytes32 tokenId, address from, address to, uint256 value) external view returns (byte); function checkTransferFromAllowed(bytes32 tokenId, address sender, address from, address to, uint256 value) external view returns (byte); function checkMintAllowed(bytes32 tokenId, address to, uint256 value) external view returns (byte); function checkBurnAllowed(bytes32 tokenId, address from, uint256 value) external view returns (byte); function updateTransferAccumulated(bytes32 tokenId, address from, address to, uint256 value) external; function updateMintAccumulated(bytes32 tokenId, address to, uint256 value) external; function updateBurnAccumulated(bytes32 tokenId, address from, uint256 value) external; function addToken(bytes32 tokenId, address token) external; function replaceToken(bytes32 tokenId, address token) external; function removeToken(bytes32 tokenId) external; function isToken(address

MOTIVATION:
Currently there is no proposal on how to accomplish decentralized compliance checks. [ERC-1462][ERC-1462] proposes a basic set of functions to check if `transfer`, `mint` and `burn` are allowed for a user, but not how those checks should be implemented. This EIP proposes a way to implement them fully on-chain while being generic enough to leave the actual implementation of the checks up to the implementers, as these may vary a lot between different tokens. The proposed `Compliance Service` supports more than one token. Therefore it could be used by law-makers to maintain the compliance rules of regulated tokens

RATIONALE:
The usage of a token id instead of the address has been chosen to give tokens the possibility to update their smart contracts and keeping all their associated accumulated. If the address would be used, a migration process would needed to be done after a smart contract update. No event is emitted after updating the accumulated as those are always associated with a `transfer`, `mint` or `burn` of a token which already emits an event of itself. While not requiring it, the naming of the functions `checkTransferAllowed`, `checkTransferFromAllowed`, `checkMintAllowed` and `checkBurnAllowed` was adopted from [ERC-1462][ERC-1462]. While not requiring


=== ERC-5725 ===
TITLE: Transferable Vesting NFT
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-09-08
REQUIRES: 721

SUMMARY:
A **Non-Fungible Token** (NFT) standard used to vest tokens ([ERC-20](./eip-20.md) or otherwise) over a vesting release curve. The following standard allows for the implementation of a standard API for NFT based contracts that hold and represent the vested and locked properties of any underlying token ([ERC-20](./eip-20.md) or otherwise) that is emitted to the NFT holder. This standard is an extension of the [ERC-721](./eip-721.md) token that provides basic functionality for creating vesting NFTs, claiming the tokens and reading vesting curve properties.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; import "@openzeppelin/contracts/token/ERC721/IERC721.sol"; /** * @title Non-Fungible Vesting Token Standard. * @notice A non-fungible token standard used to vest ERC-20 tokens over a vesting release curve * scheduled using timestamps. * @dev Because this standard relies on timestamps for the vesting schedule, it's important to keep track of the * tokens claimed per Vesting NFT so that a user cannot withdraw more tokens

MOTIVATION:
Vesting contracts, including timelock contracts, lack a standard and unified interface, which results in diverse implementations of such contracts. Standardizing such contracts into a single interface would allow for the creation of an ecosystem of on- and off-chain tooling around these contracts. In addition, liquid vesting in the form of non-fungible assets can prove to be a huge improvement over traditional **Simple Agreement for Future Tokens** (SAFTs) or **Externally Owned Account** (EOA)-based vesting as it enables transferability and the ability to attach metadata similar to the existing functionality offered by with traditional NFTs. Such a standard will not

RATIONALE:
### Terms These are base terms used around the specification which function names and definitions are based on. - _vesting_: Tokens which a vesting NFT is vesting until a future date. - _vested_: Total amount of tokens a vesting NFT has vested. - _claimable_: Amount of vested tokens which can be unlocked. - _claimed_: Total amount of tokens unlocked from a vesting NFT. - _timestamp_: The unix `timestamp` (seconds) representation of dates used for vesting. ### Vesting Functions **`vestingPayout` + `vestedPayout`** `vestingPayout(uint256 tokenId)` and `vestedPayout(uint256 tokenId)` add up to the total number of tokens which can be claimed


=== ERC-1538 ===
TITLE: Transparent Contract Standard
TYPE: Standards Track ERC
STATUS: Withdrawn
CREATED: 2018-10-31
REQUIRES: 

SUMMARY:
A transparent contract is a proxy contract design pattern that provides the following: 1. A way to add, replace and remove multiple functions of a contract atomically (at the same time). 1. Standard events to show what functions are added, replaced and removed from a contract, and why the changes are made. 2. A standard way to query a contract to discover and retrieve information about all functions exposed by it. 3. Solves the 24KB maximum contract size limitation, making the maximum contract size of a transparent contract practically unlimited. This standard makes the worry about contract size

SPECIFICATION:
> **Note:** The solidity `delegatecall` opcode enables a contract to execute a function from another contract, but it is executed as if the function was from the calling contract. Essentially `delegatecall` enables a contract to "borrow" another contract's function. Functions executed with `delegatecall` affect the storage variables of the calling contract, not the contract where the functions are defined. ### General Summary A transparent contract delegates or forwards function calls to it to other contracts using `delegatecode`. A transparent contract has an `updateContract` function that enables multiple functions to be added, replaced or removed. An event is emitted

MOTIVATION:
A fundamental benefit of Ethereum contracts is that their code is immutable, thereby acquiring trust by trustlessness. People do not have to trust others if it is not possible for a contract to be changed. However, a fundamental problem with trustless contracts that cannot be changed is that they cannot be changed. #### Bugs Bugs and security vulnerabilities are unwittingly written into immutable contracts that ruin them. #### Improvements Immutable, trustless contracts cannot be improved, resulting in increasingly inferior contracts over time. Contract standards evolve, new ones come out. People, groups and organizations learn over time what people

RATIONALE:
### String of Function Signatures Instead of bytes4[] Array of Function Selectors The `updateContract` function takes a `string` list of functions signatures as an argument instead of a `bytes4[]` array of function selectors for three reasons: 1. Passing in function signatures enables the implementation of `updateContract` to prevent selector clashes. 2. A major part of this standard is to make upgradeable contracts more transparent by making it easier to see what has changed over time and why. When a function is added, replaced or removed its function signature is included in the FunctionUpdate event that is emitted. This


=== ERC-7803 ===
TITLE: EIP-712 Extensions for Account Abstraction
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-08
REQUIRES: 712

SUMMARY:
This ERC improves on [EIP-712] signatures to better support smart contract accounts by 1) introducing signing domains as a way to prevent replay attacks when private keys are shared across accounts, and 2) allowing dapps and wallets to coordinate on the method that will be used to authenticate the signature. [EIP-712]: ./eip-712.md

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Requests for typed data signatures via JSON-RPC (`eth_signTypedData`) or client libraries are extended with the following optional properties: - `signingDomains` - `authMethods` These new properties are used alongside the existing ones, i.e., `types`, `primaryType`, `domain`, and `message`. The signature returned in response to the request MAY be of any size, and in the absence of `authMethods` it MUST be treated opaquely as the type

MOTIVATION:
### Signing Domains Standards like [ERC-1271] and [ERC-6492] give smart contract accounts (SCAs) the ability to produce signatures that an application can authenticate without knowledge of the abstract rules of the account. This is an important primitive for applications, as the account owner is able to authorize a third-party to act on its behalf without interacting with the chain. [ERC-1271]: ./eip-1271.md [ERC-6492]: ./eip-6492.md Smart contract accounts may be "owned" by cryptographic keys whose signatures are used to authorize the use of the account. There is not necessarily a one-to-one mapping between keys and accounts, because a single key

RATIONALE:
<!-- TODO -->


=== ERC-2477 ===
TITLE: Token Metadata Integrity
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-01-02
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
An interface `ERC2477` with two functions `tokenURIIntegrity` and `tokenURISchemaIntegrity` are specified for smart contracts and a narrative is provided to explain how this improves the integrity of the token metadata documents.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Smart contracts **Smart contracts implementing the ERC-2477 standard MUST implement the `ERC2477` interface.** ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.7; /// @title ERC-2477 Token Metadata Integrity /// @dev See https://eips.ethereum.org/EIPS/eip-2477 /// @dev The ERC-165 identifier for this interface is 0x832a7e0e interface ERC2477 /* is ERC165 */ { /// @notice Get the cryptographic hash of the specified tokenID's metadata /// @param tokenId Identifier for a specific token /// @return

MOTIVATION:
Tokens are being used in many applications to represent, trace and provide access to assets off-chain. These assets include in-game digital items in mobile apps, luxury watches and products in our global supply chain, among many other creative uses. Several token standards allow attaching metadata to specific tokens using a URI (RFC 3986) and these are supported by the applications mentioned above. These metadata standards are: * ERC-721 metadata extension (`ERC721Metadata`) * ERC-1155 metadata extension (`ERC1155Metadata_URI`) * ERC-1046 (DRAFT) ERC-20 Metadata Extension Although all these standards allow storing the metadata entirely on-chain (using the "data" URI, RFC 2397),

RATIONALE:
**Function and parameter naming** The W3C Subresource Integrity (SRI) specification uses the attribute "integrity" to perform integrity verification. This ERC-2477 standard provides a similar mechanism and reuses the integrity name so as to be familiar to people that have seen SRI before. **Function return tuple** The SRI integrity attribute encodes elements of the tuple $$(cryptographic\ hash\ function, digest, options)$$. This ERC-2477 standard returns a digest and hash function name and omits forward-compatibility options. Currently, the SRI specification does not make use of options. So we cannot know what format they might be when implemented. This is the motivation


=== ERC-5501 ===
TITLE: Rental & Delegation NFT - EIP-721 Extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-18
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 4, 4, 0, 0, ,,  , 4, 9, 0, 7

SUMMARY:
The following standard proposes an additional `user` role for [EIP-721](./eip-721.md). This role grants the permission to use the NFT with no ability to transfer or set users. It has an expiry and a flag if the token is borrowed or not. `Owner` can delegate the NFT for usage to hot wallets or lend the NFT. If the token is borrowed, not even the owner can change the user until the status expires or both parties agree to terminate. This way, it is possible to keep both roles active at the same time.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. **Every compliant contract MUST implement the `IERC5501` interface. This extension is OPTIONAL for [EIP-721](./eip-721.md) contracts.** ```solidity /** * @title IERC5501: Rental & Delegation NFT - EIP-721 Extension * @notice the EIP-165 identifier for this interface is 0xf808ec37. */ interface IERC5501 /* is IERC721 */ { /** * @dev Emitted when the user of an NFT is modified. */ event UpdateUser(uint256 indexed _tokenId, address indexed _user, uint64 _expires, bool _isBorrowed);

MOTIVATION:
Collectibles, gaming assets, metaverse, event tickets, music, video, domains, real item representation are several among many NFT use cases. With [EIP-721](./eip-721.md) only the owner can reap the benefits. However, with most of the utilities it would be beneficial to distinguish between the token owner and its user. For instance music or movies could be rented. Metaverse lands could be delegated for usage. The two reasons why to set the user are: * **delegation** - Assign user to your hot wallet to interact with applications securely. In this case, the owner can change the user at any time. *

RATIONALE:
The main factors influencing this standard are: * **[EIP-4400](./eip-4400.md) and [EIP-4907](./eip-4907.md)** * **Allow lending and borrowing without the necessary stake or overcollateralization while owner retains ownership** * **Leave the delegation option available** * **Keep the number of functions in the interfaces to a minimum while achieving desired functionality** * **Modularize additional extensions to let developers choose what they need for their project** ### Name The name for the additional role has been chosen to fit the purpose and to keep compatibility with EIP-4907. ### Ownership retention Many collections offer their owners airdrops or free minting of various tokens.


=== ERC-2612 ===
TITLE: Permit Extension for EIP-20 Signed Approvals
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-04-13
REQUIRES: 2, 0, ,,  , 7, 1, 2

SUMMARY:
Arguably one of the main reasons for the success of [EIP-20](./eip-20.md) tokens lies in the interplay between `approve` and `transferFrom`, which allows for tokens to not only be transferred between externally owned accounts (EOA), but to be used in other contracts under application specific conditions by abstracting away `msg.sender` as the defining mechanism for token access control. However, a limiting factor in this design stems from the fact that the EIP-20 `approve` function itself is defined in terms of `msg.sender`. This means that user's _initial action_ involving EIP-20 tokens must be performed by an EOA (_but see Note

SPECIFICATION:
Compliant contracts must implement 3 new functions in addition to EIP-20: ```sol function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external function nonces(address owner) external view returns (uint) function DOMAIN_SEPARATOR() external view returns (bytes32) ``` The semantics of which are as follows: For all addresses `owner`, `spender`, uint256s `value`, `deadline` and `nonce`, uint8 `v`, bytes32 `r` and `s`, a call to `permit(owner, spender, value, deadline, v, r, s)` will set `allowance[owner][spender]` to `value`, increment `nonces[owner]` by 1, and emit a corresponding `Approval` event, if and only if the following conditions are

MOTIVATION:
While EIP-20 tokens have become ubiquitous in the Ethereum ecosystem, their status remains that of second class tokens from the perspective of the protocol. The ability for users to interact with Ethereum without holding any ETH has been a long outstanding goal and the subject of many EIPs. So far, many of these proposals have seen very little adoption, and the ones that have been adopted (such as [EIP-777](./eip-777.md)), introduce a lot of additional functionality, causing unexpected behavior in mainstream contracts. This ERC proposes an alternative solution which is designed to be as minimal as possible and to

RATIONALE:
The `permit` function is sufficient for enabling any operation involving EIP-20 tokens to be paid for using the token itself, rather than using ETH. The `nonces` mapping is given for replay protection. A common use case of `permit` has a relayer submit a `Permit` on behalf of the `owner`. In this scenario, the relaying party is essentially given a free option to submit or withhold the `Permit`. If this is a cause of concern, the `owner` can limit the time a `Permit` is valid for by setting `deadline` to a value in the near future. The `deadline` argument


=== ERC-7573 ===
TITLE: Conditional-upon-Transfer-Decryption for DvP
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-12-05
REQUIRES: 

SUMMARY:
The interfaces in this proposal model a functional transaction scheme to establish a secure *delivery-versus-payment* across two blockchains, where a) no intermediary is required and b) one of the two chains can securely interact with a stateless "decryption oracle". Here, *delivery-versus-payment* refers to the exchange of, e.g., an asset against a payment; however, the concept is generic to make a transfer of one token on one chain (e.g., the payment) conditional to the successful transfer of another token on another chain (e.g., the asset). The scheme is realized by two smart contracts, one on each chain. One smart

SPECIFICATION:
### Methods #### Smart Contract on the chain that performs the locking (e.g. the asset chain) The following methods specify the functionality of the smart contract implementing the locking. For further information, please also look at the interface documentation [`ILockingContract.sol`](../assets/eip-7573/contracts/ILockingContract.sol). ##### Initiation of Transfer: `inceptTransfer` ```solidity function inceptTransfer(uint256 id, int amount, address from, string keyHashedSeller, string memory keyEncryptedSeller) external; ``` Called from the buyer of the token to initiate token transfer. Emits a `TransferIncepted` event. The parameter `id` is an identifier of the trade. The parameter `from` is the address of the seller (the address of the buyer

MOTIVATION:
Within the domain of financial transactions and distributed ledger technology (DLT), the Hash-Linked Contract (HLC) concept has been recognized as valuable and has been thoroughly investigated. The concept may help to solve the challenge of delivery-versus-payment (DvP), especially in cases where the asset chain and payment system (which may be a chain, too) are separated. A prominent application of smart contracts realizing a secure DvP is that of buying an asset, where the asset is managed on one chain (the asset chain), but the payments are executed on another chain (the payment chain). Proposed solutions are based on

RATIONALE:
The protocol tries to be parsimonious. The transfer is associated with a (preferably unique) `id` possibly generated by some additional interaction of the trading parties. The `key` and the `encryptedKey` arguments are strings to allow the flexible use of different encryption schemes. The decryption/encryption scheme should be inferable from the contents of the `encryptedKey`. ### Ensuring Secure Key Decryption - Key Format It has to be ensured that the decryption oracle decrypts a key only for the eligible contract. It seems as if this would require us to introduce a concept of eligibility to the description oracle, which


=== ERC-2746 ===
TITLE: Rules Engine Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-06-20
REQUIRES: 

SUMMARY:
This standard proposes an interface that will allow the creation of hierarchal sets of rules (i.e., RuleTrees) that can be invoked to evaluate and manipulate a registered data domain. At the time of this draft, all intentions to insert additional functionality onto the blockchain requires the coding and creation of a newly deployed contract. However, this standard will allow users to deploy a contract just once, one which will then allow them to create (and invoke) pipelines of commands within that contract.

SPECIFICATION:
For the clarification of terminology, an Attribute is a registered data point within the data domain, representing data that exists either in the rules engine contract or elsewhere. A Rule is an predefined action that occurs upon a single data point (i.e., Attribute) in the predefined data domain. For example, a Rule could check whether the Attribute 'TokenAmt' has a value less than the RHL (i.e., right-hand value) of 10. A RuleSet is a collection of Rules, where their collection invocation creates a boolean result that determines the navigational flow of execution between RuleSets. A RuleTree is a

MOTIVATION:
At the time of this draft, all development for Ethereum requires writing the code that forms smart contracts and then deploying those contracts to Ethereum. In order to create a proper contract, many considerations must be taken into account when designing and implementing the code, especially in terms of efficiency (i.e., gas cost) and security. Even the simplest contracts require a certain amount of vigilance and examination, before and after deployment. These requirements pertain to all cases, even for simple cases of examining a value and/or altering it. These technical challenges might form an obstacle for many others

RATIONALE:
### Attributes The data points are abstracted in order to let the implementation provide the mechanism for retrieving/populating the data. Data can be held by an internal data structure, another contract's method, or any number of other options. ### Events The events specified will help the caller of the RuleTree after execution, so that they may ascertain the navigational flow of RuleSet execution within the RuleTree and so that they may understand which RuleSets failed. ### Right-Hand Value In the function addRule(), the data type for the right-hand value is 'string' since the rule's action depends on its


=== ERC-5334 ===
TITLE: EIP-721 User And Expires And Level Extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-07-25
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
An [EIP-721](./eip-721.md) extension that adds an additional role (`user`) which can be granted to addresses, and a time where the role is automatically revoked (`expires`) and (`level`) . The `user` role represents permission to "use" the NFT, but not the ability to transfer it or set users.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Contract Interface Solidity Interface with NatSpec & OpenZeppelin v4 Interfaces (also available at [`IERC5334.sol`](../assets/eip-5334/IERC5334.sol)): ```solidity interface IERC5334 { // Logged when the user of a NFT, expires, or level is changed /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed or the user `level` is changed /// The zero address for user indicates that there is no user address event UpdateUser(uint256

MOTIVATION:
Some NFTs have certain utilities. For example, virtual land can be "used" to build scenes, and NFTs representing game assets can be "used" in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a “user”. The actions that a “user” should be able to take with an NFT would be different from the “owner” (for instance, “users” usually shouldn’t be able to sell ownership of the NFT). In these situations, it makes sense to have separate roles that identify whether an

RATIONALE:
TBD


=== ERC-2390 ===
TITLE: Geo-ENS
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-11-15
REQUIRES: 1, 3, 7, ,,  , 1, 6, 5, ,,  , 1, 0, 6, 2, ,,  , 1, 1, 8, 5

SUMMARY:
This EIP specifies an ENS resolver interface for geographically split horizon DNS. Geographic split horizon DNS returns resource records that are specific to an end user's location. This technique is commonly used by CDNs to direct traffic to content caches nearest users. Geographic split horizon resolution is primarily geared towards ENS resolvers storing DNS resource records [EIP-1185](./eip-1185.md), although the technique could be used on other interfaces like IPFS content hash storage [EIP-1062](./eip-1062.md).

SPECIFICATION:
This EIP proposes a new interface to ENS resolvers such that geo-spacial information can be recorded and retrieved from the blockchain. The interface changes are described below for "address resolvers" described in EIP137 however the idea applies to any record described in EIP1185 and EIP1062, namely DNS Resolvers, Text Resolvers, ABI Resolvers, etc. ### What is a geohash? A [Geohash](https://en.m.wikipedia.org/wiki/Geohash#Algorithm_and_example) is an interleaving of latitude and longitude bits, whose length determines it's precision. Geohashes are typically encoded in base 32 characters. ### function setGeoAddr(bytes32 node, string calldata geohash, address addr) external authorised(node) Sets a resource (contract address, IP,

MOTIVATION:
There are many use cases for traditional GeoDNS systems, like Amazon's Route53, in the centralized web. These use cases include proximity-based load balancing and serving content specific to the geographic location of the query. Unfortunately the ENS specification does not provide a mechanism for geo-specific resolution. ENS can respond to queries with IP addresses (as described in [EIP-1185](./eip-1185.md)) however there is no way to respond to geo-specific queries. This EIP proposes a standard to give the ENS system geo-proximal awareness to serve a similar purpose as GeoDNS. GeoENS can do more than DNS-based solutions. In addition to geographic

RATIONALE:
The proposed implementation uses a sparse [Quadtree](https://dl.acm.org/doi/10.1007/BF00288933) trie as an index for resource records as it has low storage overhead and good search performance. The leaf nodes of the tree store resource records while non-leaves represent one geohash character. Each node in the tree at depth d corresponds to a geohash of precision d. The tree has depth 8 because the maximum precision of a geohash is 8 characters. The tree has fanout 32 because the radix of a geohash character is 32. The path to get to a leaf node always has depth 8 and the leaf


=== ERC-7710 ===
TITLE: Smart Contract Delegation
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-05-20
REQUIRES: 1, 2, 7, 1, ,,  , 7, 5, 7, 9

SUMMARY:
This proposal introduces a standard way for smart contracts to delegate capabilities to other smart contracts or Externally Owned Accounts (EOAs). The delegating contract (delegator) must be able to authorize a `DelegationManager` contract to call the delegator to execute the desired action. This framework empowers a delegating contract with the ability to delegate any actions it has the authority to perform, thereby enabling more flexible and scalable contract interactions. This standard outlines the minimal interface necessary to facilitate such delegation. Additionally, this proposal is compatible with [ERC-4337](./eip-4337.md), although its implementation does not necessitate [ERC-4337](./eip-4337.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Terms - A **Delegator** is a smart contract that can create a delegation. - A **Delegation Manager** is a singleton smart contract that is responsible for validating delegation authority and calling on the *Delegator* to execute an action. It implements the `ERC7710Manager` interface. - A **delegation** is an authority given to another address to perform a specific action. - A **delegate** is a

MOTIVATION:
The development of smart contracts on Ethereum has led to a diverse array of decentralized applications (dApps) that leverage composability to interact with one another in innovative ways. While current smart contracts are indeed capable of working together, enabling these interactions, especially in the realm of sharing capabilities or permissions, remains a tedious and often gas-expensive process, which lacks backwards compatibility. Currently, for a smart contract to interact with or utilize the functionality of another, it typically requires hardcoded permissions or the development of bespoke, intermediary contracts. This not only increases the complexity and development time but also

RATIONALE:
The design of this ERC is motivated by the need to introduce standardized, secure, and efficient mechanisms for delegation within the Ethereum ecosystem. Several considerations were taken into account: **Flexibility and Scalability**: The proposed interfaces are designed to be minimal yet powerful, allowing contracts to delegate a wide range of actions without imposing a heavy implementation burden. This balance aims to encourage widespread adoption and innovation. **Interoperability**: Compatibility with existing standards, such as [ERC-1271](./eip-1271.md) and [ERC-4337](./eip-4337.md), ensures that this approach can be seamlessly integrated into the current Ethereum infrastructure. This encourages adoption and leverages existing security practices. **Usability**:


=== ERC-926 ===
TITLE: Address metadata registry
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-03-12
REQUIRES: 165

SUMMARY:
This EIP specifies a registry for address metadata, permitting both contracts and external accounts to supply metadata about themselves to onchain and offchain callers. This permits use-cases such as generalised authorisations, providing token acceptance settings, and claims registries.

SPECIFICATION:
The metadata registry has the following interface: ```solidity interface AddressMetadataRegistry { function provider(address target) view returns(address); function setProvider(address _provider); } ``` `setProvider` specifies the metadata registry to be associated with the caller's address, while `provider` returns the address of the metadata registry for the supplied address. The metadata registry will be compiled with an agreed-upon version of Solidity and deployed using the trustless deployment mechanism to a fixed address that can be replicated across all chains.

MOTIVATION:
An increasing set of use cases require storage of metadata associated with an address; see for instance EIP 777 and EIP 780, and the ENS reverse registry in EIP 181. Presently each use-case defines its own specialised registry. To prevent a proliferation of special-purpose registry contracts, we instead propose a single standardised registry using an extendable architecture that allows future standards to implement their own metadata standards.

RATIONALE:
There are two obvious approaches for a generic metadata registry: the indirection approach employed here, or a generalised key/value store. While indirection incurs the cost of an additional contract call, and requires providers to change over time, it also provides for significantly enhanced flexibility over a key/value store; for that reason we selected this approach.


=== ERC-7015 ===
TITLE: NFT Creator Attribution
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-05-11
REQUIRES: 5, 5, ,,  , 1, 5, 5, ,,  , 7, 1, 2, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This Ethereum Improvement Proposal aims to solve the issue of creator attribution for Non-Fungible Token (NFT) standards ([ERC-721](./eip-721.md), [ERC-1155](./eip-1155.md)). To achieve this, this EIP proposes a mechanism where the NFT creator signs the required parameters for the NFT creation, including the NFT metadata in a hash along with any other relevant information. The signed parameters and the signature are then validated and emitted during the deployment transaction, which allows the NFT to validate the creator and NFT platforms to attribute creatorship correctly. This method ensures that even if a different wallet sends the deployment transaction, the correct account

SPECIFICATION:
The keywords “MUST,” “MUST NOT,” “REQUIRED,” “SHALL,” “SHALL NOT,” “SHOULD,” “SHOULD NOT,” “RECOMMENDED,” “MAY,” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ERC-721 and ERC-1155 compliant contracts MAY implement this NFT Creator Attribution extension to provide a standard event to be emitted that defines the NFT creator at the time of contract creation. This EIP takes advantage of the fact that contract addresses can be precomputed before a contract is deployed. Whether the NFT contract is deployed through another contract (a factory) or through an EOA, the creator can be correctly attributed

MOTIVATION:
Current NFT platforms assume that the wallet deploying the smart contract is the creator of the NFT, leading to a misattribution in cases where a different wallet sends the deployment transaction. This happens often when working with smart wallet accounts, and new contract deployment strategies such as the first collector deploying the NFT contract. This proposal aims to solve the problem by allowing creators to sign the parameters required for NFT creation so that any wallet can send the deployment transaction with an signal in a verifiable way who is the creator.

RATIONALE:
By standardizing the `CreatorAttribution` event, this EIP enables platforms to ascertain creator attribution without relying on implicit assumptions. Establishing a standard for creator attribution empowers platforms to manage the complex aspects of deploying contracts while preserving accurate onchain creator information. This approach ensures a more reliable and transparent method for identifying NFT creators, fostering trust among participants in the NFT ecosystem. [ERC-5375](./eip-5375.md) attempts to solve the same issue and although offchain data offers improved backward compatibility, ensuring accurate and immutable creator attribution is vital for NFTs. A standardized onchain method for creator attribution is inherently more reliable and


=== ERC-3224 ===
TITLE: Described Data
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-01-23
REQUIRES: 191

SUMMARY:
Human-readable descriptions for machine executable operations, described in higher level machine readable data, so that wallets can provide meaningful feedback to the user describing the action the user is about to perform.

SPECIFICATION:
The **description string** and **described data** are generated simultaneously by evaluating the contract (i.e. the **describer**), passing the **describer inputs** to the method: ```solidity function eipXXXDescribe(bytes describer_inputs) view returns (string description_string, bytes described_data); ``` The method must be executable in a static context, (i.e. any side effects, such as logX, sstore, etc.), including through indirect calls may be ignored. During evaluation, the `ADDRESS` (i.e. `to`), `CALLER` (i.e. `from`), `VALUE`, and `GASPRICE` must be the same as the values for the transaction being described, so that the code generating the description can rely on them. For signing **described messages**,

MOTIVATION:
When using an Ethereum Wallet (e.g. MetaMask, Clef, Hardware Wallets) users must accept and authorize signing messages or sending transactions. Due to the complexity of Ethereum transactions, wallets are very limitd in their ability to provide insight into the contents of transactions user are approving; outside special-cased support for common transactions such as ERC20 transfers, this often amounts to asking the user to sign an opaque blob of binary data. This EIP presents a method for dapp developers to enable a more comfortable user experience by providing wallets with a means to generate a better description about what

RATIONALE:
### Meta Description There have been many attempts to solve this problem, many of which attempt to examine the encoded transaction data or message data directly. In many cases, the information that would be necessary for a meaningful description is not present in the final encoded transaction data or message data. Instead this EIP uses an indirect description of the data. For example, the `commit(bytes32)` method of ENS places a commitement **hash** on-chain. The hash contains the **blinded** name and address; since the name is blinded, the encoded data (i.e. the hash) no longer contains the original values


=== ERC-5732 ===
TITLE: Commit Interface
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-09-29
REQUIRES: 1, 6, 5, ,,  , 1, 2, 7, 1

SUMMARY:
A simple commit interface to support commit-reveal scheme which provides **only** a commit method but no reveal method, allowing implementations to integrate this interface with arbitrary reveal methods such as `vote` or `transfer`.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Interfaces referenced in this specification are as follows: ```solidity pragma solidity >=0.7.0 <0.9.0; // The EIP-165 identifier of this interface is 0xf14fcbc8 interface IERC_COMMIT_CORE { function commit(bytes32 _commitment) payable external; } pragma solidity >=0.7.0 <0.9.0; // The EIP-165 identifier of this interface is 0x67b2ec2c interface IERC_COMMIT_GENERAL { event Commit( uint256 indexed _timePoint, address indexed _from, bytes32 indexed _commitment, bytes _extraData); function commitFrom( address _from, bytes32 _commitment, bytes calldata _extraData)

MOTIVATION:
1. support commit-reveal privacy for applications such as voting. 2. make it harder for attackers for front-running, back-running or sandwich attacks.

RATIONALE:
1. One design options is that we can attach a Commit Interface to any individual ERCs such as voting standards or token standards. We choose to have a simple and generalize commit interface so all ERCs can be extended to support commit-reveal without changing their basic method signatures. 2. The key derived design decision we made is we will have a standardized `commit` method without a standardized `reveal` method, making room for customized reveal method or using `commit` with existing standard. 3. We chose to have a simple one parameter method of `commit` in our Core interface to


=== ERC-2494 ===
TITLE: Baby Jubjub Elliptic Curve
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-01-29
REQUIRES: 

SUMMARY:
Two of the main issues behind why blockchain technology is not broadly used by individuals and industry are scalability and privacy guarantees. With a set of cryptographic tools called zero-knowledge proofs (ZKP) it is possible to address both of these problems. More specifically, the most suitable protocols for blockchain are called zk-SNARKs (zero-knowledge Succinct Non-interactive ARguments of Knowledge), as they are non-interactive, have succinct proof size and sublinear verification time. These types of protocols allow proving generic computational statements that can be modelled with arithmetic circuits defined over a finite field (also called zk-SNARK circuits). To verify a

SPECIFICATION:
### Definitions Let `F_r` be the prime finite field with `r` elements, where ``` r = 21888242871839275222246405745257275088548364400416034343698204186575808495617 ``` Let `E` be the twisted Edwards elliptic curve defined over `F_r` described by equation ``` ax^2 + y^2 = 1 + dx^2y^2 ``` with parameters ``` a = 168700 d = 168696 ``` We call **Baby Jubjub** the curve `E(F_r)`, that is, the subgroup of `F_r`-rational points of `E`. ### Order Baby Jubjub has order ``` n = 21888242871839275222246405745257275088614511777268538073601725287587578984328 ``` which factors in ``` n = h x l ``` where ``` h = 8 l = 2736030358979909402780800718157159386076813972158567259200215660948447373041 ``` The

MOTIVATION:
A [zero knowledge proof](https://en.wikipedia.org/wiki/Zero-knowledge_proof) (ZKP) is a protocol that enables one party, the prover, to convince another, the verifier, that a statement is true without revealing any information beyond the veracity of the statement. [Non-Interactive ZKPs](https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Zero%20Knowledge/Noninteractive_Zero-Knowkedge.pdf) (NIZK) are a particular type of zero-knowledge proofs in which the prover can generate the proof without interaction with the verifier. NIZK protocols are very suitable for Ethereum applications, because they allow a smart contract to act as a verifier. This way, anyone can generate a proof and send it as part of a transaction to the smart contract, which can perform

RATIONALE:
The search for Baby Jubjub was motivated by the need for an elliptic curve that allows the implementation of elliptic-curve cryptography in `F_r`-arithmetic circuits. The curve choice was based on three main factors: type of curve, generation process and security criteria. This section describes how these factors were addressed. **Form of the Curve** Baby Jubjub is a **twisted Edwards** curve birationally equivalent to a **Montgomery** curve. The choice of this form of curve was based on the following facts: 1. The Edwards-curve Digital Signature Scheme is based on twisted Edwards curves. 2. Twisted Edwards curves have a single


=== ERC-3440 ===
TITLE: ERC-721 Editions Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-04-20
REQUIRES: 7, 1, 2, ,,  , 7, 2, 1

SUMMARY:
ERC-3440 is an ERC-721 extension specifically designed to make NFTs more robust for works of art. This extends the original ERC-721 spec by providing the ability to designate the original and limited-edition prints with a specialized enumeration extension similar to the [original 721 extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol) built-in. The key improvement of this extension is allowing artists to designate the limited nature of their prints and provide a signed piece of data that represents their unique signature to a given token Id, much like an artist would sign a print of their work.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ERC-721 compliant contracts MAY implement this ERC for editions to provide a standard method for designating the original and limited-edition prints with signatures from the artist. Implementations of ERC-3440 MUST designate which token Id is the original NFT (defaulted to Id 0), and which token Id is a unique replica. The original print SHOULD be token Id number 0 but MAY be assigned to a different Id. The original

MOTIVATION:
Currently the link between a NFT and the digital work of art is only enforced in the token metadata stored in the shared `tokenURI` state of a NFT. While the blockchain provides an immutable record of history back to the origin of an NFT, often the origin is not a key that an artist maintains as closely as they would a hand written signature. An edition is a printed replica of an original piece of art. ERC-721 is not specifically designed to be used for works of art, such as digital art and music. ERC-721 (NFT) was originally

RATIONALE:
A major role of NFTs is to display uniqueness in digital art. Provenance is a desired feature of works of art, and this standard will help improve a NFT by providing a better way to verify uniqueness. Taking this extra step by an artist to explicitly sign tokens provides a better connection between the artists and their work on the blockchain. Artists can now retain their private key and sign messages in the future showing that the same signature is present on a unique NFT.


=== ERC-1185 ===
TITLE: Storage of DNS Records in ENS
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2018-06-26
REQUIRES: 137

SUMMARY:
This EIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information.

SPECIFICATION:
The resolver profile to support DNS on ENS follows the resolver specification as defined in [ERC-137](./eip-137.md). Traditionally, DNS is a zone-based system in that all of the records for a zone are kept together in the same file. This has the benefit of simplicity and atomicity of zone updates, but when transposed to ENS can result in significant gas costs for simple changes. As a result, the resolver works on the basis of record sets. A record set is uniquely defined by the tuple `(domain, name, resource record type)`, for example the tuple `(example.com, www.example.com, A)` defines the

MOTIVATION:
ENS is a highly desirable store for DNS information. It provides the distributed authority of DNS without conflating ownership and authoritative serving of information. With ENS, the owner of a domain has full control over their own DNS records. Also, ENS has the ability (through smart contracts) for a domain's subdomains to be irrevocably assigned to another entity.

RATIONALE:
DNS is a federated system of naming, and the higher-level entities control availability of everything beneath them (_e.g._ `.org` controls the availability of `ethereum.org`). A decentralized version of DNS would not have this constraint, and allow lookups directly for any domain with relevant records within ENS.


=== ERC-1491 ===
TITLE: Human Cost Accounting Standard (Like Gas but for humans)
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-10-12
REQUIRES: 

SUMMARY:
The following standard allows for the implementation of a standard API for HUCAP tokens within smart contracts. This standard provides basic functionality to discover, track and transfer the motivational hierarchy of human resources. While blockchain architecture has succeeded in the financialisation of integrity by way of transparency; correspondingly real world outcomes will be proportional to the degree of individualisation of capital by way of knowledge.

SPECIFICATION:
#### Main Interface ```solidity pragma solidity ^0.4.25; pragma experimental ABIEncoderV2; /** @title ERC-**** Human Capital Accounting Standard @dev See https://github.com/freeworkculture/kazini/issues/11 Note: the ERC-165 identifier for this interface is 0xf23a6e61. */ interface IERC_HUCAP { /** @notice Compute the index value of an Agents BDI in the ecosystem. @param _address Set the stance of an agent @dev For the purpose of Throws on any error rather than return a false flag to minimize user errors */ function updateIndex() internal returns (bool); /** @notice Get the active/inactive and states of an Agent in the ecosystem. @param _address Set the stance of

MOTIVATION:
The Ethereum protocol architecture has a deterministic world-view bounded to the random reality of the human domain that supplies the intentions and logic. The yellow paper formally defines the EVM as a state machine with only deterministic parameters and state transition operators. Oracle requests to another on-chain contract, and/or off-chain HTTP lookups still make for multiple deterministic transactions. A standard interface that allows the appraisal of individual capabilities concurrently with output and the overall knowledge-base will reduce market search costs and increase the autonomous insertion of mindful innovation into the blockchain ecosystem. We provide for simple smart contracts

RATIONALE:
[WIP]


=== ERC-600 ===
TITLE: Ethereum purpose allocation for Deterministic Wallets
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2017-04-13
REQUIRES: 

SUMMARY:
This EIP defines a logical hierarchy for deterministic wallets based on [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), the purpose scheme defined in [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) and [this proposed change to BIP43](https://github.com/bitcoin/bips/pull/523). This EIP is a particular application of BIP43.

SPECIFICATION:
We define the following 2 levels in BIP32 path: <pre> m / purpose' / subpurpose' / EIP' </pre> Apostrophe in the path indicates that BIP32 hardened derivation is used. Each level has a special meaning, described in the chapters below. ### Purpose Purpose is set to 43, as documented in [this proposed change to BIP43](https://github.com/bitcoin/bips/pull/523). The purpose field indicates that this path is for a non-bitcoin cryptocurrency. Hardened derivation is used at this level. ### Subpurpose Subpurpose is set to 60, the SLIP-44 code for Ethereum. Hardened derivation is used at this level. ### EIP EIP is set

MOTIVATION:
Because Ethereum is based on account balances rather than UTXO, the hierarchy defined by BIP44 is poorly suited. As a result, several competing derivation path strategies have sprung up for deterministic wallets, resulting in inter-client incompatibility. This BIP seeks to provide a path to standardise this in a fashion better suited to Ethereum's unique requirements.

RATIONALE:
The existing convention is to use the 'Ethereum' coin type, leading to paths starting with `m/44'/60'/*`. Because this still assumes a UTXO-based coin, we contend that this is a poor fit, resulting in standardisation, usability, and security compromises. As a result, we are making the above proposal to define an entirely new hierarchy for Ethereum-based chains.


=== ERC-6682 ===
TITLE: NFT Flashloans
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-12
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 3, 1, 5, 6

SUMMARY:
This standard is an extension of the existing flashloan standard ([ERC-3156](./eip-3156.md)) to support [ERC-721](./eip-721.md) NFT flashloans. It proposes a way for flashloan providers to lend NFTs to contracts, with the condition that the loan is repaid in the same transaction along with some fee.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Contract Interface ```solidity pragma solidity ^0.8.19; interface IERC6682 { /// @dev The address of the token used to pay flash loan fees. function flashFeeToken() external view returns (address); /// @dev Whether or not the NFT is available for a flash loan. /// @param token The address of the NFT contract. /// @param tokenId The ID of the NFT. function availableForFlashLoan(address token, uint256 tokenId)

MOTIVATION:
The current flashloan standard, [ERC-3156](./eip-3156.md), only supports [ERC-20](./eip-20.md) tokens. ERC-721 tokens are sufficiently different from ERC-20 tokens that they require an extension of this existing standard to support them. An NFT flash loan could be useful in any action where NFT ownership is checked. For example, claiming airdrops, claiming staking rewards, or taking an in-game action such as claiming farmed resources.

RATIONALE:
The above modifications are the simplest possible additions to the existing flashloan standard to support NFTs. We choose to extend as much of the existing flashloan standard ([ERC-3156](./eip-3156.md)) as possible instead of creating a wholly new standard because the flashloan standard is already widely adopted and few changes are required to support NFTs. In most cases, the handling of fee payments will be desired to be paid in a separate currency to the loaned NFTs because NFTs themselves cannot always be fractionalized. Consider the following example where the flashloan provider charges a 0.1 ETH fee on each NFT


=== ERC-3643 ===
TITLE: T-REX - Token for Regulated EXchanges
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2021-07-09
REQUIRES: 2, 0, ,,  , 1, 7, 3

SUMMARY:
The T-REX token is an institutional grade security token standard. This standard provides a library of interfaces for the management and compliant transfer of security tokens, using an automated onchain validator system leveraging onchain identities for eligibility checks. The standard defines several interfaces that are described hereunder: - Token - Identity Registry - Identity Registry Storage - Compliance - Trusted Issuers Registry - Claim Topics Registry

SPECIFICATION:
The proposed standard has the following requirements: - **MUST** be [ERC-20](./eip-20.md) compatible. - **MUST** be used in combination with an onchain Identity system - **MUST** be able to apply any rule of compliance that is required by the regulator or by the token issuer (about the factors of eligibility of an identity or about the rules of the token itself) - **MUST** have a standard interface to pre-check if a transfer is going to pass or fail before sending it to the blockchain - **MUST** have a recovery system in case an investor loses access to his private

MOTIVATION:
The advent of blockchain technology has brought about a new era of efficiency, accessibility, and liquidity in the world of asset transfer. This is particularly evident in the realm of cryptocurrencies, where users can transfer token ownership peer-to-peer without intermediaries. However, when it comes to tokenized securities or security tokens, the situation is more complex due to the need for compliance with securities laws. These tokens cannot be permissionless like utility tokens; they must be permissioned to track ownership and ensure that only eligible investors can hold tokens. The existing Ethereum protocol, while powerful and versatile, does not

RATIONALE:
### Transfer Restrictions Transfers of securities can fail for a variety of reasons. This is in direct contrast to utility tokens, which generally only require the sender to have a sufficient balance. These conditions can be related to the status of an investor’s wallet, the identity of the sender and receiver of the securities (i.e., whether they have been through a KYC process, whether they are accredited or an affiliate of the issuer) or for reasons unrelated to the specific transfer but instead set at the token level (i.e., the token contract enforces a maximum number of investors


=== ERC-173 ===
TITLE: Contract Ownership Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-06-07
REQUIRES: 

SUMMARY:
This specification defines standard functions for owning or controlling a contract. An implementation allows reading the current owner (`owner() returns (address)`) and transferring ownership (`transferOwnership(address newOwner)`) along with a standardized event for when ownership is changed (`OwnershipTransferred(address indexed previousOwner, address indexed newOwner)`).

SPECIFICATION:
Every ERC-173 compliant contract must implement the `ERC173` interface. Contracts should also implement `ERC165` for the ERC-173 interface. ```solidity /// @title ERC-173 Contract Ownership Standard /// Note: the ERC-165 identifier for this interface is 0x7f5828d0 interface ERC173 /* is ERC165 */ { /// @dev This emits when ownership of a contract changes. event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /// @notice Get the address of the owner /// @return The address of the owner. function owner() view external returns(address); /// @notice Set the address of the new owner of the contract /// @dev Set _newOwner to address(0) to

MOTIVATION:
Many smart contracts require that they be owned or controlled in some way. For example to withdraw funds or perform administrative actions. It is so common that the contract interface used to handle contract ownership should be standardized to allow compatibility with user interfaces and contracts that manage contracts. Here are some examples of kinds of contracts and applications that can benefit from this standard: 1. Exchanges that buy/sell/auction ethereum contracts. This is only widely possible if there is a standard for getting the owner of a contract and transferring ownership. 2. Contract wallets that hold the ownership

RATIONALE:
Key factors influencing the standard: - Keeping the number of functions in the interface to a minimum to prevent contract bloat. - Backwards compatibility with existing contracts. - Simplicity - Gas efficient Several ownership schemes were considered. The scheme chosen in this standard was chosen because of its simplicity, low gas cost and backwards compatibility with existing contracts. Here are other schemes that were considered: 1. **Associating an Ethereum Name Service (ENS) domain name with a contract.** A contract's `owner()` function could look up the owner address of a particular ENS name and use that as the owning


=== ERC-7590 ===
TITLE: ERC-20 Holder Extension for NFTs
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-01-05
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal suggests an extension to [ERC-721](./eip-721.md) to enable easy exchange of [ERC-20](./eip-20.md) tokens. By enhancing [ERC-721](./eip-721.md), it allows unique tokens to manage and trade [ERC-20](./eip-20.md) fungible tokens bundled in a single NFT. This is achieved by including methods to pull [ERC-20](./eip-20.md) tokens into the NFT contract to a specific NFT, and transferring them out by the owner of such NFT. A transfer out nonce is included to prevent front-running issues.

SPECIFICATION:
```solidity interface IERC7590 /*is IERC165, IERC721*/ { /** * @notice Used to notify listeners that the token received ERC-20 tokens. * @param erc20Contract The address of the ERC-20 smart contract * @param toTokenId The ID of the token receiving the ERC-20 tokens * @param from The address of the account from which the tokens are being transferred * @param amount The number of ERC-20 tokens received */ event ReceivedERC20( address indexed erc20Contract, uint256 indexed toTokenId, address indexed from, uint256 amount ); /** * @notice Used to notify the listeners that the ERC-20 tokens have been transferred. * @param

MOTIVATION:
In the ever-evolving landscape of blockchain technology and decentralized ecosystems, interoperability between diverse token standards has become a paramount concern. By enhancing [ERC-721](./eip-721.md) functionality, this proposal empowers non-fungible tokens (NFTs) to engage in complex transactions, facilitating the exchange of fungible tokens, unique assets, and multi-class assets within a single protocol. This ERC introduces new utilities in the following areas: - Expanded use cases - Facilitating composite transactions - Market liquidity and value creation ### Expanded Use Cases Enabling [ERC-721](./eip-721.md) tokens to handle various token types opens the door to a wide array of innovative use cases. From gaming

RATIONALE:
### Pull Mechanism We propose using a pull mechanism, where the contract transfers the token to itself, instead of receiving it via "safe transfer" for 2 reasons: 1. Customizability with Hooks. By initiating the process this way, smart contract developers have the flexibility to execute specific actions before and after transferring the tokens. 2. Lack of transfer with callback: [ERC-20](./eip-20.md) tokens lack a standardized transfer with callback method, such as the "safeTransfer" on [ERC-721](./eip-721.md), which means there is no reliable way to notify the receiver of a successful transfer, nor to know which is the destination token is.


=== ERC-5568 ===
TITLE: Well-Known Format for Required Actions
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-08-31
REQUIRES: 140

SUMMARY:
This ERC introduces a minimalistic machine-readable (binary) format to signal to wallets that an action needs to be taken by the user using a well-known function and revert reason. It provides just enough data to be extendable by future ERCs and to take in arbitrary parameters (up to 64 kB of data). Example use cases could include approving a token for an exchange, sending an HTTP request, or requesting the user to rotate their keys after a certain period of time to enforce good hygiene.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Action Detection ```solidity interface IERC5568 { function walletSignal24(bytes32 selector, bytes function_data) view returns (uint24 instruction_id, bytes instruction_data); } ``` The `instruction_id` of an instruction defined by an ERC MUST be its ERC number unless there are exceptional circumstances (be reasonable). An ERC MUST define exactly zero or one `instruction_id`. The structure of the instruction data for any `instruction_id` MUST be defined by the ERC that defines the `instruction_id`.

MOTIVATION:
Oftentimes, a smart contract needs to signal to a wallet that an action needs to be taken, such as to sign a transaction or send an HTTP request to a URL. Traditionally, this has been done by hard-coding the logic into the frontend, but this ERC allows the smart contract itself to request the action. This means that, for example, an exchange or a market can directly tell the wallet to approve the smart contract to spend the token, vastly simplifying front-end code.

RATIONALE:
This ERC was explicitly optimized for deployment gas cost and simplicity. It is expected that libraries will eventually be developed that makes this more developer-friendly. [ERC-165](./eip-165.md) is not used, since the interface is simple enough that it can be detected simply by calling the function.


=== ERC-7897 ===
TITLE: Wallet-Linked Services for Smart Accounts
TYPE: Standards Track ERC
STATUS: Withdrawn
CREATED: 2024-04-15
REQUIRES: 1, 6, 5, ,,  , 1, 1, 6, 7, ,,  , 4, 3, 3, 7, ,,  , 6, 5, 5, 1, ,,  , 7, 6, 5, 6

SUMMARY:
This proposal defines a registry for generic services linked to smart accounts, with a special focus on [ERC-4337](./eip-4337.md) wallets, where services are contracts extending a wallet's functionality, owned by the wallet itself. It leverages [ERC-1167](./eip-1167.md) minimal proxies and deterministic addressing to enable permissionless innovation while maintaining backward compatibility with existing [ERC-4337](./eip-4337.md) wallets. To reach its goal, it takes the concept introduced with [ERC-6551](./eip-6551.md) and [ERC-7656](./eip-7656.md) standards that work for NFTs, and applies it to wallets. **Note: This proposal is not needed anymore since the same functionality can be achieved using [ERC-7656](./eip-7656.md) standard.**

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Registry Interface The interface `IERC7897Registry` is defined as follows: ```solidity interface IERC7897Registry { /** * @notice Emitted when a wallet-linked service is successfully deployed. * @param deployedService The address of the deployed contract * @param serviceImplementation The address of the implementation contract * @param salt The salt used for the CREATE2 operation * @param chainId The chain ID where the contract is deployed

MOTIVATION:
[ERC-4337](./eip-4337.md) (Account Abstraction) introduces programmable smart accounts. Existing proposals to extend wallet functionalities (e.g., [ERC-6900](./eip-6900.md)) focus on internal modules. This proposal generalizes the concept of service binding, allowing any [ERC-4337](./eip-4337.md) wallet to attach external services (e.g., recovery, automation, compliance) without requiring changes to the wallet's core logic. By enabling modular, non-invasive extensions, this standard fosters an open ecosystem of wallet-linked services while ensuring backward compatibility with existing [ERC-4337](./eip-4337.md) wallets.

RATIONALE:
The technical foundation of [ERC-7897](./eip-7897.md) centers on the extension and generalization of contract types that can be associated with [ERC-4337](./eip-4337.md) wallets. Key decisions include: - Flexibility: Enables any [ERC-4337](./eip-4337.md) wallet to attach external services without modifying its core logic. - Permissionless Innovation: Developers can deploy services for any wallet, fostering an open ecosystem. - Backward Compatibility: Works with existing [ERC-4337](./eip-4337.md) wallets, including Safe, Argent, and Biconomy. - Deterministic Addressing: Uses CREATE2 + salt/chainId/wallet for predictable service deployments.


=== ERC-4799 ===
TITLE: Non-Fungible Token Ownership Designation Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-02-13
REQUIRES: 165

SUMMARY:
The following defines a standard interface for designating ownership of an NFT to someone while the NFT is held in escrow by a smart contract. The standard allows for the construction of a directed acyclic graph of NFTs, where the designated owner of every NFT in a given chain is the terminal address of that chain. This enables the introduction of additional functionality to pre-existing NFTs, without having to give up the authenticity of the original. In effect, this means that all NFTs are composable and can be rented, used as collateral, fractionalized, and more.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity import "@openzeppelin/contracts/utils/introspection/IERC165.sol"; interface IERC4799NFT is IERC165 { /// @dev This emits when ownership of any NFT changes by any mechanism. /// This event emits when NFTs are created (`from` == 0) and destroyed /// (`to` == 0). Exception: during contract creation, any number of NFTs /// may be created and assigned without emitting Transfer. At the time of /// any transfer, the approved address for that NFT (if

MOTIVATION:
Many NFTs aim to provide their holders with some utility - utility that can come in many forms. This can be the right to inhabit an apartment, access to tickets to an event, an airdrop of tokens, or one of the infinitely many other potential applications. However, in their current form, NFTs are limited by the fact that the only verifiable wallet associated with an NFT is the owner, so clients that want to distribute utility are forced to do so to an NFT's listed owner. This means that any complex ownership agreements must be encoded into the

RATIONALE:
To maximize the future compatibility of the wrapping contract, we first defined a canonical NFT interface. We created `IERC4799NFT`, an interface implicitly implemented by virtually all popular NFT contracts, including all deployed contracts that are [ERC-721](./eip-721.md) compliant. This interface represents the essence of an NFT: a mapping from a token identifier to the address of a singular owner, represented by the function `ownerOf`. The core of our proposal is the `IERC4799` interface, an interface for a standard NFT ownership designation contract (ODC). ERC4799 requires the implementation of a `designatedTokenOf` function, which maps a source NFT to exactly one


=== ERC-5187 ===
TITLE: Extend EIP-1155 with rentable usage rights
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-04-17
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This standard is an extension of [EIP-1155](./eip-1155.md). It proposes to introduce separable, rentable, and transferable usage rights (in the form of NFT-IDs), enabling the property owner (the only NFT holder) to rent out the NFT to multiple users (ID holders) at the same time for different terms, and be withdrawn by smart contract upon expiration. The property owner always retains ownership and is able to transfer the NFT to others during the lease. The proposal also supports the sublease and renewal of the rental so that users can freely transfer the usage rights among each other and extend

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity pragma solidity ^0.8.0; /// Note: the ERC-165 identifier for this interface is 0x6938e358. interface IRental /* is IERC165,IERC1155 */ { /** * @notice This emits when user rent NFT * - `id` The id of the current token * - `user` The address to rent the NFT usage rights * - `amount` The amount of usage rights * - `expire` The specified period of time to rent **/

MOTIVATION:
The well-accepted [EIP-721](./eip-721.md) and EIP-1155 standards focused on the ownership of unique assets, quite sensible in the time of NFTs being used primarily as arts and collectibles, or, you can say, as private property rights. ### First Step: "Expirable" NFTs The advent of private ownership in the real world has promoted the vigorous development of the modern economy, and we believe that the usage right will be the first detachable right widely applied in the blockchain ecosystem. As NFTs are increasingly applied in rights, finance, games, and the Metaverse, the value of NFT is no longer simply the

RATIONALE:
Implementing the proposal to create rentable NFTs has two main benefits. One is that NFTs with multiple usage rights allow NFT property owners to perform the safeRent function and rent out usage rights to multiple users at the same time. For each usage right leased and expires, the property owner can perform the takeBack function to retrieve the usage right. Another benefit is that the transfer of usage rights can be quite flexible. The user can transfer the usage rights to other users by calling the Sublet function during the lease period, and can also extend the lease


=== ERC-6372 ===
TITLE: Contract clock
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-01-25
REQUIRES: 

SUMMARY:
Many contracts rely on some clock for enforcing delays and storing historical data. While some contracts rely on block numbers, others use timestamps. There is currently no easy way to discover which time-tracking function a contract internally uses. This EIP proposes to standardize an interface for contracts to expose their internal clock and thus improve composability and interoperability.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Compliant contracts MUST implement the `clock` and `CLOCK_MODE` functions as specified below. ```solidity interface IERC6372 { function clock() external view returns (uint48); function CLOCK_MODE() external view returns (string); } ``` ### Methods #### clock This function returns the current timepoint according to the mode the contract is operating on. It MUST be a **non-decreasing** function of the chain, such as `block.timestamp` or `block.number`. ```yaml - name: clock type: function

MOTIVATION:
Many contracts check or store time-related information. For example, timelock contracts enforce a delay before an operation can be executed. Similarly, DAOs enforce a voting period during which stakeholders can approve or reject a proposal. Last but not least, voting tokens often store the history of voting power using timed snapshots. Some contracts do time tracking using timestamps while others use block numbers. In some cases, more exotic functions might be used to track time. There is currently no interface for an external observer to detect which clock a contract uses. This seriously limits interoperability and forces devs

RATIONALE:
`clock` returns `uint48` as it is largely sufficient for storing realistic values. In timestamp mode, `uint48` will be enough until the year 8921556. Even in block number mode, with 10,000 blocks per second, it would be enough until the year 2861. Using a type smaller than `uint256` allows storage packing of timepoints with other associated values, greatly reducing the cost of writing and reading from storage. Depending on the evolution of the blockchain (particularly layer twos), using a smaller type, such as `uint32` might cause issues fairly quickly. On the other hand, anything bigger than `uint48` appears wasteful.


=== ERC-4883 ===
TITLE: Composable SVG NFT
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-03-08
REQUIRES: 721

SUMMARY:
Compose an SVG (Scalable Vector Graphics) NFT by concatenating the SVG with the SVG of another NFT rendered as a string for a specific token ID.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title EIP-4883 Non-Fungible Token Standard interface IERC4883 { function renderTokenById(uint256 id) external view returns (string memory); } ``` `renderTokenById` must return the SVG body for the specified token `id` and must either be an empty string or valid SVG element(s).

MOTIVATION:
Onchain SVG NFTs allow for NFTs to be entirely onchain by returning artwork as SVG in a data URI of the `tokenUri` function. Composability allows onchain SVG NFTs to be crafted. e.g. adding glasses & hat NFTs to a profile pic NFT or a fish NFT to a fish tank NFT.

RATIONALE:
SVG elements can be string concatenated to compose an SVG. ### Ordering of concatenation SVG uses a "painters model" of rendering. **Scalable Vector Graphics (SVG) 1.1 (Second Edition)**, section: **3.3 Rendering Order** >Elements in an SVG document fragment have an implicit drawing order, with the first elements in the SVG document fragment getting "painted" first. Subsequent elements are painted on top of previously painted elements. The ordering of the SVG concatenation determines the drawing order rather than any concept of a z-index. This EIP only specifies the rendering of the rendered SVG NFT and does not require any


=== ERC-7498 ===
TITLE: NFT Redeemables
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-28
REQUIRES: 1, 6, 5, ,,  , 7, 1, 2, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 1, 2, 7, 1

SUMMARY:
This specification introduces a new interface that extends [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) to enable the discovery and use of onchain and offchain redeemables for NFTs. Onchain getters and events facilitate discovery of redeemable campaigns and their requirements. New onchain mints use an interface that gives context to the minting contract of what was redeemed. For redeeming physical products and goods (offchain redeemables) a `redemptionHash` and `signer` can tie onchain redemptions with offchain order identifiers that contain chosen product and shipping information.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The token MUST have the following interface and MUST return `true` for [ERC-165](./eip-165.md) supportsInterface for `0x1ac61e13`, the 4 byte interfaceId of the below. ```solidity interface IERC7498 { /* Events */ event CampaignUpdated(uint256 indexed campaignId, Campaign campaign, string metadataURI); event Redemption(uint256 indexed campaignId, uint256 requirementsIndex, bytes32 redemptionHash, uint256[] considerationTokenIds, uint256[] traitRedemptionTokenIds, address redeemedBy); /* Structs */ struct Campaign { CampaignParams params; CampaignRequirements[] requirements; // one

MOTIVATION:
Creators frequently use NFTs to create redeemable entitlements for digital and physical goods. However, without a standard interface, it is challenging for users and apps to discover and interact with these NFTs in a predictable and standard way. This standard aims to encompass enabling broad functionality for: - discovery: events and getters that provide information about the requirements of a redemption campaign - onchain: token mints with context of items spent - offchain: the ability to associate with ecommerce orders (through `redemptionHash`) - trait redemptions: improving the burn-to-redeem experience with [ERC-7496](./eip-7496.md) Dynamic Traits.

RATIONALE:
The "offer" and "consideration" structs from Seaport were used to create a similar language for redeemable campaigns. The "offer" is what is being offered, e.g. a new onchain token, and the "consideration" is what must be satisfied to complete the redemption. The "consideration" field has a "recipient", who the token should be transferred to. For trait updates that do not require moving of a token, `traitRedemptionTokenIds` is specified instead. The "salt" and "signature" fields are provided primarily for offchain redemptions where a provider would want to sign approval for a redemption before it is conducted onchain, to prevent


=== ERC-1077 ===
TITLE: Gas relay for contract calls
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-04
REQUIRES: 2, 0, ,,  , 1, 9, 1, ,,  , 1, 2, 7, 1, ,,  , 1, 3, 4, 4

SUMMARY:
A main barrier for the adoption of DApps is the requirement of multiple tokens for executing in chain actions. Allowing users to sign messages to show intent of execution, but allowing a third party relayer to execute them can circumvent this problem, while ETH will always be required for ethereum transactions, it's possible for smart contract to take [EIP-191] signatures and forward a payment incentive to an untrusted party with ETH for executing the transaction.

MOTIVATION:
Standardizing a common format for them, as well as a way in which the user allows the transaction to be paid in tokens, gives app developers a lot of flexibility and can become the main way in which app users interact with the Blockchain.

RATIONALE:
User pain points: * users don't want to think about ether * users don't want to think about backing up private keys or seed phrases * users want to be able to pay for transactions using what they already have on the system, be apple pay, xbox points or even a credit card * Users don’t want to sign a new transaction at every move * Users don’t want to download apps/extensions (at least on the desktop) to connect to their apps App developer pain points: * Many apps use their own token and would prefer to use


=== ERC-900 ===
TITLE: Simple Staking Interface
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-02-22
REQUIRES: 

SUMMARY:
The following standard describes a common staking interface allowing for easy to use staking systems. The interface is kept simple allowing for various use cases to be implemented. This standard describes the common functionality for staking as well as providing information on stakes.

SPECIFICATION:
```solidity interface Staking { event Staked(address indexed user, uint256 amount, uint256 total, bytes data); event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data); function stake(uint256 amount, bytes data) public; function stakeFor(address user, uint256 amount, bytes data) public; function unstake(uint256 amount, bytes data) public; function totalStakedFor(address addr) public view returns (uint256); function totalStaked() public view returns (uint256); function token() public view returns (address); function supportsHistory() public pure returns (bool); // optional function lastStakedFor(address addr) public view returns (uint256); function totalStakedForAt(address addr, uint256 blockNumber) public view returns (uint256); function totalStakedAt(uint256 blockNumber) public view returns (uint256); } ``` ### stake

MOTIVATION:
As we move to more token models, having a common staking interface which is familiar to users can be useful. The common interface can be used by a variety of applications, this common interface could be beneficial especially to things like Token curated registries which have recently gained popularity.


=== ERC-5615 ===
TITLE: ERC-1155 Supply Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-05-25
REQUIRES: 1155

SUMMARY:
This ERC standardizes an existing mechanism to fetch token supply data from [ERC-1155](./eip-1155.md) tokens. It adds a `totalSupply` function, which fetches the number of tokens with a given `id`, and an `exists` function, which checks for the existence of a given `id`.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity interface ERC1155Supply is ERC1155 { // @notice This function MUST return whether the given token id exists, previously existed, or may exist // @param id The token id of which to check the existence // @return Whether the given token id exists, previously existed, or may exist function exists(uint256 id) external view returns (bool); // @notice This function MUST return the number of tokens with a given id.

RATIONALE:
This ERC does not implement [ERC-165](./eip-165.md), as this interface is simple enough that the extra complexity is unnecessary and would cause incompatibilities with pre-existing implementations. The `totalSupply` and `exists` functions were modeled after [ERC-721](./eip-721.md) and [ERC-20](./eip-20.md). `totalSupply` does not revert if the token ID does not exist, since contracts that care about that case should use `exists` instead (which might return false even if `totalSupply` is zero). `exists` is included to differentiate between the two ways that `totalSupply` could equal zero (either no tokens with the given ID have been minted yet, or no tokens with the given


=== ERC-7564 ===
TITLE: Contract wallet management NFT
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-11-21
REQUIRES: 165

SUMMARY:
This proposal introduces a smart contract wallet-based approach for managing NFTs, focusing on utilizing the programmable features of smart contract wallets for NFT asset management. Additionally, it introduces functions such as `nftApprove`, `nftSetApprovalForOneAll`, `nftSetApprovalForAllAll`, `nftGetApproved`, `nftIsApprovedForOneAll`, `nftIsApprovedForAllAll` and `nftTransfer`, which provide enhanced control over NFT transactions. This approach seeks to enhance NFT management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. **Compliant contract must implement the [ERC-165](./eip-165) interfaces** ```solidity /// @title ERC-7564 /// @dev See https://eips.ethereum.org/EIPS/eip-7564 /// @dev Note: the ERC-165 identifier for this interface is pragma solidity ^0.8.20; interface IERC7564{ /** * @notice Used to notify listeners that owner has granted approval to the user to manage one nft. * @param _asset Address of the nft * @param _owner Address of the account that

MOTIVATION:
An externally-owned account (EOA) wallet has no state and code storage, while the smart contract wallet does. Account abstraction (AA) is a direction of the smart contract wallet, which works around abstract accounts. This ERC can also be an extension based on [ERC-4337](./eip-4337) or as a plug-in for wallets. The smart contract wallet allows the user's own account to have state and code, bringing programmability to the wallet. We think there are more directions to expand. For example, nft asset management, functional expansion of nft transactions, etc. The smart contract wallet interface of this ERC is for nft

RATIONALE:
the key technical decisions in this proposal are: **Improved Approve Mechanism** - **Current vs. Proposed**: In the existing ERC-721 system, an externally-owned account (EOA) directly interacts with nft contracts to `approve`. The new `nftApprove`, `nftSetApprovalForOneAll`, `nftSetApprovalForAllAll`, `nftGetApproved`, `nftIsApprovedForOneAll`, `nftIsApprovedForAllAll`functions in this proposed enable more precise control over nft usage within a wallet contract, a significant improvement over the traditional method. - **Enhanced Security**: This mechanism mitigates risks like nft over-approval by shifting approval control to the user's smart contract wallet. - **Programmability**: Users gain the ability to set advanced approval strategies, such as conditional or time-limited approvals, the


=== ERC-5114 ===
TITLE: Soulbound Badge
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2022-05-30
REQUIRES: 

SUMMARY:
A soulbound badge is a token that, when minted, is bound to another Non-Fungible Token (NFT), and cannot be transferred/moved after that.

SPECIFICATION:
```solidity interface IERC5114 { // fired anytime a new instance of this badge is minted // this event **MUST NOT** be fired twice for the same `badgeId` event Mint(uint256 indexed badgeId, address indexed nftAddress, uint256 indexed nftTokenId); // returns the NFT that this badge is bound to. // this function **MUST** throw if the badge hasn't been minted yet // this function **MUST** always return the same result every time it is called after it has been minted // this function **MUST** return the same value as found in the original `Mint` event for the badge function ownerOf(uint256

RATIONALE:
### Immutability By requiring that badges can never move, we both guarantee non-separability and non-mergeability among collections of soulbound badges that are bound to a single NFT while simultaneously allowing users to aggressively cache results. ### Content Addressable URIs Required Soulbound badges are meant to be permanent badges/indicators attached to a persona. This means that not only can the user not transfer ownership, but the minter also cannot withdraw/transfer/change ownership as well. This includes mutating or removing any remote content as a means of censoring or manipulating specific users. ### No Specification for `badgeUri` Data Format The format


=== ERC-7634 ===
TITLE: Limited Transfer Count NFT
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-22
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard extends [ERC-721](./eip-721.md) to introduce a mechanism that allows minters to customize the transferability of NFTs through a parameter called `TransferCount`. `TransferCount` sets a limit on how many times an NFT can be transferred. The standard specifies an interface that includes functions for setting and retrieving transfer limits, tracking transfer counts, and defining pre- and post-transfer states. The standard enables finer control over NFT ownership and transfer rights, ensuring that NFTs can be programmed to have specific, enforceable transfer restrictions.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. - `setTransferLimit`: a function establishes the transfer limit for a tokenId. - `transferLimitOf`: a function retrieves the transfer limit for a tokenId. - `transferCountOf`: a function returns the current transfer count for a tokenId. Implementers of this standard **MUST** have all of the following functions: ```solidity pragma solidity ^0.8.4; /// @title IERC7634 Interface for Limited Transferable NFT /// @dev Interface for ERC7634 Limited Transferable NFT extension for ERC721 ///

MOTIVATION:
Once NFTs are sold, they detach from their minters (creators) and can be perpetually transferred thereafter. Yet, many circumstances demand precise control over NFT issuance. We outline their advantages across three dimensions. Firstly, by imposing limitations on the frequency of NFT sales or trades, the worth of rare NFTs can be safeguarded. For example, in auctions, limiting the round of bids for a coveted item can uphold its premium price (especially in the Dutch Auction). Similarly, in the intellectual property sector, patents could be bounded by a finite number of transfers prior to becoming freely accessible (entering CC0).

RATIONALE:
### Does tracking the internal transfer count matter? Yes and no. It is optional and quite depends on the actual requirements. The reference implementation given below is a recommended one if you opt for tracking. The `_incrementTransferCount` function and related retrieval functions (`transferLimitOf` and `transferCountOf`) are designed to keep track of the number of transfers an NFT has undergone. This internal tracking mechanism is crucial for enforcing the minter's transfer limits, ensuring that no further transfers can occur once the limit is reached. ### If opting for tracking, is that all we may want to track? It is


=== ERC-2680 ===
TITLE: Ethereum 2 wallet layout
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-05-29
REQUIRES: 

SUMMARY:
Ethereum wallets have no standards for their layout in persistent storage, making different wallet implementations incompatible. This defines a standard for the placement of Ethereum walletstores and keystores, making it possible for different software to work with the same wallets and keys.

SPECIFICATION:
There are four elements for a wallet that need to be addressed. These are defined below. ### Base location The base location is required to be well-known, either pre-defined or defined by the storage system's connection parameters. For filesystems the pre-defined base location for different operating systems is as follows: - Windows: `%APPDATA%\ethereum2\wallets` - MacOSX: `${HOME}/Library/Application Support/ethereum2/wallets` - Linux: `${HOME}/.config/ethereum2/wallets` For other hierarchical stores, for example Amazon S3, the base location MUST be the lower-case hex string representing the [SHA-256](../assets/eip-2680/sha256-384-512.pdf) hash of the string "Ethereum 2 wallet:" appended with the identifier for the hierarchical store. For example, if

MOTIVATION:
A standard layout for wallets and accounts allows interoperability between validators. This benefits users, as they can move from one validator software to another (and back) without requiring movement of files. This is important because any movement of files containing keys involves danger of either deleting them or duplicating them, both of which could cause loss of access to funds.

RATIONALE:
A standard for walletstores, similar to that for keystores, provides a higher level of compatibility between wallets and allows for simpler wallet and key interchange between them.


=== ERC-7766 ===
TITLE: Signature Aggregation for ERC-4337
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-09-01
REQUIRES: 4, 3, 3, 7, ,,  , 7, 5, 6, 2

SUMMARY:
[ERC-4337](./eip-4337) defined a way to achieve Account Abstraction on Ethereum using an alternative `UserOperation` mempool. However, one big limitation remains: each transaction must carry its own `signature` or other form of validation input in order to be included. We propose an extension to the ERC-4337 that introduces a new entity, aggregator, that is called during validation, to validate multiple user operations at once. This addition will enable `UserOperations` to support sharing validation inputs, saving gas and guaranteeing atomicity of the bundle.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Aggregator - a new ERC-4337 `UserOperation` entity contract * **Aggregator** - a helper contract trusted by accounts to validate an aggregated signature. Bundlers/Clients whitelist the supported aggregators. ### Using Signature Aggregator A signature aggregator exposes the following interface: ```solidity interface IAggregator { function validateUserOpSignature(PackedUserOperation calldata userOp) external view returns (bytes memory sigForUserOp); function aggregateSignatures(PackedUserOperation[] calldata userOps) external view returns (bytes memory aggregatesSignature); function

MOTIVATION:
Using validation schemes that allow signature aggregation enables significant optimisations and savings on gas for execution and transaction data cost. This is especially relevant in the context of rollups that publish data on the Ethereum mainnet.

RATIONALE:
### Account returning the "alternative signature" When using an `aggregator` contract, the accounts delegate their ability to authenticate `UserOperations`. The entire contents of the In order to allow the validation function of the account to perform other checks, the `validateUserOpSignature` function generates a byte array that will replace the `UserOperation` signature when executed on-chain.


=== ERC-3668 ===
TITLE: CCIP Read—Secure offchain data retrieval
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-07-19
REQUIRES: 

SUMMARY:
Contracts wishing to support lookup of data from external sources may, instead of returning the data directly, revert using `OffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData)`. Clients supporting this specification then make an RPC call to a URL from `urls`, supplying `callData`, and getting back an opaque byte string `response`. Finally, clients call the function specified by `callbackFunction` on the contract, providing `response` and `extraData`. The contract can then decode and verify the returned data using an implementation-specific method. This mechanism allows for offchain lookups of data in a way that is transparent to clients,

SPECIFICATION:
### Overview Answering a query via CCIP read takes place in three steps: 1. Querying the contract. 2. Querying the gateway using the URL provided in (1). 3. Querying or sending a transaction to the contract using the data from (1) and (2). In step 1, a standard blockchain call operation is made to the contract. The contract reverts with an error that specifies the data to complete the call can be found offchain, and provides the url to a service that can provide the answer, along with additional contextual information required for the call in step (3).

MOTIVATION:
Minimising storage and transaction costs on Ethereum has driven contract authors to adopt a variety of techniques for moving data offchain, including hashing, recursive hashing (eg Merkle Trees/Tries) and L2 solutions. While each solution has unique constraints and parameters, they all share in common the fact that enough information is stored onchain to validate the externally stored data when required. Thus far, applications have tended to devise bespoke solutions rather than trying to define a universal standard. This is practical - although inefficient - when a single offchain data storage solution suffices, but rapidly becomes impractical in a

RATIONALE:
### Use of `revert` to convey call information For offchain data lookup to function as desired, clients must either have some way to know that a function depends on this specification for functionality - such as a specifier in the ABI for the function - or else there must be a way for the contract to signal to the client that data needs to be fetched from elsewhere. While specifying the call type in the ABI is a possible solution, this makes retrofitting existing interfaces to support offchain data awkward, and either results in contracts with the same


=== ERC-2157 ===
TITLE: dType Storage Extension - Decentralized Type System for EVM
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-06-28
REQUIRES: 1900

SUMMARY:
The storage extension will enable easy navigation and retrieval of type data that is intended to be of public use. This is possible through standardizing the ABI of the dType storage contracts, with the effect of having a deterministic path to a type instance record. This standardization enables a more effective on-chain and off-chain use of data and opens up possibilities for decentralized applications, enabling developers to build on top of public global data.

SPECIFICATION:
### TypeRootContract ERC-1900 defines a `contractAddress` field in the type metadata. For the limited purpose of ERC-1900, this field contains the value of the Ethereum type library in which the type definition exists. For the purpose of this ERC, the `contractAddress` will contain the Etherereum address of a `TypeRootContract`. ```solidity contract TypeRootContract { address public libraryAddress; address public storageAddress; constructor(address _library, address _storage) public { libraryAddress = _library; storageAddress = _storage; } } ``` - `libraryAddress` - Ethereum address of the type definition library, from ERC-1900 - `storageAddress` - Ethereum address of the type data storage contract ###

MOTIVATION:
Currently, Ethereum does not have standardization of data addressability. This might not be needed for data that is meant to be quasi-private, however, it is needed for data that is meant for public consumption. ERC-1900 has started standardizing data types for increasing interoperability between projects, but this is not enough if we want to build a global ecosystem. Deterministic data addressability will enable anyone to build upon the same public data sets, off-chain or on-chain. It is true that with ERC-1900, blockchain data analysis and type-specific data retrieval will be possible off-chain, but this implies relying on centralized

RATIONALE:
We are now thinking about a building block as a smart contract with an encapsulated object that contains state changing functions that are only understood from within. This is more akin to Object-Oriented Programming and poses interoperability and scalability issues. Not necessarily for an individual project, but for a global Ethereum OS. This is why we are proposing to separate data from business logic and data structure definitions. When you have public aggregated data, categorized on each type, anyone can build tools on top of it. This is a radical change from the closed or dispersed data patterns


=== ERC-2266 ===
TITLE: Atomic Swap-based American Call Option Contract Standard
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2019-08-17
REQUIRES: 

SUMMARY:
This standard provides functionality to make Atomic Swap-based American Call Option payment. The Atomic Swap protocol based on Hashed Time-Locked Contract (HTLC) [^1] has optionality [^2], and such optionality can be utilised to construct American Call Options without trusted third party. This standard defines the common way of implementing this protocol. In particular, this EIP defines technical terms, provides interfaces, and gives reference implementations of this protocol.

SPECIFICATION:
The Atomic Swap-based American Call Option smart contract should follow the syntax and semantics of Ethereum smart contracts. ### Definitions + `initiator`: the party who publishes the advertisement of the swap. + `participant`: the party who agrees on the advertisement and participates in the swap with `initiator`. + `asset`: the amount of token(s) to be exchanged. + `premium`: the amount of token(s) that `initiator` pays to `participant` as the premium. + `redeem`: the action to claim the token from the other party. + `refund`: the action to claim the token from the party herself/himself, because of timelock expiration.

MOTIVATION:
Atomic Swap allows users to atomically exchange their tokens without trusted third parties while the HTLC is commonly used for the implementation. However, the HTLC-based Atomic Swap has optionality. More specifically, the swap initiator can choose to proceed or abort the swap for several hours, which gives him time for speculating according to the exchange rate. A discussion[^2] shows that the HTLC-based Atomic Swap is equivalent to an American Call Option in finance. On the other hand,thanks to such optionality, the HTLC-based Atomic Swap can be utilised to construct American Call Options without trusted third party. A paper[^3]

RATIONALE:
+ To achieve the atomicity, HTLC is used. + The participant should decide whether to participate after the initiator locks the token and sets up the timelock. + The initiator should decide whether to proceed the swap (redeem the tokens from the participant and reveal the preimage of the hash lock), after the participant locks the tokens and sets up the time locks. + Premium is redeemable for the participant only if the participant participates in the swap and redeems the initiator's token before premium's timelock expires. + Premium is refundable for the initiator only if the initiator


=== ERC-1900 ===
TITLE: dType - Decentralized Type System for EVM
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-03-28
REQUIRES: 

SUMMARY:
We are proposing a decentralized Type System for Ethereum, to introduce data definition (and therefore ABI) consistency. This ERC focuses on defining an on-chain Type Registry (named `dType`) and a common interface for creating types, based on `struct`s.

SPECIFICATION:
The Type Registry can have a governance protocol for its CRUD operations. However, this, and other permission guards are not covered in this proposal. ### Type Definition and Metadata The dType registry should support the registration of Solidity's elementary and complex types. In addition, it should also support contract events definitions. In this EIP, the focus will be on describing the minimal on-chain type definition and metadata needed for registering Solidity user-defined types. #### Type Definition: TypeLibrary A type definition consists of a type library containing: - the nominal `struct` used to define the type - additional functions:

MOTIVATION:
In order to build a network of interoperable protocols on Ethereum, we need data standardization, to ensure a smooth flow of on-chain information. Off-chain, the Type Registry will allow a better analysis of blockchain data (e.g. for blockchain explorers) and creation of smart contract development tools for easily using existing types in a new smart contract. However, this is only the first phase. As defined in this document and in the future proposals that will be based on this one, we are proposing something more: a decentralized Type System with Data Storage - [ERC-2158](https://github.com/ethereum/EIPs/pull/2158). In addition, developers can

RATIONALE:
The Type Registry must store the minimum amount of information for rebuilding the type ABI definition. This allows us to: * support on-chain interoperability * decode blockchain side effects off-chain (useful for block explorers) * allow off-chain tools to cache and search through the collection (e.g. editor plugin for writing typed smart contracts) There is one advantage that has become clear with the emergence of global operating systems, like Ethereum: we can have a global type system through which the system’s parts can interoperate. Projects should agree on standardizing types and a type registry, continuously working on improving


=== ERC-7774 ===
TITLE: Cache invalidation in ERC-5219 mode Web3 URL
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-09-20
REQUIRES: 5, 2, 1, 9, ,,  , 6, 9, 4, 4

SUMMARY:
In the context of the [ERC-6860](./eip-6860.md) `web3://` standard, this ERC extends the [ERC-6944](./eip-6944.md) resolve mode. It introduces mechanisms to address limitations that prevent the use of standard [RFC 9111](https://www.rfc-editor.org/rfc/rfc9111) HTTP caching.

SPECIFICATION:
This standard introduces the `evm-events` cache directive for the `Cache-Control` header of request responses, as an extension directive as defined in section 5.2.3 of [RFC 9111](https://www.rfc-editor.org/rfc/rfc9111). When an [ERC-6944](./eip-6944.md) resolve mode website wants to use event-based caching for a request, it MUST: - Include the `evm-events` directive in the `Cache-Control` header of the response. - Include the `ETag` and/or `Cache-Control` headers in the response, as per traditional [RFC 9111](https://www.rfc-editor.org/rfc/rfc9111) HTTP caching. - Emit a cache invalidation event (as defined below) for the path in the smart contract when the output of the response changes and it deems cache

MOTIVATION:
Calls to Ethereum RPC providers are costly—both CPU-wise for local nodes and monetarily for paid external RPC providers. Furthermore, external RPC providers are rate-limited, which can quickly cause disruptions when loading `web3://` URLs. Therefore, it makes sense to implement caching mechanisms to reduce RPC calls when possible. Since `web3://` aims to be as close to HTTP as possible, leveraging standard [RFC 9111](https://www.rfc-editor.org/rfc/rfc9111) HTTP caching is the natural choice. In the [ERC-6944](./eip-6944.md) resolve mode, smart contracts can already return standard HTTP caching headers like `Cache-Control` and `ETag`. However, due to the [ERC-6944](./eip-6944.md) resolve mode not forwarding request HTTP headers

RATIONALE:
To stay as close as possible to standard HTTP, we reuse the HTTP caching mechanism headers. The use of the `evm-events` directive is necessary to avoid a situation where a website uses traditional [RFC 9111](https://www.rfc-editor.org/rfc/rfc9111) HTTP caching headers, but the contract does not implement this ERC by failing to emit the events. In such cases, `web3://` clients implementing this ERC would serve stale content for that website indefinitely.


=== ERC-7160 ===
TITLE: ERC-721 Multi-Metadata Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-06-09
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This EIP proposes an extension to the [ERC-721](./eip-721.md) standard to support multiple metadata URIs per token. It introduces a new interface, `IERC721MultiMetadata`, which provides methods for accessing the metadata URIs associated with a token, including a pinned URI index and a list of all metadata URIs. The extension is designed to be backward compatible with existing `ERC721Metadata` implementations.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. **The multi-metadata extension is OPTIONAL for [ERC-721](./eip-721.md) contracts and it is RECOMMENDED to be used in conjunction with the [ERC-4906](./eip-4906.md) standard if implemented**. ```solidity /// @title EIP-721 Multi-Metdata Extension /// @dev The ERC-165 identifier for this interface is 0x06e1bc5b. interface IERC7160 { /// @dev This event emits when a token uri is pinned and is /// useful for indexing purposes. event TokenUriPinned(uint256 indexed tokenId, uint256 indexed index); /// @dev

MOTIVATION:
The current [ERC-721](./eip-721.md) standard allows for a single metadata URI per token with the `ERC721Metadata` implementation. However, there are use cases where multiple metadata URIs are desirable. Some example use cases are listed below: - A token represents a collection of (cycling) assets with individual metadata - An on-chain history of revisions to token metadata - Appending metadata with different aspect ratios so that it can be displayed properly on all screens - Dynamic and evolving metadata - Collaborative and multi-artist tokens This extension enables such use cases by introducing the concept of multi-metadata support. The primary reason

RATIONALE:
Similar terminology to [ERC-721](./eip-721.md) was used in order to keep fetching metadata familiar. The concept of pinning and unpinning metadata is introduced as it is clear that NFT owners might want to choose which piece of metadata to display. At first, we considered leaving the pinning and unpinning actions up to each developer, but realized that a standard interface for pinning and unpinning allows for dApps to easily implement universal support for multi-metadata tokens. We first considered whether the `tokenURIs` function should return just a string array, but added the extra information so that you could get all


=== ERC-7641 ===
TITLE: Intrinsic RevShare Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-28
REQUIRES: 20

SUMMARY:
This proposal outlines an extension of the prevailing [ERC-20](./eip-20.md) token standard, introducing a seamlessly integrated revenue-sharing mechanism. It incorporates a suite of interfaces designed to foster fair distribution of revenue among token holders while preserving the essential attributes of [ERC-20](./eip-20.md). Central to this design is the establishment of a communal revenue pool, aggregating revenues from diverse sources. The token, in essence, embodies shares, affording holders the ability to burn their tokens and redeem a proportionate share from the revenue pool. This innovative burning mechanism guarantees that, when the revenue pool is non-empty, the token's value remains at least

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. **Every compliant contract must implement the `IERC7641`, and [ERC-20](./eip-20.md) interfaces.** The Intrinsic RevShare Token standard includes the following interfaces: `IERC7641`: - Defines a `claimableRevenue` view function to calculate the amount of ETH claimable by a token holder at a certain snapshot. - Defines a `claim` function for token holder to claim ETH based on the token balance at certain snapshot. - Defines a `snapshot`

MOTIVATION:
### Revenue Sharing for Token Holders This proposal standardized an Intrinsic RevShare (revenue-sharing) model, allowing users to claim rewards periodically to ensure the efficiency of liquidity. This standard can inherently offer a clear path to long-term benefits for holders with revenue sharing, achieving a more sustainable token model by rewarding holders. With the inheritance of [ERC-20](./eip-20.md) functionalities, token holders enjoy flexibility in trading tokens on secondary markets, and an optional burning mechanism empowers them to actively contribute to a deflationary economic model while obtaining a proportional share of the revenue pool. This approach also encourages active participation in

RATIONALE:
### Revenue Sharing Mechanism We implement a revenue sharing mechanism wherein any token holder can claim a proportional share from the revenue pool. To ensure regular and transparent revenue distribution, we have incorporated the snapshot method, capturing both the token balance and the associated claimable revenue token balance. Periodic invocation of the snapshot method, corresponding to distinct revenue-sharing processes, is required. During each snapshot, token holders are empowered to claim a proportionate share from the revenue pool, creating a systematic and equitable distribution mechanism for participants. ### `snapshot` interface We specify a `snapshot` interface to snapshot the token


=== ERC-7529 ===
TITLE: Contract Discovery and eTLD+1 Association
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-30
REQUIRES: 1191

SUMMARY:
The introduction of DNS over HTTPS (DoH) in [RFC 8484](https://www.rfc-editor.org/rfc/rfc8484) has enabled tamper-resistant client-side queries of DNS records directly from a web application. This proposal describes a simple standard leveraging DoH to fetch TXT records (from traditional DNS service providers) which are used for discovering and verifying the association of a smart contract with a common DNS domain. This standard can be used as a straightforward technique to mitigate smart contract authorship spoofing and enhance the discoverability of smart contracts through standard web search mechanisms.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. #### Definition: eTLD+1 The term TLD stands for *top-level domain* and is always the part of a domain name which follows the final dot in a URL (e.g. `.com` or `.net`). If only domains directly under TLDs where registrable by a single organization, then it would be guaranteed that `myexample.com`, `abc.myexample.com`, and `def.myexample.com` all belonged to the same organization. However, this is not the

MOTIVATION:
As mainstream businesses begin to adopt public blockchain and digital asset technologies more rapidly, there is a growing need for a discovery/search mechanism (compatible with conventional web technologies) of smart contracts associated with a known business domain as well as reasonable assurance that the smart contract does indeed belong to the business owner of the DNS domain. The relatively recent introduction and widespread support of DoH means it is possible to make direct, tamper-resistant queries of DNS records straight from a web application context and thus leverage a simple TXT record as a pointer to an on-chain smart

RATIONALE:
In this specification, the TXT record `HOST` naming scheme is designed to mimic the DKIM naming convention. Additionally, this naming scheme makes it simple to programmatically ascertain if any smart contracts are associated with the domain on a given blockchain network. Prepending with `ERC-7529` will prevent naming collisions with other TXT records. The value of `<chain_id>` is simply the decimal representation of the chain id associated with the target blockchain network (i.e. `1` for Ethereum mainnet or `11155111` for Sepolia) where the smart contracts are deployed. So, a typical `HOST` might be: `ERC-7529.1._domainContracts`, `ERC-7529.11155111._domaincontracts`, etc. A user client


=== ERC-7092 ===
TITLE: Financial Bonds
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-05-28
REQUIRES: 165

SUMMARY:
This proposal introduces fixed-income financial bonds with key characteristics defined to facilitate bond issuance in the primary market and enable buying or selling bonds in the secondary market. The standard also provides cross-chain functionalities for bonds operations and management accross multiple blockchains.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. **Every contract compliant with this ERC MUST implement the following Token Interface as well as the [ERC-165](./eip-165.md) interface:** ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; /** * @title ERC-7092 Financial Bonds Standard */ interface IERC7092 /** is ERC165 */ { // events /** * @notice MUST be emitted when bond tokens are transferred, issued or redeemed, except during contract creation * @param _from the

MOTIVATION:
Fixed-income instruments are a widely utilized asset class for corporations and other entities raising funds. However, transitioning to tokenized bonds is challenging due to existing standards like [ERC-3475](./eip-3475.md), which introduces unfamiliar concepts and leads to unnecessary gas consumption. Additionally, the lack of named variables like coupon, maturity date, and principal, makes it difficult to implement ERC-3475 since developers need to remember which metadata is assigned to each parameter.

RATIONALE:
The design of this ERC aims to simplify the migration to tokenized bonds by maintaining consistency with traditional bond standards. This approach allows fixed-income instruments to be represented as on-chain tokens, manageable through wallets, and utilized by applications like decentralized exchanges, while avoiding the complexities and inefficiencies associated with other standards. This ERC facilitates the creation of new bond tokens with characteristics akin to traditional bonds, enhancing accessibility, liquidity, and cost-efficiency in bond trading and management. The use of traditional finance terminology, like `issueVolume` and `principalOf`, is aimed at maintaining consistency with traditional bond language, which eases the


=== ERC-7417 ===
TITLE: Token Converter
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-07-27
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 2, 2, 3

SUMMARY:
There are multiple token standards on Ethereum chain currently. This EIP introduces a concept of cross-standard interoperability by creating a service that allows [ERC-20](./eip-20.md) tokens to be upgraded to [ERC-223](./eip-223.md) tokens anytime. [ERC-223](./eip-223.md) tokens can be converted back to [ERC-20](./eip-20.md) version without any restrictions to avoid any problems with backwards compatibility and allow different standards to co-exist and become interoperable and interchangeable. In order to perform the conversion, a user must deposit tokens of one standard to the Converter contract and it will automatically send tokens of another standard back.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The Token Converter system comprises two main components: - Converter contract. - Wrapper contracts. Each original token can have exactly one wrapper of each standard. Converter contract can deploy new [ERC-223](./eip-223.md) wrapper contracts for any [ERC-20](./eip-20.md) token that does not have a [ERC-223](./eip-223.md) wrapper currently. There MUST be exactly one [ERC-223](./eip-223.md) wrapper for each [ERC-20](./eip-20.md) token. Converter contract MUST accept deposits of [ERC-20](./eip-20.md) tokens

MOTIVATION:
This proposal introduces a concept of a token standard upgrading procedure driven by a specialized smart-contract which can convert tokens of one standard to another at any time. Currently some tokens are available on different chains in different standards, for example most exchanges support [ERC-20](./eip-20.md) USDT, TRX USDT, BEP-20 USDT and all this tokens are in fact the same USDT token. This proposal is intended to introduce a concept where there can be a [ERC-20](./eip-20.md) USDT and [ERC-223](./eip-223.md) USDT available on Ethereum mainnet at the same time and these would be freely interchangeable. The address of the deployed

RATIONALE:
### Support of [ERC-223](./eip-223.md) original tokens Two methods of implementing a Token Converter service were considered: (1) a converter that can only create [ERC-223](./eip-223.md) versions of the existing [ERC-20](./eip-20.md) tokens, and (2) a converter that can create both versions ([ERC-20](./eip-20.md) and [ERC-223](./eip-223.md)) of any original token. The first approach would encourage developers to always deploy an original token as [ERC-20](./eip-20.md) and then create it's [ERC-223](./eip-223.md) version in the converter. If it would happen that some developers may consider [ERC-223](./eip-223.md) as their original standard then they would be left with the problem of creating their custom [ERC-20](./eip-20.md) version of


=== ERC-3475 ===
TITLE: Abstract Storage Bonds
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2021-04-05
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
- This EIP allows the creation of tokenized obligations with abstract on-chain metadata storage. Issuing bonds with multiple redemption data cannot be achieved with existing token standards. - This EIP enables each bond class ID to represent a new configurable token type and corresponding to each class, corresponding bond nonces to represent an issuing condition or any other form of data in uint256. Every single nonce of a bond class can have its metadata, supply, and other redemption conditions. - Bonds created by this EIP can also be batched for issuance/redemption conditions for efficiency on gas costs and

SPECIFICATION:
**Definition** Bank: an entity that issues, redeems, or burns bonds after getting the necessary amount of liquidity. Generally, a single entity with admin access to the pool. **Functions** ```solidity pragma solidity ^0.8.0; /** * transferFrom * @param _from argument is the address of the bond holder whose balance is about to decrease. * @param _to argument is the address of the bond recipient whose balance is about to increase. * @param _transactions is the `Transaction[] calldata` (of type ['classId', 'nonceId', '_amountBonds']) structure defined in the rationale section below. * @dev transferFrom MUST have the `isApprovedFor(_from, _to, _transactions[i].classId)` approval

MOTIVATION:
Current LP (Liquidity Provider) tokens are simple [EIP-20](./eip-20.md) tokens with no complex data structure. To allow more complex reward and redemption logic to be stored on-chain, we need a new token standard that: - Supports multiple token IDs - Can store on-chain metadata - Doesn't require a fixed storage pattern - Is gas-efficient. Also Some benefits: - This EIP allows the creation of any obligation with the same interface. - It will enable any 3rd party wallet applications or exchanges to read these tokens' balance and redemption conditions. - These bonds can also be batched as tradeable instruments.

RATIONALE:
### Metadata structure Instead of storing the details about the class and their issuances to the user (ie nonce) externally, we store the details in the respective structures. Classes represent the different bond types, and nonces represent the various period of issuances. Nonces under the same class share the same metadata. Meanwhile, nonces are non-fungible. Each nonce can store a different set of metadata. Thus, upon transfer of a bond, all the metadata will be transferred to the new owner of the bond. ```solidity struct Values{ string stringValue; uint uintValue; address addressValue; bool boolValue; bytes bytesValue; } ```


=== ERC-7683 ===
TITLE: Cross Chain Intents
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-11
REQUIRES: 

SUMMARY:
The following standard allows for the implementation of a standard API for cross-chain value-transfer systems. This standard provides generic order structs, as well as a standard set of settlement smart contract interfaces.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Glossary of Terms - **Destination Chain**: the chain where the intent is executed and the user receives funds. Note: intents can involve multiple destination chains. - **Filler**: a participant who fulfils a user intent on the destination chain(s) and receives payment as a reward. - **Leg**: a portion of the user intent that can be executed independently from others. All legs must be executed for an intent to

MOTIVATION:
Intent-based systems have become the preeminent solution for end-user cross-chain interaction by abstracting away the complexity and time constraints of traditional bridges. One of the key difficulties for cross-chain intents systems is accessing sufficient liquidity and a network of active fillers across chains. This challenge may be exacerbated as the number of distinct chains increases over time. The end result of this is a poor experience for users including higher costs, longer wait times and higher failure rates than necessary. By implementing a standard, cross-chain intents systems can interoperate and share infrastructure such as order dissemination services and

RATIONALE:
### Generic OrderData A key consideration is to ensure that a broad range of cross-chain intent designs can work within the same standard. To enable this, the specification is designed around a cross-chain intents _flow_, with two variations: gasless and onchain. #### Gasless cross-chain intents flow Origin Chain: 1. The user signs an off-chain message defining the parameters of their order 2. The order is disseminated to fillers 3. The filler calls resolve to unpack the order's requirements 4. The filler opens the order on the origin chain Destination Chain(s): - The filler fills each leg of the


=== ERC-5727 ===
TITLE: Semi-Fungible Soulbound Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-09-28
REQUIRES: 1, 6, 5, ,,  , 7, 1, 2, ,,  , 7, 2, 1, ,,  , 3, 5, 2, 5, ,,  , 4, 9, 0, 6, ,,  , 5, 1, 9, 2, ,,  , 5, 4, 8, 4

SUMMARY:
An interface for soulbound tokens (SBT), which are non-transferable tokens representing a person's identity, credentials, affiliations, and reputation. Our interface can handle a combination of fungible and non-fungible tokens in an organized way. It provides a set of core methods that can be used to manage the lifecycle of soulbound tokens, as well as a rich set of extensions that enables DAO governance, delegation, token expiration, and account recovery. This interface aims to provide a flexible and extensible framework for the development of soulbound token systems.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. A token is identified by its `tokenId`, which is a 256-bit unsigned integer. A token can also have a value denoting its denomination. A slot is identified by its `slotId`, which is a 256-bit unsigned integer. Slots are used to group fungible and non-fungible tokens together, thus make tokens semi-fungible. A token can only belong to one slot at a time. ### Core The core methods are used to

MOTIVATION:
The current Web3 ecosystem is heavily focused on financialized, transferable tokens. However, there's a growing need for non-transferable tokens to represent unique personal attributes and rights. Existing attempts within the Ethereum community to create such tokens lack the necessary flexibility and extensibility. Our interface addresses this gap, offering a versatile and comprehensive solution for SBTs. Our interface can be used to represent non-transferable ownerships, and provides features for common use cases including but not limited to: - Lifecycle Management: Robust tools for minting, revocation, and managing the subscription and expiration of SBTs. - DAO Governance and Delegation: Empower

RATIONALE:
### Token storage model We adopt semi-fungible token storage models designed to support both fungible and non-fungible tokens, inspired by the semi-fungible token standard. We found that such a model is better suited to the representation of SBT than the model used in [ERC-1155](./eip-1155.md). Firstly, each slot can be used to represent different categories of SBTs. For instance, a DAO can have membership SBTs, role badges, reputations, etc. in one SBT collection. Secondly, unlike [ERC-1155](./eip-1155.md), in which each unit of fungible tokens is exactly the same, our interface can help differentiate between similar tokens. This is justified by


=== ERC-1154 ===
TITLE: Oracle Interface
TYPE: Standards Track ERC
STATUS: Withdrawn
CREATED: 2018-06-13
REQUIRES: 

SUMMARY:
In order for ethereum smart contracts to interact with off-chain systems, oracles must be used. These oracles report values which are normally off-chain, allowing smart contracts to react to the state of off-chain systems. A distinction and a choice is made between push and pull based oracle systems. Furthermore, a standard interface for oracles is described here, allowing different oracle implementations to be interchangeable.

SPECIFICATION:
<dl> <dt>Oracle</dt> <dd>An entity which reports data to the blockchain.</dd> <dt>Oracle consumer</dt> <dd>A smart contract which receives data from an oracle.</dd> <dt>ID</dt> <dd>A way of indexing the data which an oracle reports. May be derived from or tied to a question for which the data provides the answer.</dd> <dt>Result</dt> <dd>Data associated with an id which is reported by an oracle. This data oftentimes will be the answer to a question tied to the id. Other equivalent terms that have been used include: answer, data, outcome.</dd> <dt>Report</dt> <dd>A pair (ID, result) which an oracle sends to an oracle consumer.</dd>

MOTIVATION:
The Ethereum ecosystem currently has many different oracle implementations available, but they do not provide a unified interface. Smart contract systems would be locked into a single set of oracle implementations, or they would require developers to write adapters/ports specific to the oracle system chosen in a given project. Beyond naming differences, there is also the issue of whether or not an oracle report-resolving transaction _pushes_ state changes by calling affected contracts, or changes the oracle state allowing dependent contracts to _pull_ the updated value from the oracle. These differing system semantics could introduce inefficiencies when adapting between

RATIONALE:
The specs are currently very similar to what is implemented by ChainLink (which can use any arbitrarily-named callback) and Oraclize (which uses `__callback`). With this spec, the oracle _pushes_ state to the consumer, which must react accordingly to the updated state. An alternate _pull_-based interface can be prescribed, as follows: ### Alternate Pull-based Interface Here are alternate specs loosely based on Gnosis prediction market contracts v1. Reality Check also exposes a similar endpoint (`getFinalAnswer`). ```solidity interface Oracle { function resultFor(bytes32 id) external view returns (bytes result); } ``` `resultFor` MUST revert if the result for an `id` is


=== ERC-2333 ===
TITLE: BLS12-381 Key Generation
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-09-30
REQUIRES: 

SUMMARY:
This standard is a method for deriving a tree-hierarchy of BLS12-381 keys based on an entropy seed. Starting with the aforementioned seed, a tree of keys is built out using only the parent node's private key and the index of the desired child. This allows for a practically limitless number of keys to be derived for many different purposes while only requiring knowledge of a single ancestor key in the tree. This allows for keys, or families thereof, to be provisioned for different purposes by further standards. In addition to the above, this method of deriving keys provides

SPECIFICATION:
### Version Due to the evolving BLS signatures CFRG draft (currently v4), the `KeyGen` function was updated, meaning that `hkdf_mod_r` no longer reflected what appeared in the BLS standard. This EIP was updated on the 17th of September 2020 to reflect this new method for deriving keys, **if you are implementing this EIP, please make sure your version is up to date.** ### Specification Keys are defined in terms of a tree structure where a key is determined by the tree's seed and a tree path. This is very useful as one can start with a single source

MOTIVATION:
### Deficiencies of the existing mechanism The curve BLS12-381 used for BLS signatures within Ethereum 2.0 (alongside many other projects) mandates a new key derivation scheme. The most commonly used scheme for key derivation within Ethereum 1.x is [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) (also known as HD derivation) which deems keys greater than the curve order invalid. Based on the order of the private key subgroup of BLS12-381 and the size of the entropy utilised, more than 54% of keys generated by BIP32 would be invalid. (secp256k1 keys derived by BIP32 are invalid with probability less than 1 in 2<sup>-127</sup>.) ### Establishing

RATIONALE:
### Lamport signatures Lamport signatures are used as the backup mechanism because of their relative simplicity for a post-quantum signature scheme. Lamport signatures are very easy both to explain and implement as the sole cryptographic dependency is a secure hash function. This is important as it minimises the complexity of implementing this standard as well as the compute time for deriving a key. Lamport signatures have very large key sizes which make them impractical for many use cases, but this is not deemed to be an issue in this case as this scheme is only meant to be


=== ERC-601 ===
TITLE: Ethereum hierarchy for deterministic wallets
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2017-04-13
REQUIRES: 

SUMMARY:
This EIP defines a logical hierarchy for deterministic wallets based on [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), the purpose scheme defined in [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) and eip-draft-ethereum-purpose. This EIP is a particular application of eip-draft-ethereum-purpose.

SPECIFICATION:
We define the following 4 levels in BIP32 path: <pre> m / purpose' / subpurpose' / EIP' / wallet' </pre> Apostrophe in the path indicates that BIP32 hardened derivation is used. Each level has a special meaning, described in the chapters below. ### Purpose Purpose is a constant set to 43, indicating the key derivation is for a non-bitcoin cryptocurrency. Hardened derivation is used at this level. ### Subpurpose Subpurpose is set to 60, the SLIP-44 code for Ethereum. Hardened derivation is used at this level. ### EIP EIP is set to the EIP number specifying the remainder

MOTIVATION:
At present, different Ethereum clients and wallets use different derivation paths; a summary of them can be found [here](https://github.com/ethereum/EIPs/issues/84#issuecomment-292324521). Some of these paths violate BIP44, the standard defining derivation paths starting with `m/44'/`. This creates confusion and incompatibility between wallet implementations, in some cases making funds from one wallet inaccessible on another, and in others requiring prompting users manually for a derivation path, which hinders usability. Further, BIP44 was designed with UTXO-based blockchains in mind, and is a poor fit for Ethereum, which uses an accounts abstraction instead. As an alternative, we propose a deterministic wallet hierarchy better

RATIONALE:
The existing convention is to use the 'Ethereum' coin type, leading to paths starting with `m/44'/60'/*`. Because this still assumes a UTXO-based coin, we contend that this is a poor fit, resulting in standardisation, usability, and security compromises. As a result, we are making the above proposal to define an entirely new hierarchy for Ethereum-based chains.


=== ERC-6366 ===
TITLE: Permission Token
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-01-19
REQUIRES: 6617

SUMMARY:
This EIP offers an alternative to Access Control Lists (ACLs) for granting authorization and enhancing security. A `uint256` is used to store permission of given address in a ecosystem. Each permission is represented by a single bit in a `uint256` as described in [ERC-6617](./eip-6617.md). Bitwise operators and bitmasks are used to determine the access right which is much more efficient and flexible than `string` or `keccak256` comparison.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. _Note_ The following specifications use syntax from Solidity `0.8.7` (or above) ### Core Interface Compliant contracts MUST implement `IEIP6366Core`. It is RECOMMENDED to define each permission as a power of `2` so that we can check for the relationship between sets of permissions using [ERC-6617](./eip-6617.md). ```solidity interface IEIP6366Core { /** * MUST trigger when `_permission` are transferred, including `zero` permission transfers. * @param _from

MOTIVATION:
Special roles like `Owner`, `Operator`, `Manager`, `Validator` are common for many smart contracts because permissioned addresses are used to administer and manage them. It is difficult to audit and maintain these system since these permissions are not managed in a single smart contract. Since permissions and roles are reflected by the permission token balance of the relevant account in the given ecosystem, cross-interactivity between many ecosystems will be made simpler.

RATIONALE:
Needs discussion.


=== ERC-7679 ===
TITLE: UserOperation Builder
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-05
REQUIRES: 4337

SUMMARY:
Different [ERC-4337](./eip-4337.md) smart account implementations encode their signature, nonce, and calldata differently. This makes it difficult for DApps, wallets, and smart account toolings to integrate with smart accounts without integrating with account-specific SDKs, which introduces vendor lock-in and hurts smart account adoption. We propose a standard way for smart account implementations to put their account-specific encoding logic on-chain. It can be achieved by implementing methods that accept the raw signature, nonce, or calldata (along with the context) as an input, and output them properly formatted, so the smart account can consume them while validating and executing the User

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### UserOp builder To conform to this standard, a smart account implementation MUST provide a “UserOp builder” contract that implements the `IUserOperationBuilder` interface, as defined below: ```solidity struct Execution { address target; uint256 value; bytes callData; } interface IUserOperationBuilder { /** * @dev Returns the ERC-4337 EntryPoint that the account implementation * supports. */ function entryPoint() external view returns (address); /** * @dev Returns the nonce to use for

MOTIVATION:
At the moment, to build a [ERC-4337](./eip-4337.md) UserOperation (UserOp for short) for a smart account requires detailed knowledge of how the smart account implementation works, since each implementation is free to encode its nonce, calldata, and signature differently. As a simple example, one account might use an execution function called `executeFoo`, whereas another account might use an execution function called `executeBar`. This will result in the `calldata` being different between the two accounts, even if they are executing the same call. Therefore, someone who wants to send a UserOp for a given smart account needs to: * Figure

RATIONALE:
### Context The `context` is an array of bytes that encodes whatever data the UserOp builder needs in order to correctly determine the nonce, calldata, and signature. Presumably, the `context` is constructed by the account owner, with the help of a wallet software. Here we outline one possible use of `context`: delegation. Say the account owner wants to delegate a transaction to be executed by the building party. The account owner could encode a signature of the public key of the building party inside the `context`. Let’s call this signature from the account owner the `authorization`. Then, when


=== ERC-4393 ===
TITLE: Micropayments for NFTs and Multi Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-10-24
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This standard outlines a smart contract interface for tipping to non-fungible and multi tokens. Holders of the tokens are able to withdraw the tips as [EIP-20](./eip-20.md) rewards. For the purpose of this EIP, a micropayment is termed as a financial transaction that involves usually a small sum of money called "tips" that are sent to specific [EIP-721](./eip-721.md) NFTs and [EIP-1155](./eip-1155.md) multi tokens, as rewards to their holders. A holder (also referred to as controller) is used as a more generic term for owner, as NFTs may represent non-digital assets such as services.

SPECIFICATION:
This standard proposal outlines a generalised way to allow tipping via implementation of an `ITipToken` interface. The interface is intentionally kept to a minimum in order to allow for maximum use cases. Smart contracts implementing this EIP standard MUST implement all of the functions in this EIP interface. MUST also emit the events specified in the interface so that a complete state of the tip token contract can be derived from the events emitted alone. Smart contracts implementing this EIP standard MUST implement the [EIP-165](./eip-165.md) supportsInterface function and MUST return the constant value true if 0xE47A7022 is passed

MOTIVATION:
A cheap way to send tips to any type of NFT or multi token. This can be achieved by gas optimising the tip token contract and sending the tips in batches using the `tipBatch` function from the interface. To make it easy to implement into dapps a tipping service to reward the NFT and multi token holders. Allows for fairer distribution of revenue back to NFT holders from the user community. To make the interface as minimal as possible in order to allow adoption into many different use cases. Some use cases include: - In game purchases and

RATIONALE:
### Simplicity ITipToken interface uses a minimal number of functions, in order to keep its use as general purpose as possible, whilst there being enough to guide implementation that fulfils its purpose for micropayments to NFT holders. ### Use of NFTs Each NFT is a unique non-fungible token digital asset stored on the blockchain that are uniquely identified by its address and token id. It's truth burnt using cryptographic hashing on a secure blockchain means that it serves as an anchor for linking with a unique digital asset, service or other contractual agreement. Such use cases may include


=== ERC-6823 ===
TITLE: Token Mapping Slot Retrieval Extension
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-29
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
The aim of this proposal is to enhance the precision of off-chain simulations for transactions that involve contracts complying with the [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), or [ERC-1155](./eip-1155.md) standards. To achieve this, a method is proposed for obtaining the reserved storage slot of the mapping responsible to track ownership of compliant tokens. The proposed extension offers a standardized entry point that allows for identifying the reserved storage slot of a mapping in a compatible manner. This not only facilitates capturing state changes more precisely but also enables external tools and services to do so without requiring expertise in the particular implementation

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The proposal suggests an extension to the ERC-20/ERC-721/ERC-1155 standards that allows retrieving the reserved storage slot for the mapping type in any compliant smart-contract implementation in a deterministic manner. This method eliminates the reliance on events and enhances the precision of the data access from storage. The proposed extension therefore enables accurate off-chain simulations. The outcome is greater transparency and predictability at no extra cost

MOTIVATION:
To understand the rationale behind this proposal, it's important to remember how values and mapping are stored in the storage layout. This procedure is language-agnostic; it can be applied to multiple programming languages beyond Solidity, including Vyper. The storage layout is a way to persistently store data in Ethereum smart contracts. In the EVM, storage is organized as a key-value store, where each key is a 32-byte location, and each value is a 32-byte word. When you define a state variable in a contract, it is assigned to a storage location. The location is determined by the variable's

RATIONALE:
The idea behind the implementation was to find an elegant and concise way that avoided any breaking changes with the current standard. Moreover, since gas consumption is crucial, it was inconceivable to find an implementation that would cost gas to the final user. In this case, the addition of a function increases the deployment cost of the contract in a minimal way, but its use is totally free for the external actors. The implementation is minimalist in order to be as flexible as possible while being directly compatible with the main programming languages used today to develop smart-contracts


=== ERC-6220 ===
TITLE: Composable NFTs utilizing Equippable Parts
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-12-20
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 5, 7, 7, 3, ,,  , 6, 0, 5, 9

SUMMARY:
The Composable NFTs utilizing equippable parts standard extends [ERC-721](./eip-721.md) by allowing the NFTs to selectively add parts to themselves via equipping. Tokens can be composed by cherry picking the list of parts from a Catalog for each NFT instance, and are able to equip other NFTs into slots, which are also defined within the Catalog. Catalogs contain parts from which NFTs can be composed. This proposal introduces two types of parts; slot type of parts and fixed type of parts. The slot type of parts allow for other NFT collections to be equipped into them, while fixed parts

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Equippable tokens The interface of the core smart contract of the equippable tokens. ```solidity /// @title EIP-6220 Composable NFTs utilizing Equippable Parts /// @dev See https://eips.ethereum.org/EIPS/eip-6220 /// @dev Note: the ERC-165 identifier for this interface is 0x28bc9ae4. pragma solidity ^0.8.16; import "./IERC5773.sol"; interface IERC6220 is IERC5773 /*, ERC165 */ { /** * @notice Used to store the core structure of the `Equippable` component. * @return assetId The ID

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to equip other tokens and be composed from a set of available parts allows for greater utility, usability and forward compatibility. In the four years since [ERC-721](./eip-721.md) was published, the need for additional functionality has resulted in countless extensions. This EIP improves upon ERC-721 in the following areas: - [Composing](#composing) - [Token progression](#token-progression) - [Merit tracking](#merit-tracking) - [Provable Digital Scarcity](#provable-digital-scarcity) ### Composing NFTs

RATIONALE:
Designing the proposal, we considered the following questions: 1. **Why are we using a Catalog in stead of supporting direct NFT equipping?**\ If NFTs could be directly equipped into other NFTs without any oversight, the resulting composite would be unpredictable. Catalog allows for parts to be pre-verified in order to result in a composite that composes as expected. Another benefit of Catalog is the ability of defining reusable fixed parts. 2. **Why do we propose two types of parts?**\ Some parts, that are the same for all of the tokens, don't make sense to be represented by individual


=== ERC-7721 ===
TITLE: Lockable Extension for ERC-1155
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-05-25
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
The Lockable Extension for [ERC-1155](./eip-1155.md) introduces a robust locking mechanism for specific Non-Fungible Tokens (NFTs) within the ERC-1155 token standard, allowing for various uses while preventing sale or transfer. The token's `owner` can `lock` it, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval for `tokenId`, enabling ability to lock asset while address holds the token approval. Token can also be locked by `approved`, assigning locker to itself. Upon token transfer, these rights get purged. Inspired by the need for enhanced security and

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview [ERC-1155](./eip-1155.md) compliant contracts MAY implement this EIP to provide standard methods of locking and unlocking the token at its current owner address. Token owner MAY `lock` the token and assign `locker` to some `address` using `lock(uint256 tokenId, address account, address _locker, uint256 amount)` function, this MUST set `locker` to `_locker`. Token owner or approved MAY `lock` the token using `lock(uint256 tokenId, address

MOTIVATION:
[ERC-1155](./eip-1155.md) has sparked an unprecedented surge in demand for NFTs. However, despite this tremendous success, the NFT economy suffers from secondary liquidity where it remains illiquid in owner’s wallet. There are projects which aim to address the liquidity challenge, but they entail the below mentioned inconveniences and risks for owners as they necessitate transferring the participating NFTs to the projects' contracts. - Loss of utility: The utility value of NFTs diminishes when they are transferred to an escrow account, no longer remaining under the direct custody of the owners. - Lack of composability: The market could benefit from

RATIONALE:
This proposal exposes `transferAndLock(address from, address to, uint256 tokenId, uint256 amount, bool setApprove)` which can be used to transfer token and lock at the receiver's address. This additionally accepts input `bool setApprove` which on `true` assign `approval` to `locker`, hence enabling `locker` to revoke the token (revocation conditions can be defined in contracts and `approval` provided to contract). This provides conditional ownership to receiver, without the privilege to `transfer` token.


=== ERC-2544 ===
TITLE: ENS Wildcard Resolution
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-02-28
REQUIRES: 137

SUMMARY:
The Ethereum Name Service Specification (EIP-137) establishes a two-step name resolution process. First, an ENS client performs the namehash algorithm on the name to determine the associated "node", and supplies that node to the ENS Registry contract to determine the resolver. Then, if a resolver has been set on the Registry, the client supplies that same node to the resolver contract, which will return the associated address or other record. As currently specified, this process terminates if a resolver is not set on the ENS Registry for a given node. This EIP changes the name resolution process by

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Let: - `namehash` be the algorithm defined in EIP 137. - `dnsencode` be the process for encoding DNS names specified in section 3.1 of RFC1035, with the exception that there is no limit on the total length of the encoded name. The empty string is encoded identically to the name '.', as a single 0-octet. - `parent` be a function that removes the first label from a name (eg,

MOTIVATION:
Many applications such as wallet providers, exchanges, and dapps have expressed a desire to issue ENS names for their users via custom subdomains on a shared parent domain. However, the cost of doing so is currently prohibitive for large user bases, as a distinct record must be set on the ENS Registry for each subdomain. Furthermore, users cannot immediately utilize these subdomains upon account creation, as the transaction to assign a resolver for the node of the subdomain must first be submitted and mined on-chain. This adds unnecessary friction when onboarding new users, who coincidentally would often benefit

RATIONALE:
The proposed implementation supports wildcard resolution in a manner that minimizes the impact to existing systems. It also reuses existing algorithms and procedures to the greatest possible extent, thereby easing the burden placed on authors and maintainers of various ENS clients. It also recognizes an existing consensus concerning the desirability of wildcard resolution for ENS, enabling more widespread adoption of the original specification by solving for a key scalability obstacle. While introducing an optional `resolve` function for resolvers, taking the unhashed name and calldata for a resolution function increases implementation complexity, it provides a means for resolvers to


=== ERC-181 ===
TITLE: ENS support for reverse resolution of Ethereum addresses
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2016-12-01
REQUIRES: 


=== ERC-7513 ===
TITLE: Smart NFT - A Component for Intent-Centric
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-06
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
Smart NFT is the fusion of Smart Contract and NFT. An NFT with the logic of a Smart Contract can be executed, enabling on-chain interactions. Transitioning from an NFT to a Smart NFT is akin to going from a regular landline telephone to a smartphone, opening up broader and more intelligent possibilities for NFTs.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview The following section will define the interface specifications for three main objects: Smart-NFT, Smart-Manager, Intent-Proxy, and establish the interaction relationships between three primary roles (developer, verifier, user) and these objects. ![](../assets/eip-7513/workflow.png) ### Smart-NFT Interface Before sending a registration request to Smart-Manager, developers should implement the following two core interfaces in Smart-NFT. - `execute`: This function **MUST** contain only one parameter of the

MOTIVATION:
Ethereum introduces smart contracts revolutionized the blockchain and paved the way for the flourishing ecosystem of decentralized applications (dApps). Also, the concept of non-fungible tokens (NFTs) was introduced through [ERC-721](./eip-721.md), offering a paradigm for ownership verification. However, smart contracts still present significant barriers for most users, and NFTs have largely been limited to repetitive explorations within Art, Gaming, and Real-World Assets realm. The widespread adoption of smart contracts and the functional applications of NFTs still face substantial challenges. Here are some facts that emerges from this contradiction: 1. The strong desire for both intelligence and usability has led

RATIONALE:
### Why using ERC-1155 In the technical implementation aspect, we chose to use [ERC-1155](./eip-1155.md) as the main contract for NFTs due to the consideration of increasing the reusability of Smart-NFTs. The reason for this choice is that both [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) are based on the concept of "token IDs" that point to NFTs. The key difference is that [ERC-1155](./eip-1155.md) introduces the concept of "shares," meaning that having at least one share gives you the right to use the functionality of that Smart-NFT. This concept can be likened to owning multiple smartphones of the same model, where owning several


=== ERC-7722 ===
TITLE: Opaque Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-06-09
REQUIRES: 

SUMMARY:
This ERC proposes a specification for an opaque token that enhances privacy by concealing balance information. Privacy is achieved by representing balances as off-chain data encapsulated in hashes, referred to as "baskets". These baskets can be reorganized, transferred, and managed through token functions on-chain.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The concept revolves around representing token balances on-chain as hashed values, called baskets, which obscure the actual balance information. These baskets combine a random salt, a unique token ID, and the token's value, making it impossible to derive the token's value directly from the blockchain. The token interface allows for creating, transferring, issuing, and reorganizing (splitting and joining) these baskets. To prevent unauthorized changes

MOTIVATION:
Smart contract accounts serve as well-defined identities that can have reusable claims and attestations attached to them, making them highly useful for various applications. However, this strength also introduces a significant privacy challenge when these identities are used to hold tokens. Specifically, in the case of [ERC-20](./eip-20.html) compatible tokens, where balances are stored directly on-chain in plain text, the transparency of these balances can compromise the privacy of the account holder. This creates a dilemma: while the reuse of claims and attestations tied to a smart contract account can be advantageous, it also increases the risk of exposing

RATIONALE:
### Breaking the ERC-20 Compatibility The transparency inherent in ERC-20 tokens presents a significant issue for reusable blockchain identities. To address this, we prioritize privacy over ERC-20 compatibility, ensuring the confidentiality of token balances. ### Reorg Oracles The trusted oracles and the minimum number of required signatures can be configured to achieve the desired level of decentralization. The basket holder proposes the input and output baskets for the reorg, while the oracles are responsible for verifying that the sums of the values on both sides (input and output) are equal. This system allows for mutual control, ensuring that


=== ERC-7531 ===
TITLE: Staked ERC-721 Ownership Recognition
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-10-01
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The ownership of [ERC-721](./eip-721.md) tokens when staked in a pool presents challenges, particularly when it involves older, non-lockable NFTs like, for example, Crypto Punks or Bored Ape Yacht Club (BAYC) tokens. This proposal introduces an interface to address these challenges by allowing staked NFTs to be recognized by their original owners, even after they've been staked.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The interface is defined as follows: ```solidity interface IERC7531 { /** * @notice MUST be emitted when the token's technical owner (the contract holding the token) is different * from its actual owner (the entity with rights over the token). * @dev This scenario is common in staking, where a staking contract is the technical owner. The event MUST * be emitted in the

MOTIVATION:
Recent solutions involve retaining NFT ownership while "locking" an NFT letting the owner keeping its ownership. However, this requires the NFT contract to implement lockable functionality. Early NFTs were not originally designed as lockable and so they must be staked transferring the ownership to the staking contract. This prevents the original owner from accessing valuable privileges and benefits associated with their NFTs. For example: - A BAYC NFT holder would lose access to the BAYC Yacht Club and member events when staked. - A CryptoPunks holder may miss out on special airdrops or displays only available to verified

RATIONALE:
### Addressing Non-Lockable NFT Challenges: Non-lockable NFTs present a unique challenge in decentralized ecosystems, especially in scenarios involving staking or delegating usage rights. The standard [ERC-721](./eip-721.md) `ownerOf` function returns the current owner of the NFT, which, in the case of staking, would be the staking pool contract. This transfer of ownership to the staking pool, even if temporary, can disrupt the utility or privileges tied to the NFT, such as participation in governance, access to exclusive content, or utility within a specific ecosystem. ### The `rightsHolderOf` Method: The `rightsHolderOf` method provides a solution to this challenge. By maintaining


=== ERC-5095 ===
TITLE: Principal Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-05-01
REQUIRES: 2, 0, ,,  , 2, 6, 1, 2

SUMMARY:
Principal tokens represent ownership of an underlying [EIP-20](./eip-20.md) token at a future timestamp. This specification is an extension on the [EIP-20](./eip-20.md) token that provides basic functionality for depositing and withdrawing tokens and reading balances and the [EIP-2612](./eip-2612.md) specification that provides [EIP-712](./eip-712.md) signature based approvals.

SPECIFICATION:
All Principal Tokens (PTs) MUST implement [EIP-20](./eip-20.md) to represent ownership of future underlying redemption. If a PT is to be non-transferrable, it MAY revert on calls to `transfer` or `transferFrom`. The [EIP-20](./eip-20.md) operations `balanceOf`, `transfer`, `totalSupply`, etc. operate on the Principal Token balance. All Principal Tokens MUST implement [EIP-20](./eip-20.md)'s optional metadata extensions. The `name` and `symbol` functions SHOULD reflect the underlying token's `name` and `symbol` in some way, as well as the origination protocol, and in the case of yield tokenization protocols, the origination money-market. All Principal Tokens MAY implement [EIP-2612](./eip-2612.md) to improve the UX of approving PTs

MOTIVATION:
Principal tokens lack standardization which has led to a difficult to navigate development space and diverse implementation schemes. The primary examples include yield tokenization platforms which strip future yield leaving a principal token behind, as well as fixed-rate money-markets which utilize principal tokens as a medium to lend/borrow. This inconsistency in implementation makes integration difficult at the application layer as well as wallet layer which are key catalysts for the space's growth. Developers are currently expected to implement individual adapters for each principal token, as well as adapters for their pool contracts, and many times adapters for their

RATIONALE:
The Principal Token interface is designed to be optimized for integrators with a core minimal interface alongside optional interfaces to enable backwards compatibility. Details such as accounting and management of underlying are intentionally not specified, as Principal Tokens are expected to be treated as black boxes on-chain and inspected off-chain before use. [EIP-20](./eip-20.md) is enforced as implementation details such as token approval and balance calculation directly carry over. This standardization makes Principal Tokens immediately compatible with all [EIP-20](./eip-20.md) use cases in addition to EIP-5095. All principal tokens are redeemable upon maturity, with the only variance being whether further


=== ERC-2771 ===
TITLE: Secure Protocol for Native Meta Transactions
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-07-01
REQUIRES: 

SUMMARY:
This EIP defines a contract-level protocol for `Recipient` contracts to accept meta-transactions through trusted `Forwarder` contracts. No protocol changes are made. `Recipient` contracts are sent the effective `msg.sender` (referred to as `_msgSender()`) and `msg.data` (referred to as `_msgData()`) by appending additional calldata.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Definitions **Transaction Signer**: Signs & sends transactions to a Gas Relay **Gas Relay**: Receives signed requests off-chain from Transaction Signers and pays gas to turn it into a valid transaction that goes through a Trusted Forwarder **Trusted Forwarder**: A contract trusted by the `Recipient` to correctly verify signatures and nonces before forwarding the request from Transaction Signers **Recipient**: A contract that accepts meta-transactions through a Trusted Forwarder ### Example

MOTIVATION:
There is a growing interest in making it possible for Ethereum contracts to accept calls from externally owned accounts that do not have ETH to pay for gas. Solutions that allow for third parties to pay for gas costs are called meta transactions. For the purposes of this EIP, meta transactions are transactions that have been authorized by a **Transaction Signer** and relayed by an untrusted third party that pays for the gas (the **Gas Relay**).

RATIONALE:
* Make it easy for contract developers to add support for meta transactions by standardizing the simplest viable contract interface. * Without support for meta transactions in the recipient contract, an externally owned account can not use meta transactions to interact with the recipient contract. * Without a standard contract interface, there is no standard way for a client to discover whether a recipient supports meta transactions. * Without a standard contract interface, there is no standard way to send a meta transaction to a recipient. * Without the ability to leverage a trusted forwarder every recipient contract


=== ERC-7528 ===
TITLE: ETH (Native Asset) Address Convention
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-10-03
REQUIRES: 2, 0, ,,  , 5, 5, ,,  , 4, 6, 2, 6

SUMMARY:
The following standard proposes a convention for using the address `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` in all contexts where an address is used to represent ETH in the same capacity as an [ERC-20](./eip-20.md) token. This would apply to both events where an address field would denote ETH or an [ERC-20](./eip-20.md) token, as well as discriminators such as the `asset` field of an [ERC-4626](./eip-4626.md) vault. This standard generalizes to other EVM chains where the native asset is not ETH.

SPECIFICATION:
This standard applies for all components of smart contract systems in which an address is used to identify an [ERC-20](./eip-20.md) token, and where native ETH is used in certain instances in place of an [ERC-20](./eip-20.md) token. The usage of the term Token below means ETH or an [ERC-20](./eip-20.md) in this context. Any fields or events where an [ERC-20](./eip-20.md) address is used, yet the underlying Token is ETH, the address field MUST return `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` Any fields or events where the Token is a non-enshrined wrapped ERC-20 version of ETH (i.e WETH9) MUST use that Token's address and MUST NOT

MOTIVATION:
ETH, being a fungible unit of value, often behaves similarly to [ERC-20](./eip-20.md) tokens. Protocols tend to implement a standard interface for ERC-20 tokens, and benefit from having the ETH implementation to closely mirror the [ERC-20](./eip-20.md) implementations. In many cases, protocols opt to use Wrapped ETH (e.g. WETH9 deployed at address 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 on Etherum Mainnet) for [ERC-20](./eip-20.md) compliance. In other cases, protocols will use native ETH due to gas considerations, or the requirement of using native ETH such as in the case of a Liquid Staking Token (LST). In addition, protocols might create separate events for handling ETH native

RATIONALE:
### Considered alternative addresses Many existing implementations of the same use case as this standard use addresses such as 0x0, 0x1, and 0xe for gas efficiency of having leading zero bytes. Ultimately, all of these addresses collide with potential precompile addresses and are less distinctive as identifiers for ETH. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` has the most current usage, is distinctive, and would not collide with any precompiles. These benefits outweigh the potential gas benefits of other alternatives.


=== ERC-1363 ===
TITLE: Payable Token
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-08-30
REQUIRES: 2, 0, ,,  , 1, 6, 5

SUMMARY:
Standard functions a token contract and contracts working with tokens can implement to make a token Payable. `transferAndCall` and `transferFromAndCall` will call an `onTransferReceived` on a `ERC1363Receiver` contract. `approveAndCall` will call an `onApprovalReceived` on a `ERC1363Spender` contract.

SPECIFICATION:
Implementing contracts **MUST** implement the [ERC-1363](./eip-1363.md) interface as well as the [ERC-20](./eip-20.md) and [ERC-165](./eip-165.md) interfaces. ```solidity pragma solidity ^0.8.0; interface ERC1363 /* is ERC20, ERC165 */ { /* * Note: the ERC-165 identifier for this interface is 0xb0202a11. * 0xb0202a11 === * bytes4(keccak256('transferAndCall(address,uint256)')) ^ * bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^ * bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^ * bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^ * bytes4(keccak256('approveAndCall(address,uint256)')) ^ * bytes4(keccak256('approveAndCall(address,uint256,bytes)')) */ /** * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver * @param to address The address which you want to transfer to * @param value uint256 The amount of tokens to be transferred

MOTIVATION:
There is no way to execute code after a [ERC-20](./eip-20.md) transfer or approval (i.e. making a payment), so to make an action it is required to send another transaction and pay GAS twice. This proposal wants to make token payments easier and working without the use of any other listener. It allows to make a callback after a transfer or approval in a single transaction. There are many proposed uses of Ethereum smart contracts that can accept [ERC-20](./eip-20.md) payments. Examples could be * to create a token payable crowdsale * selling services for tokens * paying invoices *

RATIONALE:
The choice to use `transferAndCall`, `transferFromAndCall` and `approveAndCall` derives from the [ERC-20](./eip-20.md) naming. They want to highlight that they have the same behaviours of `transfer`, `transferFrom` and `approve` with the addition of a callback on receiver or spender.


=== ERC-6224 ===
TITLE: Contracts Dependencies Registry
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-12-27
REQUIRES: 1, 9, 6, 7, ,,  , 5, 7, 5, 0

SUMMARY:
This EIP introduces an on-chain registry system that a decentralized protocol may use to manage its smart contracts. The proposed system consists of two components: `ContractsRegistry` and `Dependant`. The `ContractsRegistry` contract stores references to every smart contract used within a protocol, optionally making them upgradeable by deploying self-managed proxies on top, and acts as a hub the `Dependant` contracts query to fetch their required dependencies from.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview The system consists of two smart contracts: - `ContractsRegistry` that is a singleton registry to manage and upgrade a protocol's smart contracts. - `Dependant` that is a mix-in which enables a dependency injection mechanism. The following diagram depicts the relationship between the registry and its dependants: ![](../assets/eip-6224/diagram.svg) ### ContractsRegistry The `ContractsRegistry` is the main contract of the proposed system. It MUST store

MOTIVATION:
In the ever-growing Ethereum ecosystem, projects tend to become more and more complex. Modern protocols require portability and agility to satisfy customer needs by continuously delivering new features and staying on pace with the industry. However, the requirement is hard to achieve due to the immutable nature of blockchains and smart contracts. Moreover, the increased complexity and continuous delivery bring bugs and entangle the dependencies between the contracts, making systems less supportable. Applications that have a clear architectural facade; which are designed with forward compatibility in mind; which dependencies are transparent and clean are easier to develop and

RATIONALE:
There are a few design decisions that have to be explicitly specified: ### ContractsRegistry Rationale #### Contracts Identifier The `string` contracts identifier is chosen over the `uint256` and `bytes32` to maintain code readability and reduce the human error chances when interacting with the `ContractsRegistry`. Being the topmost smart contract of a protocol, it MAY be typical for the users to interact with it via block explorers or DAOs. Clarity was prioritized over gas usage. Due to the `string` identifier, the event parameters are not indexed. The `string indexed` parameter will become the `keccak256` hash of the contract name


=== ERC-897 ===
TITLE: DelegateProxy
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-02-21
REQUIRES: 

SUMMARY:
Using proxies that delegate their own logic to another contract is becoming an increasingly popular technique for both smart contract upgradeability and creating cheap clone contracts. We don't believe there is value in standardizing any particular implementation of a DelegateProxy, given its simplicity, but we believe there is a lot of value in agreeing on an interface all proxies use that allows for a standard way to operate with proxies.


=== ERC-5851 ===
TITLE: On-Chain Verifiable Credentials
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-10-18
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 1, 1, 6, 7, ,,  , 1, 9, 6, 7, ,,  , 3, 4, 7, 5

SUMMARY:
This proposal introduces a method of certifying that a particular address meets a claim, and a method of verifying those certifications using on-chain metadata. Claims are assertions or statements made about a subject having certain properties that may be met conditions (for example: `age >= 18`), and are certified by issuers using a Soundbound Token (SBT).

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions - Zero-Knowledge Proof (ZKP): a cryptographic device that can convince a verifier that an assertion is correct without revealing all of the inputs to the assertion. - Soulbound Token (SBT): A non-fungible and non-transferrable token that is used for defining the identity of the users. - SBT Certificate: An SBT that represents the ownership of ID signatures corresponding to the claims defined in

MOTIVATION:
On-chain issuance of verifiable attestations are essential for use-case like: - Avoiding Sybil attacks with one person one vote - Participation in certain events with credentials - Compliance to government financial regulations etc. We are proposing a standard claims structure for Decentralized Identity (DID) issuers and verifier entities to create smart contracts in order to provide on-chain commitment of the off-chain verification process, and once the given address is associated with the given attestation of the identity verification off-chain, the issuers can then onboard other verifiers (i.e. governance, financial institution, non-profit organization, web3 related cooperation) to define the

RATIONALE:
TBD


=== ERC-7739 ===
TITLE: Readable Typed Signatures for Smart Accounts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-05-28
REQUIRES: 1, 9, 1, ,,  , 7, 1, 2, ,,  , 1, 2, 7, 1, ,,  , 5, 2, 6, 7

SUMMARY:
This proposal defines a standard to prevent signature replays across multiple smart accounts when they are owned by a single Externally Owned Account (EOA). This is achieved through a defensive rehashing scheme for [ERC-1271](./eip-1271.md) verification using specific nested [EIP-712](./eip-712.md) typed structures, which preserves the readability of the signed contents during wallet client signature requests.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview The following dependencies are REQUIRED: - [EIP-712](./eip-712.md) Typed structured data hashing and signing. Provides the relevant typed data hashing logic internally, which is required to construct the final hashes. - [ERC-1271](./eip-1271.md) Standard Signature Validation Method for Contracts. Provides the `isValidSignature(bytes32 hash, bytes calldata signature)` function. - [ERC-5267](./eip-5267.md) Retrieval of EIP-712 domain. Provides the `eip712Domain()` function which is required to compute the final

MOTIVATION:
Smart accounts can verify signatures with via [ERC-1271](./eip-1271.md) using the `isValidSignature` function. A straightforward implementation as shown below, is vulnerable to signature replay attacks. ```solidity /// @dev This implementation is NOT safe. function isValidSignature( bytes32 hash, bytes calldata signature ) external override view returns (bytes4) { uint8 v = uint8(signature[64]); (bytes32 r, bytes32 s) = abi.decode(signature, (bytes32, bytes32)); // Reject malleable signatures. require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0); address signer = ecrecover(hash, v, r, s); // Reject failed recovery. require(signer != address(0)); // `owner` is a storage variable containing the smart account's owner. if (signer == owner) { return 0x1626ba7e; }

RATIONALE:
### `TypedDataSign` structure The `typedDataSignTypehash` must be constructed on-the-fly on-chain. This is to enforce that the signed contents will be visible in the signature request, by requiring that `contents` be a user defined type. The fields of `eip712Domain` are flattened into the `TypedDataSign` structure instead of being included as a field of type `EIP712Domain` in order to to avoid a conflict with the domain type of the verifying contract in case it's different. The `bytes1 fields` bitmap and `uint256[] extensions` array in [ERC-5267](./eip-5267.md) have been omitted. Differentiating between an absent field versus a zero field (e.g. `bytes32(0)`) offers


=== ERC-6604 ===
TITLE: Abstract Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-03
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
Abstract tokens provide a standard interface to: * Mint tokens off-chain as messages * Reify tokens on-chain via smart contract * Dereify tokens back into messages Abstract tokens can comply with existing standards like [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), and [ERC-1155](./eip-1155.md). The standard allows wallets and other applications to better handle *potential* tokens before any consensus-dependent events occur on-chain.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Data Types #### Token Messages A token message defines one or more tokens along with the context needed to reify the token(s) using a smart contract. `chainId` & `implementation`: set the domain of the token message to a specific chain and contract: this is where the token can be reified `owner`: the address that owns the tokens defined in the messages when reified

MOTIVATION:
Abstract tokens enable zero-cost token minting, facilitating high-volume applications by allowing token holders to reify tokens (place the tokens on-chain) as desired. Example use cases: * airdrops * POAPs / receipts * identity / access credentials Merkle trees are often used for large token distributions to spread mint/claim costs to participants, but they require participants to provide a markle proof when claiming tokens. This standard aims to improve the claims proces for similar distributions: * Generic: compatible with merkle trees, digital signatures, or other eligibility proofs * Legible: users can query an abstract token contract to understand their

RATIONALE:
### Meta format The abstract token message `meta` field is simply a byte array to preserve the widest possible accesibility. * Applications handling abstract tokens can interact with the implementation contract for token metadata rather than parsing this field, so legibility is of secondary importance * A byte array can be decoded as a struct and checked for errors within the implementation contract * Future token standards will include unpredictable metadata ### Proof format Similar considerations went into defining the `proof` field as a plain byte array: * The contents of this field may vary, e.g. an array


=== ERC-1178 ===
TITLE: Multi-class Token Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-06-22
REQUIRES: 

SUMMARY:
This standard allows for the implementation of a standard API for multi-class fungible tokens (henceforth referred to as "MCFTs") within smart contracts. This standard provides basic functionality to track and transfer ownership of MCFTs.

SPECIFICATION:
### ERC-20 Compatibility (partial) **name** ```solidity function name() constant returns (string name) ``` *OPTIONAL - It is recommended that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method.* Returns the name of the aggregate collection of MCFTs managed by this contract. - e.g. `"My Company Tokens"`. **class name** ```solidity function className(uint256 classId) constant returns (string name) ``` *OPTIONAL - It is recommended that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend

MOTIVATION:
Currently, there is no standard to support tokens that have multiple classes. In the real world, there are many situations in which defining distinct classes of the same token would be fitting (e.g. distinguishing between preferred/common/restricted shares of a company). Yet, such nuance cannot be supported in today's token standards. An ERC-20 token contract defines tokens that are all of one class while an ERC-721 token contract creates a class (defined by token_id) for each individual token. The ERC-1178 token standard proposes a new standard for creating multiple classes of tokens within one token contract. > Aside: In

RATIONALE:
### Current Limitations The design of this project was motivated when I tried to create different classes of fungible ERC-721 tokens (an oxymoron) but ran into gas limits from having to create each tokens individually and maintain them in an efficient data structure for access. Using the maximum gas amount one can send with a transaction on Metamask (a popular web wallet), I was only able to create around 46 ERC-721 tokens before exhausting all gas. This experience motivated the creation of the multi-class fungible token standard.


=== ERC-7729 ===
TITLE: Token with Metadata
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-24
REQUIRES: 20

SUMMARY:
This standard extends the [ERC-20](./eip-20.md) standard to include a `metadata` function interface and a JSON schema for metadata.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. **Every compliant contract must implement the `IERC7729`, and [`ERC20`](./eip-20.md) interfaces.** This standard includes the following interface: ```solidity pragma solidity ^0.8.0; interface IERC20Metadata is IERC20 { /// @dev Returns the metadata URI associated with the token. /// The URI may point to a JSON file that conforms to the "ERCX Metadata JSON Schema". function metadata() external view returns (string memory); } ``` This is the "[ERC-7729](./eip-7729.md)

MOTIVATION:
Memecoins have demonstrated the value of associating tokens with visual metadata. By standardizing a way to include metadata in ERC-20 tokens, developers can create more engaging and interactive tokens, fostering community engagement.

RATIONALE:
The `metadata` function was chosen based on existing implementations in standards and applications.


=== ERC-5982 ===
TITLE: Role-based Access Control
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-11-15
REQUIRES: 1, 6, 5, ,,  , 5, 7, 5, 0

SUMMARY:
This EIP defines an interface for role-based access control for smart contracts. Roles are defined as `byte32`. The interface specifies how to read, grant, create and destroy roles. It specifies the sense of role power in the format of its ability to call a given method identified by `bytes4` method selector. It also specifies how metadata of roles are represented.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Interfaces of reference is described as followed: ```solidity interface IERC_ACL_CORE { function hasRole(bytes32 role, address account) external view returns (bool); function grantRole(bytes32 role, address account) external; function revokeRole(bytes32 role, address account) external; } ``` ```solidity interface IERC_ACL_GENERAL { event RoleGranted(address indexed grantor, bytes32 indexed role, address indexed grantee, bytes _data); event RoleRevoked(address indexed revoker, bytes32 indexed role, address indexed revokee, bytes _data); event RoleCreated(address

MOTIVATION:
There are many ways to establish access control for privileged actions. One common pattern is "role-based" access control, where one or more users are assigned to one or more "roles," which grant access to privileged actions. This pattern is more secure and flexible than ownership-based access control since it allows for many people to be granted permissions according to the principle of least privilege.

RATIONALE:
1. The names and parameters of methods in `IERC_ACL_CORE` are chosen to allow backward compatibility with OpenZeppelin's implementation. 2. The methods in `IERC_ACL_GENERAL` conform to [ERC-5750](./eip-5750.md) to allow extension. 3. The method of `renounceRole` was not adopted, consolidating with `revokeRole` to simplify interface.


=== ERC-5633 ===
TITLE: Composable Soulbound NFT, EIP-1155 Extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-09-09
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This standard is an extension of [EIP-1155](./eip-1155.md). It proposes a smart contract interface that can represent any number of soulbound and non-soulbound NFT types. Soulbound is the property of a token that prevents it from being transferred between accounts. This standard allows for each token ID to have its own soulbound property.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. A token type with a `uint256 id` is soulbound if function `isSoulbound(uint256 id)` returning true. In this case, all EIP-1155 functions of the contract that transfer the token from one account to another MUST throw, except for mint and burn. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; interface IERC5633 { /** * @dev Emitted when a token type `id` is set or cancel to soulbound, according to `bounded`. */

MOTIVATION:
The soulbound NFTs similar to World of Warcraft’s soulbound items are attracting more and more attention in the Ethereum community. In a real world game like World of Warcraft, there are thousands of items, and each item has its own soulbound property. For example, the amulate Necklace of Calisea is of soulbound property, but another low level amulate is not. This proposal provides a standard way to represent soulbound NFTs that can coexist with non-soulbound ones. It is easy to design a composable NFTs for an entire collection in a single contract. This standard outline a interface to

RATIONALE:
If all tokens in a contract are soulbound by default, `isSoulbound(uint256 id)` should return true by default during implementation.


=== ERC-1844 ===
TITLE: ENS Interface Discovery
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-03-15
REQUIRES: 1, 3, 7, ,,  , 1, 6, 5

SUMMARY:
This EIP specifies a method for exposing interfaces associated with an ENS name or an address (typically a contract address) and allowing applications to discover those interfaces and interact with them. Interfaces can be implemented either by the target contract (if any) or by any other contract.

SPECIFICATION:
A new profile for ENS resolvers is defined, consisting of the following method: ```solidity function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address); ``` The EIP-165 interface ID of this interface is `0xb8f2bbb4`. Given an ENS name hash `node` and an EIP-165 `interfaceID`, this function returns the address of an appropriate implementer of that interface. If there is no interface matching that interface ID for that node, 0 is returned. The address returned by `interfaceImplementer` MUST refer to a smart contract. The smart contract at the returned address SHOULD implement EIP-165. Resolvers implementing this interface MAY utilise a

MOTIVATION:
EIP 165 supports interface discovery - determining if the contract at a given address supports a requested interface. However, in many cases it's useful to be able to discover functionality associated with a name or an address that is implemented by other contracts. For example, a token contract may not itself provide any kind of 'atomic swap' functionality, but there may be associated contracts that do. With ENS interface discovery, the token contract can expose this metadata, informing applications where they can find that functionality.

RATIONALE:
A naive approach to this problem would involve adding this method directly to the target contract. However, doing this has several shortcomings: 1. Each contract must maintain its own list of interface implementations. 2. Modifying this list requires access controls, which the contract may not have previously required. 3. Support for this must be designed in when the contract is written, and cannot be retrofitted afterwards. 4. Only one canonical list of interfaces can be supported. Using ENS resolvers instead mitigates these shortcomings, making it possible for anyone to associate interfaces with a name, even for contracts not


=== ERC-5883 ===
TITLE: Token Transfer by Social Recovery
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-07-19
REQUIRES: 

SUMMARY:
This EIP standardizes a mechanism of a social recovery where a token may be transferred from an inaccessible account to a new account, given enough approvals from other identities. This approval is not purely technical, but rather needs human intervention. These humans are - based on the Soul Bound Token proposal - called Souls. When enough Souls give their approval (which is a Yes/No decision) and a threshold is reached, a token is transferred from an old to a new identity.

SPECIFICATION:
```solidity pragma solidity ^0.8.7; interface ISocialRecovery { /// @dev Related but independent identity approves the transfer function approveTransfer(address from_, address to_) external; /// @dev User wants to move their onchain identity to another wallet which needs to be approved by n-nearest neighbour identities function requestTransfer(address from_, address to_) external payable; function addNeighbour(address neighbour_) external; function removeNeighbour(address neighbour_) external; } ``` **The math behind it**: A compliant contract SHOULD calculate the score of a node n with the following formula: $$ score(n) = tanh({ { {\displaystyle\sum_{i = 1}^{|N|} } {log{(n_i^{r} {1 \over t - n_i^{t} + 1})}} \over{|N| +

MOTIVATION:
It is a known problem that the private key of an account can be lost. If that key is lost it's not possible to recover the tokens owned by that account. The holder loses those tokens forever. In addition to directly harming the token holder, the entire ecosystem of the token itself is affected: the more tokens that are lost the less tokens are available for the natural growth and planned evolution of that ecosystem.

RATIONALE:
The formula proposed was deemed very resilient and provides a coherent incentivation structure to actually see value in the on-chain score. The formula adds weights based on scores based on time which further contributes to the fairness of the metric.


=== ERC-1616 ===
TITLE: Attribute Registry Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-11-23
REQUIRES: 165

SUMMARY:
This EIP contains the following core ideas: 1. Instead of relying directly on the reputation of a claims issuer to assess the veracity of a given claim, trust can be brought up to the level of a registry curator. This registry which we call an "**Attribute Registry**" allows for reduced complexity in implementation since a party needing to verify an attribute can now work with a trusted claims aggregator instead of relying on individual claim providers. 2. Claims are abstracted as standard "attributes" which represent metadata assigned to an account, with claims decoupled from the issuing party. Attributes

SPECIFICATION:
The Attribute Registry interface contains four functions, outlined as follows: ```solidity /** * @title EIP-1616 Attribute Registry Standard interface. EIP-165 ID: 0x5f46473f */ interface AttributeRegistryInterface { function hasAttribute(address account, uint256 attributeTypeID) external view returns (bool); function getAttributeValue(address account, uint256 attributeTypeID) external view returns (uint256); function countAttributeTypes() external view returns (uint256); function getAttributeTypeID(uint256 index) external view returns (uint256); } ``` Contracts that comply with the Attribute Registry EIP MUST implement the above interface. As an additional requirement, the ERC-165 interface MUST be included: ```solidity /** * @title EIP-165 interface. EIP-165 ID: 0x01ffc9a7 */ interface EIP-165 { /** * @notice

MOTIVATION:
This EIP is motivated by the need for contracts and external accounts to be able to verify information about a given address from a single trusted source **without concerning themselves with the particular details of how the information was obtained**, and to do so in as simple a manner as possible. It is also motivated by the desire to promote broad **cross-compatibility and composability** between attribute registries, a property which is amplified by both the simplicity of the interface as well as by the guarantees on uniqueness provided by the proposed standard. Existing EIPs for assigning metadata to

RATIONALE:
This standard extends the applicability of metadata assignment to those use cases that are not adequately represented by EIP-735, EIP-780, or similar proposals. Namely, it enforces the constraint of one attribute value per attribute ID per address, as opposed to one value per ID per address *per issuer*. Aside from the prescribed attribute value, attribute properties are deliberately omitted from the standard. While many attribute registries will require additional metadata on attributes at both the instance and the class level, reliable and flexible interoperability between highly variable registry extensions is facilitated more effectively by enforcing a widely-applicable base


=== ERC-1613 ===
TITLE: Gas stations network
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-11-18
REQUIRES: 1077

SUMMARY:
Communicating with dapps currently requires paying ETH for gas, which limits dapp adoption to ether users. Therefore, contract owners may wish to pay for the gas to increase user acquisition, or let their users pay for gas with fiat money. Alternatively, a 3rd party may wish to subsidize the gas costs of certain contracts. Solutions such as described in [EIP-1077](./eip-1077.md) could allow transactions from addresses that hold no ETH. The gas stations network is an [EIP-1077](./eip-1077.md) compliant effort to solve the problem by creating an incentive for nodes to run gas stations, where gasless transactions can be "fueled

SPECIFICATION:
The system consists of a `RelayHub` singleton contract, participating contracts inheriting the `RelayRecipient` contract, a decentralized network of `Relay` nodes, a.k.a. Gas Stations, and user applications (e.g. mobile or web) interacting with contracts via relays. Roles of the `RelayHub`: * Maintain a list of active relays. Senders select a `Relay` from this list for each transaction. The selection process is discussed below. * Mediate all communication between relays and contracts. * Provide contracts with trusted versions of the real msg.sender and msg.data. * Hold ETH stakes placed by relays. A minimum stake size is enforced. Stake can be

MOTIVATION:
* Increase user adoption of smart contracts by: * Removing the user hassle of acquiring ETH. Transactions are still paid by ETH but costs can be borne by the dapp or paid by the user through other means. * Removing the need to interact directly with the blockchain, while maintaining decentralization and censorship-resistance. Contracts can "listen" on multiple public channels, and users can interact with the contracts through common protocols that are generally permitted even in restrictive environments. * Ethereum nodes get a revenue source without requiring mining equipment. The entire network benefits from having more nodes. *

RATIONALE:
The rationale for the gas stations network design is a combination of two sets of requirements: Easy adoption, and robustness. For easy adoption, the design goals are: * No network changes. * Minimal changes to contracts, apps and frameworks. The robustness requirement translates to decentralization and attack resistance. The gas stations network is decentralized, and we have to assume that any entity may attack other entities in the system. Specifically we've considered the following types of attacks: * Denial-of-service attacks against individual senders, i.e. transactions censorship. * Denial-of-service and financial attacks against individual relays. * Denial-of-service and financial


=== ERC-7561 ===
TITLE: Simple NFT, Simplified ERC-721
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-10-29
REQUIRES: 721

SUMMARY:
This ERC is a new NFT asset designed based on the user contract wallet (including account abstraction), and is forward compatible with [ERC-721](./eip-721.md). To keep NFT assets simple, this ERC removes the `approve`, `setApprovalForAll`, `getApproved`, `isApprovedForAll` and `safeTransferFrom` functions of ERC-721.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Compliant contracts MUST implement the following interface: ```solidity pragma solidity ^0.8.20; /** * @title ERC7561 Simple NFT interface * @dev See https://ercs.ethereum.org/ERCS/erc-7561 */ interface IERC7561 { /** * @notice Used to notify transfer NFT. * @param from Address of the from * @param to Address of the receive * @param tokenId The transaction token id */ event Transfer( address indexed from, address indexed to,

MOTIVATION:
[ERC-721](./eip-721.md) defines Ethereum-based standard NFT that can be traded and transferred, but the essence of ERC-721 is based on the externally-owned account (EOA) wallet design. An EOA wallet has no state and code storage, and the smart contract wallet is different. Almost all ERCs related to NFTs are add functions, but our opinion is the opposite. We think the NFT contract should be simpler, with more functions taken care of by the smart contract wallet. Our proposal is to design a simpler NFT asset based on the smart contract wallet. It aims to achieve the following goals: 1.

RATIONALE:
The proposal is to simplify NFT standards by removing `approve`, `setApprovalForAll`, `getApproved`, `isApprovedForAll` and `safeTransferFrom` functions. This simplification aims to enhance security, reduce complexity, and improve efficiency, making the standard more suitable for smart contract wallet environments while maintaining essential functionalities.


=== ERC-1633 ===
TITLE: Re-Fungible Token Standard (RFT)
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-11-18
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The intention of this proposal, the Re-Fungible Token Standard, is to extend the ERC-20 Token Standard and utilize ERC-165 Standard Interface Detection in order to represent the shared ownership of an ERC-721 Non-Fungible Token. The ERC-20 Token Standard was modified as little as possible in order to allow this new class of token to operate in all of the ways and locations which are familiar to assets that follow the original ERC-20 specification. While there are many possible variations of this specification that would enable many different capabilities and scenarios for shared ownership, this proposal is focused on

SPECIFICATION:
At a minimum, third parties need two things: 1) to be able to distinguish re-fungible tokens from other token standards and 2) to determine when a non-fungible token is collectively owned. These two scenarios can be encountered from the perspective of initial contact with the non-fungible token or from the perspective of initial contact with the re-fungible token. #### Initial Contact with the Re-Fungible Token In order for a third party to confirm which non-fungible token is owned by the re-fungible token there needs to be a pointer from the RFT contract to the NFT contract and the

MOTIVATION:
Shared ownership occurs across many industries and for many reasons. As more assets are registered, regulated and/or represented by the ERC-721 Non-Fungible Token Standard there will be more instances where the need for shared ownership of these assets will arise. For example, ARTBLX Inc. is working towards facilitating a protocol for collective ownership of physical, digital and conceptual artworks. The fungible tokens created from this process will have a value attached to the non-fungible tokens which they represent. This will be useful for price discovery of the underlying asset, liquidity for shared owners and as a new class

RATIONALE:
Most of the decisions made around the design of this standard were done in the hopes of keeping it as flexible as possible for as many use cases as possible. This includes making the standard 100% backwards compatible with ERC-20 Token Standard and able to interact with any previously deployed or future ERC-721 non-fungible token. This allows for each project to determine their own system for minting, burning and governing their re-fungible tokens depending on their specific use case.


=== ERC-5192 ===
TITLE: Minimal Soulbound NFTs
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-07-01
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [EIP-721](./eip-721.md). It proposes a minimal interface to make tokens soulbound using the feature detection functionality of [EIP-165](./eip-165.md). A soulbound token is a non-fungible token bound to a single account.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Contract Interface A token with a `uint256 tokenId` may be bound to a receiving account with `function locked(...)` returning `true`. In this case, all [EIP-721](./eip-721.md) functions of the contract that transfer the token from one account to another must throw. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; interface IERC5192 { /// @notice Emitted when the locking status is changed to locked. /// @dev If a token is minted and

MOTIVATION:
The Ethereum community has expressed a need for non-transferrable, non-fungible, and socially-priced tokens similar to World of Warcraft’s soulbound items. But the lack of a token standard leads many developers to simply throw errors upon a user's invocation of transfer functionalities. Over the long term, this will lead to fragmentation and less composability. In this document, we outline a minimal addition to [EIP-721](./eip-721.md) that allows wallet implementers to check for a token contract's permanent (non-)transferability using [EIP-165](./eip-165.md).

RATIONALE:
The above model is the simplest possible path towards a canonical interface for Soulbound tokens. It reflects upon the numerous Soulbound token implementations that simply revert upon transfers.


=== ERC-5005 ===
TITLE: Zodiac Modular Accounts
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-04-14
REQUIRES: 165

SUMMARY:
This EIP standardizes interfaces for composable and interoperable tooling for programmable Ethereum accounts. These interfaces separate contract accounts ("avatars") from their authentication and execution logic ("guards" and "modules"). Avatars implement the `IAvatar` interface, and guards implement the `IGuard` interface. Modules may take any form.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. This EIP consists of four key concepts: - **Avatars** are programmable Ethereum accounts. Avatars are the address that holds balances, owns systems, executes transaction, is referenced externally, and ultimately represents your DAO. Avatars MUST implement the `IAvatar` interface. - **Modules** are contracts enabled by an avatar that implement some execution logic. - **Modifiers** are contracts that sit between modules and avatars to modify the module's behavior. For example, they

MOTIVATION:
Currently, most programmable accounts (like DAO tools and frameworks) are built as monolithic systems where the authorization and execution logic are coupled, either within the same contract or in a tightly integrated system of contracts. This needlessly inhibits the flexibility of these tools and encourages platform lock-in via high switching costs. By using the this EIP standard to separate concerns (decoupling authentication and execution logic), users are able to: 1. Enable flexible, module-based control of programmable accounts 2. Easily switch between tools and frameworks without unnecessary overhead. 3. Enable multiple control mechanism in parallel. 4. Enable cross-chain /

RATIONALE:
The interface defined in this standard is designed to be mostly compatible with most popular programmable accounts in use right now, to minimize the need for changes to existing tooling.


=== ERC-7548 ===
TITLE: Open IP Protocol built on NFTs
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-10-31
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal aims to establish a standardized method for creating new intellectual properties (IPs) by remixing multiple existing IPs in a decentralized manner. The protocol is built on the foundation of NFTs (Non-Fungible Tokens). Within this protocol, each intellectual property is represented as an NFT. It extends the [ERC-721](./eip-721.md) standard, enabling users to generate a new NFT by remixing multiple existing NFTs. To ensure transparency and traceability in the creation process, the relationships between the new NFT and the original NFTs are recorded on the blockchain and made publicly accessible. Furthermore, to enhance the liquidity of IP, users

SPECIFICATION:
The keywords “MUST,” “MUST NOT,” “REQUIRED,” “SHALL,” “SHALL NOT,” “SHOULD,” “SHOULD NOT,” “RECOMMENDED,” “MAY,” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. **Interface** This protocol standardizes how to remix multiple existing NFTs and create a new NFT derivative work (known as a combo), while their relationships can be traced on the blockchain. It contains three core modules, remix module, network module, and license module. ### Remix Module This module extends the ERC-721 standard and enables users to create a new NFT by remixing multiple existing NFTs, whether they’re ERC-721 or [ERC-1155](./eip-1155.md). ```solidity

MOTIVATION:
The internet is flooded with fresh content every day, but with the traditional IP infrastructure, IP registration and licensing is a headache for digital creators. The rapid creation of content has eclipsed the slower pace of IP registration, leaving much of this content unprotected. This means digital creators can't fairly earn from their work's spread. ||Traditional IP Infrastructure|Open IP Infrastructure| |-|-|-| |IP Registration|Long waits, heaps of paperwork, and tedious back-and-forths.|An NFT represents intellectual property; the owner of the NFT holds the rights to the IP.| |IP Licensing|Lengthy discussions, legal jargon, and case-by-case agreements.|A one-stop global IP licensing market

RATIONALE:
The Open IP Protocol is built on the "1 premise, 2 extensions, 1 constant" principle. The “1 premise” means that for any IP in the Open IP ecosystem, an NFT stands for that IP. So, if you have the NFT, you own the IP. That’s why the Open IP Protocol is designed as an extended protocol compatible with ERC-721. The “2 extensions” refer to the diversification of IP licensing and remixing. - IP licensing methods are diverse. For example, delegating an NFT to someone else is one type of licensing, setting a price for the number of usage


=== ERC-7254 ===
TITLE: Token Revenue Sharing
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-29
REQUIRES: 

SUMMARY:
With the aspiration of bringing forth unique functionality and enhancing value for holders of [ERC-20](./eip-20.md) tokens, our project aims to effortlessly reward token holders without necessitating users to lock, stake, or farm their tokens. Whenever the project generates profits, these profits can be distributed to the token holders. Revenue Sharing is an extended version of [ERC-20](./eip-20.md). It proposes an additional payment method for token holders. This standard includes updating rewards for holders and allowing token holders to withdraw rewards. Potential use cases encompass: * Companies distributing dividends to token holders. * Direct sharing of revenue derived from business

SPECIFICATION:
### Methods #### maxTokenReward Returns max token reward. ``` js function maxTokenReward() public view returns (uint256) ``` #### informationOf Returns the account information of another account with the address `token` and `account`, including: inReward, outReward and withdraw. ``` js function informationOf(address token, address account) public view returns (UserInformation memory) ``` #### informationOfBatch Returns the list account information of another account with the `account`, including: inReward, outReward and withdraw. ``` js function informationOfBatch(address account) public view returns (UserInformation[] memory) ``` #### UserInformation `inReward`: when user's balance decreases, inReward will be updated `outReward`: when user's balance increases, outReward will be

RATIONALE:
TBD


=== ERC-2335 ===
TITLE: BLS12-381 Keystore
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-09-30
REQUIRES: 2, 3, 3, 3, ,,  , 2, 3, 3, 4

SUMMARY:
A keystore is a mechanism for storing private keys. It is a JSON file that encrypts a private key and is the standard for interchanging keys between devices as until a user provides their password, their key is safe.

SPECIFICATION:
The process of decrypting the secret held within a keystore can be broken down into 3 sub-processes: obtaining the decryption key, verifying the password and decrypting the secret. Each process has its own functions which can be selected from as well as parameters required for the function all of which are specified within the keystore file itself. ### Password requirements The password is a string of arbitrary unicode characters. The password is first converted to its NFKD representation, then the control codes (specified below) are stripped from the password and finally it is UTF-8 encoded. #### Control codes

MOTIVATION:
The secure storage and exchange of keys is a vital component of the user experience as people are expected to hold their own keys. It allows users to control access to individual keys and their use by applications. In Ethereum 1, [the Web3 Secret Storage Definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) fulfills these requirements, however it is not perfectly suitable for these purposes moving forward. Specifically the problems with the existing standard are: * __The use of Keccak256.__ Eth1 keystores use Keccak for their checksum, a sensible choice considering its usage within Ethereum 1. BLS12-381 [signatures](https://tools.ietf.org/html/draft-irtf-cfrg-bls-signature-00), [keys (EIP-2333)](./eip-2333.md), and key-storage are inter-chain standards,

RATIONALE:
The rationale behind the design of this specification is largely the same as that behind the [Ethereum 1 keystore definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) except for the lack of support for Keccak (explained in [motivation above](#motivation)) and the notion of modules. Modules provide a very useful level of abstraction which allow the Key-Derivation-Function, Checksum, and Cipher to be thought of as instances of the same thing allowing for their substitution with minimal effort. The `version` is set to 4 to prevent collisions with the existing Ethereum keystore standard.


=== ERC-1923 ===
TITLE: zk-SNARK Verifier Registry Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-12-22
REQUIRES: 1, 6, 5, ,,  , 1, 9, 6, ,,  , 1, 9, 7

SUMMARY:
The following standard allows for the implementation of a standard contract API for the registration of zk-SNARKs ("Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge"), also known as "proofs", "arguments", or "commitments". TODO: Which functionality is exposed in this standard interface?

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ```solidity pragma solidity ^0.5.6; /// @title EIP-XXXX zk-SNARK Verifier Registry Standard /// @dev See https://github.com/EYBlockchain/zksnark-verifier-standard /// Note: the ERC-165 identifier for this interface is 0xXXXXXXXXX. /// ⚠️ TODO: Set the interface identifier interface EIP-XXXX /* is ERC165 */ { event NewProofSubmitted(bytes32 indexed _proofId, uint256[] _proof, uint64[] _inputs); event NewVkRegistered(bytes32 indexed _vkId); event NewVerifierContractRegistered(address indexed _contractAddress); event NewAttestation(bytes32 indexed _proofId, address indexed _verifier, bool indexed _result); function getVk(bytes32 _vkId) external

MOTIVATION:
zk-SNARKs are a promising area of interest for the Ethereum community. Key applications of zk-SNARKs include: - Private transactions - Private computations - Ethereum scaling through proofs of 'bundled' transactions A standard interface for registering all zk-SNARKs will allow applications to more easily implement private transactions, private contracts, and scaling solutions; and to extract and interpret the limited information which gets emitted during zk-SNARK verifications. :warning: TODO: Explain the motivation for standardizing a registry, other than simply standardizing the verifier interactions. ⚠️ TODO: Explain the benefits to and perspective of a consumer of information. I.e. the thing that

RATIONALE:
⚠️ TODO: Add Rationale section. ### Backwards Compatibility ⚠️ TODO: Add Backwards Compatibility section. ### Test Cases Truffle tests of example implementations are included in this Repo. ⚠️ TODO: Reference specific test cases because there are many currently in the repository.


=== ERC-2917 ===
TITLE: Staking Reward Calculation
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-08-28
REQUIRES: 

SUMMARY:
Based on the product of effective collateral and time, ERC2917 calculates the reward a user can get at any time, and realize the real decentralized DeFi. Here below is the formula for the calculation of reward for a user U: ![concept image](../assets/eip-2917/erc-reward-formula.png "erc-reward-formula") where ∆p<sub>i</sub> denotes individual productivity of the user U between the consecutive block numbers t<sub>i-1</sub> and t<sub>i</sub>, ∆P<sub>i</sub> denotes global productivity between the consecutive block numbers t<sub>i-1</sub> and t<sub>i</sub>, and ∆G<sub>i</sub> denotes gross product between the consecutive block numbers t<sub>i-1</sub> and t<sub>i</sub>. The formula ensures that there is no benefit in case of exiting earlier

SPECIFICATION:
Every ERC-2917 compliant contract must implement the ERC2917 and ERC20 interfaces (if necessary): ```solidity interface IERC2917 is IERC20 { /// @dev This emit when interests amount per block is changed by the owner of the contract. /// It emits with the old interests amount and the new interests amount. event InterestRatePerBlockChanged (uint oldValue, uint newValue); /// @dev This emit when a users' productivity has changed /// It emits with the user's address and the value after the change. event ProductivityIncreased (address indexed user, uint value); /// @dev This emit when a users' productivity has changed /// It emits

MOTIVATION:
One of the main drawbacks of many DeFi projects is the reward distribution mechanism within the smart contract. In fact, there are two main mechanisms are adopted so far. 1. Distribution of rewards is only given when all users exit the contract 2. The project collects on-chain data, conducts calculation off-chain, and sends the results to the chain before starting rewards distribution accordingly The first approach conducts all calculation in an on-chain fashion, the cycle of its rewards distribution is too long. Furthermore, users need to remove their collateral before getting the rewards, which can be harmful for

RATIONALE:
TBD


=== ERC-5006 ===
TITLE: Rental NFT, NFT User Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-04-12
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This standard is an extension of [ERC-1155](./eip-1155.md). It proposes an additional role (`user`) which can be granted to addresses that represent a `user` of the assets rather than an `owner`.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; interface IERC5006 { struct UserRecord { uint256 tokenId; address owner; uint64 amount; address user; uint64 expiry; } /** * @dev Emitted when permission for `user` to use `amount` of `tokenId` token owned by `owner` * until `expiry` are given. */ event CreateUserRecord( uint256 recordId, uint256 tokenId, uint64 amount, address owner, address user, uint64 expiry ); /** * @dev Emitted when record of `recordId`

MOTIVATION:
Like [ERC-721](./eip-721.md), [ERC-1155](./eip-1155.md) tokens may have utility of some kind. The people who “use” the token may be different than the people who own it (such as in a rental). Thus, it would be useful to have separate roles for the “owner” and the “user” so that the “user” would not be able to take actions that the owner could (for example, transferring ownership).

RATIONALE:
This model is intended to facilitate easy implementation. The following are some problems that are solved by this standard: ### Clear Rights Assignment With Dual “owner” and “user” roles, it becomes significantly easier to manage what lenders and borrowers can and cannot do with the NFT (in other words, their rights). For example, for the right to transfer ownership, the project simply needs to check whether the address taking the action represents the owner or the user and prevent the transaction if it is the user. Additionally, owners can control who the user is and it is easy


=== ERC-1167 ===
TITLE: Minimal Proxy Contract
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-06-22
REQUIRES: 211

SUMMARY:
By standardizing on a known minimal bytecode redirect implementation, this standard allows users and third party tools (e.g. Etherscan) to (a) simply discover that a contract will always redirect in a known manner and (b) depend on the behavior of the code at the destination contract as the behavior of the redirecting contract. Specifically, tooling can interrogate the bytecode at a redirecting address to determine the location of the code that will run - and can depend on representations about that code (verified source, third-party audits, etc). This implementation forwards all calls and 100% of the gas to

SPECIFICATION:
The exact bytecode of the standard clone contract is this: `363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3` wherein the bytes at indices 10 - 29 (inclusive) are replaced with the 20 byte address of the master functionality contract. A reference implementation of this can be found at the [optionality/clone-factory](https://github.com/optionality/clone-factory) github repo.

MOTIVATION:
This standard supports use-cases wherein it is desirable to clone exact contract functionality with a minimum of side effects (e.g. memory slot stomping) and with low gas cost deployment of duplicate proxies.

RATIONALE:
The goals of this effort have been the following: - inexpensive deployment (low gas to deploy clones) - support clone initialization in creation transaction (through factory contract model) - simple clone bytecode to encourage directly bytecode interrogation (see CloneProbe.sol in the clone-factory project) - dependable, locked-down behavior - this is not designed to handle upgradability, nor should it as the representation we are seeking is stronger. - small operational overhead - adds a single call cost to each call - handles error return bubbling for revert messages


=== ERC-7053 ===
TITLE: Interoperable Digital Media Indexing
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-05-22
REQUIRES: 

SUMMARY:
This EIP proposes an interoperable indexing strategy designed to enhance the organization and retrieval of digital media information across multiple smart contracts and EVM-compatible blockchains. This system enhances the traceability and verification of cross-contract and cross-chain data, facilitating a more efficient discovery of storage locations and crucial information related to media assets. The major purpose is to foster an integrated digital media environment on the blockchain.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Content Identifier Content Identifier in this EIP is the content address generated by passing the content of a digital media through a cryptographic hash function. Before the indexing process for digital media can begin, it is REQUIRED to generate unique Content Identifiers for each file. This identifier should the same as the Content Identifiers on the decentralized storage, ensuring each identifier provides access

MOTIVATION:
Given the significant role digital media files play on the Internet, it's crucial to have a robust and efficient method for indexing immutable information. Existing systems encounter challenges due to the absence of a universal, interoperable identifier for digital media content. This leads to fragmentation and complications in retrieving metadata, storage information, or the provenance of specific media assets. The issues become increasingly critical as the volume of digital media continues to expand. The motivation behind this EIP is to establish a standardized, decentralized, and interoperable approach to index digital media across EVM-compatible networks. By integrating Decentralized Content

RATIONALE:
The design decisions in this EIP prioritize the effectiveness and efficiency of the indexing method. To achieve this, Decentralized Content Identifiers (CIDs) are utilized to uniquely identify digital media content across all systems. This approach offers accurate and precise searching of media, along with the following benefits: 1. Strengthened data integrity: CIDs serve as cryptographic hashes of the content, ensuring their uniqueness and preventing forgery. With the content in hand, obtaining the CID allows for searching relevant information associated with that content. 2. Streamlined data portability: CIDs enable the seamless transfer of digital media content across different systems,


=== ERC-4521 ===
TITLE: 721/20-compatible transfer
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-12-13
REQUIRES: 721

SUMMARY:
ERC-721, the popular standard for non-fungible tokens (NFTs), includes send functions, such as `transferFrom()` and `safeTransferFrom()`, but does not include a backwards-compatible `transfer()` found in fungible ERC-20 tokens. This standard provides references to add such a `transfer()`.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. The interface for ERC-4521 `transfer()` MUST conform to ERC-20 and resulting transfers MUST fire the `Transfer` event as described in ERC-721. ```sol function transfer(address to, uint256 tokenId) external returns (bool success); ```

MOTIVATION:
This standard proposes a simple extension to allow NFTs to work with contracts designed to manage ERC-20s and many consumer wallets which expect to be able to execute a token `transfer()`. For example, if an NFT is inadvertently sent to a contract that typically handles ERC-20, that NFT will be locked. It should also simplify the task for contract programmers if they can rely on `transfer()` to both handle ERC-20 and NFTs.

RATIONALE:
Replicating ERC-20 `transfer()` with just a minor change to accurately reflect that a unique `tokenId` rather than fungible sum is being sent is desirable for code simplicity and to make integration easier.


=== ERC-918 ===
TITLE: Mineable Token Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-03-07
REQUIRES: 

SUMMARY:
This specification describes a method for initially locking tokens within a token contract and slowly dispensing them with a mint() function which acts like a faucet. This mint() function uses a Proof of Work algorithm in order to minimize gas fees and control the distribution rate. Additionally, standardization of mineable tokens will give rise to standardized CPU and GPU token mining software, token mining pools and other external tools in the token mining ecosystem. ### Motivation Token distribution via the ICO model and its derivatives is susceptible to illicit behavior by human actors. Furthermore, new token projects are

SPECIFICATION:
#### Interface The general behavioral specification includes a primary function that defines the token minting operation, an optional merged minting operation for issuing multiple tokens, getters for challenge number, mining difficulty, mining target and current reward, and finally a Mint event, to be emitted upon successful solution validation and token issuance. At a minimum, contracts must adhere to this interface (save the optional merge operation). It is recommended that contracts interface with the more behaviorally defined Abstract Contract described below, in order to leverage a more defined construct, allowing for easier external implementations via overridden phased functions. (see

MOTIVATION:
Token distribution via the ICO model and its derivatives is susceptible to illicit behavior by human actors. Furthermore, new token projects are centralized because a single entity must handle and control all of the initial coins and all of the raised ICO money. By distributing tokens via an 'Initial Mining Offering' (or IMO), the ownership of the token contract no longer belongs with the deployer at all and the deployer is 'just another user.' As a result, investor risk exposure utilizing a mined token distribution model is significantly diminished. This standard is intended to be standalone, allowing maximum

RATIONALE:
The solidity keccak256 algorithm does not have to be used, but it is recommended since it is a cost effective one-way algorithm to perform in the EVM and simple to perform in solidity. The nonce is the solution that miners try to find and so it is part of the hashing algorithm. A challengeNumber is also part of the hash so that future blocks cannot be mined since it acts like a random piece of data that is not revealed until a mining round starts. The msg.sender address is part of the hash so that a nonce solution


=== ERC-1081 ===
TITLE: Standard Bounties
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-14
REQUIRES: 20

SUMMARY:
In order to encourage cross-platform interoperability of bounties on Ethereum, and for easier reputational tracking, StandardBounties can facilitate the administration of funds in exchange for deliverables corresponding to a completed task, in a publicly auditable and immutable fashion.

SPECIFICATION:
After studying bounties as they've existed for thousands of years (and after implementing and processing over 300 of them on main-net in beta), we've discovered that there are 3 core steps to every bounty: - a bounty is **issued**: an `issuer` specifies the requirements for the task, describing the desired outcome, and how much they would be willing to pay for the completion of that task (denoted in one or several tokens). - a bounty is **fulfilled**: a bounty `fulfiller` may see the bounty, complete the task, and produce a deliverable which is itself the desired outcome of

MOTIVATION:
In the absence of a standard for bounties on Ethereum, it would be difficult for platforms to collaborate and share the bounties which users create (thereby recreating the walled gardens which currently exist on Web2.0 task outsourcing platforms). A standardization of these interactions across task types also makes it far easier to track various reputational metrics (such as how frequently you pay for completed submissions, or how frequently your work gets accepted).

RATIONALE:
The development of this standard began a year ago, with the goal of encouraging interoperability among bounty implementations on Ethereum. The initial version had significantly more restrictions: a bounty's `data` could not be changed after issuance (it seemed unfair for bounty `issuer`s to change the requirements after work is underway), and the bounty payout could not be changed (all funds needed to be deposited in the bounty contract before it could accept submissions). The initial version was also far less extensible, and only allowed for fixed payments to a given set of fulfillments. This new version makes it


=== ERC-3005 ===
TITLE: Batched meta transactions
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-09-25
REQUIRES: 

SUMMARY:
This EIP defines a new function called `processMetaBatch()` that extends any fungible token standard, and enables batched meta transactions coming from many senders in one on-chain transaction. The function must be able to receive multiple meta transactions data and process it. This means validating the data and the signature, before proceeding with token transfers based on the data. The function enables senders to make gasless transactions, while reducing the relayer's gas cost due to batching.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. The key words "MUST (BUT WE KNOW YOU WON'T)", "SHOULD CONSIDER", "REALLY SHOULD NOT", "OUGHT TO", "WOULD PROBABLY", "MAY WISH TO", "COULD", "POSSIBLE", and "MIGHT" in this document are to be interpreted as described in RFC 6919. ### Meta transaction data In order to successfully validate and transfer tokens, the `processMetaBatch()` function MUST process the following data about a meta transaction: - sender address - receiver address - token

MOTIVATION:
Meta transactions have proven useful as a solution for Ethereum accounts that don't have any ether, but hold ERC-20 tokens and would like to transfer them (gasless transactions). The current meta transaction relayer implementations only allow relaying one meta transaction at a time. Some also allow batched meta transactions from the same sender. But none offers batched meta transactions from **multiple** senders. The motivation behind this EIP is to find a way to allow relaying batched meta transactions from **many senders** in **one on-chain transaction**, which also **reduces the total gas cost** that a relayer needs to cover.

RATIONALE:
### All-in-one Alternative implementations (like GSN) use multiple smart contracts to enable meta transactions, although this increases gas usage. This implementation (EIP-3005) intentionally keeps everything within one function which reduces complexity and gas cost. The `processMetaBatch()` function thus does the job of receiving a batch of meta transactions, validating them, and then transferring tokens from one address to another. ### Function parameters As you can see, the `processMetaBatch()` function in the reference implementation takes the following parameters: - an array of **sender addresses** (meta txs senders, not relayers) - an array of **receiver addresses** - an array of


=== ERC-4430 ===
TITLE: Described Transactions
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-11-07
REQUIRES: 

SUMMARY:
Use a contract method to provide *virtual functions* which can generate a human-readable description at the same time as the machine-readable bytecode, allowing the user to agree to the human-readable component in a UI while the machine can execute the bytecode once accepted.

SPECIFICATION:
The **description** (a string) and the matching **execcode** (bytecode) are generated simultaneously by evaluating the method on a contract: ```solidity function eipXXXDescribe(bytes inputs, bytes32 reserved) view returns (string description, bytes execcode) ``` The human-readable **description** can be shown in any client which supports user interaction for approval, while the **execcode** is the data that should be included in a transaction to the contract to perform that operation. The method must be executable in a static context, (i.e. any side effects, such as logX, sstore, etc.), including through indirect calls may be ignored. During evaluation, the `ADDRESS` (i.e. `to`),

MOTIVATION:
When using an Ethereum Wallet (e.g. MetaMask, Clef, Hardware Wallets) users must accept a transaction before it can be submitted (or the user may decline). Due to the complexity of Ethereum transactions, wallets are very limited in their ability to provide insight into the effects of a transaction that the user is approving; outside special-cased support for common transactions such as ERC20 transfers, this often amounts to asking the user to sign an opaque blob of binary data. This EIP presents a method for dapp developers to enable a more comfortable user experience by providing wallets with a

RATIONALE:
### Meta Description There have been many attempts to solve this problem, many of which attempt to examine the encoded transaction data or message data directly. In many cases, the information that would be necessary for a meaningful description is not present in the final encoded transaction data or message data. Instead this EIP uses an indirect description of the data. For example, the `commit(bytes32)` method of ENS places a commitment **hash** on-chain. The hash contains the **blinded** name and address; since the name is blinded, the encoded data (i.e. the hash) no longer contains the original values


=== ERC-4675 ===
TITLE: Multi-Fractional Non-Fungible Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-01-13
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard outlines a smart contract interface eligible to represent any number of fractionalized non-fungible tokens. Existing projects utilizing standards like [EIP-1633](./eip-1633.md) conventionally deploy separate [EIP-20](./eip-20.md) compatible token contracts to fractionalize the non-fungible token into EIP-20 tokens. In contrast, this ERC allows each token ID to represent a token type representing(fractionalizing) the non-fungible token. This standard is approximate in terms of using `_id` for distinguishing token types. However, this ERC has a clear difference with [EIP-1155](./eip-1155.md) as each `_id` represents a distinct NFT.

SPECIFICATION:
```solidity /** @title Multi-Fractional Non-Fungible Token Standard @dev Note : The ERC-165 identifier for this interface is 0x83f5d35f. */ interface IMFNFT { /** @dev This emits when ownership of any token changes by any mechanism. The `_from` argument MUST be the address of an account/contract sending the token. The `_to` argument MUST be the address of an account/contract receiving the token. The `_id` argument MUST be the token type being transferred. (represents NFT) The `_value` argument MUST be the number of tokens the holder balance is decrease by and match the recipient balance is increased by. */ event

MOTIVATION:
The conventional fractionalization process of fractionalizing a NFT to FT requires deployment of a FT token contract representing the ownership of NFT. This leads to inefficient bytecode usage on Ethereum Blockchain and limits functionalities since each token contract is separated into its own permissioned address. With the rise of multiple NFT projects needing to fractionalize NFT to FT, new type of token standard is needed to back up them.

RATIONALE:
**Metadata** The `symbol()` & `name()` functions were not included since the majority of users can just fetch it from the originating NFT contract. Also, copying the name & symbol every time when token gets added might place a lot of redundant bytecode on the Ethereum blockchain. However, according to the need and design of the project it could also be added to each token type by fetching the metadata from the NFT contract. **Design** Most of the decisions made around the design of this ERC were done to keep it as flexible for diverse token design & architecture.


=== ERC-7231 ===
TITLE: Identity-aggregated NFT
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-06-25
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 2, 7, 1

SUMMARY:
This standard extends [ERC-721](./eip-721.md) by binding individuals' Web2 and Web3 identities to non-fungible tokens (NFTs) and soulbound tokens (SBTs). By binding multiple identities, aggregated and composible identity infomation can be verified, resulting in more beneficial onchain scenarios for individuals, such as self-authentication, social overlapping, commercial value generation from user targetting, etc. By adding a custom schema in the metadata, and updating and verifying the schema hash in the contract, the binding of NFT and identity information is completed.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Every compliant contract must implement the Interface ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.15; interface IERC7231 { /** * @notice emit the use binding information * @param id nft id * @param identitiesRoot new identity root */ event SetIdentitiesRoot( uint256 id, bytes32 identitiesRoot ); /** * @notice * @dev set the user ID binding information of NFT with identitiesRoot * @param id nft id * @param identitiesRoot multi UserID

MOTIVATION:
One of the most interesting aspects of Web3 is the ability to bring an individual's own identity to different applications. Even more powerful is the fact that individuals truly own their accounts without relying on centralized gatekeepers, disclosing to different apps components necessary for authentication and approved by individuals. Exisiting solutions such as ENS, although open, decentralized, and more convenient for Ethereum-based applications, suffer from a lack of data standardization and authentication of identity due to inherent anominity. Other solutions such as SBTs rely on centralized attestors, can not prevent data tampering, and do not inscribe data into

RATIONALE:
Designing the proposal, we considered the following problems that are solved by this standard: ![EIP Flow Diagram](../assets/eip-7231/img/Identity-aggregated-NFT-flow.png) 1. Resolve the issue of multiple ID bindings for web2 and web3. By incorporating the MultiIdentities schema into the metadata file, an authorized bond is established between user identity information and NFTs. This schema encompasses a userID field that can be sourced from a variety of web2 platforms or a decentralized identity (DID) created on blockchain. By binding the NFT ID with the UserIDInfo array, it becomes possible to aggregate multiple identities seamlessly. 1. Users have full ownership and control of


=== ERC-2304 ===
TITLE: Multichain address resolution for ENS
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-09-09
REQUIRES: 137

SUMMARY:
This EIP introduces new overloads for the `addr` field for ENS resolvers, which permit resolution of addresses for other blockchains via ENS.

SPECIFICATION:
A new accessor function for resolvers is specified: ```solidity function addr(bytes32 node, uint coinType) external view returns(bytes memory); ``` The EIP165 interface ID for this function is 0xf1cb7e06. When called on a resolver, this function must return the cryptocurrency address for the specified namehash and coin type. A zero-length string must be returned if the specified coin ID does not exist on the specified node. `coinType` is the cryptocurrency coin type index from [SLIP44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md). The return value is the cryptocurency address in its native binary format. Detailed descriptions of the binary encodings for several popular chains are provided

MOTIVATION:
With the increasing uptake of ENS by multi-coin wallets, wallet authors have requested the ability to resolve addresses for non-Ethereum chains inside ENS. This specification standardises a way to enter and retrieve these addresses in a cross-client fashion.


=== ERC-7439 ===
TITLE: Prevent ticket touting
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-07-28
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md) and defines standard functions outlining a scope for ticketing agents or event organizers to take preventative actions to stop audiences being exploited in the ticket scalping market and allow customers to resell their tickets via authorized ticket resellers.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Interface The interface and structure referenced here are as follows: * TokenInfo * `signature`: Recommend that the adapter self-defines what to sign using the user's private key or agent's private key to prove the token validity. * `status`: Represent token current status. * `expireTime`: Recommend set to the event due time. * TokenStatus * `Sold`: When a token is sold, it MUST change

MOTIVATION:
Industrial-scale ticket touting has been a longstanding issue, with its associated fraud and criminal problems leading to unfortunate incidents and waste of social resources. It is also hugely damaging to artists at all levels of their careers and to related businesses across the board. Although the governments of various countries have begun to legislate to restrict the behavior of scalpers, the effect is limited. They still sold tickets for events at which resale was banned or did not yet own then obtained substantial illegal profits from speculative selling. We consulted many opinions to provide a consumer-friendly resale interface,

RATIONALE:
Designing the proposal, we considered the following questions: 1. What is the most crucial for ticketing agents, performers, and audiences? * For ticketing companies, selling out all tickets is crucial. Sometimes, to create a vibrant sales environment, ticketing companies may even collaborate with scalpers. This practice can be detrimental to both the audience and performers. To prevent such situations, there must be an open and transparent primary sales channel, as well as a fair secondary sales mechanism. In the `safeMint` function, which is a public function, we hope that everyone can mint tickets transparently at a listed price


=== ERC-2645 ===
TITLE: Hierarchical Deterministic Wallet for Layer-2
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-05-13
REQUIRES: 

SUMMARY:
We provide a Derivation Path allowing a user to derive hierarchical keys for Layer-2 solutions depending on the zk-technology, the application, the user’s Layer-1 address, as well as an efficient grinding method to enforce the private key distribution within the curve domain. The propose Derivation Path is defined as follow ``` m / purpose' / layer' / application' / eth_address_1' / eth_address_2' / index ```

SPECIFICATION:
Starkware keys are derived with the following [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki)-compatible derivation path, with direct inspiration from [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki): ``` m / purpose' / layer' / application' / eth_address_1' / eth_address_2' / index ``` where: * `m` - the seed. * `purpose` - `2645` (the number of this EIP). * `layer` - the 31 lowest bits of sha256 on the layer name. Serve as a domain separator between different technologies. In the context of `starkex`, the value would be `579218131`. * `application` - the 31 lowest bits of sha256 of the application name. Serve as a domain separator between different applications. In

MOTIVATION:
In the context of Computation Integrity Proof (CIP) Layer-2 solutions such as ZK-Rollups, users are required to sign messages on new elliptic curves optimized for those environments. Extensive work has been done to make it secure on Bitcoin via [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) and [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki). These protocols are the standard for wallets in the entire industry, independent of the underlying blockchain. As Layer-2 solutions are taking off, it is a necessary requirement to maintain the same standard and security in this new space.

RATIONALE:
This EIP specifies two aspects of keys derivation in the context of Hierarchical Wallets: - Derivation Path - Grinding Algorithm to enforce a uniform distribution over the elliptic curve. The derivation path is defined to allow efficient keys separation based on technology and application while maintaining a 1-1 relation with the Layer-1 wallet. In such a way, losing EIP-2645 wallets falls back to losing the Layer-1 wallet.


=== ERC-6785 ===
TITLE: ERC-721 Utilities Information Extension
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-27
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This specification defines standard functions and an extension of the metadata schema that outlines what a token's utility entails and how the utility may be used and/or accessed. This specification is an optional extension of [ERC-721](./eip-721.md).

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Every contract compliant with [ERC-6785](./eip-6785.md) MUST implement the interface defined as follows: ### Contract Interface ```solidity // @title NFT Utility description /// Note: the EIP-165 identifier for this interface is ed231d73 interface IERC6785 { // Logged when the utility description URL of an NFT is changed /// @notice Emitted when the utilityURL of an NFT is changed /// The empty string for `utilityUri` indicates that there is no utility associated

MOTIVATION:
This specification aims to clarify what the utility associated with an NFT is and how to access this utility. Relying on third-party platforms to obtain information regarding the utility of the NFT that one owns can lead to scams, phishing or other forms of fraud. Currently, utilities that are offered with NFTs are not captured on-chain. We want the utility of an NFT to be part of the metadata of an NFT. The metadata information would include: a) type of utility, b) description of utility, c) frequency and duration of utility, and d) expiration of utility. This will

RATIONALE:
Since the `utilityUri` could contain information that has to be restricted to some level and could be dependent on an off-chain tool for displaying said information, the creator needs the ability to modify it in the event the off-chain tool or platform becomes unavailable or inaccessible. For transparency purposes, having a `utilityHistoryOf` method will make it clear how the `utilityUri` has changed over time. For example, if a creator sells an NFT that gives holders a right to a video call with the creator, the metadata for this utility NFT would read as follows: ```json { "name": "...",


=== ERC-7538 ===
TITLE: Multiplicative Tokens
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-10-18
REQUIRES: 2, 0, ,,  , 1, 0, 4, 6, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP extends [ERC-1046](./eip-1046.md)-compatible token types (notably, [ERC-20](./eip-20.md) and [ERC-1155](./eip-1155.md) by introducing a `multiplier` field to the metadata schema, altering how user-facing balances are displayed.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The `MultiplierMetadata` interface MUST be implemented in the resolved ERC-1046 `tokenURI` of tokens that use a `multiplier`: ```typescript interface MultiplierMetadata { /** * The positive multiplier for generating user-facing representation. * Defaults to 1 if undefined. * This is an EXACT VALUE, base 10. Beware of floating-point error! **/ multiplier: string | undefined; /** * Decimals are no longer supported **/ decimals: never; }

MOTIVATION:
Many projects necessitate the creation of various types of tokens, both fungible and non-fungible. While certain standards are ideal for this purpose, they lack support for fractional tokens. Additionally, some tokens may require built-in inflation or deflation mechanisms, or may wish to allow transfers in unconventional increments, such as `0.5`.

RATIONALE:
Employing strings for numerical representation offers enhanced precision when needed. The use of a multiplier instead of decimals facilitates increments other than powers of 10, and ensures seamless handling of inflation or deflation. Utilizing ERC-1046 promotes gas efficiency in the majority of cases.


=== ERC-2135 ===
TITLE: Consumable Interface (Tickets, etc)
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2019-06-23
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP defines an interface to mark a digital asset as "consumable" and to react to its "consumption."

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. 1. Any compliant contract **MUST** implement the following interface: ```solidity pragma solidity >=0.7.0 <0.9.0; /// The ERC-165 identifier of this interface is 0xdd691946 interface IERC2135 { /// @notice The consume function consumes a token every time it succeeds. /// @param _consumer the address of consumer of this token. It doesn't have /// to be the EOA or contract Account that initiates the TX. /// @param _assetId the NFT asset

MOTIVATION:
Digital assets sometimes need to be consumed. One of the most common examples is a concert ticket. It is "consumed" when the ticket-holder enters the concert hall. Having a standard interface enables interoperability for services, clients, UI, and inter-contract functionalities on top of this use-case.

RATIONALE:
1. The function `consume` performs the consume action. This EIP does not assume: - who has the power to perform consumption - under what condition consumption can occur It does, however, assume the asset can be identified in a `uint256` asset id as in the parameter. A design convention and compatibility consideration is put in place to follow the ERC-721 pattern. 2. The event notifies subscribers whoever are interested to learn an asset is being consumed. 3. To keep it simple, this standard *intentionally* contains no functions or events related to the creation of a consumable asset. This


=== ERC-7699 ===
TITLE: ERC-20 Transfer Reference Extension
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-26
REQUIRES: 2, 0, ,,  , 1, 6, 5

SUMMARY:
The [ERC-20](./eip-20.md) token standard does not provide a built-in mechanism for including a payment transfer reference (message for recipient) in token transfers. This proposal extends the existing ERC-20 token standard by adding minimal methods to include a transfer reference in token transfers and transferFrom operations. The addition of a reference can help users, merchants, and service providers to associate and reconcile individual transactions with specific orders or invoices.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Any contract complying with ERC-20 when extended with this ERC, MUST implement the following interface: ``` // The EIP-165 identifier of this interface is 0x1522573a interface IERC7699 { function transfer(address to, uint256 amount, bytes calldata transferReference) external returns (bool); function transferFrom(address from, address to, uint256 amount, bytes calldata transferReference) external returns (bool); event TransferReference(bytes32 indexed loggedReference); } ``` These `transfer` and `transferFrom` functions, in addition to the standard transfer

MOTIVATION:
The primary motivation for this proposal is to improve the functionality of the ERC-20 token standard by providing a mechanism for including a payment reference in token transfers, similar to the traditional finance systems where payment references are commonly used to associate and reconcile transactions with specific orders, invoices or other financial records. Currently, users and merchants who want to include a payment reference in their transactions must rely on off chain external systems or custom payment proxy implementations. In traditional finance systems, payment references are often included in wire transfers and other types of electronic payments, making

RATIONALE:
### Parameter name The choice to name the added parameter `transferReference` was made to align with traditional banking terminology, where payment references are widely used to associate and reconcile transactions with specific orders, invoices or other financial records. The `transferReference` parameter name also helps to clearly communicate the purpose of the parameter and its role in facilitating the association and reconciliation of transactions. By adopting terminology that is well-established in the financial industry, the proposal aims to foster a greater understanding and adoption of the extended ERC-20 token standard. ### Parameter type The `transferReference` type is bytes. The


=== ERC-7796 ===
TITLE: Conditional send transaction RPC
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-16
REQUIRES: 

SUMMARY:
This EIP proposes a new JSON-RPC API method `eth_sendRawTransactionConditional` for block builders and sequencers, enhancing transaction integration by allowing users to express preconditions for transaction inclusion. This method aims to improve efficiency by reducing the need for transaction simulation, thereby improving the computational efficiency of transaction ordering.

SPECIFICATION:
* Method: `eth_sendRawTransactionConditional` * Parameters: 1. `transaction`: The raw, signed transaction data. Similar to `eth_sendRawTransaction`. 2. `options`: An object containing conditions under which the transaction must be included. * The `options` parameter may include any of the following optional members: * **knownAccounts**: a mapping of accounts with their expected storage slots' values. * The key of the mapping is account address. * A special key `balance` defines the expected balance of the account. * A special key `code` defines the expected code of the account. Use `""` to indicate that address is expected not to have any code.

MOTIVATION:
Current private block builder APIs, such as the Flashbots API, require block builders to simulate transactions to determine eligibility for inclusion, a process that is CPU-intensive and inefficient. The proposed RPC method addresses this by enabling transactions to specify preconditions, thus reducing computational overhead and potentially lowering transaction costs. Moreover, the flashbots API does not provide the block builder with a mechanism to determine the cross-dependencies of different transactions. The only way to guarantee that another transaction does not interfere with a given one is by placing it as the first transaction in the block. This makes this

RATIONALE:
The `knownAccounts` only allows specifying the exact values for storage slots. While in some cases specifying `minValue` or `maxValue` for a slot could be useful, it would significantly increase complexity of the proposed API. Additionally, determining the validity range for a slot value is a non-trivial task for the sender of a transaction. One way to provide a more complex rule for a transaction condition is by specifying the `paysCoinbase` parameter, and issuing a transfer to the `coinbase` address on some condition.


=== ERC-6065 ===
TITLE: Real Estate Token
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-11-29
REQUIRES: 721

SUMMARY:
This proposal introduces an open structure for physical real estate and property to exist on the blockchain. This standard builds off of [ERC-721](./eip-721.md), adding important functionality necessary for representing real world assets such as real estate. The three objectives this standard aims to meet are: universal transferability of the NFT, private property rights attached to the NFT, and atomic transfer of property rights with the transfer of the NFT. The token contains a hash of the operating agreement detailing the NFT holder’s legal right to the property, unique identifiers for the property, a debt value and foreclosure status,

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. In order to meet the above objectives and create an open standard for on-chain property ownership we have created a token structure that builds on the widely-used ERC-721 standard. ### Token Components: 1. Inherits ERC-721 - Allows for backwards compatibility with the most widely accepted NFT token standard. 2. operatingAgreementHashOf - immutable hash of the legal agreement detailing the right to ownership and conditions

MOTIVATION:
Real estate is the largest asset class in the world. By tokenizing real estate, barriers to entry are lowered, transaction costs are minimized, information asymmetry is reduced, ownership structures become more malleable, and a new building block for innovation is formed. However, in order to tokenize this asset class, a common standard is needed that accounts for its real world particularities while remaining flexible enough to adapt to various jurisdictions and regulatory environments. Ethereum tokens involving real world assets (RWAs) are notoriously tricky. This is because Ethereum tokens exist on-chain, while real estate exists off-chain. As such, the

RATIONALE:
### Introduction Real world assets operate in messy, non-deterministic environments. Because of this, validating the true state of an asset can be murky, expensive, or time-consuming. For example, in the U.S., change of property ownership is usually recorded at the County Recorder’s office, sometimes using pen and paper. It would be infeasible to continuously update this manual record every time an NFT transaction occurs on the blockchain. Additionally, since real world property rights are enforced by the court of law, it is essential that property ownership be documented in such a way that courts are able to interpret


=== ERC-7632 ===
TITLE: Interfaces for Named Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-08
REQUIRES: 165

SUMMARY:
Extends tokens using `uint256 tokenId` to support `tokenName` in type `string` and be able to convert backward to `tokenId`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. 1. Compliant contracts MUST support `tokenName` and mapping between `tokenName` and `tokenId` in one of the following ways: - 1a all compliant contracts are RECOMMENDED to implement the following interfaces: `IERC_NamedTokenCore`, ```solidity interface IERC_NamedTokenCore { function idToName(uint256 _tokenId) external view returns (string); function nameToId(string memory _tokenName) external returns (uint256); } ``` and it should satisfy the behavior rules that: - 1a.1. when a new

MOTIVATION:
For Marketplaces, Explorers, Wallets, DeFi and dApps to better display and operate NFTs that comes with a name.

RATIONALE:
1. We allow default way to map `tokenId` and `tokenName` for convenience, but we also allow contract to implement their own way to map `tokenId` and `tokenName` for flexibility. 2. We consider providing an interface for


=== ERC-902 ===
TITLE: Token Validation
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-02-14
REQUIRES: 1066


=== ERC-6900 ===
TITLE: Modular Smart Contract Accounts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-18
REQUIRES: 1, 6, 5, ,,  , 1, 2, 7, 1, ,,  , 4, 3, 3, 7

SUMMARY:
This proposal standardizes smart contract accounts and account modules, which are smart contracts that allow for composable logic within smart contract accounts. This proposal is compliant with [ERC-4337](./eip-4337.md). This standard emphasizes secure permissioning of modules, and maximal interoperability between all spec-compliant accounts and modules. This modular approach splits account functionality into three categories, implements them in external contracts, and defines an expected execution flow from accounts.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Terms - An **account** (or **smart contract account, SCA**) is a smart contract that can be used to send transactions and hold digital assets. It implements the `IAccount` interface from ERC-4337. - A **modular account** (or **modular smart contract account, MSCA**) is an account that supports modular functions. There are three types of modular functions: - **Validation functions** validate authorization on behalf of

MOTIVATION:
One of the goals that ERC-4337 accomplishes is abstracting the logic for execution and validation to each smart contract account. Many new features of accounts can be built by customizing the logic that goes into the validation and execution steps. Examples of such features include session keys, subscriptions, spending limits, and role-based access control. Currently, some of these features are implemented natively by specific smart contract accounts, and others are able to be implemented by proprietary module systems like Safe modules. However, managing multiple account implementations provides a poor user experience, fragmenting accounts across supported features and security

RATIONALE:
ERC-4337 compatible accounts must implement the `IAccount` interface, which consists of only one method that bundles validation with execution: `validateUserOp`. A primary design rationale for this proposal is to extend the possible functions for a smart contract account beyond this single method by unbundling these and other functions, while retaining the benefits of account abstraction. This proposal includes several interfaces that build on ERC-4337. First, we standardize a set of modular functions that allow smart contract developers greater flexibility in bundling validation, execution, and hook logic. We also propose interfaces that provide methods for querying execution functions, validation


=== ERC-5805 ===
TITLE: Voting with delegation
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-07-04
REQUIRES: 7, 1, 2, ,,  , 6, 3, 7, 2

SUMMARY:
Many DAOs (decentralized autonomous organizations) rely on tokens to represent one's voting power. In order to perform this task effectively, the token contracts need to include specific mechanisms such as checkpoints and delegation. The existing implementations are not standardized. This ERC proposes to standardize the way votes are delegated from one account to another, and the way current and past votes are tracked and queried. The corresponding behavior is compatible with many token types, including but not limited to [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md). This ERC also considers the diversity of time tracking functions, allowing the voting tokens (and any

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Following pre-existing (but not-standardized) implementation, the EIP proposes the following mechanism. Each user account (address) can delegate to an account of its choice. This can be itself, someone else, or no one (represented by `address(0)`). Assets held by the user cannot express their voting power unless they are delegated. When a "delegator" delegates its tokens voting power to a "delegatee", its balance is added to the voting power of

MOTIVATION:
Beyond simple monetary transactions, decentralized autonomous organizations are arguably one of the most important use cases of blockchain and smart contract technologies. Today, many communities are organized around a governance contract that allows users to vote. Among these communities, some represent voting power using transferable tokens ([ERC-20](./eip-20.md), [ERC-721](./eip-721.md), other). In this context, the more tokens one owns, the more voting power one has. Governor contracts, such as Compound's `GovernorBravo`, read from these "voting token" contracts to get the voting power of the users. Unfortunately, simply using the `balanceOf(address)` function present in most token standards is not good enough:

RATIONALE:
Delegation allows token holders to trust a delegate with their vote while keeping full custody of their token. This means that only a small-ish number of delegates need to pay gas for voting. This leads to better representation of small token holders by allowing their votes to be cast without requiring them to pay expensive gas fees. Users can take over their voting power at any point, and delegate it to someone else, or to themselves. The use of checkpoints prevents double voting. Votes, for example in the context of a governance proposal, should rely on a snapshot


=== ERC-3448 ===
TITLE: MetaProxy Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2021-03-29
REQUIRES: 

SUMMARY:
By standardizing on a known minimal bytecode proxy implementation with support for immutable metadata, this standard allows users and third party tools (e.g. Etherscan) to: (a) simply discover that a contract will always redirect in a known manner and (b) depend on the behavior of the code at the destination contract as the behavior of the redirecting contract and (c) verify/view the attached metadata. Tooling can interrogate the bytecode at a redirecting address to determine the location of the code that will run along with the associated metadata - and can depend on representations about that code (verified

SPECIFICATION:
The exact bytecode of the MetaProxy contract is: ``` 20 bytes target contract address ---------------------------------------- 363d3d373d3d3d3d60368038038091363936013d7300000000000000000000000000000000000000005af43d3d93803e603457fd5bf3 ``` wherein the bytes at indices 21 - 41 (inclusive) are replaced with the 20 byte address of the master functionality contract. Additionally, everything after the MetaProxy bytecode can be arbitrary metadata and the last 32 bytes (one word) of the bytecode must indicate the length of the metadata in bytes. ``` <54 bytes metaproxy> <arbitrary data> <length in bytes of arbitrary data (uint256)> ```

MOTIVATION:
This standard supports use-cases wherein it is desirable to clone exact contract functionality with different parameters at another address.

RATIONALE:
The goals of this effort have been the following: - a cheap way of storing immutable metadata for each child instead of using storage slots - inexpensive deployment of clones - handles error return bubbling for revert messages


=== ERC-7562 ===
TITLE: Account Abstraction Validation Scope Rules
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-01
REQUIRES: 

SUMMARY:
This document describes the rules Account Abstraction protocols should follow, during the validation phase of Account Abstraction transactions, such as [ERC-4337](./eip-4337) `UserOperation` or RIP-7560 (Native Account Abstraction), which are enforced off-chain by a block builder or a standalone bundler, and the rationale behind each one of them.

SPECIFICATION:
### Validation Rules Types We define two types of validation rules: **network-wide rules** and **local rules**. A violation of any validation rule by a UserOperation results in the UserOperation being dropped from the mempool and excluded from a bundle. **Network-wide rule** is a rule, that its violation by a UserOperation validation should result in a reputation damage for the peer bundler that sent this UserOperation in the p2p mempool. A peer bundler with a critically low reputation will eventually be marked as a malicious **spammer** peer. **Local rule** is a rule that is enforced in the context of

MOTIVATION:
With Account-Abstraction, instead of hard-coded logic for processing a transaction (validation, gas-payment, and execution), this logic is executed by EVM code. The benefits for the account are countless - - abstracting the validation allows the contract to use different signature schemes, multisig configuration, custom recovery, and more. - abstracting gas payments allows easy onboarding by 3rd party payments, paying with tokens, cross-chain gas payments - abstracting execution allows batch transactions All of the above are missing from the EOA account model. However, there is one rule a transaction must follow to preserve the decentralized network: once submitted into

RATIONALE:
All transactions initiated by EOAs have an implicit validation phase where balance, nonce, and signature are checked to be valid for the current state of the Ethereum blockchain. Once the transaction is checked to be valid by a node, only another transaction by the same EOA can modify the Ethereum state in a way that makes the first transaction invalid. With Account Abstraction, however, the validation can also include an arbitrary EVM code and rely on storage as well, which means that unrelated `UserOperations` or transactions may invalidate each other. If not addressed, this would make the job


=== ERC-7820 ===
TITLE: Access Control Registry
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2024-11-19
REQUIRES: 

SUMMARY:
The Access Control Registry (ACR) standard defines a universal interface for managing role-based access control across multiple smart contracts. This standard introduces a centralized registry system allowing access control management for multiple smart contracts. The single access-control registry smart contract manages the user roles across multiple contracts, and can be queryed for contract-specific role information. Additionally, the ACR standard provides functionality to grant and revoke roles for specific accounts, either individually or in bulk, ensuring that only authorized users can perform specific actions within a specific contract. The core of the standard includes: - **Registration and Unregistration**: Contracts

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. The `AccessControlRegistry` contract provides a standardized interface for managing access control in Ethereum smart contracts. It includes functions to register and unregister contracts, grant and revoke roles for specific contracts, and check if an account has a particular role in a registered contract. Events are emitted for contract registration, unregistration, role grants, and role revocations, ensuring transparency and traceability of access control changes. Additionally,

MOTIVATION:
As decentralized applications (dApps) grow in complexity, managing access control across multiple smart contracts becomes increasingly difficult. Current practices involve bespoke implementations, leading to redundancy and potential security flaws. A standardized approach for managing roles and permissions will ensure better interoperability, security, and transparency. By providing a unified interface for registering contracts and managing roles, this standard simplifies development, ensures consistency and enhances security. It facilitates easier integration and auditing, fostering a more robust and interoperable ecosystem. The advantages of using the provided system might be: Structured smart contracts management via specialized contracts. Ad-hoc access-control provision of a

RATIONALE:
The `IAccessControlRegistry` interface aims to provide a standardized way to manage access control across multiple contracts within the ecosystem. By defining a clear structure and set of events, this interface helps streamline the process of registering, unregistering, and managing roles for contracts. The rationale for each function and event is as follows: ### Contract Registration and Unregistration **`registerContract(address _admin)`**: This function allows the registration of a new contract along with its admin address. This is crucial for initializing the access control settings for a contract and ensuring that there is an accountable admin who can manage roles and


=== ERC-4626 ===
TITLE: Tokenized Vaults
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2021-12-22
REQUIRES: 2, 0, ,,  , 2, 6, 1, 2

SUMMARY:
The following standard allows for the implementation of a standard API for tokenized Vaults representing shares of a single underlying [EIP-20](./eip-20.md) token. This standard is an extension on the EIP-20 token that provides basic functionality for depositing and withdrawing tokens and reading balances.

SPECIFICATION:
All [EIP-4626](./eip-4626.md) tokenized Vaults MUST implement EIP-20 to represent shares. If a Vault is to be non-transferrable, it MAY revert on calls to `transfer` or `transferFrom`. The EIP-20 operations `balanceOf`, `transfer`, `totalSupply`, etc. operate on the Vault "shares" which represent a claim to ownership on a fraction of the Vault's underlying holdings. All EIP-4626 tokenized Vaults MUST implement EIP-20's optional metadata extensions. The `name` and `symbol` functions SHOULD reflect the underlying token's `name` and `symbol` in some way. EIP-4626 tokenized Vaults MAY implement [EIP-2612](./eip-2612.md) to improve the UX of approving shares on various integrations. ### Definitions: - asset:

MOTIVATION:
Tokenized Vaults have a lack of standardization leading to diverse implementation details. Some various examples include lending markets, aggregators, and intrinsically interest bearing tokens. This makes integration difficult at the aggregator or plugin layer for protocols which need to conform to many standards, and forces each protocol to implement their own adapters which are error prone and waste development resources. A standard for tokenized Vaults will lower the integration effort for yield-bearing vaults, while creating more consistent and robust implementation patterns.

RATIONALE:
The Vault interface is designed to be optimized for integrators with a feature complete yet minimal interface. Details such as accounting and allocation of deposited tokens are intentionally not specified, as Vaults are expected to be treated as black boxes on-chain and inspected off-chain before use. EIP-20 is enforced because implementation details like token approval and balance calculation directly carry over to the shares accounting. This standardization makes the Vaults immediately compatible with all EIP-20 use cases in addition to EIP-4626. The mint method was included for symmetry and feature completeness. Most current use cases of share-based Vaults


=== ERC-5539 ===
TITLE: Revocation List Registry
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-26
REQUIRES: 712

SUMMARY:
This EIP proposes a set of methods and standards for a role-based registry of indicators aimed for usage in revocations.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. This EIP specifies a contract called `EthereumRevocationRegistry` that is deployed once and may then be commonly used by everyone. By default, an Ethereum address **MAY** own and manage a multitude of revocation lists in a namespace that **MUST** contain the revocation states for a set of revocation keys. An owner of a namespace **MAY** allow delegates to manage one or more of its revocation lists. Delegates **MUST** be removable

MOTIVATION:
Revocation is a universally needed construct both in the traditional centralized and decentralized credential attestation. This EIP aims to provide an interface to standardize a decentralized approach to managing and resolving revocation states in a contract registry. The largest problem with traditional revocation lists is the centralized aspect of them. Most of the world's CRLs rely on HTTP servers as well as caching and are therefore vulnerable to known attack vectors in the traditional web space. This aspect severely weakens the underlying strong asymmetric key architecture in current PKI systems. In addition, issuers in existing CRL approaches are

RATIONALE:
### Why the concept of namespaces? This provides every Ethereum address a reserved space, without the need to actively claim it in the contract. Initially addresses only have owner access in their own namespace. ### Why does a namespace always represent the initial owner address? The change of an owner of a list shouldn't break the link to a revocation key in it, as already existing off-chain data may depend on it.


=== ERC-1129 ===
TITLE: Standardised DAPP announcements
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-31
REQUIRES: 

SUMMARY:
The proposed ERC defines format on how to post announcements about the service as well as how to remove them. It also defines mechanics on posting permissions and human friendly interface.

SPECIFICATION:
### Structures #### Announcer Stores information about the announcement maker. The `allowedToPost` stores posting permissions and is used for modifiers limiting announcement posting only to authorised entities. The `name` is used for human friendly identifier of the author to be stored. ``` js struct Announcer{ bool allowedToPost; string name; } ``` #### Announcement Stores information about the individual announcement. The human friendly author identifier is stored in `author`. Ethereum address associated with the author is stored in `authorAddress`. The announcement itself is stored in `post`. ``` js struct Announcement{ string author; address authorAddress; string post; } ``` ###

MOTIVATION:
Currently there are no guidelines on how to notify the users of the service status in the DAPPs. This is especially obvious in ERC20 and it's derivates. If the service is impeded by any reason it is good practice to have some sort of guidelines on how to announce that to the user. The standardisation would also provide traceability of the service's status.

RATIONALE:
The proposed solution was designed with UX in mind . It provides mechanics that serve to present the announcements in the user friendly way. It is meant to be deployed as a Solidity smart contract on Ethereum network.


=== ERC-6808 ===
TITLE: Fungible Key Bound Token
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-03-31
REQUIRES: 20

SUMMARY:
A standard interface for Fungible Key Bound Tokens (**FKBT/s**), a subset of the more general Key Bound Tokens (**KBT/s**). The following standardizes an API for tokens within smart contracts and provides basic functionality to the [addBindings](#addbindings-function) function. This function designates **Key Wallets**[^1], which are responsible for conducting a **Safe Transfer**[^2]. During this process, **FKBT's** are safely approved so they can be spent by the user or an on-chain third-party entity. The premise of **FKBT's** is to provide fully optional security features built directly into the fungible asset, via the concept of _allow_ found in the [allowTransfer](#allowtransfer-function) and [allowApproval](#allowapproval-function)

SPECIFICATION:
### `IKBT20` (Token Contract) **NOTES**: - The following specifications use syntax from Solidity `0.8.0` (or above) - Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned! ```solidity interface IKBT20 { event AccountSecured(address _account, uint256 _amount); event AccountResetBinding(address _account); event SafeFallbackActivated(address _account); event AccountEnabledTransfer( address _account, uint256 _amount, uint256 _time, address _to, bool _allFunds ); event AccountEnabledApproval( address _account, uint256 _time, uint256 _numberOfTransfers ); event Ingress(address _account, uint256 _amount); event Egress(address _account, uint256 _amount); struct AccountHolderBindings { address firstWallet; address secondWallet; } struct FirstAccountBindings { address accountHolderWallet; address secondWallet; } struct

MOTIVATION:
In this fast-paced technologically advancing world, people learn and mature at different speeds. The goal of global adoption must take into consideration the target demographic is of all ages and backgrounds. Unfortunately for self-custodial assets, one of the greatest pros is also one of its greatest cons. The individual is solely responsible for their actions and adequately securing their assets. If a mistake is made leading to a loss of funds, no one is able to guarantee their return. From January 2021 through March 2022, the United States Federal Trade Commission received more than 46,000[^5] crypto scam reports.

RATIONALE:
The intent from individual technical decisions made during the development of **FKBTs** focused on maintaining consistency and backward compatibility with ERC-20s, all the while offering self-custodial security features to the user. It was important that **FKBT's** inherited all of ERC-20s characteristics to comply with requirements found in dApps which use fungible tokens on their platform. In doing so, it allowed for flawless backward compatibility to take place and gave the user the choice to decide if they want their **FKBTs** to act with **Default Behaviors**[^4]. We wanted to ensure that wide-scale implementation and adoption of **FKBTs** could take


=== ERC-1191 ===
TITLE: Add chain id to mixed-case checksum address encoding
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2018-03-18
REQUIRES: 5, 5, ,,  , 1, 5, 5

SUMMARY:
The [EIP-55](./eip-55.md) was created to prevent users from losing funds by sending them to invalid addresses. This EIP extends [EIP-55](./eip-55.md) to protect users from losing funds by sending them to addresses that are valid but that where obtained from a client of another network.For example, if this EIP is implemented, a wallet can alert the user that is trying to send funds to an Ethereum Testnet address from an Ethereum Mainnet wallet.

SPECIFICATION:
Convert the address using the same algorithm defined by [EIP-55](./eip-55.md) but if a registered chain id is provided, add it to the input of the hash function. If the chain id passed to the function belongs to a network that opted for using this checksum variant, prefix the address with the chain id and the `0x` separator before calculating the hash. Then convert the address to hexadecimal, but if the ith digit is a letter (ie. it's one of `abcdef`) print it in uppercase if the 4*ith bit of the calculated hash is 1 otherwise print it in

MOTIVATION:
The motivation of this proposal is to provide a mechanism to allow software to distinguish addresses from different Ethereum based networks. This proposal is necessary because Ethereum addresses are hashes of public keys and do not include any metadata. By extending the [EIP-55](./eip-55.md) checksum algorithm it is possible to achieve this objective.

RATIONALE:
Benefits: - By means of a minimal code change on existing libraries, users are protected from losing funds by mixing addresses of different Ethereum based networks.


=== ERC-6047 ===
TITLE: ERC-721 Balance indexing via Transfer event
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-11-26
REQUIRES: 721

SUMMARY:
This EIP extends [ERC-721](./eip-721.md) to allow the tracking and indexing of NFTs by mandating that a pre-existing event be emitted during contract creation. ERC-721 requires a `Transfer` event to be emitted whenever a transfer or mint (i.e. transfer from `0x0`) or burn (i.g. transfer to `0x0`) occurs, **except during contract creation**. This EIP mandates that compliant contracts emit a `Transfer` event **regardless of whether it occurs during or after contract creation.**

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. 1. Compliant contracts MUST implement [ERC-721](./eip-721.md) 2. Compliant contracts MUST emit a `Transfer` event whenever a token is transferred, minted (i.e. transferred from `0x0`), or burned (i.g. transferred to `0x0`), **including during contract creation.**

MOTIVATION:
[ERC-721](./eip-721.md) requires a `Transfer` event to be emitted whenever a transfer or mint (i.e. transfer from `0x0`) or burn (i.e. transfer to `0x0`) occurs, EXCEPT for during contract creation. Due to this exception, contracts can mint NFTs during contract creation without the event being emitted. Unlike ERC-721, the [ERC-1155](./eip-1155.md) standard mandates events to be emitted regardless of whether such minting occurs during or outside of contract creation. This allows an indexing service or any off-chain service to reliably capture and account for token creation. This EIP removes this exception granted by ERC-721 and mandates emitting the `Transfer` for

RATIONALE:
Using the existing `Transfer` event instead of creating a new event (e.g. `Creation`) allows this EIP to be backward compatible with existing indexers.E


=== ERC-4834 ===
TITLE: Hierarchical Domains
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-02-22
REQUIRES: 

SUMMARY:
This is a standard for generic name resolution with arbitrarily complex access control and resolution. It permits a contract that implements this EIP (referred to as a "domain" hereafter) to be addressable with a more human-friendly name, with a similar purpose to [ERC-137](./eip-137.md) (also known as "ENS").

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Contract Interface ```solidity interface IDomain { /// @notice Query if a domain has a subdomain with a given name /// @param name The subdomain to query, in right to left order /// @return `true` if the domain has a subdomain with the given name, `false` otherwise function hasDomain(string[] memory name) external view returns (bool); /// @notice Fetch the subdomain with a given name /// @dev This should revert

MOTIVATION:
The advantage of this EIP over existing standards is that it provides a minimal interface that supports name resolution, adds standardized access control, and has a simple architecture. ENS, although useful, has a comparatively complex architecture and does not have standard access control. In addition, all domains (including subdomains, TLDs, and even the root itself) are actually implemented as domains, meaning that name resolution is a simple iterative algorithm, not unlike DNS itself.

RATIONALE:
This EIP's goal, as mentioned in the abstract, is to have a simple interface for resolving names. Here are a few design decisions and why they were made: - Name resolution algorithm - Unlike ENS's resolution algorithm, this EIP's name resolution is fully under the control of the contracts along the resolution path. - This behavior is more intuitive to users. - This behavior allows for greater flexibility - e.g. a contract that changes what it resolves to based on the time of day. - Parent domain access control - A simple "ownable" interface was not used because


=== ERC-5521 ===
TITLE: Referable NFT
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-08-10
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It proposes two referable indicators, referring and referred, and a time-based indicator `createdTimestamp`. The relationship between each NFT forms a directed acyclic graph (DAG). The standard allows users to query, track and analyze their relationships. ![System Architecture](../assets/eip-5521/system-arch.png)

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. - `UpdateNode`: event emitted when `setNode` is invoked; - `safeMint`: mint a new rNFT; - `setNode`: set the referring list of an rNFT and update the referred list of each one in the referring list; - `setNodeReferring`: set the referring list of an rNFT; - `setNodeReferred`: set the referred list of the given rNFTs sourced from different contracts; - `setNodeReferredExternal`: set the referred list of the given rNFTs sourced

MOTIVATION:
Many scenarios require the inheritance, reference, and extension of NFTs. For instance, an artist may develop his NFT work based on a previous NFT, or a DJ may remix his record by referring to two pop songs, etc. A gap in existing NFT standards is the absence of established relationships between an NFT and its original creator. This void isolates NFTs, rendering the sale of each one a one-off transaction, thereby obstructing creators from accruing the full value of their intellectual property over time. In this sense, proposing a referable solution for existing NFTs that enables efficient queries

RATIONALE:
### Is this event informative enough? `UpdateNode`: This event disseminates crucial information, including the rNFT ID, its owner, and lists of contract addresses/IDs with rNFTs referring to or referred by the subject rNFT. This data set enables stakeholders to efficiently manage and navigate the complex web of relationships inherent in the rNFT ecosystem. Implementers are free to choose to use a struct (a recommended struct is given in the Reference Implementation), or several separate mappings, or whatever other storage mechanism. Whichever mechanism chosen has no observable effect on the behaviour of the contract, as long as its output


=== ERC-7589 ===
TITLE: Semi-Fungible Token Roles
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-12-28
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This standard introduces role management for SFTs (Semi-Fungible Tokens). Each role assignment is granted to a single user (grantee) and expires automatically. Roles are defined as `bytes32` and feature a custom `_data` field of arbitrary size to allow customization.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Compliant contracts MUST implement the following interface: ```solidity /// @title ERC-7589 Semi-Fungible Token Roles /// @dev See https://eips.ethereum.org/EIPS/eip-7589 /// Note: the ERC-165 identifier for this interface is 0xc4c8a71d. interface IERC7589 /* is IERC165 */ { /** Events **/ /// @notice Emitted when tokens are committed (deposited or frozen). /// @param _grantor The owner of the SFTs. /// @param _commitmentId The identifier of the commitment created.

MOTIVATION:
[ERC-1155](./eip-1155.md) has significantly contributed to the tokenization capabilities of Ethereum by enabling developers to create fungible and non-fungible tokens with a single contract. While [ERC-1155](./eip-1155.md) excels at tracking ownership, it focuses solely on token balances, overlooking the nuanced aspects of how these tokens can be utilized. An essential aspect of token utility is access control, which determines who has permission to spend or use these tokens. In some cases, the owner has complete control over its balance. Nevertheless, in many others, the utility can be delegated (or granted) to other users, allowing for more complex use cases to

RATIONALE:
The concept of "token commitments" as an abstraction serves as a powerful tool for users looking to delegate the control of their SFTs. A token commitment represents either a frozen balance or tokens deposited into a contract, offering a standardized and secure way for SFT owners to delegate the use of their assets. Through [ERC-7589](./eip-7589.md), users gain a versatile mechanism to abstract the complexities of secure delegation, enhancing the utility and interoperability of semi-fungible tokens. [ERC-7589](./eip-7589.md) IS NOT an extension of [ERC-1155](./eip-1155.md). The main reason behind this decision is to keep the standard agnostic of any implementation. This


=== ERC-2767 ===
TITLE: Contract Ownership Governance
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-07-04
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 1, 7, 3

SUMMARY:
The following standard defines the implementation of a standard API for a Governance smart contract based on `ERC-20`. Existing `ERC-173` compatible contracts can upgrade from private key wallet ownership to a Governance smart contract. Adhering to a standard API enables general tools to populate governance information of various projects, thus increasing transparency.

SPECIFICATION:
A Governance contract that is compliant with `ERC-2767` shall implement the following interfaces: ```solidity /// @title ERC-2767 Governance /// @dev ERC-165 InterfaceID: 0xd8b04e0e interface ERC2767 is ERC165 { /// @notice Gets number votes required for achieving consensus /// @dev Should cost less than 30000 gas /// @return Required number of votes for achieving consensus function quorumVotes() external view returns (uint256); /// @notice The address of the Governance ERC20 token function token() external view returns (address); } ``` ### `ERC-20` Governance Token An `ERC-2767` Governance Contract should reference an address through `token()` that implements `ERC-20` interface. `token()` is allowed

MOTIVATION:
Traditionally, many contracts that require that they be owned or controlled in some way use `ERC-173` which standardized the use of ownership in the smart contracts. For example to withdraw funds or perform administrative actions. ```solidity contract dApp { function doSomethingAdministrative() external onlyOwner { // admin logic that can be performed by a single wallet } } ``` Often, such administrative rights for a contract are written for maintenance purpose but users need to trust the owner. Rescue operations by an owner have raised questions on decentralised nature of the projects. Also, there is a possibility of compromise

RATIONALE:
The goals of this EIP have been the following: - Standardize API of Governance contracts to make it easy for analysis tools to be built. - Encourage use of `ERC-20` based weighted governance over existing multi-sig (_generally limited to 50 max owners_) for big projects. - Encourage existing `ERC-173` ownership smart contracts / projects to move to Governance based ownership by removing the effort needed to host custom UI for their project. - Encourage availability of publicly audited governance contracts, just like `ERC-20` which anyone can use. - Make it possible to utilize existing `ERC-20` tools for owners


=== ERC-5573 ===
TITLE: Sign-In with Ethereum Capabilities, ReCaps
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2021-07-20
REQUIRES: 4361

SUMMARY:
[ERC-4361](./eip-4361.md), or Sign-In with Ethereum (SIWE), describes how Ethereum accounts authenticate with off-chain services. This proposal, known as ReCaps, describes a mechanism on top of SIWE to give informed consent to authorize a Relying Party to exercise certain scoped capabilities. How a Relying Party authenticates against the target resource is out of scope for this specification and depends on the implementation of the target resource.

SPECIFICATION:
This specification has three different audiences: - Web3 application developers that want to integrate ReCaps to authenticate with any protocols and APIs that support object capabilities. - Protocol or API developers that want to learn how to define their own ReCaps. - Wallet implementers that want to improve the UI for ReCaps. ### Terms and Definitions - ReCap - A SIWE Message complying with this specification, i.e. containing at least one ReCap URI in the `Resources` section and the corresponding human-readable ReCap Statement appended to the SIWE `statement`. - ReCap URI - A type of URI that resolves

MOTIVATION:
SIWE ReCaps unlock integration of protocols and/or APIs for developers by reducing user friction, onchain state and increasing security by introducing informed consent and deterministic capability objects on top of Sign-In With Ethereum (ERC-4361). While SIWE focuses on authenticating the Ethereum account against the service (relying party or SIWE client) initiating the SIWE flow, there is no canonical way for the authenticated Ethereum account to authorize a relying party to interact with a third-party service (resource service) on behalf of the Ethereum account. A relying party may want to interact with another service on behalf of the Ethereum

RATIONALE:
TBD


=== ERC-7085 ===
TITLE: NFT Relationship Enhancement
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-05-02
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This proposal builds on [ERC-1155](./eip-1155.md) and creates a standard for referring relationships and quantifiable attributes between non-isolated [ERC-721](./eip-721.md) or [ERC-1155](./eip-1155.md) non-fungible tokens (NFTs). It enables users to build a graph of NFTs and set quantifiable attributes for each NFT, facilitating more complex NFT ecosystems. While a similar proposal exists for [ERC-721](./eip-721.md) tokens, it does not provide a way to establish quantifiable relationships or object attributes.

SPECIFICATION:
This EIP proposes the addition of five new functions to the [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) standards: `setRelationship`, `setAttribute`, `getRelationship`, `getAttribute`, and `getAttributeNames`. These functions allow users to establish referring relationships and set quantifiable attributes between NFTs. ### `setRelationship` The `setRelationship` function establishes a referring relationship between two NFTs. It takes the following parameters: ```solidity function setRelationship(uint256 _originalID, uint256 _derivativeID, uint256 _attribute) external; ``` - `_originalID`: the ID of the original NFT - `_derivativeID`: the ID of the derivative NFT that refers to the original NFT - `_attribute`: the quantifiable attribute for this relationship, which defaults to 1 if not

MOTIVATION:
The current standard for NFTs lacks the ability to establish relationships and attributes between tokens. This limitation makes it difficult for users to build more complex NFT ecosystems that require referring relationships and quantifiable attributes between tokens. For example, a user may create a derivative NFT that refers to the original NFT and sets a quantifiable attribute for the relationship between the two NFTs, but without a standardized way to establish relationships and attributes between NFTs, managing these ecosystems becomes increasingly difficult and inefficient. This proposal aims to address this issue by extending the [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) standards

RATIONALE:
In developing this EIP, some key design decisions were made. For example, we limited the complexity of the relationship graph that can be created by only allowing for one referring relationship between two NFTs. This helps to ensure that the graph remains manageable and does not become too complex to be useful. Additionally, we kept the gas cost of setting attributes to a minimum by only allowing for one attribute to be set at a time. While there are currently no similar features in other blockchain languages or standards, we drew inspiration from the concept of Graph Theory,


=== ERC-801 ===
TITLE: Canary Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2017-12-16
REQUIRES: 

SUMMARY:
The following standard allows the implementation of canaries within contracts. This standard provides basic functionality to check if a canary is alive, keeping the canary alive and optionally manage feeders.

SPECIFICATION:
### Methods #### isAlive() Returns if the canary was fed properly to signal e.g. that no warrant was received. ``` js function isAlive() constant returns (bool alive) ``` #### getBlockOfDeath() Returns the block the canary died. Throws if the canary is alive. ``` js function getBlockOfDeath() constant returns (uint256 block) ``` #### getType() Returns the type of the canary: * `1` = Simple (just the pure interface as defined in this ERC) * `2` = Single feeder (as defined in ERC-TBD) * `3` = Single feeder with bad food (as defined in ERC-TBD) * `4` = Multiple feeders

MOTIVATION:
The canary can e.g. be used as a [warrant canary](https://en.wikipedia.org/wiki/Warrant_canary). A standard interface allows other applications to easily interface with canaries on Ethereum - e.g. for visualizing the state, automated alarms, applications to feed the canary or contracts (e.g. insurance) that use the state.


=== ERC-5131 ===
TITLE: SAFE Authentication For ENS
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-06-03
REQUIRES: 1, 3, 7, ,,  , 1, 8, 1, ,,  , 6, 3, 4

SUMMARY:
This EIP links one or more signing wallets via Ethereum Name Service Specification ([EIP-137](./eip-137.md)) to prove control and asset ownership of a main wallet.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Let: - `mainAddress` represent the wallet address we are trying to authenticate or prove asset ownership for. - `mainENS` represent the reverse lookup ENS string for `mainAddress`. - `authAddress` represent the address we want to use for signing in lieu of `mainAddress`. - `authENS` represent the reverse lookup ENS string for `authAddress`. - `authKey` represents a string in the format `[0-9A-Za-z]+`. Control of `mainAddress` and ownership of `mainAddress` assets

MOTIVATION:
Proving ownership of an asset to a third party application in the Ethereum ecosystem is common. Users frequently sign payloads of data to authenticate themselves before gaining access to perform some operation. However, this method--akin to giving the third party root access to one's main wallet--is both insecure and inconvenient. ***Examples:*** 1. In order for you to edit your profile on OpenSea, you must sign a message with your wallet. 2. In order to access NFT gated content, you must sign a message with the wallet containing the NFT in order to prove ownership. 3. In order to

RATIONALE:
### Usage of EIP-137 The proposed specification makes use of EIP-137 rather than introduce another registry paradigm. The reason for this is due to the existing wide adoption of EIP-137 and ENS. However, the drawback to EIP-137 is that any linked `authAddress` must contain some ETH in order to set the `authENS` reverse record as well as the `eip5131:vault` TEXT record. This can be solved by a separate reverse lookup registry that enables `mainAddress` to set the reverse record and TEXT record with a message signed by `authAddress`. With the advent of L2s and ENS Layer 2 functionalities,


=== ERC-7201 ===
TITLE: Namespaced Storage Layout
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-06-20
REQUIRES: 

SUMMARY:
We define the NatSpec annotation `@custom:storage-location` to document storage namespaces and their location in storage in Solidity or Vyper source code. Additionally, we define a formula to derive a location from an arbitrary identifier. The formula is chosen to be safe against collisions with the storage layouts used by Solidity and Vyper.

SPECIFICATION:
### Preliminaries A _namespace_ consists of a set of ordered variables, some of which may be dynamic arrays or mappings, with its values laid out following the same rules as the default storage layout but rooted in some location that is not necessarily slot 0. A contract using namespaces to organize storage is said to use _namespaced storage_. A _namespace id_ is a string that identifies a namespace in a contract. It should not contain any whitespace characters. ### `@custom:storage-location` A namespace in a contract should be implemented as a struct type. These structs should be annotated with

MOTIVATION:
Smart contract languages such as Solidity and Vyper rely on tree-shaped storage layout. This tree starts at slot 0 and is composed of sequential chunks for consecutive variables. Hashes are used to ensure the chunks containing values of mappings and dynamic arrays do not collide. This is sufficient for most contracts. However, it presents a challenge for various design patterns used in smart contract development. One example is a modular design where using `DELEGATECALL` a contract executes code from multiple contracts, all of which share the same storage space, and which have to carefully coordinate on how to

RATIONALE:
The tree-shaped storage layout used by Solidity and Vyper follows the following grammar (with root=0): $L_{root} := \mathit{root} \mid L_{root} + n \mid \texttt{keccak256}(L_{root}) \mid \texttt{keccak256}(H(k) \oplus L_{root}) \mid \texttt{keccak256}(L_{root} \oplus H(k))$ A requirement for the root is that it shouldn't overlap with any storage location that would be part of the standard storage tree used by Solidity and Vyper (root = 0), nor should it be part of the storage tree derived from any other namespace (another root). This is so that multiple namespaces may be used alongside each other and alongside the standard storage layout, either


=== ERC-6997 ===
TITLE: ERC-721 with transaction validation step.
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-05-07
REQUIRES: 721

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It defines new validation functionality to avoid wallet draining: every `transfer` or `approve` will be locked waiting for validation.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. [ERC-721](./eip-721.md) compliant contracts MAY implement this EIP. All the operations that change the ownership of an NFT, like a `transferFrom`/`safeTransferFrom`, SHALL create a `TransferValidation` pending to be validated and emit a `ValidateTransfer`, and SHALL NOT transfer the ownership of an NFT. All the operations that enable an approval to manage an NFT, like an `approve`/`setApprovalForAll`, SHALL create an `ApprovalValidation` pending to be validated and emit a `ValidateApproval`, and SHALL NOT

MOTIVATION:
The power of the blockchain is at the same time its weakness: giving the user full responsibility for their data. Many cases of NFT theft currently exist, and current NFT anti-theft schemes, such as transferring NFTs to cold wallets, make NFTs inconvenient to use. Having a validation step before every `transfer` and `approve` would give Smart Contract developers the opportunity to create secure NFT anti-theft schemes. An implementation example would be a system where a validator address is responsible for validating all Smart Contract transactions. This address would be connected to a dApp where the user could see

RATIONALE:
### Universality The standard only defines the validation functions, but not how they should be used. It defines the validations as internal and lets the user decide how to manage them. An example could be to have an address validator connected to a dApp so that users could manage their validations. This validator could be used for all NFTs or only for some users. It could also be used as a wrapped Smart Contract for existing ERC-721, allowing 1/1 conversion with existing NFTs. ### Extensibility This standard only defines the validation function, but does not define the system


=== ERC-4974 ===
TITLE: Ratings
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-04-02
REQUIRES: 165

SUMMARY:
This standard defines a standardized interface for assigning and managing numerical ratings on the Ethereum blockchain. This allows ratings to be codified within smart contracts and recognized by other applications, enabling a wide range of new use cases for tokens.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Every compliant contract MUST implement the following interfaces: ``` // SPDX-License-Identifier: CC0 pragma solidity ^0.8.0; /// @title EIP-4974 Ratings /// @dev See https://eips.ethereum.org/EIPS/EIP-4974 /// Note: the EIP-165 identifier for this interface is #######. /// Must initialize contracts with an `operator` address that is not `address(0)`. interface IERC4974 /* is ERC165 */ { /// @dev Emits when operator changes. /// MUST emit when `operator` changes by any mechanism. /// MUST

MOTIVATION:
Traditionally, blockchain applications have focused on buying and selling digital assets. However, the asset-centric model has often been detrimental to community-based blockchain projects, as seen in the pay-to-play dynamics of many EVM-based games and DAOs in 2021. This proposal addresses this issue by allowing ratings to be assigned to contracts and wallets, providing a new composable primitive for blockchain applications. This allows for a diverse array of new use cases, such as: - Voting weight in a DAO: Ratings assigned using this standard can be used to determine the voting weight of members in a decentralized autonomous organization

RATIONALE:
### Rating Assignment Ratings SHALL be at the sole discretion of the contract operator. This party may be a sports team coach or a multisig DAO wallet. We decide not to specify how governance occurs, but only *that* governance occurs. This allows for a wider range of potential use cases than optimizing for particular decision-making forms. This proposal standardizes a control mechanism to allocate community reputation without encouraging financialization of that recognition. While it does not ensure meritocracy, it opens the door. ### Choice of int8 It's signed: Reviewers should be able to give neutral and negative ratings


=== ERC-162 ===
TITLE: Initial ENS Hash Registrar
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2016-10-25
REQUIRES: 

SUMMARY:
This ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code is [here](https://github.com/ethereum/ens/blob/mainnet/contracts/HashRegistrarSimplified.sol). For more background, refer to [EIP-137](./eip-137.md). > Registrars are responsible for allocating domain names to users of the system, and are the only entities capable of updating the ENS; the owner of a node in the ENS registry is its registrar. Registrars may be contracts or externally owned accounts, though it is expected that the root and top-level registrars, at a minimum,

SPECIFICATION:
### Initial restrictions The Initial Registrar is expected to be in service for approximately two years, prior to upgrading. This should be sufficient time to learn, observe, and design an updated system. During the initial two year period, the available name space will be restricted to the `.eth` TLD. This restriction is enforced by the owner of the ENS root node who should not assign any nodes other than `.eth` to the Initial Registrar. The ENS's root node should be controlled by multiple parties using a multisig contract. The Initial Registrar will also prohibit registration of names 6

RATIONALE:
### Starting with a temporary registrar Anticipating and designing for all the potential issues of name allocation names is unlikely to succeed. This approach chooses not to be concerned with getting it perfect, but allows us to observe and learn with training wheels on, and implement improvements before expanding the available namespace to shorter names or another TLD. ### Valid names >= 7 characters Preserving the shortest, and often most valuable, domain names for the upgraded registrar provides the opportunity to implement processes for dispute resolution (assuming they are found to be necessary). ### Delayed release of names


=== ERC-7700 ===
TITLE: Cross-chain Storage Router Protocol
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-30
REQUIRES: 155

SUMMARY:
The following standard provides a mechanism by which smart contracts can route storage to external providers. In particular, protocols can reduce the gas fees associated with storing data on mainnet by routing the handling of storage operations to another system or network. These storage routers act as an extension to the core L1 contract. Methods in this document specifically target security and cost-effectiveness of storage routing to three router types: L1, L2 and databases. The cross-chain data written with these methods can be retrieved by generic [EIP-3668](./eip-3668)-compliant contracts, thus completing the cross-chain data life cycle. This document, nicknamed

SPECIFICATION:
### Overview The following specification revolves around the structure and description of a cross-chain storage router tasked with the responsibility of writing to an L2 or database storage. This document introduces `StorageRoutedToL2()` and `StorageRoutedToDatabase()` storage routers, along with the trivial `StorageRoutedToL1()` router, and proposes that new `StorageRoutedTo__()` reverts be allowed through new EIPs that sufficiently detail their interfaces and designs. Some foreseen examples of new storage routers include `StorageRoutedToSolana()` for Solana, `StorageRoutedToFilecoin()` for Filecoin, `StorageRoutedToIPFS()` for IPFS, `StorageRoutedToIPNS()` for IPNS, `StorageRoutedToArweave()` for Arweave, `StorageRoutedToArNS()` for ArNS, `StorageRoutedToSwarm()` for Swarm etc. ### L1 Router: `StorageRoutedToL1()` A minimal L1 router

MOTIVATION:
[EIP-3668](./eip-3668), aka 'CCIP-Read', has been key to retrieving cross-chain data for a variety of contracts on Ethereum blockchain, ranging from price feeds for DeFi contracts, to more recently records for ENS users. The latter case dedicatedly uses cross-chain storage to bypass the usually high gas fees associated with on-chain storage; this aspect has a plethora of use cases well beyond ENS records and a potential for significant impact on universal affordability and accessibility of Ethereum. Cross-chain data retrieval through [EIP-3668](./eip-3668) is a relatively simpler task since it assumes that all relevant data originating from cross-chain storages is translated

RATIONALE:
Technically, the cases of L2s and databases are similar; routing to an L2 involves routing the `eth_call` to another EVM, while routing to a database can be made by extracting `eth_sign` from `eth_call` and posting the resulting signature explicitly along with the data for later verification. Methods in this document perform these precise tasks when routing storage operations to external routers. In addition, methods such as signing data with a derived signer (for databases) allow for significant UX improvement by fixing the number of signature prompts in wallets to 2, irrespective of the number of data instances to


=== ERC-5773 ===
TITLE: Context-Dependent Multi-Asset Tokens
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-10-10
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The Multi-Asset NFT standard allows for the construction of a new primitive: context-dependent output of information per single NFT. The context-dependent output of information means that the asset in an appropriate format is displayed based on how the token is being accessed. I.e. if the token is being opened in an e-book reader, the PDF asset is displayed, if the token is opened in the marketplace, the PNG or the SVG asset is displayed, if the token is accessed from within a game, the 3D model asset is accessed and if the token is accessed by the (Internet

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title ERC-5773 Context-Dependent Multi-Asset Tokens /// @dev See https://eips.ethereum.org/EIPS/eip-5773 /// @dev Note: the ERC-165 identifier for this interface is 0x06b4329a. pragma solidity ^0.8.16; interface IERC5773 /* is ERC165 */ { /** * @notice Used to notify listeners that an asset object is initialised at `assetId`. * @param assetId ID of the asset that was initialised */ event AssetSet(uint64 assetId); /** * @notice Used to notify listeners that

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having multiple assets associated with a single NFT allows for greater utility, usability and forward compatibility. In the four years since [ERC-721](./eip-721.md) was published, the need for additional functionality has resulted in countless extensions. This EIP improves upon ERC-721 in the following areas: - [Cross-metaverse compatibility](#cross-metaverse-compatibility) - [Multi-media output](#multi-media-output) - [Media redundancy](#media-redundancy) - [NFT evolution](#nft-evolution) ### Cross-metaverse compatibility At the time of writing this proposal, the metaverse is

RATIONALE:
Designing the proposal, we considered the following questions: 1. **Should we use Asset or Resource when referring to the structure that comprises the token?**\ The original idea was to call the proposal Multi-Resource, but while this denoted the broadness of the structures that could be held by a single token, the term *asset* represents it better.\ An asset is defined as something that is owned by a person, company, or organization, such as money, property, or land. This is the best representation of what an asset of this proposal can be. An asset in this proposal can be


=== ERC-5606 ===
TITLE: Multiverse NFTs
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-09-06
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This specification defines a minimal interface to create a multiverse NFT standard for digital assets such as wearables and in-game items that, in turn, index the delegate NFTs on each platform where this asset exists. These platforms could be metaverses, play-to-earn games or NFT marketplaces. This proposal depends on and extends [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md). The standard also allows for the ‘bundling’ and ‘unbundling’ of these delegate NFTs within the multiverse NFT so holders can trade them individually or as a bundle.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. A multiverse NFT contract represents a digital asset across multiple platforms. This contract can own one or more delegate NFT tokens of the digital asset on the various platforms through bundling or unbundling. ``` /** * @dev Interface of the Multiverse NFT standard as defined in the EIP. */ interface IMultiverseNFT { /** * @dev struct to store delegate token details * */ struct DelegateData { address contractAddress; uint256

MOTIVATION:
Several metaverses and blockchain games ("platforms") exist that use NFT standards such as ERC-721 and ERC-1155 for creating in-universe assets like avatar wearables, in-game items including weapons, shields, potions and much more. The biggest shortcoming while using these standards is that there is no interoperability between these platforms. As a publisher, you must publish the same digital asset (for example, a shirt) on various platforms as separate ERC-721 or ERC-1155 tokens. Moreover, there is no relationship between these, although they represent the same digital asset in reality. Hence, it is very difficult to prove the scarcity of these

RATIONALE:
The `delegateData` struct contains information about the delegate NFT tokens on each platform. It contains variables such as `contractAddress`, `tokenId`, `quantity` to differentiate the NFTs. These NFTs could be following either the ERC-721 standard or the ERC-1155 standard. The `bundle` and `unbundle` functions accept an array of DelegateData struct because of the need to cater to partial bundling and unbundling. For instance, a user could initialise a bundle with three delegate NFTs, but they should be able to bundle and unbundle less than three at any time. They can never bundle or unbundle more than three. They also


=== ERC-6787 ===
TITLE: Order Book DEX with Two Phase Withdrawal
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-27
REQUIRES: 

SUMMARY:
The Order Book DEX Standard is a proposed set of interface specifications that define a decentralized exchange (DEX) protocol for trading assets using order books. This standard provides a set of functions that allow users to deposit, withdraw, and trade assets on a decentralized exchange. Additionally, it proposes a novel two-phase withdrawal scheme to ensure the asset security of both users and the exchange, addressing users' trust issues with the exchange.

SPECIFICATION:
### Interfaces The Order Book DEX Standard defines the following Interfaces: #### `deposit` `function deposit(address token, uint256 amount) external;` The **deposit** function allows a user to deposit a specified amount of a particular token to the exchange. The *token* parameter specifies the address of the token contract, and the *amount* parameter specifies the amount of the token to be deposited. #### `withdraw` `function withdraw(address token, uint256 amount) external;` The **withdraw** function allows a user to withdraw a specified amount of a particular token from the exchange. The *token* parameter specifies the address of the token contract, and the

MOTIVATION:
Decentralized exchanges (DEXs) have become increasingly popular in recent years due to their ability to provide users with greater control over their assets and reduce reliance on centralized intermediaries. However, many existing DEX protocols suffer from issues such as low liquidity and inefficient price discovery. Order book-based DEXs based Layer2 have emerged as a popular alternative, but there is currently no standardized interface for implementing such exchanges. The Order Book DEX Standard aims to provide developers with a common interface for building interoperable order book-based DEXs that can benefit from network effects. By establishing a standard set of

RATIONALE:
The flow charts for two-phase withdrawal are shown below: ![](../assets/eip-6787/image1.png)


=== ERC-7410 ===
TITLE: ERC-20 Update Allowance By Spender
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-26
REQUIRES: 2, 0, ,,  , 1, 6, 5

SUMMARY:
This extension adds a `decreaseAllowanceBySpender` function to decrease [ERC-20](./eip-20.md) allowances, in which a spender can revoke or decrease a given allowance by a specific address. This ERC extends [ERC-20](./eip-20.md).

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Contracts using this ERC MUST implement the `IERC7410` interface. ### Interface implementation ```solidity pragma solidity ^0.8.0; /** * @title IERC-7410 Update Allowance By Spender Extension * Note: the ERC-165 identifier for this interface is 0x12860fba */ interface IERC7410 is IERC20 { /** * @notice Decreases any allowance by `owner` address for caller. * Emits an {IERC20-Approval} event. * * Requirements: * - when `subtractedValue` is equal or higher than current

MOTIVATION:
Currently, [ERC-20](./eip-20.md) tokens offer allowances, enabling token owners to authorize spenders to use a designated amount of tokens on their behalf. However, the process of decreasing an allowance is limited to the owner's side, which can be problematic if the token owner is a treasury wallet or a multi-signature wallet that has granted an excessive allowance to a spender. In such cases, reducing the allowance from the owner's perspective can be time-consuming and challenging. To address this issue and enhance security measures, this ERC proposes allowing spenders to decrease or revoke the granted allowance from their end. This

RATIONALE:
The technical design choices within this ERC are driven by the following considerations: - The introduction of the `decreaseAllowanceBySpender` function empowers spenders by allowing them to autonomously revoke or decrease allowances. This design choice aligns with the goal of providing more direct control to spenders over their authorization levels. - The requirement for the `subtractedValue` to be lower than the current allowance ensures a secure implementation. Additionally, nullification is achieved by setting the new allowance to 0 when `subtractedValue` is equal to or exceeds the current allowance. This approach adds an extra layer of security and simplifies the


=== ERC-7618 ===
TITLE: Content encoding in ERC-5219 mode Web3 URL
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-08
REQUIRES: 5, 2, 1, 9, ,,  , 6, 9, 4, 4

SUMMARY:
In the context of the [ERC-6860](./eip-6860.md) `web3://` standard, this ERC extends the [ERC-6944](./eip-6944.md) resolve mode: This standard specifies that if a `Content-Encoding` header is returned by the `request()` call, then the returned data is decoded if necessary according to the specified algorithm before being returned to the client.

SPECIFICATION:
In the [ERC-6944](./eip-6944.md) resolve mode, this standard indicates that if a ``Content-Encoding`` HTTP header (in the returned `headers` `KeyValue` array of the `request()` method) is provided, and if it is not part of the supported algorithms provided by the client in the ``Accept-Encoding`` header, or the client did not provide an ``Accept-Encoding`` header, then the protocol MUST decode the content before forwarding it to the `web3://` client. The protocol MUST support the following content encodings: `gzip`, `br` (brotli). If the protocol is to decode the content, and if the advertized ``Content-encoding`` is not part of this list, an

MOTIVATION:
As storage in blockchains is expensive, it is optimal to try to store and serve compressed assets. Standard HTTP uses the `Accept-Encoding`/`Content-Encoding` mechanism, in which the client specifies their supported compression algorithms, and the server returns the data compressed in one of them. It is not optimal to replicate this mechanism in the `web3://` protocol, due to blockchain storage and computation constraints. Moreover, it is not possible to blindly serve content with a fixed `Content-Encoding` header, because the HTTP client may not implement the compression algorithm. By specifying a list of supported compression algorithms, optionally doing the decompression

RATIONALE:
We add this feature to the [ERC-6944](./eip-6944.md) resolve mode because it can be added without changes the interface. To stay as close as possible to standard HTTP, we don't introduce a new HTTP header but reuse the known `Content-Encoding` header.


=== ERC-1577 ===
TITLE: contenthash field for ENS
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-11-13
REQUIRES: 

SUMMARY:
This EIP introduces the new `contenthash` field for ENS resolvers, allowing for a better defined system of mapping names to network and content addresses. Additionally the `content` and `multihash` fields are deprecated.

SPECIFICATION:
The field `contenthash` is introduced, which permits a wide range of protocols to be supported by ENS names. Resolvers supporting this field MUST return `true` when the `supportsInterface` function is called with argument `0xbc1c58d1`. The fields `content` and `multihash` are deprecated. The value returned by `contenthash` MUST be represented as a machine-readable [multicodec](https://github.com/multiformats/multicodec). The format is specified as follows: ``` <protoCode uvarint><value []byte> ``` protoCodes and their meanings are specified in the [multiformats/multicodec](https://github.com/multiformats/multicodec) repository. The encoding of the value depends on the content type specified by the protoCode. Values with protocodes of 0xe3 and 0xe4 represent IPFS and

MOTIVATION:
Multiple applications including [Metamask](https://metamask.io/) and mobile clients such as [Status](https://status.im) have begun resolving ENS names to content hosted on distributed systems such as [IPFS](https://ipfs.io/) and [Swarm](https://swarm-guide.readthedocs.io). Due to the various ways content can be stored and addressed, a standard is required so these applications know how to resolve names and that domain owners know how their content will be resolved. The `contenthash` field allows for easy specification of network and content addresses in ENS.


=== ERC-191 ===
TITLE: Signed Data Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2016-01-20
REQUIRES: 

SPECIFICATION:
We propose the following format for `signed_data` ``` 0x19 <1 byte version> <version specific data> <data to sign>. ``` The initial `0x19` byte is intended to ensure that the `signed_data` is not valid RLP. > For a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding. That means that any `signed_data` cannot be one RLP-structure, but a 1-byte `RLP` payload followed by something else. Thus, any EIP-191 `signed_data` can never be an Ethereum transaction. Additionally, `0x19` has been chosen because since ethereum/go-ethereum#2940 , the following is prepended before hashing in


=== ERC-6806 ===
TITLE: ERC-721 Holding Time Tracking
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-30
REQUIRES: 721

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It adds an interface that tracks and describes the holding time of a Non-Fungible Token (NFT) by an account.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. **Interface** The following interface extends the existing ERC-721 standard: ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0 interface IERC6806 { function getHoldingInfo( uint256 tokenId ) external view returns (address holder, uint256 holdingTime); } ``` **Functions** ### getHoldingInfo ``` function getHoldingInfo(uint256 tokenId) external view returns (address holder, uint256 holdingTime); ``` This function returns the current holder of the specified NFT and the length of time (in seconds) the NFT has been

MOTIVATION:
In some use cases, it is valuable to know the duration for which a NFT has been held by an account. This information can be useful for rewarding long-term holders, determining access to exclusive content, or even implementing specific business logic based on holding time. However, the current ERC-721 standard does not have a built-in mechanism to track NFT holding time. This proposal aims to address these limitations by extending the ERC-721 standard to include holding time tracking functionality.

RATIONALE:
The addition of the `getHoldingInfo` function to an extension of the ERC-721 standard enables developers to implement NFT-based applications that require holding time information. This extension maintains compatibility with existing ERC-721 implementations while offering additional functionality for new use cases. The `getHoldingInfo` function provides a straightforward method for retrieving the holding time and holder address of an NFT. By using seconds as the unit of time for holding duration, it ensures precision and compatibility with other time-based functions in smart contracts. `getHoldingInfo` returns both `holder` and `holdingTime` so that some token owners (as decided by the implementation) can


=== ERC-1271 ===
TITLE: Standard Signature Validation Method for Contracts
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-07-25
REQUIRES: 

SUMMARY:
Externally Owned Accounts (EOA) can sign messages with their associated private keys, but currently contracts cannot. We propose a standard way for any contracts to verify whether a signature on a behalf of a given contract is valid. This is possible via the implementation of a `isValidSignature(hash, signature)` function on the signing contract, which can be called to validate a signature.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt). ```javascript pragma solidity ^0.5.0; contract ERC1271 { // bytes4(keccak256("isValidSignature(bytes32,bytes)") bytes4 constant internal MAGICVALUE = 0x1626ba7e; /** * @dev Should return whether the signature provided is valid for the provided hash * @param _hash Hash of the data to be signed * @param _signature Signature byte array associated with _hash * * MUST return the bytes4 magic value 0x1626ba7e when function passes. * MUST NOT modify state (using STATICCALL for

MOTIVATION:
There are and will be many contracts that want to utilize signed messages for validation of rights-to-move assets or other purposes. In order for these contracts to be able to support non Externally Owned Accounts (i.e., contract owners), we need a standard mechanism by which a contract can indicate whether a given signature is valid or not on its behalf. One example of an application that requires signatures to be provided would be decentralized exchanges with off-chain orderbook, where buy/sell orders are signed messages. In these applications, EOAs sign orders, signaling their desire to buy/sell a given asset

RATIONALE:
We believe the name of the proposed function to be appropriate considering that an *authorized* signers providing proper signatures for a given data would see their signature as "valid" by the signing contract. Hence, a signed action message is only valid when the signer is authorized to perform a given action on the behalf of a smart wallet. Two arguments are provided for simplicity of separating the hash signed from the signature. A bytes32 hash is used instead of the unhashed message for simplicity, since contracts could expect a certain hashing function that is not standard, such as


=== ERC-7744 ===
TITLE: Code Index
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-07-16
REQUIRES: 

SUMMARY:
This EIP defines a standard interface for indexing smart contracts on Ethereum by their bytecode hash. This enables trustless discovery and verification of contract code, facilitating use cases like bytecode signing, whitelisting, and decentralized distribution mechanisms.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity 0.8.28; interface IERC7744 { event Indexed(address indexed container, bytes32 indexed codeHash); error alreadyExists(bytes32 id, address source); function register(address container) external; function get(bytes32 id) external view returns (address); } /** * @title Byte Code Indexer Contract * @notice You can use this contract to index contracts by their bytecode. * @dev This allows to query contracts by their bytecode

MOTIVATION:
Existing contract discovery relies on addresses, which are non-deterministic and can be obfuscated through proxies. Indexing by bytecode hash provides a deterministic and tamper-proof way to identify and verify contract code, enhancing security and trust in the Ethereum ecosystem. Consider a security auditor who wants to attest to the integrity of a contract's code. By referencing bytecode hashes, auditors can focus their audit on the bytecode itself, without needing to assess deployment parameters or storage contents. This method verifies the integrity of a contract's codebase without auditing the entire contract state. Additionally, bytecode referencing allows whitelist contracts before

RATIONALE:
**Bytecode over Addresses**: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable. **Reverting on re-indexing**: There is small, yet non-zero probability of hash collision attack. Disallowing updates to indexed location of bytecode coupes with this. **Simple Interface**: The interface is minimal and focused to maximize composability and ease of implementation. **Library Implementation**: Implementing this as a library would limit its impact, making code reuse more difficult and lacking a single, official source of truth. By establishing this as an ERC, we ensure standardization and widespread adoption, driving the ecosystem forward.


=== ERC-2193 ===
TITLE: dType Alias Extension - Decentralized Type System
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-07-16
REQUIRES: 1, 5, 5, ,,  , 1, 9, 0, 0, ,,  , 2, 1, 5, 7

SUMMARY:
The dType Alias is a system for providing human-readable resource identifiers to on-chain content. A resource identifier is based on the type of data (identifier provided by dType, [EIP-1900](./eip-1900.md)) and the data content (identifier provided by a dType Storage Contract, [EIP-2157](./eip-2157.md)). It is a universal way of addressing content, supporting any type of data.

SPECIFICATION:
The dType registry will provide domain and subdomain names for the resource type. Subdomains can be attributed recursively, to dType types which contain other complex types in their composition. We define an `Alias` registry contract, that keeps track of the human-readable identifiers for data resources, which exist in dType storage contracts. Anyone can set an alias in the `Alias` registry, as long as the Ethereum address that signs the alias data has ownership on the resource, in the dType storage contract. Storage contract data ownership will be detailed in [EIP-2157](./eip-2157.md). An owner can update or delete an alias

MOTIVATION:
There are standards that currently address the need for attaching human-readable identifiers to Ethereum accounts, such as [EIP-137](./eip-137.md). These standards are an attempt to bring domain names to Ethereum, following the same format as DNS: `subdomain.domain.tld`. This leaf -> root format is unintuitive and contradicts the semantic meaning that `.` has in programming languages, which is a root -> leaf connection (e.g. in OOP, when accessing an object's property). A more intuitive and widely used approach is a root->leaf format, used in file browsers, hierarchical menus, and even in other decentralized systems, which give unique identifiers to resources

RATIONALE:
Current attempts to solve content addressability, such as [EIP-137](./eip-137.md), only target Ethereum accounts. These are based on inherited concepts from HTTP and DNS, which are not machine friendly. With [EIP-1900](./eip-1900.md) and [EIP-2157](./eip-2157.md), general content addressability can be achieved. dType provides type information and a reference to the smart contract where the type instances are stored. Additionally, Alias uses the semantic meaning of subdomain separators to have a [intuitive order rule](https://github.com/loredanacirstea/articles/blob/master/articles/Flexible_Alias_or_Why_ENS_is_Obsolete.md). Multiple aliases can be assigned to a single resource. Either by using a different `name` or by using a different `separator`. Each `separator` can have a specific standard


=== ERC-7412 ===
TITLE: On-Demand Off-Chain Data Retrieval
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-26
REQUIRES: 

SUMMARY:
Contracts may require off-chain data during execution. A smart contract function could implement the standard proposed here by reverting with `error OracleDataRequired(address oracleContract, bytes oracleQuery, uint256 feeRequired)`. Clients supporting this standard would recognize this error message during a simulation of the request, query the specified decentralized oracle network for signed data, and instead stage a transaction with a multicall that prepends the verification of the required off-chain data. The data would be written on-chain during verification to a smart contract for the subsequent call to read, avoiding the error.

SPECIFICATION:
A contract implementing this standard MUST revert with the following error whenever off-chain data is required: ```solidity error OracleDataRequired(address oracleContract, bytes oracleQuery, uint256 feeRequired) ``` `oracleQuery` specifies the off-chain data that is being required. Valid data formats for this parameter are specific to the oracle ID specified by the oracle contract. This might include chain id, contract address, function signature, payload, and timestamp/"latest" for cross-chain reads. For price feeds, it could include a ticker symbol and timestamp/"latest". `oracleContract` is the address of the contract which can verify the off-chain data and provide it to the contract to avoid

MOTIVATION:
Ethereum's scaling roadmap involves a series of separate execution contexts for smart contract code (including layer two and layer three scaling solutions). This makes the ability to read data across multiple chains crucial to the construction of scalable applications. Also, for decentralized finance protocols that rely on price data, it is not reasonable to expect oracle networks will be able to continuously push fresh data to every layer two and layer three network for an arbitrary number of price feeds. Cross-chain bridges are being developed where smart contract functions can write data to other chains. There is a

RATIONALE:
This proposal is essentially an alternative to [ERC-3668](./eip-3668.md) with a couple notable distinctions: - The error is very simple to construct. Developers implementing this standard only need to have awareness of the oracle network they choose to rely on, the form of the query accepted by this network, and the contract from which they expect to retrieve the data. - By relying on a multicall rather than callbacks, it is much simpler to handle situations in which nested calls require different off-chain data. By the standard proposed here, end users (including those using clients that implement account abstraction)


=== ERC-1319 ===
TITLE: Smart Contract Package Registry Interface
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-08-13
REQUIRES: 

SUMMARY:
This EIP specifies an interface for publishing to and retrieving assets from smart contract package registries. It is a companion EIP to [1123](./eip-1123.md) which defines a standard for smart contract package manifests.

SPECIFICATION:
The specification describes a small read/write API whose components are mandatory. It allows registries to manage versioned releases using the conventions of [semver](https://semver.org/) without imposing this as a requirement. It assumes registries will share the following structure and conventions: + a **registry** is a deployed contract which manages a collection of **packages**. + a **package** is a collection of **releases** + a **package** is identified by a unique string name and unique bytes32 **packageId** within a given **registry** + a **release** is identified by a `bytes32` **releaseId** which must be unique for a given package name and release

MOTIVATION:
The goal is to establish a framework that allows smart contract publishers to design and deploy code registries with arbitrary business logic while exposing a set of common endpoints that tooling can use to retrieve assets for contract consumers. A clear standard would help the existing EthPM Package Registry evolve from a centralized, single-project community resource into a decentralized multi-registry system whose constituents are bound together by the proposed interface. In turn, these registries could be ENS name-spaced, enabling installation conventions familiar to users of `npm` and other package managers. **Examples** ```shell $ ethpm install packages.zeppelin.eth/Ownership ``` ```javascript

RATIONALE:
The proposal hopes to accomplish the following: + Define the smallest set of inputs necessary to allow registries to map package names to a set of release versions while allowing them to use any versioning schema they choose. + Provide the minimum set of getter methods needed to retrieve package data from a registry so that registry aggregators can read all of their data. + Define a standard query that synthesizes a release identifier from a package name and version pair so that tooling can resolve specific package version requests without needing to query a registry about all


=== ERC-5505 ===
TITLE: EIP-1155 asset backed NFT extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-18
REQUIRES: 1155

SUMMARY:
To propose an extension of smart contract interfaces for asset-backed, fractionalized projects using the [EIP-1155](./eip-1155.md) standard such that total acquisition will become possible. This proposal focuses on physical asset, where total acquisition should be able to happen.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. [EIP-1155](./eip-1155.md) compliant contracts MAY implement this EIP for adding functionalities to support total acquisition. ```solidity //set the percentage required for any acquirer to trigger a forced sale //set also the payment token to settle for the acquisition function setForcedSaleRequirement( uint128 requiredBP, address erc20Token ) public onlyOwner //set the unit price to acquire the remaining NFTs (100% - requiredBP) //suggest to use a Time Weighted Average Price for a certain

MOTIVATION:
Fractionalized, asset backed NFTs face difficulty when someone wants to acquire the whole asset. For example, if someone wants to bring home a fractionalized asset, he needs to buy all NFT pieces so he will become the 100% owner. However he could not do so as it is publicly visible that someone is trying to perform a total acquisition in an open environment like Ethereum. Sellers will take advantage to set unreasonable high prices which hinders the acquisition. Or in other cases, NFTs are owned by wallets with lost keys, such that the ownership will never be a

RATIONALE:
Native ETH is supported by via Wrapped Ether [EIP-20](./eip-20.md). After forcedSale is set, the remaining NFTs metadata should be updated to reflect the NFTs are at most valued at the previously set TWAP price.


=== ERC-5189 ===
TITLE: Account Abstraction via Endorsed Operations
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-06-29
REQUIRES: 

SUMMARY:
This ERC proposes a form of account abstraction (AA) that ensures compatibility with existing smart contract wallets and provides flexibility for alternative designs while avoiding introducing changes to the consensus layer. Instead of defining a strict structure for AA transactions, this proposal introduces the figure of `endorser` contracts. These smart contract instances are tasked with determining the quality of the submitted AA transactions, thus safely helping bundlers determine if a transaction should be kept in the mempool or not. Developers that intend to make their smart contract wallet compatible with this ERC must create and deploy an instance

SPECIFICATION:
To avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, AA transactions are packed up in a struct called `Operation`, operations are structs composed by the following fields: | Field | Type | Description | | -------------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | | entrypoint | address | Contract address that must be called with `callData` to execute the `operation`. | | callData | bytes | Data that must be passed to the `entrypoint` call to execute the `operation`. | | fixedGas | uint64 | Amount of gas that the operation

MOTIVATION:
This account abstraction proposal aims to implement a generalized system for executing AA transactions while maintaining the following goals: * **Achieve the primary goal of account abstraction:** allow users to use smart contract wallets containing arbitrary verification and execution logic instead of EOAs as their primary account. * **Decentralization:** * Allow any bundler to participate in the process of including AA transactions. * Work with all activity happening over a public mempool without having to concentrate transactions on centralized relayers. * Define structures that help maintain a healthy mempool without risking its participants from getting flooded with invalid

RATIONALE:
### Griefing protection The main challenge with a purely smart contract wallet-based account abstraction system is DoS safety: how can a bundler that includes an operation make sure it will be paid without executing the entire operation? Bundlers could execute the entire operation to determine if it is healthy or not, but this operation may be expensive and complex for the following reasons: * The bundler does not have a way to simulate the transaction with a reduced amount of gas; it has to use the whole `gasLimit`, exposing itself to a higher level of griefing. * The


=== ERC-7741 ===
TITLE: Authorize Operator
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-06-03
REQUIRES: 7, 1, 2, ,,  , 1, 2, 7, 1

SUMMARY:
A set of functions to enable meta-transactions and atomic interactions with contracts implementing an operator model, via signatures conforming to the [EIP-712](./eip-712.md) typed message signing specification.

SPECIFICATION:
### Operator-compatible contracts This signed authorization scheme applies to any contracts implementing the following interface: ```solidity interface IOperator { event OperatorSet(address indexed owner, address indexed operator, bool approved); function setOperator(address operator, bool approved) external returns (bool); function isOperator(address owner, address operator) external returns (bool status); } ``` [EIP-6909](./eip-6909.md) and [EIP-7540](./eip-7540.md) already implement this interface. The naming of the arguments is interchangeable, e.g. [EIP-6909](./eip-6909.md) uses `spender` instead of `operator`. ### Methods #### `authorizeOperator` Grants or revokes permissions for `operator` to manage Requests on behalf of the `msg.sender`, using an [EIP-712](./eip-712.md) signature. MUST revert if the `deadline` has passed. MUST

MOTIVATION:
The primary motivation for this standard is to enhance the flexibility, security, and efficiency of operator management. By leveraging EIP-712 signatures, this standard allows users to authorize operators without the need for on-chain transactions, reducing gas costs and improving user experience. This is particularly beneficial whenever frequent operator changes and cross-chain interactions are required. Additionally, this standard aims to: 1. **Enable Meta-Transactions**: Allow users to delegate the execution of transactions to operators, enabling meta-transactions where the user does not need to hold native tokens to pay for gas fees on each chain. 2. **Improve Security**: Utilize the EIP-712

RATIONALE:
### Similarity to [ERC-2612](./eip-2612.md) The specification is intentionally designed to closely match [ERC-2612](./eip-2612.md). This should simplify new integrations of the standard. The main difference is using `bytes32` vs `uint256`, which enables unordered nonces.


=== ERC-5791 ===
TITLE: Physical Backed Tokens
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-10-17
REQUIRES: 1, 9, 1, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It proposes a minimal interface for a [ERC-721](./eip-721.md) NFT to be "physically backed" and owned by whoever owns the NFT's physical counterpart.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Requirements This approach requires that the physical item must have a chip attached to it that should be secure and signal authenticity: - The chip can securely generate and store an asymmetric key pair; - The chip can sign messages using the private key of the previously-generated asymmetric key pair; - The chip exposes the public key; and - The private key cannot be extracted or duplicated by

MOTIVATION:
NFT collectors enjoy collecting digital assets and sharing them with others online. However, there is currently no such standard for showcasing physical assets as NFTs with verified authenticity and ownership. Existing solutions are fragmented and tend to be susceptible to at least one of the following: - The ownership of the physical item and the ownership of the NFT are decoupled. - Verifying the authenticity of the physical item requires action from a trusted 3rd party (e.g. StockX).

RATIONALE:
This solution's intent is to be the simplest possible path towards linking physical items to digital NFTs without a centralized authority. The interface includes a `transferToken` function that's opinionated with respect to the signature scheme, in order to enable a downstream aggregator-like product that supports transfers of any NFTs that implement this EIP in the future. The chip address is included in `transferToken` to allow signature verification by a smart contract. This ensures that chips in physically backed tokens are not strictly tied to implementing secp256k1 signatures, but instead may use a variety of signature schemes such as


=== ERC-6956 ===
TITLE: Asset-bound Non-Fungible Tokens
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-04-29
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard allows integrating physical and digital ASSETS without signing capabilities into dApps/web3 by extending [ERC-721](eip-721.md). An ASSET, for example a physical object, is marked with a uniquely identifiable ANCHOR. The ANCHOR is bound in a secure and inseparable manner 1:1 to an NFT on-chain - over the complete life cycle of the ASSET. Through an ATTESTATION, an ORACLE testifies that a particular ASSET associated with an ANCHOR has been CONTROLLED when defining the `to`-address for certain operations (mint, transfer, burn, approve, ...). The ORACLE signs the ATTESTATION off-chain. The operations are authorized through verifying on-chain that ATTESTATION

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions (alphabetical) - **ANCHOR** uniquely identifies the off-chain ASSET, whether it is physical or digital. - **ANCHOR-TECHNOLOGY** MUST ensure that - the ANCHOR is inseparable from the ASSET (physically or otherwise) - an ORACLE can establish PROOF-OF-CONTROL over the ASSET beyond reasonable doubt - For physical ASSETS, additional [Security considerations for Physical Assets](#security-considerations-for-physical-assets) MUST be taken into account - **ASSET** refers to the

MOTIVATION:
The well-known [ERC-721](eip-721.md) establishes that NFTs may represent "ownership over physical properties [...] as well as digital collectables and even more abstract things such as responsibilities" - in a broader sense, we will refer to all those things as ASSETS, which typically have value to people. ### The Problem ERC-721 outlines that "NFTs can represent ownership over digital or physical assets". ERC-721 excels in this task when used to represent ownership over digital, on-chain assets, that is when the asset is "holding a token of a specific contract" or the asset is an NFT's metadata. Today, people commonly

RATIONALE:
**Why do you use an anchor<>tokenId mapping and not simply use tokenIds directly?** Especially for collectable use-cases, special or sequential tokenIds (for example low numbers), have value. Holders may be proud to have claimed tokenId=1 respectively the off-chain ASSET with tokenId=1 may increase in value, because it was the first ever claimed. Or an Issuer may want to address the first 100 owners who claimed their ASSET-BOUND NFT. While these use-cases technically can certainly be covered by observing the blockchain state-changes, we consider reflecting the order in the tokenIds to be the user-friendly way. Please refer [Security considerations](#security-considerations)


=== ERC-1066 ===
TITLE: Status Codes
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-05
REQUIRES: 

SUMMARY:
This standard outlines a common set of status codes in a similar vein to HTTP statuses. This provides a shared set of signals to allow smart contracts to react to situations autonomously, expose localized error messages to users, and so on. The current state of the art is to either `revert` on anything other than a clear success (ie: require human intervention), or return a low-context `true` or `false`. Status codes are similar-but-orthogonal to `revert`ing with a reason, but aimed at automation, debugging, and end-user feedback (including translation). _They are fully compatible with both `revert` and `revert`-with-reason._ As

SPECIFICATION:
### Format Codes are returned either on their own, or as the first value of a multiple return. ```solidity // Status only function isInt(uint num) public pure returns (byte status) { return hex"01"; } // Status and value uint8 private counter; function safeIncrement(uint8 interval) public returns (byte status, uint8 newCounter) { uint8 updated = counter + interval; if (updated >= counter) { counter = updated; return (hex"01", updated); } else { return (hex"00", counter); } } ``` ### Code Table Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number. The high nibble represents the

MOTIVATION:
### Semantic Density HTTP status codes are widely used for this purpose. BEAM languages use atoms and tagged tuples to signify much the same information. Both provide a lot of information both to the programmer (debugging for instance), and to the program that needs to decide what to do next. Status codes convey a much richer set of information [than Booleans](https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/), and are able to be reacted to autonomously unlike arbitrary strings. ### User Experience (UX) _End users get little to no feedback, and there is no translation layer._ Since ERC1066 status codes are finite and known in

RATIONALE:
### Encoding Status codes are encoded as a `byte`. Hex values break nicely into high and low nibbles: `category` and `reason`. For instance, `0x01` stands for general success (ie: `true`) and `0x00` for general failure (ie: `false`). As a general approach, all even numbers are blocking conditions (where the receiver does not have control), and odd numbers are nonblocking (the receiver is free to continue as they wish). This aligns both a simple bit check with the common encoding of Booleans. `bytes1` is very lightweight, portable, easily interoperable with `uint8`, cast from `enum`s, and so on. #### Alternatives


=== ERC-5646 ===
TITLE: Token State Fingerprint
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-09-11
REQUIRES: 165

SUMMARY:
This specification defines the minimum interface required to unambiguously identify the state of a mutable token without knowledge of implementation details.

SPECIFICATION:
The key words "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", and "MAY" in this document are to be interpreted as described in RFC 2119. ```solidity pragma solidity ^0.8.0; interface ERC5646 is ERC165 { /// @notice Function to return current token state fingerprint. /// @param tokenId Id of a token state in question. /// @return Current token state fingerprint. function getStateFingerprint(uint256 tokenId) external view returns (bytes32); } ``` - `getStateFingerprint` MUST return a different value when the token state changes. - `getStateFingerprint` MUST NOT return a different value when the token state remains the same. - `getStateFingerprint` MUST include all

MOTIVATION:
Currently, protocols need to know about tokens' state properties to create the unambiguous identifier. Unfortunately, this leads to an obvious bottleneck in which protocols need to support every new token specifically. ![](../assets/eip-5646/support-per-abi.png)

RATIONALE:
Protocols can use state fingerprints as a part of a token identifier and support mutable tokens without knowing any state implementation details. ![](../assets/eip-5646/support-per-eip.png) State fingerprints don't have to factor in state properties that are immutable, because they can be safely identified by a token id. This standard is not for use cases where token state property knowledge is required, as these cases cannot escape the bottleneck problem described earlier.


=== ERC-7656 ===
TITLE: Generalized Contract-Linked Services
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-03-15
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 1, 1, 6, 7, ,,  , 4, 3, 3, 7, ,,  , 6, 5, 5, 1

SUMMARY:
This proposal defines a factory capable of deploying generic services linked to specific contracts, such as [ERC-4337](./eip-4337.md) accounts or [ERC-721](./eip-721.md) tokens (NFTs). These linked services extend the functionalities of the target contract, operating under the ownership of the contract's or NFT's owner without requiring modifications to the original contract's code. As a secondary effect, this proposal helps fighting the proliferation of ERCs that require changes to the basic standards.

SPECIFICATION:
The keywords "MUST," "MUST NOT," "REQUIRED," "SHALL," "SHALL NOT," "SHOULD," "SHOULD NOT," "RECOMMENDED," "NOT RECOMMENDED," "MAY," and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The `IERC7656Factory` interface is defined as follows: ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; /** * @title ERC7656 * @dev ERC165 interface ID: 0x9e23230a * @notice Manages the creation of contract-linked services */ interface IERC7656Factory { event Created( address contractAddress, address indexed implementation, bytes32 salt, uint256 chainId, bytes12 mode, address indexed linkedContract, uint256 indexed linkedId ); error CreationFailed(); function create( address implementation, bytes32 salt, uint256

MOTIVATION:
Existing standards like [ERC-6551](./eip-6551.md) successfully bind smart accounts to NFTs, allowing registries to deploy accounts owned by specific token IDs. However, these standards have two key limitations: 1. They often require deployed contracts to implement specific interfaces for handling assets and executing transactions, effectively mandating that the deployed contract must function as an account. 2. They are restricted to NFTs, while many other contract types (particularly [ERC-4337](./eip-4337.md) accounts) could benefit from similar linking mechanisms to extend their functionalities. This ERC proposes a more versatile factory specification that enables the deployment of proxies pointing to any contract that enhances

RATIONALE:
The design of [ERC-7656](./eip-7656.md) is guided by several key principles that address limitations in current contract extension methods: ### Why a Unified Factory? Rather than creating separate standards for NFT extensions and account extensions, [ERC-7656](./eip-7656.md) employs a unified factory approach. This design choice stems from recognizing the fundamental similarity between linking services to tokens and linking services to accounts - both involve extending functionality while maintaining a clear ownership relationship. ### Mode Parameter Design The `mode` parameter uses 12 bytes instead of a simple boolean flag because the 12-byte format reserves space for future linking modes beyond the


=== ERC-7566 ===
TITLE: Multiplayer Game Communication
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-11-28
REQUIRES: 

SUMMARY:
This proposal introduces a multiplayer game communication (MGC) interface, using `room` to match and group players, and using `message` to process actions between players. This allows one smart contract to handle multiple players playing games on the chain, preventing centralized servers from affecting the fairness of the game.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The principle of Multiplayer Game Communication is to use the same game logic to change the state of different groups of players. It consists of two core parts: **Room**: A container for players, used to match and view connected players. The game can only be played after players join the room. **Message**: Actions between players, using messages to perform game behaviors and change the

RATIONALE:
### Why are multiplayer onchain games room-based? Because the rooms are independent, each player will be assigned a new ID when entering a room. A new game round can be a room, a game task can be a room, and a game activity can be a room. ### The player's state in the game. The game state refers to the player's data changes in the game, and `sendMessage` actually plays the role of a state converter. The proposal is very flexible, you can define some data inside the room (internal) or outside the room (global) according to the


=== ERC-1056 ===
TITLE: Ethereum Lightweight Identity
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-03
REQUIRES: 

SUMMARY:
This ERC describes a standard for creating and updating identities with a limited use of blockchain resources. An identity can have an unlimited number of `delegates` and `attributes` associated with it. Identity creation is as simple as creating a regular key pair ethereum account, which means that it's free (no gas costs) and all ethereum accounts are valid identities. Furthermore this ERC is fully [DID compliant](https://w3c-ccg.github.io/did-spec/).

SPECIFICATION:
This ERC specifies a contract called `EthereumDIDRegistry` that is deployed once and can then be commonly used by everyone. ### Identity ownership By default an identity is owned by itself, meaning whoever controls the ethereum account with that address. The owner can be updated to a new key pair account or to a multisig account etc. #### identityOwner Returns the owner of the given identity. ```js function identityOwner(address identity) public view returns(address); ``` #### changeOwner Sets the owner of the given identity to another ethereum account. ```js function changeOwner(address identity, address newOwner) public; ``` #### changeOwnerSigned Same as

MOTIVATION:
As we have been developing identity systems for the last couple of years at uPort it has become apparent that the cost of identity creation is a large issue. The previous Identity proposal [ERC-725](./eip-725.md) faces this exact issue. Our requirements when creating this ERC is that identity creation should be free, and should be possible to do in an offline environment (e.g. refugee scenario). However it must also be possible to rotate keys without changing the primary identifier of the identity. The identity system should be fit to use off-chain as well as on-chain.

RATIONALE:
For on-chain interactions Ethereum has a built in account abstraction that can be used regardless of whether the account is a smart contract or a key pair. Any transaction has a `msg.sender` as the verified send of the transaction. Since each Ethereum transaction has to be funded, there is a growing trend of on-chain transactions that are authenticated via an externally created signature and not by the actual transaction originator. This allows 3rd party funding services or receiver pays without any fundamental changes to the underlying Ethereum architecture. These kinds of transactions have to be signed by an


=== ERC-2021 ===
TITLE: Payoutable Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-05-10
REQUIRES: 2, 0, ,,  , 1, 0, 6, 6, ,,  , 1, 9, 9, 6

SUMMARY:
Token wallet owners (or approved addresses) can order payout requests through blockchain. This is done by calling the ```orderPayoutFrom``` or ```orderPayoutFrom``` methods, which initiate the workflow for the token contract operator to either honor or reject the payout request. In this case, payout instructions are provided when submitting the request, which are used by the operator to determine the destination of the funds. In general, it is not advisable to place explicit routing instructions for the payouts on a verbatim basis on the blockchain, and it is advised to use a private communication alternatives, such as private channels,

SPECIFICATION:
```solidity interface IPayoutable /* is ERC-20 */ { enum PayoutStatusCode { Nonexistent, Ordered, InProcess, FundsInSuspense, Executed, Rejected, Cancelled } function authorizePayoutOperator(address orderer) external returns (bool); function revokePayoutOperator(address orderer) external returns (bool); function orderPayout(string calldata operationId, uint256 value, string calldata instructions) external returns (bool); function orderPayoutFrom(string calldata operationId, address walletToBePaidOut, uint256 value, string calldata instructions) external returns (bool); function cancelPayout(string calldata operationId) external returns (bool); function processPayout(string calldata operationId) external returns (bool); function putFundsInSuspenseInPayout(string calldata operationId) external returns (bool); function executePayout(string calldata operationId) external returns (bool); function rejectPayout(string calldata operationId, string calldata reason) external returns (bool); function isPayoutOperatorFor(address walletToDebit,

MOTIVATION:
Nowadays most of the token payout requests, need a previous centralized transaction, to be able to define the payout destination to be able to execute the payout (burn transaction). In the aim of trying to bring all the needed steps into decentralization, exposing all the needed steps of token lifecycle and payment transactions, a payout request can allow wallet owner to initiate the payout order via blockchain. Key benefits: * Payout, burning traceability is enhanced bringing the initiation into the ledger. All payment, payout statuses can be stored on chain. * Almost all money/token lifecycle is covered via

RATIONALE:
This standards provides a functionality to allow token holders to start payout requests in a decentralized way. It's important to highlight that the token operator, need to process all payout request, updating the payout status based on the linked payment that will be done. Payout instruction format is open. ISO payment standard like is a good start point. This EIP uses [EIP-1996] to hold the money after a payout is ordered. The token contract owner or agent, whose implementation is not part of this proposal, acts as a predefined notary to decide if the payout is executed or


=== ERC-7518 ===
TITLE: Dynamic Compliant Interop Security Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-14
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This proposal is a security token standard that extends [ERC-1155](./eip-1155.md) to provide a flexible framework for managing compliant real-asset security tokens. It introduces the concept of partitions, where each `tokenId` represents a distinct partition with its own set of rights and privileges. This makes it suitable for various use cases, particularly semi-fungible asset management. The standard also includes features like token locking, forced transfers for recovery, address freezing, payouts, and dynamic compliance management using off-chain vouchers.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Interface ```solidity pragma solidity ^0.8.0; interface IERC7518 is IERC1155, IERC165{ event TokensLocked(address indexed account, uint indexed id, uint256 amount, uint256 releaseTime); event TokenUnlocked(address indexed account, uint indexed id); event TokensForceTransferred(address indexed from, address indexed to, uint indexed id, uint256 amount); event AddressFrozen(address indexed account, bytes data); event AddressUnfrozen(address indexed account, bytes data); // Emitted when the transferability of tokens with a specific ID

MOTIVATION:
The growing demand for tokenized real-world assets necessitates a token standard that can accommodate the unique requirements of security tokens. Existing standards, while powerful, do not fully address the need for flexible partitioning and comprehensive compliance management. Build upon of [ERC-1155](./eip-1155.md) to introduce partitions, allowing for the creation of semi-fungible tokens representing fractional ownership, different share classes, or other distinct units within a single token contract. This flexibility is crucial for tokenizing complex real-world assets like real estate or funds. Furthermore, it includes features essential for security tokens, such as token locking for vesting or holding periods, forced

RATIONALE:
### Enhancing Compliance Management The `canTransfer` function facilitates compliance checks during token transfers, offering adaptability through diverse implementation methods such as on-chain storage, oracle utilization, or any off-chain methodologies. This versatility ensures seamless integration with existing compliance frameworks, particularly in enforcing regulatory standards like KYC/AML. Additionally, functionalities like `freezeAddress`, `restrictTransfer`, `lockToken` and `forceTransfer` empower entities to regulate token movements based on specified conditions or regulatory requirements. Complementing these, the `unlockToken` function enhances transparency and accountability by facilitating the release of tokens post-compliance actions. ### Interoperability with other standard The functions `wrapToken` and `wrapTokenFromPartition` are essential for simplifying conversions


=== ERC-5643 ===
TITLE: Subscription NFTs
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-09-10
REQUIRES: 721

SUMMARY:
This standard is an extension of [EIP-721](./eip-721.md). It proposes an additional interface for NFTs to be used as recurring, expirable subscriptions. The interface includes functions to renew and cancel the subscription.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity interface IERC5643 { /// @notice Emitted when a subscription expiration changes /// @dev When a subscription is canceled, the expiration value should also be 0. event SubscriptionUpdate(uint256 indexed tokenId, uint64 expiration); /// @notice Renews the subscription to an NFT /// Throws if `tokenId` is not a valid NFT /// @param tokenId The NFT to renew the subscription for /// @param duration The number of seconds to extend a

MOTIVATION:
NFTs are commonly used as accounts on decentralized apps or membership passes to communities, events, and more. However, it is currently rare to see NFTs like these that have a finite expiration date. The "permanence" of the blockchain often leads to memberships that have no expiration dates and thus no required recurring payments. However, for many real-world applications, a paid subscription is needed to keep an account or membership valid. The most prevalent on-chain application that makes use of the renewable subscription model is the Ethereum Name Service (ENS), which utilizes a similar interface to the one proposed

RATIONALE:
This standard aims to make on-chain subscriptions as simple as possible by adding the minimal required functions and events for implementing on-chain subscriptions. It is important to note that in this interface, the NFT itself represents ownership of a subscription, there is no facilitation of any other fungible or non-fungible tokens. ### Subscription Management Subscriptions represent agreements to make advanced payments in order to receive or participate in something. In order to facilitate these agreements, a user must be able to renew or cancel their subscriptions hence the `renewSubscription` and `cancelSubscription` functions. It also important to know when


=== ERC-7856 ===
TITLE: Chain-Specific Payment Requests
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2025-01-01
REQUIRES: 

SUMMARY:
This EIP proposes a standardized URI scheme for chain-specific payment requests, enabling users to specify transactions in the form "send me X tokens of type Y on chain Z". The URI format includes essential components such as the recipient's blockchain account, the amount of tokens, the token contract address, and optional success and error callback URLs. This standard aims to eliminate ambiguity in multi-chain payment requests, ensuring clarity and accuracy in peer-to-peer transactions and vendor or dApp requests across different blockchain networks.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The format of the payment request URI is: ```txt cspr://<recipient>/<amount>/<token-address>?on-success=<success-callback-url>&on-error=<error-callback-url> ``` - `cspr://` - [REQUIRED] Short for "Chain-Specific Payment Request". Indicates a blockchain-based payment request. - `<recipient>` - [REQUIRED] The blockchain account requesting the payment (represented as a CAIP-10 account identifier). - `<amount>` - [REQUIRED] The amount of tokens to be sent, specified as an integer or decimal number. - `<token-address>` - [REQUIRED] The

MOTIVATION:
The ongoing expansion of the Ethereum network into a multi-chain ecosystem has introduced complexities regarding the execution of payment requests. Users and developers currently face a lack of clarity on which chain a payment request should be fulfilled, particularly when similar assets exist across multiple chains. This ambiguity complicates peer-to-peer transactions and vendor or dApp requests, leading to inefficiencies and a higher potential for errors. This standard will ensure that payment requests are clearly understood and correctly executed, regardless of the chain, thus significantly enhancing the user experience in a multi-chain environment.

RATIONALE:
The design of this URI standard for blockchain-based payment requests addresses the need for a clear and unambiguous method to initiate transactions across multiple Ethereum chains, including mainnet and various Layer 2 networks. The rationale for each component of the URI structure is as follows: - **`cspr://` Prefix:** This prefix explicitly identifies the URI as a blockchain-based payment request, ensuring systems recognize and correctly handle these URIs. It follows the precedent of other protocol-specific URI schemes like `mailto://` for email and `http://` for web links. - **Recipient:** The recipient is specified using a CAIP-10 account identifier, a standardized


=== ERC-7291 ===
TITLE: Purpose bound money
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-24
REQUIRES: 1, 6, 5, ,,  , 1, 7, 3, ,,  , 1, 1, 5, 5

SUMMARY:
This proposal outlines a smart contract interface that builds upon the [ERC-1155](./eip-1155.md) standard to implement the purpose bound money (PBM) concept: - PBMs is comprised of a PBM wrapper and a digital money token that it wraps. A digital money token (e.g. stablecoins, central bank digital currency, tokenised bank deposits etc) serves as as a store of value (abbreviated as "sov"). Thus, a digital money token (also referred to as "sovToken") **SHOULD** be: - a good store of value; - a suitable unit of account; and - a medium of exchange. - PBMs are bearer instruments, with self-contained

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions - **sovToken** - an ERC-20 or ERC-20 compatible digital currency (e.g. [ERC-777](./eip-777.md), [ERC-1363](./eip-1363.md)) serving as the store of value token (i.e. collateral backing the PBM Token). - **PBM Wrapper** - an ERC-1155 compliant smart contract, which wraps the sovToken by specifying one or more conditions that have to be met (referred to as PBM business logic in subsequent section of this proposal).

MOTIVATION:
This proposal intends to forestall technology fragmentation and consequently a lack of interoperability. By making the PBM specification open, it gives new participants easy and free access to the pre-existing market standards, enabling interoperability across different platforms, wallets, payment systems and rails. This would lower cost of entry for new participants, foster a vibrant payment landscape and prevent the development of walled gardens and monopolies, ultimately leading to more efficient, affordable services and better user experiences.

RATIONALE:
### Why sovToken **MUST** be ERC-20 compatible? As PBM is envisioned to have functionality of money, it has to be a fungible token with stable value. Currently, the major stablecoins in the market are mainly based on the ERC-20 interface. ERC-20 or ERC-20 compatible tokens are the most widely supported by existing wallets, defi apps, and used also by protocol design such as [ERC-4337](./eip-4337.md) and more importantly they are the de facto standard for fungible tokens. With regards to [ERC-721](./eip-721.md) and ERC-1155 compatible tokens: - ERC-721 is not suitable given that it is a standard for non-fungible tokens,


=== ERC-3135 ===
TITLE: Exclusive Claimable Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-08-10
REQUIRES: 20

SUMMARY:
This EIP defines a set of additions to the default token standard such as ERC-20, that allows online/offline service providers establish micropayment channels with any number of users by signing and verifying messages about the consumption of token off chain. Using this mechanism will reduce interactions with blockchain to minimal for both participants, thus saving gas and improve performance.

SPECIFICATION:
```solidity /// @return Image url of this token or descriptive resources function iconUrl() external view returns (string memory); /// @return Issuer of this token. Only issuer can execute claim function function issuer() external view returns (address); /** * @notice Remove consumption from payer's deposite * @dev Check if msg.sender == issuer * @param from Payer's address * @param consumption How many token is consumed in this epoch, specified * @param epoch Epoch increased by 1 after claim or withdraw, at the beginning of each epoch, consumption goes back to 0 * @param signature Signature of payment message signed

MOTIVATION:
There are two main purposes of this EIP, one is to reduce interactions with blockchain, the second is to link Ethereum to real-world payment problems. Many small businesses want to build payment system based on blockchain but find it difficult. There are basically two ways: 1. Directly pay with token. There are many wallet can receive and transfer token but transactions on Ethereum cost gas and take time to confirm. 2. User lock token on payment smart contract and service provider use payment messages signed by user to release token, establishing a micropayment channel. The advantage is interactions

RATIONALE:
This EIP targets on ERC-20 tokens due to its widespread adoption. However, this extension is designed to be compatible with other token standard. The reason we chose to implement those functions in token contract rather than a separate record contract is as follows: - Token can transfer is more convenient and more general than interact with DApp - Token is more standardized and has better UI support - Token is equal to service, make token economy more prosperous - Remove the approve process


=== ERC-1710 ===
TITLE: URL Format for Web3 Browsers
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-01-13
REQUIRES: 155

SUMMARY:
Since most normal web browsers (specifically on mobile devices) can not run decentralized applications correctly because of the lack of web3 support, it is necessary to differentiate them from normal urls, so they can be opened in web3 browsers if available.

SPECIFICATION:
### Syntax Web3 browser URLs contain "dapp" in their schema (protocol) part and are constructed as follows: request = "dapp" ":" [chain_id "@"] dapp_url chain_id = 1*DIGIT dapp_url = URI ### Semantics `chain_id` is optional and it is a parameter for the browser to automatically select the corresponding chain ID as specified in [EIP-155](./eip-155.md) before opening the dApp. `dapp_url` is a valid [RFC3986](https://www.ietf.org/rfc/rfc3986.txt) URI This a complete example url: `dapp:1@peepeth.com/brunobar79?utm_source=github` which will open the web3 browser, select `mainnet` (chain_id = 1) and then navigate to: `https://peepeth.com/brunobar79?utm_source=github`

MOTIVATION:
Lots of dApps that are trying to improve their mobile experience are currently (deep)linking to specific mobile web3 browsers which are currently using their own url scheme. In order to make the experience more seamless, dApps should still be able to recommend a specific mobile web3 browser via [deferred deeplinking](https://en.wikipedia.org/wiki/Deferred_deep_linking) but by having a standard url format, if the user already has a web3 browser installed that implements this standard, it will be automatically linked to it. There is also a compatibility problem with the current `ethereum:` url scheme described in [EIP-831](./eip-831.md) where any ethereum related app (wallets,

RATIONALE:
The proposed format attempts to solve the problem of vendor specific protocols for web3 browsers, avoiding conflicts with the existing 'ethereum:' URL scheme while also adding an extra feature: `chain_id` which will help dApps to be accessed with the right network preselected, optionally extracting away that complexity from end users.


=== ERC-5679 ===
TITLE: Token Minting and Burning
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-09-17
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP introduces a consistent way to extend token standards for minting and burning.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. 1. Any contract complying with [EIP-20](./eip-20.md) when extended with this EIP, **MUST** implement the following interface: ```solidity // The EIP-165 identifier of this interface is 0xd0017968 interface IERC5679Ext20 { function mint(address _to, uint256 _amount, bytes calldata _data) external; function burn(address _from, uint256 _amount, bytes calldata _data) external; } ``` 2. Any contract complying with [EIP-721](./eip-721.md) when extended with this EIP, **MUST** implement the following interface: ```solidity // The EIP-165

MOTIVATION:
Minting and Burning are typical actions for creating and destroying tokens. By establishing a consistent way to mint and burn a token, we complete the basic lifecycle. Some implementations of [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) have been able to use `transfer` methods or the-like to mint and burn tokens. However, minting and burning change token supply. The access controls of minting and burning also usually follow different rules than transfer. Therefore, creating separate methods for burning and minting simplifies implementations and reduces security error.

RATIONALE:
1. It's possible that the interface be consolidated to the same as EIP-1155 which is always bearing `_amount` field, regardless of whether it's a EIP-20, EIP-721 or EIP-1155. But we choose that each ERC token should have their own standard way of representing the amount of token to follow the same way of `_id` and `_amount` in their original token standard. 2. We have chosen to identify the interface with [EIP-165](./eip-165.md) identifiers each individually, instead of having a single identifier because the signatures of interface are different. 3. We have chosen NOT to create new events but to


=== ERC-7746 ===
TITLE: Composable Security Middleware Hooks
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-07-17
REQUIRES: 

SUMMARY:
This EIP proposes a standard interface, `ILayer`, for implementing composable security layers in smart contracts. These layers act as middleware, enabling runtime validation of function calls before and after execution, independent of the protected contract's logic. This approach facilitates modular security, allowing independent providers to manage and upgrade security layers across multiple contracts.

SPECIFICATION:
A contract implementing the `ILayer` interface MUST provide two functions: ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity 0.8.20; interface ILayer { /// @notice Validates a function call before execution. /// @param configuration Layer-specific configuration data. /// @param selector The function selector being called. /// @param sender The address initiating the call. /// @param value The amount of ETH sent with the call (if any). /// @param data The calldata for the function call. /// @return beforeCallResult Arbitrary data to be passed to `afterCallValidation`. /// @dev MUST revert if validation fails. function beforeCall( bytes memory configuration, bytes4 selector, address sender,

MOTIVATION:
Current smart contract security practices often rely on monolithic validation logic within the contract itself. This can lead to tightly coupled code, making it difficult to isolate and address security concerns. Better structured architecture is needed, middleware like approach is widely used in the industry, allowing to wrap calls in other calls in generic and repeatable pattern with same call signatures. The Security Layers Standard introduces a modular approach, enabling: - **Independent Security Providers:** Specialized security providers can focus on developing and maintaining specific security checks. - **Composable Security:** Layers can be combined to create comprehensive security profiles

RATIONALE:
**Flexibility**: The `layerConfig` parameter allows for layer-specific customization, enabling a single layer implementation to serve multiple contracts with varying requirements. **non-static calls**: Layers can maintain their own state, allowing for more complex validation logic (e.g., rate limiting, usage tracking). **Strict Validation**: Reverts on validation failure ensure a fail-safe mechanism, preventing execution of potentially harmful transactions. **Gas Costs**: Layers naturally will have gas costs associated with their execution. However, the benefits of enhanced security and modularity outweigh these costs, especially as blockchain technology continues to evolve and we expect gas costs to decrease over time.


=== ERC-5008 ===
TITLE: ERC-721 Nonce Extension
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2022-04-10
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It proposes adding a `nonce` function to ERC-721 tokens.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ```solidity /// @dev the ERC-165 identifier for this interface is 0xce03fdab. interface IERC5008 /* is IERC165 */ { /// @notice Emitted when the `nonce` of an NFT is changed event NonceChanged(uint256 tokenId, uint256 nonce); /// @notice Get the nonce of an NFT /// Throws if `tokenId` is not a valid NFT /// @param tokenId The id of the NFT /// @return The nonce of the NFT function nonce(uint256 tokenId) external

MOTIVATION:
Some orders of NFT marketplaces have been attacked and the NFTs sold at a lower price than the current market floor price. This can happen when users transfer an NFT to another wallet and, later, back to the original wallet. This reactivates the order, which may list the token at a much lower price than the owner would have intended. This EIP proposes adding a `nonce` property to ERC-721 tokens, and the `nonce` will be changed when a token is transferred. If a `nonce` is added to an order, the order can be checked to avoid attacks.

RATIONALE:
At first `transferCount` was considered as function name, but there may some case to change the `nonce` besides transfer, such as important properties changed, then we changed `transferCount` to `nonce`.


=== ERC-3156 ===
TITLE: Flash Loans
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-11-15
REQUIRES: 

SUMMARY:
A flash loan is a smart contract transaction in which a lender smart contract lends assets to a borrower smart contract with the condition that the assets are returned, plus an optional fee, before the end of the transaction. This ERC specifies interfaces for lenders to accept flash loan requests, and for borrowers to take temporary control of the transaction within the lender execution. The process for the safe execution of flash loans is also specified.

SPECIFICATION:
A flash lending feature integrates two smart contracts using a callback pattern. These are called the LENDER and the RECEIVER in this EIP. ### Lender Specification A `lender` MUST implement the IERC3156FlashLender interface. ``` pragma solidity ^0.7.0 || ^0.8.0; import "./IERC3156FlashBorrower.sol"; interface IERC3156FlashLender { /** * @dev The amount of currency available to be lent. * @param token The loan currency. * @return The amount of `token` that can be borrowed. */ function maxFlashLoan( address token ) external view returns (uint256); /** * @dev The fee to be charged for a given loan. * @param token The loan

MOTIVATION:
Flash loans allow smart contracts to lend an amount of tokens without a requirement for collateral, with the condition that they must be returned within the same transaction. Early adopters of the flash loan pattern have produced different interfaces and different use patterns. The diversification is expected to intensify, and with it the technical debt required to integrate with diverse flash lending patterns. Some of the high level differences in the approaches across the protocols include: - Repayment approaches at the end of the transaction, where some pull the principal plus the fee from the loan receiver, and

RATIONALE:
The interfaces described in this ERC have been chosen as to cover the known flash lending use cases, while allowing for safe and gas efficient implementations. `flashFee` reverts on unsupported tokens, because returning a numerical value would be incorrect. `flashLoan` has been chosen as a function name as descriptive enough, unlikely to clash with other functions in the lender, and including both the use cases in which the tokens lent are held or minted by the lender. `receiver` is taken as a parameter to allow flexibility on the implementation of separate loan initiators and receivers. Existing flash lenders


=== ERC-7615 ===
TITLE: Atomic Push-based Data Feed Among Contracts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-03
REQUIRES: 

SUMMARY:
This ERC proposes a push-based mechanism for sending data, allowing publisher contract to automatically push certain data to subscriber contracts during a call. The specific implementation relies on two interfaces: one for publisher contract to push data, and another for the subscriber contract to receive data. When the publisher contract is called, it checks if the called function corresponds to subscriber addresses. If it does, the publisher contract push data to the subscriber contracts.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Overview The push mechanism can be divided into the following four steps: 1. The publisher contract is called. 2. The publisher contract query the subscriber list from the `selector` of the function called. The subscriber contract can put the selected data into `inbox`. 3. The publisher contract push `selector` and data through calling `exec` function of the subscriber contract. 4. The subscriber contract executes based on pushed `selector`

MOTIVATION:
Currently, there are many keepers rely on off-chain data or seperate data collection process to monitor the events on chain. This proposal aims to establish a system where the publisher contract can atomicly push data to inform subscriber contracts about the updates. The direct on-chain interaction bewteen the publisher and the subscriber allows the system to be more trustless and efficient. This proposal will offer significant advantages across a range of applications, such as enabling the boundless and permissionless expansion of DeFi, as well as enhancing DAO governance, among others. ### Lending Protocol An example of publisher contract

RATIONALE:
### Unconditional and Conditional Configuration When the sending contract is called, it is possible to trigger a push, requiring the caller to pay the resulting gas fees. In some cases, an Unconditional Push is necessary, such as pushing price changes to a lending protocol. While, Conditional Push will reduce the unwanted gas consumption. ### Check `isLocked` Before Unsubscribing Before `forceCancel` or `cancel`, the publisher contract MUST call the `isLocked` function of the subscriber contract to avoid unilateral unsubscribing. The subscriber contract may have a significant logical dependence on the publisher contract, and thus unsubscription could lead to severe


=== ERC-6268 ===
TITLE: Untransferability Indicator for EIP-1155
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-01-06
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP standardizes an interface indicating [EIP-1155](./eip-1155.md)-compatible token non-transferability using [EIP-165](./eip-165.md) feature detection.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Smart contracts implementing this standard MUST comform to the [EIP-1155](./eip-1155.md) specification. Smart contracts implementing this standard MUST implement all of the functions in the `IERC6268` interface. Smart contracts implementing this standard MUST implement the [EIP-165](./eip-165.md) supportsInterface function and MUST return the constant value true if `0xd87116f3` is passed through the interfaceID argument. For the token identifier `_id` that is marked as `locked`, `locked(_id)` MUST

MOTIVATION:
Soulbound Tokens (SBT) are non-transferable tokens. While [EIP-5192](./eip-5192.md) standardizes non-fungible SBTs, a standard for Soulbound semi-fungible or fungible tokens does not yet exist. The introduction of a standard non-transferability indicator that is agnostic to fungibility promotes the usage of Souldbound semi-fungible or fungible tokens.

RATIONALE:
Needs discussion.


=== ERC-3569 ===
TITLE: Sealed NFT Metadata Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-05-07
REQUIRES: 

SUMMARY:
This standard accomplishes three things; it provides a way for potential collectors to verify that the NFT metadata will not change, allows creators to immortalize metadata for multiple tokens at one time, and allows metadata for many NFTs to be read and cached from one file. A creator can call the `seal` function for a range of one or many sequential NFTs. Included as an argument is a URI which points to a decentralized storage service like IPFS and will be stored in the smart contract. The URI will return a JSON object in which the keys are

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ``` interface SealedMetadata { /** @notice This function is used to set a sealed URI for the given range of tokens. @dev - If the sealed URI is being set for one token then the fromTokenId and toTokenId values MUST be the same. - If any token within the range of tokens specified has already been sealed then this function MUST throw. - This function MAY be called at

MOTIVATION:
In the original ERC-721 standard, the metadata extension specifies a `tokenURI` function which returns a URI for a single token ID. This may be hosted on IPFS or might be hosted on a centralized server. There's no guarantee that the NFT metadata will not change. This is the same for the ERC-1155 metadata extension. In addition to that - if you want to update the metadata for many NFTs you would need to do so in O(n) time, which as we know is not financially feasible at scale. By allowing for a decentralized URI to point to a

RATIONALE:
**Rationale for rule not explicitly requiring that sealed URI be hosted on decentralized filestorage** In order for this standard to remain future proof there is no validation within the smart contract that would verify the sealed URI is hosted on IPFS or another decentralized file storage system. The standard allows potential collectors and platforms to validate the URI on the client. **Rationale to include many NFT metadata objects, or URIs in one JSON file** By including metadata for many NFTs in one JSON file we can eliminate the need for many transactions to set the metadata for multiple


=== ERC-7444 ===
TITLE: Time Locks Maturity
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-05
REQUIRES: 165

SUMMARY:
This EIP defines a standardized method to communicate the date on which a time-locked system will become unlocked. This allows for the determination of maturities for a wide variety of asset classes and increases the ease with which these assets may be valued.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. **Every [ERC-7444](./eip-7444.md) compliant contract must implement [ERC-165](./eip-165.md) interface detection** ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; interface ERC-7444 { / * @notice This function returns the timestamp that the time lock specified by `id` unlocks at * @param id The identifier which describes a specific time lock * @return maturity The timestamp of the time lock when it unlocks */ function getMaturity(bytes32 id) external

MOTIVATION:
Time-locks are ubiquitous, yet no standard on how to determine the date upon which they unlock exists. Time-locked assets experience theta-decay, where the time remaining until they become unlocked dictates their value. Providing a universal standard to view what date they mature on allows for improved on-chain valuations of the rights to these illiquid assets, particularly useful in cases where the rights to these illiquid assets may be passed between owners through semi-liquid assets such as [ERC-721](./eip-721.md) or [ERC-1155](./eip-1155.md).

RATIONALE:
### Universal Maturities on Locked Assets Locked Assets have become increasingly popular and used in different parts of defi, such as yield farming and vested escrow concept. This has increased the need to formalize and define an universal interface for all these timelocked assets. ### Valuation of Locked Assets via the Black-Scholes Model Locked Assets cannot be valued normally since the value of these assets can be varied through time and many other different factors throughout the locking time. For instance, The Black-Scholes Model or Black-Scholes-Merton model is an example of a suitable model to estimate the theoretical


=== ERC-5902 ===
TITLE: Smart Contract Event Hooks
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-11-09
REQUIRES: 712

SUMMARY:
This EIP proposes a standard for creating "hooks" that allow a smart contract function to be called automatically in response to a trigger fired by another contract, by using a public relayer network as a messaging bus. While there are many similar solutions in existence already, this proposal describes a simple yet powerful primitive that can be employed by many applications in an open, permissionless and decentralized manner. It relies on two interfaces, one for a publisher contract and one for a subscriber contract. The publisher contract emits events that are picked up by "relayers", who are independent

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Registering a Publisher Both the publisher and subscriber contracts **MUST** register in a specific register contract, similarly to how smart contracts register an interface in the [ERC-1820](./eip-1820.md) contract. The registry contract **MUST** must use a deterministic deployment mechanism, i.e. using a factory contract and a specific salt. To register a publisher contract's hook, the `registerHook` function **MUST** be called on the registry contract. The parameters that need to

MOTIVATION:
There exists a number of use cases that require some off-chain party to monitor the chain and respond to on-chain events by broadcasting a transaction. Such cases usually require some off-chain process to run alongside an Ethereum node in order to subscribe to events emitted by smart contract, and then execute some logic in response and subsequently broadcast a transaction to the network. This requires an Ethereum node and an open websocket connection to some long-running process that may only be used infrequently, resulting in a sub-optimal use of resources. This proposal would allow for a smart contract

RATIONALE:
The rationale for this design is that it allows smart contract developers to write contract logic that listens and responds to events fired in other smart contracts, without requiring them to run some dedicated off-chain process to achieve this. This best suits any simple smart contract logic that runs relatively infrequently in response to events in other contracts. This improves on the existing solutions to achieve a pub/sub design pattern. To elaborate: a number of service providers currently offer "webhooks" as a way to subscribe to events emitted by smart contracts, by having some API endpoint called when


=== ERC-6123 ===
TITLE: Smart Derivative Contract
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-12-13
REQUIRES: 

SUMMARY:
The Smart Derivative Contract (SDC) allows fully automizing and securing a financial product's - e.g. a financial derivative or bond - complete trade life cycle. The SDC leverages the advantages of smart contracts to remove many of the frictions associated with the classical derivative life cycle. Most notably, the protocol allows the removal of counterpart risk essentially. The SDC can be implemented using a pre-agreed valuation oracle and valuation model, removing ambiguity in the settlement amounts. The SDC provides methods and callbacks to enable fully automated and fully transactional settlements (delivery-versus-payment, payment-vs-payment). Token-based settlement can be realized by

SPECIFICATION:
### Methods The following methods specify a Smart Derivative Contract's trade initiation, trade termination and settlement life cycle. For further information, please also look at the interface documentation ISDC.sol. #### Trade Initiation Phase: `inceptTrade` A party can initiate a trade by providing the party address to trade with, trade data, trade position, payment amount for the trade and initial settlement data. Only registered counterparties are allowed to use that function. ```solidity function inceptTrade(address withParty, string memory tradeData, int position, int256 paymentAmount, string memory initialSettlementData) external returns (string memory); ``` The position and the paymentAmount are viewed from the

MOTIVATION:
### Rethinking Financial Derivatives By their very nature, so-called "over-the-counter (OTC)" financial contracts are bilateral contractual agreements on exchanging long-dated cash flow schedules. Since these contracts change their intrinsic market value due to changing market environments, they are subject to counterparty credit risk when one counterparty is subject to default. The initial white paper describes the concept of a Smart Derivative Contract (SDC) with the central aim to detach bilateral financial transactions from counterparty credit risk and to remove complexities in bilateral post-trade processing by a complete redesign. ### Concept of a Smart Derivative Contract A Smart Derivative

RATIONALE:
The interface design and reference implementation are based on the following considerations: - An SDC protocol enables interacting parties to initiate and process a financial transaction in a bilateral and deterministic manner. Settlement and Counterparty Risk is managed by the contract. - The provided interface specification is supposed to completely reflect the entire trade life cycle. - The interface specification is generic enough to handle the case that parties process one or even multiple financial transactions (on a netted base) - Usually, the valuation of financial trades (e.g. OTC Derivatives) will require advanced valuation methodology to determine the


=== ERC-1996 ===
TITLE: Holdable Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-04-10
REQUIRES: 20

SUMMARY:
A hold specifies a payer, a payee, a maximum amount, a notary and an expiration time. When the hold is created, the specified token balance from the payer is put on hold. A held balance cannot be transferred until the hold is either executed or released. The hold can only be executed by the notary, which triggers the transfer of the tokens from the payer to the payee. If a hold is released, either by the notary at any time, or by anyone after the expiration, no transfer is carried out and the amount is available again for

SPECIFICATION:
```solidity interface IHoldable /* is ERC-20 */ { enum HoldStatusCode { Nonexistent, Ordered, Executed, ReleasedByNotary, ReleasedByPayee, ReleasedOnExpiration } function hold(string calldata operationId, address to, address notary, uint256 value, uint256 timeToExpiration) external returns (bool); function holdFrom(string calldata operationId, address from, address to, address notary, uint256 value, uint256 timeToExpiration) external returns (bool); function releaseHold(string calldata operationId) external returns (bool); function executeHold(string calldata operationId, uint256 value) external returns (bool); function renewHold(string calldata operationId, uint256 timeToExpiration) external returns (bool); function retrieveHoldData(string calldata operationId) external view returns (address from, address to, address notary, uint256 value, uint256 expiration, HoldStatusCode status); function balanceOnHold(address account) external

MOTIVATION:
A hold has to be used in different scenarios where a immediate transfer between accounts is not possible or has to be guaranteed beforehand: 1. A regulated token may not allow to do a token transfer between accounts without verifying first, that it follows all the regulations. In this case a clearable transfer has to be used. During the clearing process a hold is created to ensure, that the transfer is successful after all checks have passed. If the transfer violates any of the regulations, it is cleared and not further processed. 1. In certain business situations a

RATIONALE:
This standards provides a functionality, to guarantee future payments, which is needed for many business cases where transfers have to be guaranteed. It goes a step further than the ERC-20 `approve` function by ensuring that the held balance will be available when the transfer is done. Something that can not be done with `approve`, as the approved amount is only a maximum spending amount, but never guaranteed to be available. While not requiring it, the naming of the functions `authorizeHoldOperator`, `revokeHoldOperator` and `isHoldOperatorFor` follows the naming convention of [ERC-777](./eip-777.md). The `operationId` is a string and not something more


=== ERC-838 ===
TITLE: ABI specification for REVERT reason string
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2020-08-20
REQUIRES: 

SUMMARY:
This proposal specifies how to encode potential error conditions in the JSON ABI of a smart contract. A high-level language could then provide a syntax for declaring and throwing these errors. The compiler will encode these errors in the reason parameter of the REVERT opcode in a way that can be easily reconstructed by libraries such as web3.

SPECIFICATION:
To conform to this specification, compilers producing JSON ABIs SHOULD include error declarations alongside functions and events. Each error object MUST contain the keys name (string) and arguments (same types as the function’s inputs list). The value of type MUST be "error". Example: ``` { "type": "error", "name": "InsufficientBalance", "arguments": [ { "name": "amount", "type": "uint256" } ] } ``` A selector for this error can be computed from its signature (InsufficientBalance() for the example above) in the same way that it's currently done for public functions and events. This selector MUST be included in the reason string

MOTIVATION:
It's important to provide clear feedback to users (and developers) about what went wrong with their Ethereum transactions. The REVERT opcode is a step in the right direction, as it allows smart contract developers to encode a message describing the failure in the reason parameter. There is an implementation under review in Solidity that accepts a string, thus providing a low-level interface to this parameter. However, standardizing a method for passing errors from this parameter back to clients will bring many benefits to both users and developers. The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",

RATIONALE:
Needs discussion. <!-- TODO -->


=== ERC-7786 ===
TITLE: Cross-Chain Messaging Gateway
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-14
REQUIRES: 

SUMMARY:
This proposal describes an interface, and the corresponding workflow, for smart contracts to send arbitrary data through cross-chain messaging protocols. The end goal of this proposal is to have all such messaging protocols accessible via this interface (natively or using "adapters") to improve their composability and interoperability. That would allow a new class of cross-chain native smart contracts to emerge while reducing vendor lock-in. This proposal is modular by design, allowing users to leverage bridge-specific features through attributes while providing simple "universal" access to the simple feature of "just getting a simple message through".

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Message Field Encoding A cross-chain message consists of a sender, receiver, payload, and list of attributes. #### Sender & Receiver The sender account (in the source chain) and receiver account (in the destination chain) MUST be represented using [CAIP-10] account identifiers. Note that these are ASCII-encoded strings. A [CAIP-10] account identifier embeds a [CAIP-2] chain identifier along with an address. In some parts

MOTIVATION:
Cross-chain messaging protocols (or bridges) allow communication between smart contracts deployed on different blockchains. There is a large diversity of such protocols with multiple degrees of decentralization, different architectures, implementing different interfaces, and providing different guarantees to users. Because almost every protocol implements a different workflow using a specific interface, portability between bridges is currently basically impossible. This also prevents the development of generic contracts that rely on cross chain communication. The objective of this ERC is to provide a standard interface, and a corresponding workflow, for performing cross-chain communication between contracts. Existing cross-chain communication protocols that do

RATIONALE:
Attributes are designed so that gateways can expose any specific features the bridge offers without having to use a specific endpoint. Having a unique endpoint, with modularity through attributes, SHOULD allow contracts to change the gateway they use while continuing to express messages the same way. This portability offers many advantages: - A contract that relies on a specific gateway for sending messages is vulnerable to the gateway being paused, deprecated, or simply breaking. If the communication between the contract and the gateway is standard, an admin of the contract COULD update the address (in storage) of the


=== ERC-7144 ===
TITLE: ERC-20 with transaction validation step.
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-05-07
REQUIRES: 20

SUMMARY:
This standard is an extension of [ERC-20](./eip-20.md). It defines new validation functionality to avoid wallet draining: every `transfer` or `approve` will be locked waiting for validation.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. [ERC-20](./eip-20.md) compliant contracts MAY implement this EIP. All the operations that change the ownership of Tokens, like a `transfer`/`transferFrom`, SHALL create a `TransferValidation` pending to be validated and emit a `ValidateTransfer`, and SHALL NOT transfer the Tokens. All the operations that enable an approval to manage a Token, like an `approve`, SHALL create an `ApprovalValidation` pending to be validated and emit a `ValidateApproval`, and SHALL NOT enable an approval. When

MOTIVATION:
The power of the blockchain is at the same time its weakness: giving the user full responsibility for their data. Many cases of Token theft currently exist, and current Token anti-theft schemes, such as transferring Tokens to cold wallets, make Tokens inconvenient to use. Having a validation step before every `transfer` and `approve` would give Smart Contract developers the opportunity to create secure Token anti-theft schemes. An implementation example would be a system where a validator address is responsible for validating all Smart Contract transactions. This address would be connected to a dApp where the user could see

RATIONALE:
### Universality The standard only defines the validation functions, but not how they should be used. It defines the validations as internal and lets the user decide how to manage them. An example could be to have an address validator connected to a dApp so that users could manage their validations. This validator could be used for all Tokens or only for some users. It could also be used as a wrapped Smart Contract for existing ERC-20, allowing 1/1 conversion with existing Tokens. ### Extensibility This standard only defines the validation function, but does not define the system


=== ERC-3754 ===
TITLE: A Vanilla Non-Fungible Token Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-08-21
REQUIRES: 

SUMMARY:
In this standard, a non-fungible token stands as atomic existence and encourages layers of abstraction built on top of it. Ideal for representing concepts like rights, a form of abstract ownership. Such right can take the form of NFT options, oracle membership, virtual coupons, etc., and can then be made liquid because of this tokenization.

SPECIFICATION:
``` interface IERC3754 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function balanceOf(address owner) external view returns (uint256); function ownerOf(uint256 tokenId) external view returns (address); function approve(address to, uint256 tokenId) external; function getApproved(uint256 tokenId) external view returns (address); function setApprovalForAll(address operator, bool approved) external; function isApprovedForAll(address owner, address operator) external view returns (bool); function transferFrom(address from, address to, uint256 tokenId) external; function safeTransferFrom(address from, address to, uint256 tokenId) external; function safeTransferFrom(address from, address to, uint256 tokenId,

MOTIVATION:
Non-fungible tokens are popularized by the [ERC-721](./eip-721.md) NFT standard for representing "ownership over digital or physical assets". Over the course of development, reputable NFT projects are about crypto-assets, digital collectibles, etc. The proposed standard aims to single out a special type of NFTs that are ideal for representing abstract ownership such as rights. Examples include the right of making a function call to a smart contract, an NFT option that gives the owner the right, but not obligation, to purchase an ERC-721 NFT, and the prepaid membership (time-dependent right) of accessing to data feeds provided by oracles without

RATIONALE:
The NFTs defined in the [ERC-721](./eip-721.md) standard are already largely accepted and known as representing ownership of digital assets, and the NFTs by this standard aim to be accepted and known as representing abstract ownership. This is achieved by allowing and encouraging layers of abstract utilities built on top of them. Ownership of such NFTs is equivalent with having the rights to perform functions assigned to such tokens. Transfer of such rights is also made easier because of this tokenization. To further distinguish this standard from [ERC-721](./eip-721.md), data fields and functions related to `URI` are excluded.


=== ERC-7858 ===
TITLE: Expirable NFTs and SBTs
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-01-04
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
Introduces an extension for [ERC-721](./eip-721.md) Non-Fungible Tokens (NFTs) and Soulbound Tokens (SBTs) that adds an expiration mechanism, allowing tokens to become invalid after a predefined period. This additional layer of functionality ensures that the expiration mechanism does not interfere with existing NFTs or SBTs, preserving transferability for NFTs and compatibility with current DApps such as NFT Marketplace. Expiration can be defined using either block height or timestamp, offering flexibility for various use cases.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Interface ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity >=0.8.0 <0.9.0; /** * @title ERC-7858: Expirable NFTs and SBTs * @notice unique/granular expiry */ // import "./IERC721.sol"; // The EIP-165 identifier of this interface is `0x3ebdfa31`. interface IERC7858 /**is IERC721 */ { enum EXPIRY_TYPE { BLOCKS_BASED, // block.number TIME_BASED // block.timestamp } /** * @dev Emitted when the expiration date of a token is set or

MOTIVATION:
Introduces an extension for [ERC-721](./eip-721.md) Non-Fungible Tokens (NFTs) and Soulbound Tokens (SBTs), which facilitates the implementation of an expiration mechanism. Use cases include: - Access and Authentication - Authentication for Identity and Access Management (IAM) - Membership for Membership Management System (MMS) - Ticket and Press for Meetings, Incentive Travel, Conventions, and Exhibitions (MICE) when using with [ERC-2135](./eip-2135.md) or [ERC-7578](./eip-7578.md). - Subscription-based access for digital platforms. - Digital Certifications, Contracts, Copyrights, Documents, Licenses, Policies, etc. - Loyalty Program voucher or coupon - Governance and Voting Rights - Financial Product - Bonds, Loans, Hedge, and Options Contract

RATIONALE:
### First, do no harm Introducing expirability as an additional layer of functionality ensures it doesn’t interfere with existing use cases or applications. For non-SBT tokens, transferability remains intact, maintaining compatibility with current systems. Expired tokens are simply flagged as unusable during validity checks, treating expiration as an enhancement rather than a fundamental change. ### Expiry Types Defining expiration by either block height (`block.number`) or block timestamp (`block.timestamp`) offers flexibility for various use cases. Block-based expiration suits applications that rely on network activity and require precise consistency, while time-based expiration is ideal for networks with variable block intervals.


=== ERC-1337 ===
TITLE: Subscriptions on the blockchain
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-08-01
REQUIRES: 2, 0, ,,  , 1, 6, 5

SUMMARY:
To enable replay-able transactions users sign a concatenated bytes hash that is composed of the input data needed to execute the transaction. This data is stored off chain by the recipient of the payment and is transmitted to the customers smart contract for execution alongside a provided signature.

SPECIFICATION:
#### Enum Contract EIP-1337 Contracts should be compiled with a contract that references all the enumerations that are required for operation ```SOLIDITY /// @title Enum - Collection of enums /// Original concept from Richard Meissner - <richard@gnosis.pm> Gnosis safe contracts contract Enum { enum Operation { Call, DelegateCall, Create, ERC20, ERC20Approve } enum SubscriptionStatus { ACTIVE, PAUSED, CANCELLED, EXPIRED } enum Period { INIT, DAY, WEEK, MONTH } } ``` #### EIP-165 EIP-1337 compliant contracts support EIP-165 announcing what interfaces they support ```SOLIDITY interface ERC165 { /** * @notice Query if a contract implements an interface * @param

MOTIVATION:
Recurring payments are the bedrock of SaSS and countless other businesses, a robust specification for defining this interaction will enable a broad spectrum of revenue generation and business models.

RATIONALE:
Merchants who accept credit-cards do so by storing a token that is retrieved from a third party processor(stripe, paypal, etc), this token is used to grant access to pull payment from the cx's credit card provider and move funds to the merchant account. Having users sign input data acts in a similliar fashion and enables that merchant to store the signature of the concatenated bytes hash and input data used to generate the hash and pass them off to the contract holding the subscription logic, thus enabling a workflow that is similliar to what exists in the present


=== ERC-205 ===
TITLE: ENS support for contract ABIs
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2017-02-06
REQUIRES: 1, 3, 7, ,,  , 1, 8, 1

SUMMARY:
ABIs are important metadata required for interacting with most contracts. At present, they are typically supplied out-of-band, which adds an additional burden to interacting with contracts, particularly on a one-off basis or where the ABI may be updated over time. The small size of ABIs permits an alternative solution, storing them in ENS, permitting name lookup and ABI discovery via the same process. ABIs are typically quite compact; the largest in-use ABI we could find, that for the DAO, is 9450 bytes uncompressed JSON, 6920 bytes uncompressed CBOR, and 1128 bytes when the JSON form is compressed with

SPECIFICATION:
### ABI encodings In order to allow for different tradeoffs between onchain size and accessibility, several ABI encodings are defined. Each ABI encoding is defined by a unique constant with only a single bit set, allowing for the specification of 256 unique encodings in a single uint. The currently recognised encodings are: | ID | Description | |----|----------------------| | 1 | JSON | | 2 | zlib-compressed JSON | | 4 | CBOR | | 8 | URI | This table may be extended in future through the EIP process. Encoding type 1 specifies plaintext JSON, uncompressed; this

RATIONALE:
Storing ABIs onchain avoids the need to introduce additional dependencies for applications wishing to fetch them, such as swarm or HTTP access. Given the typical compactness of ABIs, we believe this is a worthwhile tradeoff in many cases. The two-step resolution process permits different names to provide different ABIs for the same contract, such as in the case where it's useful to provide a minimal ABI to some callers, as well as specifying ABIs for contracts that did not specify one of their own. The fallback to looking up an ABI on the reverse record permits contracts to


=== ERC-2520 ===
TITLE: Multiple contenthash records for ENS
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-02-18
REQUIRES: 1577

SPECIFICATION:
Setting and getting functions **MUST** have the same public interface as specified in EIP 1577. Additionally, they **MUST** also have new public interfaces introduced by this EIP: * For setting a `contenthash` record, the `setContenthash` **MUST** provide additional `proto` parameter and use it to save the `contenthash`. When `proto` is not provided, it **MUST** save the record as default record. ```solidity function setContenthash(bytes32 node, bytes calldata proto, bytes calldata hash) external authorised(node); ``` * For getting a `contenthash` record, the `contenthash` **MUST** provide additional `proto` parameter and use it to get the `contenthash` for requested type. When `proto`

MOTIVATION:
Many applications are resolving ENS names to content hosted on distributed systems. To do this, they use `contenthash` record from ENS domain to know how to resolve names and which distributed system should be used. However, the domain can store only one `contenthash` record which means that the site owner needs to decide which hosting system to use. Because there are many ENS-compatible hosting systems available (IPFS, Swarm, recently Onion and ZeroNet), and there will probably be even more in the future, lack of support for multiple records could become problematic. Instead, domains should be able to store

RATIONALE:
The proposed implementation was chosen because it is simple to implement and supports all important requested features. However, it doesn't support multiple records for the same type and priority order, as they don't give much advantage and are harder to implement properly.


=== ERC-7738 ===
TITLE: Permissionless Script Registry
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-07-01
REQUIRES: 173

SUMMARY:
This EIP provides a means to create a standard registry for locating executable scripts associated with the token.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. The contract MUST implement the `IERC7738` interface. The contract MUST emit the `ScriptUpdate` event when the script is updated. The contract SHOULD order the `scriptURI` returned so that the [ERC-173](./eip-173.md) `owner()` of the contract's script entries are returned first (in the case of simple implementations the wallet will pick the first `scriptURI` returned). The contract SHOULD provide a means to page through entries if there are a large number of

MOTIVATION:
[ERC-5169](./eip-5169.md) provides a client script lookup method for contracts. This requires the contract to have implemented the [ERC-5169](./eip-5169.md) interface at the time of construction (or allow an upgrade path). This proposal outlines a contract that can supply prototype and certified scripts. The contract would be a multichain singleton instance that would be deployed at identical addresses on supported chains. ### Overview The registry contract will supply a set of URI links for a given contract address. These URI links point to script programs that can be fetched by a wallet, viewer or mini-dapp. The pointers can be set

RATIONALE:
This method allows contracts written without the [ERC-5169](./eip-5169.md) interface to associate scripts with themselves, and avoids the need for a centralised online server, with subsequent need for security and the requires an organisation to become a gatekeeper for the database.


=== ERC-7533 ===
TITLE: Public Cross Port
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-10-11
REQUIRES: 

SUMMARY:
The objective of Public Cross Port (PCP) is to securely and efficiently connect various EVM chains. It replaces the method of pushing message to multiple chains with a method of pulling messages from multiple chains, significantly reducing the number of cross-chain bridges and gas cost, as more cross-chain bridge projects are built on PCP, the overall security increases.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The essence of cross-chain is to inform the target chain about events happening on the source chain. This process can be divided into 3 steps. The following diagram illustrates the overall principle: ![](../assets/eip-7533/1.png) ### 1.Add cross-chain message Under this EIP, a `SendPort` contract is deployed on each chain. It is responsible for collecting cross-chain messages on that chain and packing them. `SendPort` operates as

MOTIVATION:
Currently, there are official cross-chain bridges between L2 and L1, but not between L2s. If there are 10 L2 chains that need to cross-chain with each other, it would require 10 x 9 = 90 cross-chain bridges. However, if a pull mechanism is used to merge messages from the other 9 chains into one transaction synchronized to its own chain, only 10 cross-chain bridges would be needed. This significantly reduces the number of cross-chain bridges required and minimizes gas cost. This implementation, with the participation of multiple cross-chain bridge projects, would greatly enhance security. There is currently a

RATIONALE:
The traditional approach involves using a push method, as depicted in the following diagram: ![](../assets/eip-7533/2.png) If there are 6 chains, each chain needs to push to the other 5 chains, resulting in the requirement of 30 cross-chain bridges, as shown in the diagram below: ![](../assets/eip-7533/3.png) When N chains require cross-chain communication with each other, the number of cross-chain bridges needed is calculated as: num = N * (N - 1). Using the pull approach allows the batch of cross-chain messages from 5 chains into 1 transaction, significantly reducing the number of required cross-chain bridges, as illustrated in the


=== ERC-2535 ===
TITLE: Diamonds, Multi-Facet Proxy
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-02-22
REQUIRES: 

SUMMARY:
<img align="right" src="../assets/eip-2535/diamond.svg" width="230" height="230" alt="Diamonds contract structure"> This proposal standardizes diamonds, which are modular smart contract systems that can be upgraded/extended after deployment, and have virtually no size limit. More technically, a **diamond** is a contract with external functions that are supplied by contracts called **facets**. Facets are separate, independent contracts that can share internal functions, libraries, and state variables.

SPECIFICATION:
### Terms 1. A **diamond** is a facade smart contract that `delegatecall`s into its facets to execute function calls. A diamond is stateful. Data is stored in the contract storage of a diamond. 1. A **facet** is a stateless smart contract or Solidity library with external functions. A facet is deployed and one or more of its functions are added to one or more diamonds. A facet does not store data within its own contract storage but it can define state and read and write to the storage of one or more diamonds. The term facet comes from

MOTIVATION:
There are a number of different reasons to use diamonds. Here are some of them: 1. **A single address for unlimited contract functionality.** Using a single address for contract functionality makes deployment, testing and integration with other smart contracts, software and user interfaces easier. 1. **Your contract exceeds the 24KB maximum contract size.** You may have related functionality that it makes sense to keep in a single contract, or at a single contract address. A diamond does not have a max contract size. 1. **A diamond provides a way to organize contract code and data.** You may want

RATIONALE:
### Using Function Selectors User interface software can be used to retrieve function selectors and facet addresses from a diamond in order show what functions a diamond has. This standard is designed to make diamonds work well with user-interface software. Function selectors with the ABI of a contract provide enough information about functions to be useful for user-interface software. ### Gas Considerations Delegating function calls does have some gas overhead. This is mitigated in several ways: 1. Because diamonds do not have a max size limitation it is possible to add gas optimizing functions for use cases. For


=== ERC-1820 ===
TITLE: Pseudo-introspection Registry Contract
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2019-03-04
REQUIRES: 1, 6, 5, ,,  , 2, 1, 4

SUMMARY:
This standard defines a registry where smart contracts and regular accounts can publish which functionality they implement---either directly or through a proxy contract. Anyone can query this registry to ask if a specific address implements a given interface and which smart contract handles its implementation. This registry MAY be deployed on any chain and shares the same address on all chains. Interfaces with zeroes (`0`) as the last 28 bytes are considered [ERC-165] interfaces, and this registry SHALL forward the call to the contract to see if it implements the interface. This contract also acts as an [ERC-165]

SPECIFICATION:
### [ERC-1820] Registry Smart Contract > This is an exact copy of the code of the [ERC1820 registry smart contract]. ``` solidity /* ERC1820 Pseudo-introspection Registry Contract * This standard defines a universal registry smart contract where any address (contract or regular account) can * register which interface it supports and which smart contract is responsible for its implementation. * * Written in 2019 by Jordi Baylina and Jacques Dafflon * * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to * this software to the public domain worldwide.

MOTIVATION:
There have been different approaches to define pseudo-introspection in Ethereum. The first is [ERC-165] which has the limitation that it cannot be used by regular accounts. The second attempt is [ERC-672] which uses reverse [ENS]. Using reverse [ENS] has two issues. First, it is unnecessarily complicated, and second, [ENS] is still a centralized contract controlled by a multisig. This multisig theoretically would be able to modify the system. This standard is much simpler than [ERC-672], and it is *fully* decentralized. This standard also provides a *unique* address for all chains. Thus solving the problem of resolving the correct

RATIONALE:
This standards offers a way for any type of address (externally owned and contracts) to implement an interface and potentially delegate the implementation of the interface to a proxy contract. This delegation to a proxy contract is necessary for externally owned accounts and useful to avoid redeploying existing contracts such as multisigs and DAOs. The registry can also act as a [ERC-165] cache in order to save gas when looking up if a contract implements a specific [ERC-165] interface. This cache is intentionally kept simple, without automatic cache update or invalidation. Anyone can easily and safely update the


=== ERC-2525 ===
TITLE: ENSLogin
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-02-19
REQUIRES: 1, 3, 7, ,,  , 6, 3, 4, ,,  , 1, 1, 9, 3, ,,  , 2, 3, 0, 4


=== ERC-2942 ===
TITLE: EthPM URI Specification
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-09-04
REQUIRES: 2678

SUMMARY:
When interacting with the EthPM ecosystem, users and tooling can benefit from a URI scheme to identify EthPM assets. Being able to specify a package, registry, or release with a single string makes simplifies the steps required to install, publish, or distribute EthPM packages.

SPECIFICATION:
`scheme://registry_address[:chain_id][/package_name[@package_version[/json_pointer]]]` #### `scheme` - Required - Must be one of `ethpm` or `erc1319`. If future versions of the EthPM registry standard are designed and published via the ERC process, those ERCs will also be valid schemes. #### `registry_address` - Required - This **SHOULD** be either an ENS name or a 0x-prefixed, checksummed address. ENS names are more suitable for cases where mutability of the underlying asset is acceptable and there is implicit trust in the owner of the name. 0x prefixed addresses are more preferable in higher security cases to avoid needing to trust the controller of the

RATIONALE:
Most interactions within the EthPM ecosystem benefit from a single-string representation of EthPM assets; from installing a package, to identifying a registry, to distributing a package. A single string that can faithfully represent any kind of EthPM asset, across the mainnet or testnets, reduces the mental overload for new users, minimizes configuration requirements for frameworks, and simplifies distribution of packages for package authors.


=== ERC-1504 ===
TITLE: Upgradable Smart Contract
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-10-17
REQUIRES: 

SUMMARY:
Ethereum smart contracts have suffered a number of security issues in the past few years. The cost of fixing such a bug in smart contract is significant; for example, the consequences of The DAO attack in June 2016 caused tremendous financial loss and the hard fork of Ethereum blockchain. The following standard makes it possible to upgrade a standard API within smart contracts. This standard provides basic functionalities to upgrade the operations of the contract without data migration. To ensure the decentralization/community interests, it also contains a voting mechanism to control the upgrading process.

SPECIFICATION:
The upgradable contract consists of three parts: - **Handler contract** (implements **Handler interface**) defines operations and provides services. This contract can be upgraded; - **Data contract** keeps the resources (data) and is controlled by the Handler contract; - **Upgrader contract (optional)** deals with the voting mechanism and upgrades the Handler contract. The voters are pre-defined by the contract owner. > The following codes are exact copies of the [ERC-1504 Upgradable Smart Contract.](https://gist.github.com/swordghost/77c96a972106af6ec6ccea9c2d66e768) ### Handler contract and Handler interface Functions of the Handler contract vary with requirements, so developers would better design interfaces for Handler contracts to limit them

MOTIVATION:
Smart contract is immutable after deployment. If any security risk is identified or program bug is detected, developers always have to destruct the old contract, deploy a new one and potentially migrate the data (hard fork) to the new contract. In some cases, deploying a smart contract with bugs and potential security vulnerabilities can cause a significant amount of financial loss. We propose this upgradable contract to fix the current situation. With the upgradable contract, developers can deploy a new version of smart contract after previous deployment and retain the data at the same time. For example, after

RATIONALE:
### Data Contract and Handler Contract A smart contract is actually a kind of software, which provides some kind of services. From the perspective of software engineering, a service consists of **resources** that abstract the data and **operations** that abstract the process logic on the data. The requirement of upgrading is mostly on the logic part. Therefore, in order to make a smart contract upgradable, we divide it into two parts: 1. Data contract keeps the resources; 2. Handler contract contains operations. The Handler contract can be upgraded in the future while the Data contract is permanent. Handler


=== ERC-7406 ===
TITLE: Multi-Namespace Onchain Registry
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-23
REQUIRES: 137

SUMMARY:
This EIP proposes a universally accepted description for onchain registry entries with support for multi-namespaces, where each entry is structured as a mapping type. The multi-namespace registry enables the storage of a collection of key-value mappings within the blockchain, serving as a definitive source of information with a traceable history of changes. These mapping records act as pointers combined with onchain assets, offering enhanced versatility in various use cases by encapsulating extensive details. The proposed solution introduces a general mapping data structure that is flexible enough to support and be compatible with different situations, providing a more scalable

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### **Registry specification** The multi namespace registry contract exposes the following functions: ```solidity function owner(bytes32 namespace, bytes32 key) external view returns (address); ``` - Returns the owner of the specified **key** under the given **namespace**. ```solidity function resolver(bytes32 namespace, bytes32 key) external view returns (address); ``` - Returns the resolver address for the specified **key** under the given **namespace**. ```solidity function setOwner(bytes32 namespace, bytes32 key, address newOwner) external; ```

MOTIVATION:
Blockchain-based registries are fundamental components for decentralized applications, enabling the storage and retrieval of essential information. Existing solutions, like the ENS registry, serve specific use cases but may lack the necessary flexibility to accommodate more complex scenarios. The need for a more general mapping data structure with multi-namespace support arises to empower developers with a single registry capable of handling diverse use cases efficiently. The proposed multi-namespace registry offers several key advantages: - **Versatility**: Developers can define and manage multiple namespaces, each with its distinct set of keys, allowing for more granular control and organization of data. For

RATIONALE:
By supporting multiple namespaces, the registry caters to various use cases, including but not limited to identity management, session management, record tracking, and decentralized content publishing. This flexibility enables developers to design and implement more complex decentralized applications with ease.


=== ERC-7780 ===
TITLE: Validation Module Extension for ERC-7579
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-01
REQUIRES: 7579

SUMMARY:
This proposal introduces three new module types on top of the existing modules described in [ERC-7579](./eip-7579). The modules are policy, signer and stateless validator. None of these modules are required to be implemented by accounts, but accounts can choose to implement them or other modules can choose to make use of them for additional composability. Policy modules can be used to check what a `UserOperation` or action is trying to achieve and determine if this is allowed. Signer modules can be used to validate signatures on provided hashes. Stateless validators are modules that are used to both validate

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This standard introduces three new module types on top of the existing modules introduced by ERC-7579: - Policy (type id: 5) - Signer (type id: 6) - Stateless Validator (type id: 7) Note: A single module can be of multiple types. ### Policy Policies MUST implement [ERC-7579](./eip-7579.md)'s `IModule` and the `IPolicy` interface and have module type id: `5`. ```solidity interface IPolicy is IModule {

MOTIVATION:
The modules introduced by this proposal aim to create more composability around signature and permission verification. Policy and signer modules allow an account to make direct use of such a permissioning logic rather than relying on external modules to handle this. This has the upside of lower gas cost but the downside of less flexibility for users and developers that use the account. Stateless validators enable further composability around signature validation logic. In many cases, it does not make sense to re-write signature validation for new validators, but instead to use the existing ones. However, this is usually

RATIONALE:
TBD <!-- TODO -->


=== ERC-7603 ===
TITLE: ERC-1155 Multi-Asset extension
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-01-25
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
The Multi-Asset Token standard, compatible with [ERC-1155](./eip-1155.md), facilitates the development of a new fundamental component: the context-dependent data output for each collection. The context-dependent data output means that the asset is displayed in an appropriate format based on how the token is accessed. I.e., if the token is being opened in an e-book reader, the PDF asset is displayed; if the token is opened in the marketplace, the PNG or the SVG asset is displayed; if the token is accessed from within a game, the 3D model asset is accessed, and if the token is accessed by an

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ```solidity /// @title ERC-7603 Context-Dependent Multi-Asset Tokens, ERC-1155 Execution /// @dev See https://eips.ethereum.org/EIPS/erc-7603 pragma solidity ^0.8.23; interface IERC7603 /* is ERC165 */ { /** * @notice Used to notify listeners that an asset object is initialised at `assetId`. * @param assetId ID of the asset that was initialised */ event AssetSet(uint64 assetId); /** * @notice Used to notify listeners that an asset object at

MOTIVATION:
With ERC-1155 compatible tokens being a widespread form of tokens in the Ethereum ecosystem and being used for various use cases, it is time to standardize additional utility for them. Having multiple assets associated with a single Token Collection allows for greater utility, usability, and forward compatibility. This EIP improves upon ERC-1155 in the following areas: - [Cross-metaverse compatibility](#cross-metaverse-compatibility) - [Multi-media output](#multi-media-output) - [Media redundancy](#media-redundancy) ### Cross-metaverse compatibility The proposal can support any number of different implementations. Cross-metaverse compatibility could also be referred to as cross-engine compatibility. An example is where a cosmetic item for game A is

RATIONALE:
TBD <!-- TODO -->


=== ERC-6059 ===
TITLE: Parent-Governed Nestable Non-Fungible Tokens
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-11-15
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The Parent-Governed Nestable NFT standard extends [ERC-721](./eip-721.md) by allowing for a new inter-NFT relationship and interaction. At its core, the idea behind the proposal is simple: the owner of an NFT does not have to be an Externally Owned Account (EOA) or a smart contract, it can also be an NFT. The process of nesting an NFT into another is functionally identical to sending it to another user. The process of sending a token out of another one involves issuing a transaction from the account owning the parent token. An NFT can be owned by a single other

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title EIP-6059 Parent-Governed Nestable Non-Fungible Tokens /// @dev See https://eips.ethereum.org/EIPS/eip-6059 /// @dev Note: the ERC-165 identifier for this interface is 0x42b0e56f. pragma solidity ^0.8.16; interface IERC6059 /* is ERC165 */ { /** * @notice The core struct of ownership. * @dev The `DirectOwner` struct is used to store information of the next immediate owner, be it the parent token, * an `ERC721Receiver` contract or an externally owned

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to own other tokens allows for greater utility, usability and forward compatibility. In the four years since [ERC-721](./eip-721.md) was published, the need for additional functionality has resulted in countless extensions. This ERC improves upon ERC-721 in the following areas: - [Bundling](#bundling) - [Collecting](#collecting) - [Membership](#membership) - [Delegation](#delegation) ### Bundling One of the most frequent uses of [ERC-721](./eip-721.md) is to disseminate the multimedia content

RATIONALE:
Designing the proposal, we considered the following questions: 1. **How to name the proposal?**\ In an effort to provide as much information about the proposal we identified the most important aspect of the proposal; the parent centered control over nesting. The child token's role is only to be able to be `Nestable` and support a token owning it. This is how we landed on the `Parent-Centered` part of the title. 2. **Why is automatically accepting a child using [EIP-712](./eip-712.md) permit-style signatures not a part of this proposal?**\ For consistency. This proposal extends ERC-721 which already uses 1 transaction


=== ERC-5139 ===
TITLE: Remote Procedure Call Provider Lists
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-06-06
REQUIRES: 1, 5, 5, ,,  , 1, 5, 7, 7

SUMMARY:
This proposal specifies a JSON schema for describing lists of remote procedure call (RPC) providers for Ethereum-like chains, including their supported [EIP-155](./eip-155.md) `CHAIN_ID`.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### List Validation & Schema List consumers (like wallets) MUST validate lists against the provided schema. List consumers MUST NOT connect to RPC providers present only in an invalid list. Lists MUST conform to the following JSON Schema: ```json { "$schema": "https://json-schema.org/draft/2020-12/schema", "title": "Ethereum RPC Provider List", "description": "Schema for lists of RPC providers compatible with Ethereum wallets.", "$defs": { "VersionBase": { "type": "object", "description": "Version of a list, used

MOTIVATION:
The recent explosion of alternate chains, scaling solutions, and other mostly Ethereum-compatible ledgers has brought with it many risks for users. It has become commonplace to blindly add new RPC providers using [EIP-3085](./eip-3085.md) without evaluating their trustworthiness. At best, these RPC providers may be accurate, but track requests; and at worst, they may provide misleading information and frontrun transactions. If users instead are provided with a comprehensive provider list built directly by their wallet, with the option of switching to whatever list they so choose, the risk of these malicious providers is mitigated significantly, without sacrificing functionality for

RATIONALE:
This specification has two layers (provider, then chain id) instead of a flatter structure so that wallets can choose to query multiple independent providers for the same query and compare the results. Each provider may specify multiple endpoints to implement load balancing or redundancy. List version identifiers conform to SemVer to roughly communicate the kinds of changes that each new version brings. If a new version adds functionality (eg. a new chain id), then users can expect the minor version to be incremented. Similarly, if the major version is not incremented, list subscribers can assume dapps that work


=== ERC-7794 ===
TITLE: Grant Registry
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-22
REQUIRES: 

SUMMARY:
This proposal introduces a Grant Registry contract intended for managing financial, research, or project-based grants that provide funding for projects across multiple blockchains. The contract standardizes the registration, management, and tracking of these grants by organizing data into distinct categories, enabling clear separation between immutable fields and mutable fields. It supports modular disbursement tracking and allows for external links to off-chain documentation. This registry emits lifecycle events, enabling external protocols to efficiently access grant data, which promotes transparency, interoperability, and enhanced insights into grant program performance.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### **Contract Interface** ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.20; interface IGrantRegistry { /** * @dev Thrown when the community name length is invalid (e.g., too short or too long). */ error InvalidCommunityNameLength(); /** * @dev Thrown when the caller is not the current grant manager. */ error InvalidGrantManager(); /** * @dev Thrown when a grant is already registered with the provided ID. */

MOTIVATION:
The Ethereum ecosystem currently lacks a standardized way to manage and track grants across different chains and programs, leading to inefficiencies and fragmentation. Each grant program has its own distinct interface, processes, and management mechanisms, which creates barriers for both funders and grantees. These issues hinder transparency, complicate the tracking of fund disbursements, and make it difficult to evaluate the overall effectiveness of grant programs across different networks. The lack of interoperability between grant programs further exacerbates the problem, as projects and contributors often work across multiple blockchains. This makes it challenging to aggregate data, monitor milestones, and

RATIONALE:
The design of this Grant Registry Contract is driven by the need for a flexible and modular system that supports a wide range of grant programs across different chains. The rationale for the key design decisions is outlined below: 1. Separation of Fields: The division of fields into different categories, such as identification, grant data, and disbursement-related information, allows for a more efficient use of on-chain storage. Immutable fields like id, chainid, and community are kept separate from mutable fields, ensuring that core identification elements remain unchanged, while other aspects like milestones and participants can be updated throughout


=== ERC-7595 ===
TITLE: Collateralized NFT
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-03-13
REQUIRES: 2, 0, ,,  , 7, 2, 1

SUMMARY:
This proposal recommends an extension of [ERC-721](./eip-721.md) to allow for collateralization using a list of [ERC-20](./eip-20.md) based tokens. The proprietor of this ERC collection could hold both the native coin and [ERC-20](./eip-20.md) based tokens, with the `ownerOf` tokenId being able to unlock the associated portion of the underlying [ERC-20](./eip-20.md) balance.

SPECIFICATION:
### ERC standard for new NFT collections ```solidity interface IERC721Envious is IERC721 { event Collateralized(uint256 indexed tokenId, uint256 amount, address tokenAddress); event Uncollateralized(uint256 indexed tokenId, uint256 amount, address tokenAddress); event Dispersed(address indexed tokenAddress, uint256 amount); event Harvested(address indexed tokenAddress, uint256 amount, uint256 scaledAmount); /** * @dev An array with two elements. Each of them represents percentage from collateral * to be taken as a commission. First element represents collateralization commission. * Second element represents uncollateralization commission. There should be 3 * decimal buffer for each of them, e.g. 1000 = 1%. * * @param uint 256 index of

MOTIVATION:
The emerging trend of NFT finance focuses on the NFT floor price to enable the market value of the NFT serve as a collateral in lending protocols. The NFT floor price is susceptible to the supply-demand dynamics of the NFT market, characterized by higher volatility compared to the broader crypto market. Furthermore, potential price manipulation in specific NFT collections can artificially inflate NFT market prices, impacting the floor price considered by lending protocols. Relying solely on the NFT floor price based on market value is both unpredictable and unreliable. This ERC addresses various challenges encountered by the crypto

RATIONALE:
### “Envious” Term Choice We propose adopting the term "Envious" to describe any NFT collection minted using this ERC standard or any [ERC-721](./eip-721.md) based NFT collection that utilized the EnviousHouse abstraction layer. ### NFT Collateralization with Multiple Tokens Some Web3 projects primarily collateralize a specific NFT asset with one [ERC-20](./eip-20.md) based token, resulting in increased gas fees and complications in User Experience (UX). This ERC has been crafted to enable the collateralization of a designated NFT asset with multiple [ERC-20](./eip-20.md) based tokens within a single transaction. ### NFT Collateralization with the Native Coin Each [ERC-20](./eip-20.md) based token possesses


=== ERC-7597 ===
TITLE: Signature Validation Extension for Permit
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-01-15
REQUIRES: 1, 2, 7, 1, ,,  , 2, 6, 1, 2

SUMMARY:
This proposal aims to extend the functionality of the existing [ERC-2612](./eip-2612.md) Permit to support gasless [ERC-20](./eip-20.md) approval operations initiated by smart contract wallets.

SPECIFICATION:
Compliant contracts must implement the `permit` using the following spec ``` function permit(address owner, address spender, uint value, uint deadline, bytes memory signature) external ``` as well as two other interfaces previously mandated by [ERC-2612](./eip-2612.md): ``` function nonces(address owner) external view returns (uint) function DOMAIN_SEPARATOR() external view returns (bytes32) ``` A call to `permit(owner, spender, value, deadline, signature)` will set `allowance[owner][spender]` to value, increment `nonces[owner]` by 1, and emit a corresponding `Approval` event, if and only if the following conditions are met: - The current blocktime is less than or equal to `deadline`. - `owner` is not the

MOTIVATION:
The current signature validation scheme in [ERC-2612](./eip-2612.md), based on V, R, S parameters, restricts signature validation to EOA wallets. With the growing popularity of smart contract wallets and increased adoption of [ERC-1271](./eip-1271.md), it is necessary to allow for flexible signature validation methods and the use of custom logic in each contract's signature verification. By accepting unstructured signature bytes as input, custom algorithms and signature schemes can be utilized, enabling a wider range of wallet types.

RATIONALE:
By replacing the existing V, R, S signature validation scheme and introducing support for unstructured bytes input, contract developers can use a unified interface to validate signature from both EOAs and SC wallets. This allows for the utilization of different signature schemes and algorithms fitting the wallet type, paving the way for smart contract wallets and advanced wallet types to enhance their signature validation processes, promoting flexibility and innovation.


=== ERC-7694 ===
TITLE: Solana Storage Router
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-18
REQUIRES: 3, 6, 6, 8, ,,  , 7, 7, 0, 0

SUMMARY:
The following standard is an extension to the cross-chain storage router protocol introducing the storage router for Solana blockchain. With this specification, any Ethereum L1 contract can defer a call to Solana blockchain as part of its core functionality, provided that the client is equipped to handle Solana transactions. It was previously possible to defer write and storage operations to other Ethereum L1 contracts, L2 contracts and off-chain databases, and this document extends that functionality to include alternative L1 chains. The data stored on Solana must be translated to [EIP-3668](./eip-3668)-compliant format by an appropriate HTTP gateway where it

SPECIFICATION:
A Solana storage router `StorageRoutedToSolana()` requires the hex-encoded `programId` and the manager `account` on the Solana blockchain. `programId` is equivalent to a contract address on Solana while `account` is the manager wallet on Solana handling storage on behalf of `msg.sender`. ```solidity // Revert handling Solana storage router error StorageRoutedToSolana( bytes32 programId, bytes32 account ); // Generic function in a contract function setValue( bytes32 node, bytes32 key, bytes32 value ) external { // Get metadata from on-chain sources ( bytes32 programId, // Program (= contract) address on Solana; hex-encoded bytes32 account // Manager account on Solana; hex-encoded ) =

MOTIVATION:
Cross-Chain Storage Router Protocol (CCIP-Store) introduced in [EIP-7700](./eip-7700), describes three external routers for routing storage to L1 contracts, L2s and databases. This document extends that specification by introducing a fourth storage router targeting Solana as the storage provider. L2s and databases both have centralising catalysts in their stack. For L2s, this centralising agent is the shared security with Ethereum mainnet. In case of databases, the centralising agent is trivial; it is the physical server hosting the database. In light of this, a storage provider that relies on its own independent consensus mechanism is preferred. This specification instructs how

RATIONALE:
`StorageRoutedToSolana()` works in a similar fashion to `StorageRoutedToL2()` in CCIP-Store in the sense that the client needs to be pointed to a certain contract on another chain by the revert event. Other than that, the only technical difference is casting between EVM and SVM data types. ![Fig.2 Solana Call Lifecycle](../assets/eip-7694/images/Solana.svg)


=== ERC-3770 ===
TITLE: Chain-specific addresses
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2021-08-26
REQUIRES: 

SUMMARY:
[ERC-3770](./eip-3770.md) introduces a new address standard to be adapted by wallets and dApps to display chain-specific addresses by using a human-readable prefix.

SPECIFICATION:
This proposal extends addresses with a human-readable blockchain short name. ### Syntax A chain-specific address is prefixed with a chain shortName, separated with a colon sign (:). Chain-specific address = "`shortName`" "`:`" "`address`" - `shortName` = STRING - `address` = STRING ### Semantics * `shortName` is mandatory and MUST be a valid chain short name from https://github.com/ethereum-lists/chains * `address` is mandatory and MUST be a [ERC-55](./eip-55.md) compatible hexadecimal address ### Examples ![Chain-specific addresses](../assets/eip-3770/examples.png "Examples of chain-specific addresses")

MOTIVATION:
The need for this proposal emerges from the increasing adoption of non-Ethereum Mainnet chains that use the Ethereum Virtual Machine (EVM). In this context, addresses become ambiguous, as the same address may refer to an EOA on chain X or a smart contract on chain Y. This will eventually lead to Ethereum users losing funds due to human error. For example, users sending funds to a smart contract wallet address which was not deployed on a particular chain. Therefore we should prefix addresses with a unique identifier that signals to Dapps and wallets on what chain the target

RATIONALE:
To solve the initial problem of user-facing addresses being ambiguous in a multichain context, we need to map EIP-155 chain IDs with a user-facing format of displaying chain identifiers.


=== ERC-6734 ===
TITLE: L2 Token List
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-03-20
REQUIRES: 155

SUMMARY:
The document describes a JSON token list that ensures that two or more Layer 1, Layer 2, or Sidechains can identify tokens from a different Layer 1, Layer 2, or Sidechain.

SPECIFICATION:
### Keywords: The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [[RFC2119](https://www.rfc-editor.org/rfc/rfc2119)] when, and only when, they appear in all capitals, as shown here. ### Typographical Convention: Requirement Ids A requirement is uniquely identified by a unique ID composed of its requirement level followed by a requirement number, as per convention **[RequirementLevelRequirementNumber]**. There are four requirement levels that are coded in requirement ids as per below convention: **[R]** - The requirement level for requirements which IDs start with the

MOTIVATION:
This particular work by the L2 WG of the EEA Communities Projects managed by OASIS, an open-source initiative, is motivated by a significant challenge around the definition and listing of tokens on Layer 1 (L1), Layer 2 (L2), and Sidechain systems. Note that for simplicity, this document we will collectively refer to L1, L2 and Sidechain systems as chains below since the challenge described below is valid across all such systems: * Consensus on the "canonical" token on chain B that corresponds to some token on chain A. When one wants to bridge token X from chain A

RATIONALE:
This specification is extending and clarifying current custom lists such as from Arbitrum and Optimism as referenced in the [Motivation](#motivation) or the Uniswap Tokenlist Project to improve clarity, security and encourage adoption by non-Web3 native entities. The specification is utilizing the current JSON-LD standard to describe a token list to allow for easy integrations with Self-Sovereign-Identity frameworks such as W3C DID and W3C Verifiable Credential standards that allow for interoperability across L2s, Sidechains and L1s when identifying token list relevant entities such as Token Issuers. In addition, being compatible to W3C utilized frameworks allows implementers to use existing


=== ERC-7196 ===
TITLE: Simple token, Simplified ERC-20
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-06-21
REQUIRES: 20

SUMMARY:
This ERC is a new asset designed based on the user contract wallet (including account abstraction), and is forward compatible with [ERC-20](./eip-20.md). To keep token assets simple, this ERC removes the `transferFrom`, `approve` and `allowance` functions of ERC-20.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Compliant contracts MUST implement the following interface: ```solidity pragma solidity ^0.8.20; /** * @title ERC7196 Simple token interface * @dev See https://ercs.ethereum.org/ERCS/erc-7196 */ interface IERC7196 { /** * @notice Used to notify transfer tokens. * @param from Address of the from * @param to Address of the receive * @param value The transaction amount */ event Transfer( address indexed from, address indexed to, uint256

MOTIVATION:
[ERC-20](./eip-20.md) defines Ethereum-based standard tokens that can be traded and transferred, but the essence of ERC-20 is based on the externally-owned account (EOA) wallet design. An EOA wallet has no state and code storage, and the smart contract wallet is different. Almost all ERCs related to tokens add functions, but our opinion is the opposite. We think the token contract should be simpler, with more functions taken care of by the smart contract wallet. Our proposal is to design a simpler token asset based on the smart contract wallet. It aims to achieve the following goals: 1. Keep

RATIONALE:
The proposal is to simplify token standards by removing `transferFrom`, `approve` and `allowance` functions. This simplification aims to enhance security, reduce complexity, and improve efficiency, making the standard more suitable for smart contract wallet environments while maintaining essential functionalities.


=== ERC-7649 ===
TITLE: Bonding curve-embedded liquidity for NFTs
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-28
REQUIRES: 721

SUMMARY:
This proposal introduces a standard for embedding Bonding Curve-like liquidity into Non-Fungible Tokens (NFTs) without modifying the [ERC-721](./eip-721.md) standard. The proposed standard allows the attachment of an embedded liquidity contract, referred to as Tradable Shares, to an ERC-721 NFT. Tradable Shares leverage a Bonding Curve-like approach to attract liquidity, enabling trading of shares based on the bonding curve price formula.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. 1. Bonding Curve-Embedded Liquidity / Tradable Shares: - An embedded bonding curve-based liquidity SHOULD be attached to the NFT via a separate contract. - An embedded bonding curve-based liquidity MUST NOT be embedded into or modify the ERC-721 standard. - The bonding curve contract MUST manage the liquidity of the associated NFT through a bonding curve mechanism. 2. Bonding Curve Mechanism: - The bonding

MOTIVATION:
The ERC-721 standard lacks a specific mechanism for embedding bonding curve-based liquidity, limiting the creative possibilities for NFT-based projects. This EIP addresses the need for a standardized approach to integrate bonding curve contracts seamlessly into ERC-721 NFTs, allowing for diverse and innovative implementations without modifying the ERC-721 standard. The proposed standard focuses on enhancing the ERC-721 standard by introducing a framework for embedding bonding curve-based liquidity into NFTs. This approach provides creators with a flexible and customizable tool to attract liquidity through bonding curve mechanisms, while ensuring creators receive guaranteed fees for their contributions. The bonding curve-embedded liquidity

RATIONALE:
The rationale behind the design choices for the embedded liquidity standard is deeply rooted in providing a robust and versatile framework for embedding Bonding Curve-like liquidity into NFTs. The following key considerations have influenced the technical decisions: 1. **Bonding Curve-Embedded Liquidity / Tradable Shares Contract**: - **Seamless Integration**: The decision to allow an embedded bonding curve-based liquidity contract to be attached to an NFT without altering the ERC-721 standard stems from the desire for seamless integration. This approach ensures that NFT developers can enhance their creations with liquidity mechanisms without introducing complexities or requiring modifications to the widely


=== ERC-6384 ===
TITLE: Human-readable offline signatures
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2023-01-08
REQUIRES: 712

SUMMARY:
This EIP introduces the `evalEIP712Buffer` function, which takes an [EIP-712](./eip-712.md) buffer and returns a human-readable text description.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. EIP-712 already formally binds an off-chain signature to a contract, with the `verifyingContract` parameter. We suggest adding a “view” function (`"stateMutability":"view"`) to such contracts, that returns a human readable description of the meaning of this specific off-chain buffer. ```solidity /** * @dev Returns the expected result of the offchain message. */ function evalEIP712Buffer(bytes32 domainHash, string memory primaryType, bytes memory typedDataBuffer) external view returns (string[] memory) { ... } ```

MOTIVATION:
The use case of Web3 off-chain signatures intended to be used within on-chain transaction is gaining traction and being used in multiple leading protocols (e.g. OpenSea) and standards [EIP-2612](./eip-2612.md), mainly as it offers a fee-less experience. Attackers are known to actively and successfully abuse such off-chain signatures, leveraging the fact that users are blindly signing off-chain messages, since they are not humanly readable. While [EIP-712](./eip-712.md) originally declared in its title that being ”humanly readable” is one of its goals, it did not live up to its promise eventually and EIP-712 messages are not understandable by an average user.

RATIONALE:
- We chose to implement the `typeDataBuffer` parameter as abi encoded as it is a generic way to pass the data to the contract. The alternative was to pass the `typedData` struct, which is not generic as it requires the contract to specify the message data. - We chose to return an array of strings and not a single string as there are potential cases where the message is composed of multiple parts. For example, in the case of a multiple assets transfers in the same `typedDataBuffer`, the contract is advised to describe each transfer in a separate


=== ERC-7631 ===
TITLE: Dual Nature Token Pair
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-02-21
REQUIRES: 2, 0, ,,  , 7, 2, 1

SUMMARY:
A fungible [ERC-20](./eip-20.md) token contract and non-fungible [ERC-721](./eip-721.md) token contract can be interlinked, allowing actions performed on one contract to be reflected on the other. This proposal defines how the relationship between the two token contracts can be queried. It also enables accounts to configure whether ERC-721 mints and transfers should be skipped during ERC-20 to ERC-721 synchronization.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview A dual nature token pair comprises of an ERC-20 contract and an ERC-721 contract. For convention, the ERC-20 contract is designated as the base contract, and the ERC-721 contract is designated as the mirror contract. ### ERC-20 Extension Interface The ERC-20 contract MUST implement the following interface. ```solidity interface IERC7631Base { /// @dev Returns the address of the mirror ERC-721 contract. ///

MOTIVATION:
The ERC-20 fungible and ERC-721 non-fungible token standards offer sufficient flexibility for a co-joined, dual nature token pair. Transfers on the ERC-20 token can automatically trigger transfers on the ERC-721 token, and vice-versa. This enables applications such as native ERC-721 fractionalization, wherein acquiring ERC-20 tokens leads to the automatic issuance of ERC-721 tokens, proportional to the ERC-20 balance. Dual nature token pairs maintain full compliance with both ERC-20 and ERC-721 token standards. This proposal aims to enhance the functionality of dual nature token pairs. To facilitate querying the relationship between the tokens, extension interfaces are proposed for the

RATIONALE:
### Implementation Detection The `mirrorERC721` and `baseERC20` methods returning non-zero addresses signal that the ERC-20 and ERC-721 contracts implement the required interfaces respectively. As such, [ERC-165](./eip-165.md) is not required. The `getSkipNFT` and `setSkipNFT` methods MAY revert. As contracts compiled with Solidity or Vyper inherently revert on calls to undefined methods, a typical `IERC7631Base` implementation lacking explicit `getSkipNFT` and `setSkipNFT` definitions still complies with `IERC7631BaseNFTSkippable`. ### NFT Skipping The skip NFT methods allow accounts to avoid having ERC-721 tokens automatically minted to it whenever there is an ERC-20 transfer. They are helpful in the following situations: - Loading vesting


=== ERC-3234 ===
TITLE: Batch Flash Loans
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-01-31
REQUIRES: 

SPECIFICATION:
A batch flash lending feature integrates two smart contracts using a callback pattern. These are called the LENDER and the RECEIVER in this EIP. ### Lender Specification A `lender` MUST implement the IERC3234BatchFlashLender interface. ``` pragma solidity ^0.7.0 || ^0.8.0; import "./IERC3234BatchFlashBorrower.sol"; interface IERC3234BatchFlashLender { /** * @dev The amount of currency available to be lended. * @param tokens The currency for each loan in the batch. * @return The maximum amount that can be borrowed for each loan in the batch. */ function maxFlashLoan( address[] calldata tokens ) external view returns (uint256[]); /** * @dev The fees

MOTIVATION:
Flash loans of multiple assets, or batch flash loans, are a common offering of flash lenders, and have a strong use case in the simultaneous refinance of several positions between platforms. At the same time, batch flash loans are more complicated to use than single asset flash loans (ER3156). This divergence of use cases and user profiles calls for independent, but consistent, standards for single asset flash loans and batch flash loans.

RATIONALE:
The interfaces described in this ERC have been chosen as to cover the known flash lending use cases, while allowing for safe and gas efficient implementations. `flashFee` reverts on unsupported tokens, because returning a numerical value would be incorrect. `batchFlashLoan` has been chosen as a function name as descriptive enough, unlikely to clash with other functions in the lender, and including both the use cases in which the tokens lended are held or minted by the lender. `receiver` is taken as a parameter to allow flexibility on the implementation of separate loan initiators and receivers. Existing flash lenders


=== ERC-7066 ===
TITLE: Lockable Extension for ERC-721
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-05-25
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
An extension of [ERC-721](./eip-721.md), this standard incorporates `locking` features into NFTs, allowing for various uses while preventing sale or transfer. The token's `owner` can `lock` it, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval for `tokenId`, enabling ability to lock asset while address holds the token approval. Token can also be locked by `approved`, assigning locker to itself. Upon token transfer, these rights get purged.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview [ERC-721](./eip-721.md) compliant contracts MAY implement this EIP to provide standard methods of locking and unlocking the token at its current owner address. Token owner MAY `lock` the token and assign `locker` to some `address` using `lock(uint256 tokenId, address _locker)` function, this MUST set `locker` to `_locker`. Token owner or approved MAY `lock` the token using `lock(uint256 tokenId)` function, this MUST set `locker`

MOTIVATION:
[ERC-721](./eip-721.md) has sparked an unprecedented surge in demand for NFTs. However, despite this tremendous success, the NFT economy suffers from secondary liquidity where it remains illiquid in owner’s wallet. There are projects which aim to address the liquidity challenge, but they entail the below mentioned inconveniences and risks for owners as they necessitate transferring the participating NFTs to the projects' contracts. - Loss of utility: The utility value of NFTs diminishes when they are transferred to an escrow account, no longer remaining under the direct custody of the owners. - Lack of composability: The market could benefit from

RATIONALE:
This proposal set `locker[tokenId]` to `address(0)` when token is `unlocked` because we delete mapping on `locker[tokenId]` freeing up space. Also, this assertion helps our contract to validate if token is `locked` or `unlocked` for internal function calls. This proposal exposes `transferAndLock(uint256 tokenId, address from, address to, bool setApprove)` which can be used to transfer token and lock at the receiver's address. This additionally accepts input `bool setApprove` which on `true` assign `approval` to `locker`, hence enabling `locker` to revoke the token (revocation conditions can be defined in contracts and `approval` provided to contract). This provides conditional ownership to


=== ERC-1775 ===
TITLE: App Keys, application specific wallet accounts
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-02-20
REQUIRES: 

SUMMARY:
In a wallet, an user often holds most of her funds in her main accounts. These accounts require a significant level of security and should not be delegated in any way, this significantly impacts the design of cryptographic applications if a user has to manually confirm every action. Also often an user uses the same accounts across apps, which is a privacy and potentially also a security issue. We introduce here a new account type, app keys, which permits signing delegation and accounts isolation across applications for privacy and security. In this EIP, we provide a proposal on

SPECIFICATION:
### Applications An app is a website (or other) that would like to request from a wallet to access a cryptographic key specifically derived for this usage. It can be any form of cryptography/identity relying application, Ethereum based but not only. Once connected to a wallet, an application can request to access an account derived exclusively for that application using the following algorithm. ### Private App Key generation algorithm We now propose an algorithm to generate application keys that: - are uniquely defined, with respect to the account that the user selected to generate these keys, - and

MOTIVATION:
Wallets developers have agreed on an HD derivation path for ethereum accounts using BIP32, BIP44, SLIP44, [(see the discussion here)](https://github.com/ethereum/EIPs/issues/84). Web3 wallets have implemented in a roughly similar way the rpc eth api. [EIP-1102](./eip-1102.md) introduced privacy through non automatic opt-in of a wallet account into an app increasing privacy. However several limitations remain in order to allow for proper design and UX for crypto permissioned apps. Most of GUI based current wallets don't allow to: * being able to automatically and effortlessly use different keys / accounts for each apps, * being able to sign some app's action

RATIONALE:
### Sharing application keys across domains: While this does not explicit cover cases of sharing these app keys between pages on its own, this need can be met by composition: Since a domain would get a unique key per persona, and because domains can intercommunicate, one domain (app) could request another domain (signer) to perform its cryptographic operation on some data, with its appKey as a seed, potentially allowing new signing strategies to be added as easily as new websites. This could also pass it to domains that are loading specific signing strategies. This may sound dangerous at


=== ERC-7730 ===
TITLE: Structured Data Clear Signing Format
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-07
REQUIRES: 1, 5, 5, ,,  , 7, 1, 2

SUMMARY:
This specification defines a JSON format carrying additional information required to correctly display structured data to a human for review on a wallet screen, before signature by the wallet. The [ERC-7730](./eip-7730.md) specification enriches type data contained in the ABIs and schemas of structured messages (structures like the calldata of an EVM transaction or an [EIP-712](./eip-712.md) message) with additional formatting information, so that wallets can construct a better UI when displaying the data before signature. For instance, a solidity field containing an amount, encoded as an uint256, can be converted to the right magnitude and appended with the correct

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Simple example The following is an example of how to clear sign a `transfer` function call on an [ERC-20](./eip-20.md) contract. ```json { "$schema": "https://eips.ethereum.org/assets/eip-7730/erc7730-v1.schema.json", "context": { "$id": "Example ERC-20", "contract" : { "abi": "https://api.example.io/api?module=contract&action=getabi&address=0xdac17f958d2ee523a2206206994597c13d831ec7", "deployments": [ { "chainId": 1, "address": "0xdAC17F958D2ee523a2206206994597C13D831ec7" }, { "chainId": 137, "address": "0xc2132D05D31c914a87C6611C10748AEb04B58e8F" }, { "chainId": 42161, "address": "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9" } ] } }, "metadata": { "owner": "Example", "info": { "legalName":

MOTIVATION:
Properly validating a transaction on a hardware wallet's screen (also known as Clear Signing) is a key element of good security practices for end users when interacting with any Blockchain. Unfortunately, most data to sign, even enriched with the data structure description (like ABIs or EIP-712 types) are not self-sufficient in terms of correctly displaying them to the user for review. Among other things: * Function name or main message type is often a developer oriented name and does not translate to a clear intent for the user * Fields in the data to sign are tied to

RATIONALE:
### Human readability It is expected that the main limitation to adoption of ERC-7730 will be the complexity of writing this interface description file compared to interest of writing it. This drove a few choices when introducing this ERC specification: * The form of an ERC itself will allow usage of these file by any wallets (Hardware or Software, without restrictions), and in turn drive up the benefits for dApps developers to provide their own ERC-7730 description * The specification is intended to be directly readable by developers, in order to facilitate direct edition by developers. * In


=== ERC-7540 ===
TITLE: Asynchronous ERC-4626 Tokenized Vaults
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-10-18
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 4, 6, 2, 6, ,,  , 7, 5, 7, 5

SUMMARY:
The following standard extends [ERC-4626](./eip-4626.md) by adding support for asynchronous deposit and redemption flows. The async flows are called Requests. New methods are added to asynchronously Request a deposit or redemption, and view the status of the Request. The existing `deposit`, `mint`, `withdraw`, and `redeem` ERC-4626 methods are used for executing Claimable Requests. Implementations can choose whether to add asynchronous flows for deposits, redemptions, or both.

SPECIFICATION:
### Definitions: The existing definitions from [ERC-4626](./eip-4626.md) apply. In addition, this spec defines: - Request: a request to enter (`requestDeposit`) or exit (`requestRedeem`) the Vault - Pending: the state where a Request has been made but is not yet Claimable - Claimable: the state where a Request is processed by the Vault enabling the user to claim corresponding `shares` (for async deposit) or `assets` (for async redeem) - Claimed: the state where a Request is finalized by the user and the user receives the output token (e.g. `shares` for a deposit Request) - Claim function: the corresponding Vault

MOTIVATION:
The ERC-4626 Tokenized Vaults standard has helped to make yield-bearing tokens more composable across decentralized finance. The standard is optimized for atomic deposits and redemptions up to a limit. If the limit is reached, no new deposits or redemptions can be submitted. This limitation does not work well for any smart contract system with asynchronous actions or delays as a prerequisite for interfacing with the Vault (e.g. real-world asset protocols, undercollateralized lending protocols, cross-chain lending protocols, liquid staking tokens, or insurance safety modules). This standard expands the utility of ERC-4626 Vaults for asynchronous use cases. The existing Vault

RATIONALE:
### Including Request IDs but not including a Claim by ID method Requests in an Asynchronous Vault have properties of NFTs or Semi-Fungible tokens due to their asynchronicity. However, trying to pigeonhole all ERC-7540 Vaults into supporting [ERC-721](./eip-721) or [ERC-1155](./eip-1155) for Requests would create too much interface bloat. Using both an id and address to discriminate Requests allows for any of these use cases to be developed at an external layer without adding too much complexity to the core interface. Certain Vaults, especially `requestId==0` cases, benefit from using the underlying [ERC-4626](./eip-4626) methods for claiming because there is no


=== ERC-6981 ===
TITLE: Reserved Ownership Accounts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-25
REQUIRES: 1, 1, 6, 7, ,,  , 1, 2, 7, 1, ,,  , 6, 4, 9, 2

SUMMARY:
The following specifies a system for services to link their users to a claimable Ethereum address. Services can provide a signed message and unique salt to their users which can be used to deploy a smart contract wallet to the deterministic address through a registry contract using the `create2` opcode.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview The system for creating reserved ownership accounts consists of: 1. An Account Registry which provides deterministic addresses based on the service users' identifying salts, and implements a signature verified function that enables claiming of Account Instances by the service's end users. 2. Account Instances created through the Account Registry by end users which allow access to the assets received at the deterministic

MOTIVATION:
It is common for web services to allow their users to hold on-chain assets via custodial wallets. These wallets are typically EOAs, deployed smart contract wallets or omnibus contracts, with private keys or asset ownership information stored on a traditional database. This proposal outlines a solution that avoids the security concerns associated with historical approaches, and rids the need and implications of services controlling user assets Users on external services that choose to leverage the following specification can be given an Ethereum address to receive assets without the need to do any on-chain transaction. These users can choose

RATIONALE:
### Service-Owned Registry Instances While it might seem more user-friendly to implement and deploy a universal registry for reserved ownership accounts, we believe that it is important for external service providers to have the option to own and control their own Account Registry. This provides the flexibility of implementing their own permission controls and account deployment authorization frameworks. We are providing a reference Registry Factory which can deploy Account Registries for an external service, which comes with: - Immutable Account Instance implementation - Validation for the `claimAccount` method via ECDSA for EOA signers, or [ERC-1271](./eip-1271.md) validation for smart


=== ERC-6066 ===
TITLE: Signature Validation Method for NFTs
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-11-29
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 1, 2, 7, 1, ,,  , 5, 7, 5, 0

SUMMARY:
While **E**xternally **O**wned **A**ccounts can validate signed messages with `ecrecover()` and smart contracts can validate signatures using specifications outlined in [ERC-1271](./eip-1271.md), currently there is no standard method to create or validate signatures made by NFTs. We propose a standard way for anyone to validate whether a signature made by an NFT is valid. This is possible via a modified signature validation function originally found in [ERC-1271](./eip-1271.md): `isValidSignature(tokenId, hash, data)`.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ``` pragma solidity ^0.8.0; interface IERC6066 { /** * @dev MUST return if the signature provided is valid for the provided tokenId and hash * @param tokenId Token ID of the signing NFT * @param hash Hash of the data to be signed * @param data OPTIONAL arbitrary data that may aid verification * * MUST return the bytes4 magic value 0x12edb34f when function

MOTIVATION:
With billions of ETH in trading volume, the **N**on-**F**ungible **T**oken standard has exploded into tremendous popularity in recent years. Despite the far-reaching implications of having unique tokenized items on-chain, NFTs have mainly been used to represent artwork in the form of avatars or profile pictures. While this is certainly not a trivial use case for the [ERC-721](./eip-721.md) & [ERC-1155](./eip-1155.md) token standards, we reckon more can be done to aid the community in discovering alternative uses for NFTs. One of the alternative use cases for NFTs is using them to represent offices in an organization. In this case, tying

RATIONALE:
We have purposefully decided to not include a signature generation standard in this proposal as it would restrict flexibility of such mechanism, just as [ERC-1271](./eip-1271.md) does not enforce a signing standard for smart contracts. We also decided to reference Gnosis Safe's contract signing approach as it is both simplistic and proven to be adequate. The `bytes calldata data` parameter is considered optional if extra data is needed for signature verification, also conforming this EIP to [ERC-5750](./eip-5750.md) for future-proofing purposes.


=== ERC-5023 ===
TITLE: Shareable Non-Fungible Token
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-01-28
REQUIRES: 165

SUMMARY:
This EIP standardizes an interface for non-fungible value-holding shareable tokens. Shareability is accomplished by minting copies of existing tokens for new recipients. Sharing and associated events allow the construction of a graph describing who has shared what to which party.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// Note: the ERC-165 identifier for this interface is 0xded6338b interface IERC5023 is IERC165 { /// @dev This emits when a token is shared, reminted and given to another wallet that isn't function caller event Share(address indexed from, address indexed to, uint256 indexed tokenId, uint256 derivedFromtokenId); /// @dev Shares, remints an existing token, gives a newly minted token a fresh token id, keeps original token at function callers

MOTIVATION:
NFT standards such as [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) have been developed to standardize scarce digital resources. However, many non-fungible digital resources need not be scarce. We have attempted to capture positive externalities in ecosystems with new types of incentive mechanisms that exhibit anti-rival logic, serve as an unit of accounting and function as medium of sharing. We envision that shareable tokens can work both as incentives but also as representations of items that are typically digital in their nature and gain more value as they are shared. These requirements have set us to define shareable NFTs and more specifically

RATIONALE:
Current NFT standards define transferable non-fungible tokens, but not shareable non-fungible tokens. To be able to create shareable NFTs we see that existing NFT contracts could be extended with an interface which defines the basic principles of sharing, namely the Event of sharing and the function method of sharing. Definition of how transferability of tokens should be handled is left to the contract implementor. In case transferring is left enable shareable tokens behave similarly to the existing tokens, except when they are shared, a version of token is retained. In case transfering is disabled, shareable tokens become shareable


=== ERC-5489 ===
TITLE: NFT Hyperlink Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-08-16
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This EIP proposes a new extension for NFTs (non-fungible token, aka [EIP-721](./eip-721.md)): nft-hyperlink-extention (hNFT), embedding NFTs with hyperlinks, referred to as “hNFTs”. As owners of hNFTs, users may authorize a URL slot to a specific address which can be either an externally-owned account (EOA) or a contract address and hNFT owners are entitled to revoke that authorization at any time. The address which has slot authorization can manage the URL of that slot.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Interface #### `IERC5489` ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; interface IERC5489 { /** * @dev this event emits when the slot on `tokenId` is authorzized to `slotManagerAddr` */ event SlotAuthorizationCreated(uint256 indexed tokenId, address indexed slotManagerAddr); /** * @dev this event emits when the authorization on slot `slotManagerAddr` of token `tokenId` is revoked. * So, the corresponding DApp can handle this to stop on-going incentives or rights */

MOTIVATION:
As NFTs attract more attention, they have the potential to become the primary medium of Web3. Currently, end users can’t attach rich texts, videos, or images to NFTs, and there’s no way to render these rich-content attachments. Many industries eagerly look forward to this kind of rich-content attachment ability. Attaching, editing, and displaying highly customized information can usefully be standardized. This EIP uses hyperlinks as the aforementioned form of “highly customized attachment on NFT”, and also specifies how to attach, edit, and display these attachments on NFTs.

RATIONALE:
### Extends NFT with hyperlinks URIs are used to represent the value of slots to ensure enough flexibility to deal with different use cases. ### Authorize slot to address We use addresses to represent the key of slots to ensure enough flexibility to deal with all use cases.


=== ERC-1417 ===
TITLE: Poll Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-16
REQUIRES: 1, 6, 5, ,,  , 1, 2, 6, 1

SUMMARY:
The following standard allows for the implementation of a standard API for polls to be used with MVTs (refer [EIP-1261](./eip-1261.md)). The standard provides basic functionality to vote, unvote, tally votes, get voter turnout, and a lot more. The poll standard attempts to modularize blockchain voting by breaking down a poll into 4 crucial building blocks: voterbase qualification, vote weight calculation, vote consequences, and vote tallying. By creating a common interface for polls that have different kinds of building blocks, the poll standard makes it possible to make interactive front end applications which can seamlessly get data from a

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. **Every ERC-1417 compliant contract must implement the `ERC1417` and `ERC165` interfaces** (subject to "caveats" below): ```solidity /// @title ERC-1417 Poll Standard /// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1417.md /// Note: the ERC-165 identifier for this interface is 0x4fad898b. interface IPoll { /// @dev This emits when a person tries to vote without permissions. Useful for auditing purposes. /// E.g.: To prevent an admin to revoke permissions; calculate the result had they not

MOTIVATION:
A standard interface allows any user or applications to work with any Poll contract on Ethereum. We provide for simple ERC-1417 smart contracts. Additional applications are discussed below. This standard is inspired by the lack of governance tools in the blockchain space. Whenever there is a consensus collection exercise, someone goes ahead and deploys some kind of poll, and there is no standard software for accessing the data on the poll. For an end user who is not a developer, this is a real problem. The poll, which might be fully transparent, appears to be completely opaque to

RATIONALE:
As the poll standard is built with the intention of creating a system that allows for more transparency and accessibility of governance data, the design choices in the poll standard are driven by this motivator. In this section we go over some of the major design choices, and why these choices were made: 1. Event logging: The logic behind maintaining event logs in the cases of: - Cast Vote - Unvote - Failed Vote is to ensure that in the event of a manipulated voterbase, simple off chain checks can be performed to audit the integrity of the


=== ERC-5185 ===
TITLE: NFT Updatable Metadata Extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-06-27
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This specification defines a standard way to allow controlled NFTs' metadata updates along predefined formulas. Updates of the original metadata are restricted and defined by a set of recipes and the sequence and results of these recipes are deterministic and fully verifiable with on-chain metadata updates event. The proposal depends on and extends the [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. The **metadata updates extension** is OPTIONAL for [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) contracts. ```solidity /// @title ERC-721/ERC-1155 Updatable Metadata Extension interface IERC5185UpdatableMetadata { /// @notice A distinct Uniform Resource Identifier (URI) for a set of updates /// @dev This event emits an URI (defined in RFC 3986) of a set of metadata updates. /// The URI should point to a JSON file that conforms to the "NFT Metadata Updates JSON Schema"

MOTIVATION:
Storing voluminous NFT metadata on-chain is often neither practical nor cost-efficient. Storing NFT metadata off-chain on distributed file systems like IPFS can answer some needs of verifiable correlation and permanence between an NFT tokenId and its metadata but updates come at the cost of being all or nothing (aka changing the `tokenURI`). Bespoke solutions can be easily developed for a specific NFT smart contract but a common specification is necessary for NFT marketplaces and third parties tools to understand and verify these metadata updates. This ERC allows the original JSON metadata to be modified step by step along

RATIONALE:
There have been numerous interesting uses of [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) smart contracts that associate for each token essential and significant metadata. While some projects (e.g. EtherOrcs) have experimented successfully to manage these metadata on-chain, that experimental solution will always be limited by the cost and speed of generating and storing JSON on-chain. Symmetrically, while storing the JSON metadata at URI endpoint controlled by traditional servers permit limitless updates the metadata for each NFT, it is somehow defeating in many uses cases, the whole purpose of using a trustless blockchain to manage NFT: indeed users may want or demand


=== ERC-5516 ===
TITLE: Soulbound Multi-owner Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-19
REQUIRES: 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP proposes a standard interface for non-fungible double signature Soulbound multi-tokens. Previous account-bound token standards face the issue of users losing their account keys or having them rotated, thereby losing their tokens in the process. This EIP provides a solution to this issue that allows for the recycling of SBTs.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. **Smart contracts implementing this EIP MUST implement all of the functions in the `EIP-5516` interface.** **Smart contracts implementing this EIP MUST implement the [EIP-165](./eip-165.md) `supportsInterface` function and and MUST return the constant value `true` if `0x8314f22b` is passed through the `interfaceID` argument. They also MUST implement the [EIP-1155](./eip-1155.md) Interface and MUST return the constant value `true` if `0xd9b67a26` is passed through the `interfaceID` argument. Furthermore, they MUST implement the

MOTIVATION:
This EIP was inspired by the main characteristics of the [EIP-1155](./eip-1155.md) token and by articles in which benefits and potential use cases of Soulbound/Accountbound Tokens (SBTs) were presented. This design also allows for batch token transfers, saving on transaction costs. Trading of multiple tokens can be built on top of this standard and it removes the need to approve individual token contracts separately. It is also easy to describe and mix multiple fungible or non-fungible token types in a single contract. ### Characteristics - The NFT will be non-transferable after the initial transfer - Partially compatible with [EIP-1155](./eip-1155.md)

RATIONALE:
### SBT as an extension of EIP-1155 We believe that Soulbound Tokens serve as a specialized subset of existing [EIP-1155](./eip-1155.md) tokens. The advantage of such a design is the seamless compatibility of SBTs with existing NFT services. Service providers can treat SBTs like NFTs and do not need to make drastic changes to their existing codebase. Making the standard mostly compatible with [EIP-1155](./eip-1155.md) also allows for SBTs to bind to multiple addresses and to Smart Contracts. ### Double-Signature The Double-Signature functionality was implemented to prevent the receipt of unwanted tokens. It symbolizes a handshake between the token receiver


=== ERC-7509 ===
TITLE: Entity Component System
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-05
REQUIRES: 

SUMMARY:
This proposal defines a minimal Entity Component System (ECS). Entities are unique identities that are assigned to multiple components (data) and then processed using the system (logic). This proposal standardizes the interface specification for using ECS in smart contracts, providing a set of basic functions that allow users to freely combine and manage multi-contract applications.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. World contracts are containers for entities, component contracts, and system contracts. Its core principle is to establish the relationship between entities and component contracts, where different entities will attach different components, and use system contracts to dynamically change the data of the entity in the component. Usual workflow when building ECS-based programs: 1. Implement the `IWorld` interface to create a world contract. 2. Call

RATIONALE:
### Why include type information instead of simple byte arrays? This is to ensure the correctness of types when using components, in order to avoid potential errors and inconsistencies. External developers can clearly set and get based on the type. ### Why differentiate between a non-existent entity and an entity with false state? We cannot judge whether an entity actually exists based on its state alone. External contributors can create components based on entities. If the entities he uses don't exist, the components he creates may not make sense. Component creators should first check if the entity exists,


=== ERC-5058 ===
TITLE: Lockable Non-Fungible Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-04-30
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
We propose to extend the [EIP-721](./eip-721.md) standard with a secure locking mechanism. The NFT owners approve the operator to lock the NFT through `setLockApprovalForAll()` or `lockApprove()`. The approved operator locks the NFT through `lock()`. The locked NFTs cannot be transferred until the end of the locking period. An immediate use case is to allow NFTs to participate in smart contracts without leaving the wallets of their owners.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Lockable EIP-721 **MUST** implement the `IERC5058` interfaces: ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.8; /** * @dev EIP-721 Non-Fungible Token Standard, optional lockable extension * ERC721 Token that can be locked for a certain period and cannot be transferred. * This is designed for a non-escrow staking contract that comes later to lock a user's NFT * while still letting them keep it in their wallet. * This extension

MOTIVATION:
NFTs, enabled by [EIP-721](./eip-721.md), have exploded in demand. The total market value and the ecosystem continue to grow with more and more blue chip NFTs, which are approximately equivalent to popular intellectual properties in a conventional sense. Despite the vast success, something is left to be desired. Liquidity has always been one of the biggest challenges for NFTs. Several attempts have been made to tackle the liquidity challenge: NFTFi and BendDAO, to name a few. Utilizing the currently prevalent EIP-721 standard, these projects require participating NFTs to be transferred to the projects' contracts, which poses inconveniences and risks

RATIONALE:
### NFT lock approvals An NFT owner can give another trusted operator the right to lock his NFT through the approve functions. The `lockApprove()` function only approves for the specified NFT, whereas `setLockApprovalForAll()` approves for all NFTs of the collection under the wallet. When a user participates in an NFTFi project, the project contract calls `lock()` to lock the user's NFT. Locked NFTs cannot be transferred, but the NFTFi project contract can use the unlock function `unlock()` to unlock the NFT. ### NFT lock/unlock Authorized project contracts have permission to lock NFT with the `lock` method. Locked NFTs


=== ERC-1387 ===
TITLE: Merkle Tree Attestations with Privacy enabled
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-08
REQUIRES: 


=== ERC-1620 ===
TITLE: Money Streaming
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-11-24
REQUIRES: 

SUMMARY:
The following describes a standard whereby time is measured using block numbers and streams are mappings in a master contract. 1. A provider sets up a money streaming contract. 2. A prospective payer can interact with the contract and start the stream right away by depositing the funds required for the chosen period. 3. The payee is able to withdraw money from the contract based on its ongoing solvency. That is: `payment rate * (current block height - starting block height)` 4. The stream terms (payment rate, length, metadata) can be updated at any time if both parties

SPECIFICATION:
### Structs The structure of a `stream` should be as follows: - `stream` - `sender`: the `address` of the entity funding the stream - `recipient`: the `address` where the money is being delivered to - `tokenAddress`: the `address` of the ERC20 token used as payment asset - `balance`: the total funds left in the stream - `timeframe`: as defined below - `rate`: as defined below ```solidity struct Stream { address sender; address recipient; address tokenAddress; uint256 balance; Timeframe timeframe; Rate rate; } ``` - `timeframe` - `start`: the starting block number of the stream - `stop`: the stopping

MOTIVATION:
This standardised interface aims to change the way we think about long-term financial commitments. Thanks to blockchains, payments need not be sent in chunks (e.g. monthly salaries), as there is much less overhead in paying-as-you-go. Money as a function of time would better align incentives in a host of scenarios. ### Use Cases This is just a preliminary list of use cases. There are other spooky ideas interesting to explore, such as time-dependent disincetivisation, but, for brevity, we have not included them here. - Salaries - Subscriptions - Consultancies - CDPs - Rent - Parking ### Crowdsales [RICOs](https://github.com/lukso-network/rico),

RATIONALE:
This specification was designed to serve as an entry point to the quirky concept of money as a function of time and it is definitely not set in stone. Several other designs, including payment channels and Plasma chains were also considered, but they were eventually deemed dense in assumptions unnecessary for an initial version. <!-- - Block times and oracles for time calculation - GCD - Miners - Sidechain-compatible (and preferable) - The `update` function - Multi-hop streams --> Block times are a reasonable, trustless proxy for time on the blockchain. Between 2016 and 2018, the Ethereum block


=== ERC-4906 ===
TITLE: EIP-721 Metadata Update Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-03-13
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [EIP-721](./eip-721.md). It adds a `MetadataUpdate` event to EIP-721 tokens.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. The **metadata update extension** is OPTIONAL for EIP-721 contracts. ```solidity /// @title EIP-721 Metadata Update Extension interface IERC4906 is IERC165, IERC721 { /// @dev This event emits when the metadata of a token is changed. /// So that the third-party platforms such as NFT market could /// timely update the images and related attributes of the NFT. event MetadataUpdate(uint256 _tokenId); /// @dev This event emits when the metadata of a

MOTIVATION:
Many [EIP-721](./eip-721.md) contracts emit an event when one of its tokens' metadata are changed. While tracking changes based on these different events is possible, it is an extra effort for third-party platforms, such as an NFT marketplace, to build individualized solutions for each NFT collection. Having a standard `MetadataUpdate` event will make it easy for third-party platforms to timely update the metadata of many NFTs.

RATIONALE:
Different NFTs have different metadata, and metadata generally has multiple fields. `bytes data` could be used to represents the modified value of metadata. It is difficult for third-party platforms to identify various types of `bytes data`, so as to avoid unnecessary complexity, arbitrary metadata is not included in the `MetadataUpdate` event. After capturing the `MetadataUpdate` event, a third party can update the metadata with information returned from the `tokenURI(uint256 _tokenId)` of EIP-721. When a range of token ids is specified, the third party can query each token URI individually.


=== ERC-2019 ===
TITLE: Fundable Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-05-10
REQUIRES: 20

SUMMARY:
Token wallet owners (or approved addresses) can order tokenization requests through blockchain. This is done by calling the ```orderFund``` or ```orderFundFrom``` methods, which initiate the workflow for the token contract operator to either honor or reject the fund request. In this case, fund instructions are provided when submitting the request, which are used by the operator to determine the source of the funds to be debited in order to do fund the token wallet (through minting). In general, it is not advisable to place explicit routing instructions for debiting funds on a verbatim basis on the blockchain, and

SPECIFICATION:
```solidity interface IFundable /* is ERC-20 */ { enum FundStatusCode { Nonexistent, Ordered, InProcess, Executed, Rejected, Cancelled } function authorizeFundOperator(address orderer) external returns (bool); function revokeFundOperator(address orderer) external returns (bool) ; function orderFund(string calldata operationId, uint256 value, string calldata instructions) external returns (bool); function orderFundFrom(string calldata operationId, address walletToFund, uint256 value, string calldata instructions) external returns (bool); function cancelFund(string calldata operationId) external returns (bool); function processFund(string calldata operationId) external returns (bool); function executeFund(string calldata operationId) external returns (bool); function rejectFund(string calldata operationId, string calldata reason) external returns (bool); function isFundOperatorFor(address walletToFund, address orderer) external view returns (bool); function

MOTIVATION:
Nowadays most of the token issuing/funding request, based on any fiat based payment method need a previous centralized transaction, to be able to get the desired tokens issued on requester's wallet. In the aim of trying to bring all the needed steps into decentralization, exposing all the needed steps of token lifecycle and payment transactions, a funding request can allow wallet owner to initiate the funding request via blockchain. Key benefits: * Funding and payment traceability is enhanced bringing the initiation into the ledger. All payment stat s can be stored on chain. * Almost all money/token lifecycle

RATIONALE:
This standards provides a functionality to allow token holders to start funding requests in a decentralized way. It's important to highlight that the token operator, need to process all funding request, updating the fund status based on the linked payment that will be done. Funding instruction format is open. ISO payment standard like is a good start point, The `operationId` is a string and not something more gas efficient to allow easy traceability of the hold and allow human readable ids. It is up to the implementer if the string should be stored on-chain or only its hash,


=== ERC-67 ===
TITLE: URI Scheme with Metadata, Value and Bytecode
TYPE: Standards Track ERC
STATUS: Withdrawn
CREATED: 2016-02-17
REQUIRES: 

SUMMARY:
This proposal (inspired by BIP 21) defines a format for encoding a transaction into a URI, including a recipient, number of ethers (possibly zero), and optional bytecode.

SPECIFICATION:
If we follow the bitcoin standard, the result would be: ``` ethereum:<address>[?value=<value>][?gas=<suggestedGas>][?data=<bytecode>] ``` Other data could be added, but ideally the client should take them from elsewhere in the blockchain, so instead of having a `label` or a `message` to be displayed to the users, these should be read from an identity system or metadata on the transaction itself. ### Example 1 Clicking this link would open a transaction that would try to send _5 unicorns_ to address _deadbeef_. The user would then simply approve, based on each wallet UI. ``` ethereum:0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7?gas=100000&data=0xa9059cbb00000000000000000000000000000000000000000000000000000000deadbeef0000000000000000000000000000000000000000000000000000000000000005 ``` #### Without Bytecode Alternatively, the

MOTIVATION:
Imagine these scenarios: * An exchange or a instant converter like ShapeShift wants to create a single Ethereum address for payments that will be converted into credit in their internal system or output bitcoin to an address. * A store wants to show a QR code to a client that will pop up a payment for exactly 12.34 ethers, which contains metadata on the product being bought. * A betting site wants to provide a link that the user can click on his site and it will open a default Ethereum wallet and execute a specific contract with

RATIONALE:
TODO


=== ERC-5827 ===
TITLE: Auto-renewable allowance extension
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-10-22
REQUIRES: 2, 0, ,,  , 1, 6, 5

SUMMARY:
This extension adds a renewable allowance mechanism to [ERC-20](./eip-20.md) allowances, in which a `recoveryRate` defines the amount of token per second that the allowance regains towards the initial maximum approval `amount`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ```solidity pragma solidity ^0.8.0; interface IERC5827 /* is ERC20, ERC165 */ { /* * Note: the ERC-165 identifier for this interface is 0x93cd7af6. * 0x93cd7af6 === * bytes4(keccak256('approveRenewable(address,uint256,uint256)')) ^ * bytes4(keccak256('renewableAllowance(address,address)')) ^ * bytes4(keccak256('approve(address,uint256)') ^ * bytes4(keccak256('transferFrom(address,address,uint256)') ^ * bytes4(keccak256('allowance(address,address)') ^ */ /** * @notice Thrown when the available allowance is less than the transfer amount. * @param available allowance available; 0 if unset */ error InsufficientRenewableAllowance(uint256 available); /**

MOTIVATION:
Currently, ERC-20 tokens support allowances, with which token owners can allow a spender to spend a certain amount of tokens on their behalf. However, this is not ideal in circumstances involving recurring payments (e.g. subscriptions, salaries, recurring direct-cost-averaging purchases). Many existing DApps circumvent this limitation by requesting that users grant a large or unlimited allowance. This presents a security risk as malicious DApps can drain users' accounts up to the allowance granted, and users may not be aware of the implications of granting allowances. An auto-renewable allowance enables many traditional financial concepts like credit and debit limits. An

RATIONALE:
Renewable allowances can be implemented with discrete resets per time cycle. However, a continuous `recoveryRate` allows for more flexible use cases not bound by reset cycles and can be implemented with simpler logic.


=== ERC-7695 ===
TITLE: Ownership Delegation and Context for ERC-721
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-02
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension for [ERC-721](./eip-721.md), designed to specify users for various contexts with a locking feature and allow temporary ownership delegation without changing the original owner. This EIP preserves the benefits and rights of the owner while expanding the utility of NFTs across various dApps by adding the concepts of Ownership Delegation and Contexts, which define specific roles: Controller and User, who can use the NFT within defined contexts.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Definitions This specification encompasses the following components: **Token Context** provides a specified use case of a token. It serves as the association relationship between Tokens and Contexts. Within each unique token context, there exists an allocated user who is authorized to utilize the token within that context. In a specified context, there are two distinct roles: - **Controller**: This role possesses the authority to control the context. - **User**:

MOTIVATION:
For standard [ERC-721](./eip-721.md) NFTs, there are several use cases in financial applications, including: - Staking NFTs to earn rewards. - Mortgaging an NFT to generate income. - Granting users for different purposes like rental and token delegation—where someone pays to use tokens and pays another party to use the tokens. Traditionally, these applications require ownership transfers to lock the NFT in contracts. However, other decentralized applications (dApps) recognize token ownership as proof that the token owner is entitled to benefits within their reward systems, such as airdrops or tiered rewards. If token owners have their tokens locked in

RATIONALE:
When designing the proposal, we considered the following concerns. ### Multiple contexts for multiple use cases This proposal is centered around Token Context to allow for the creation of distinct contexts tailored to various decentralized applications (dApps). The context controller assumes the role of facilitating (rental or delegation) dApps, by enabling the granting of usage rights to another user without modifying the NFT's owner record. Besides, this proposal provides the lock feature for contexts to ensure trustlessness in performing these dApps, especially staking cases. ### Providing an unlock mechanism for owners By providing an unlock mechanism for owners,


=== ERC-7627 ===
TITLE: Secure Messaging Protocol
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2024-02-19
REQUIRES: 

SUMMARY:
This proposal implements the capability to securely exchange encrypted messages on-chain. Users can register their public keys and encryption algorithms by registration and subsequently send encrypted messages to other users using their addresses. The interface also includes enumerations for public key algorithms and a structure for user information to support various encryption algorithms and user information management.

SPECIFICATION:
### Objectives - Provide a standardized interface for implementing messaging systems in smart contracts, including user registration and message sending functionalities. - Enhance flexibility and scalability for messaging systems by defining enumerations for public key algorithms and a structure for user information. - Define events for tracking message sending to enhance the observability and auditability of the contract. - Using a custom sessionId allows messages to be organized into a conversation. - Encrypt message content using the recipient's public key during message transmission. ### Interface The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",

MOTIVATION:
With the emergence of Layer 2 chains featuring sub-second block times and the introduction of account abstraction, the use of end-to-end encrypted communication has facilitated the proliferation of real-time communication and online chat dApps. Providing a unified interface enables easy integration of encrypted communication into smart contracts, thereby fostering innovation. Standardization promotes interoperability, facilitating seamless communication across platforms.

RATIONALE:
### Event Emission for Off-Chain Integration By emitting events when messages are sent or public keys are updated, the implementation facilitates seamless integration with off-chain dApps. This enables these dApps to easily track and display the latest messages and updates, ensuring real-time responsiveness and enhancing user interaction. ### End-to-End Encryption Security The design ensures that only the owner of an address can update their public key. This restriction preserves the integrity of the end-to-end encryption, making sure that only the intended recipient can decrypt and read the messages, thereby securing communication. ### Session ID for Conversation Organization The


=== ERC-5219 ===
TITLE: Contract Resource Requests
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-07-10
REQUIRES: 

SUMMARY:
This EIP standardizes an interface to make resource requests to smart contracts and to receive HTTP-like responses.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Name Resolution EIPs that propose a name resolution mechanism MAY reference this EIP and MAY recommend that clients support their mechanism. Clients MAY also support regular DNS, as defined in RFC 1034 and RFC 1035. ### Separation of Concerns It is RECOMMENDED to separate the application logic from the front-end logic (the contract implementing the interface defined in [Contract Interface](#contract-interface)). ### Contract Interface DApp contracts MUST implement the

MOTIVATION:
Ethereum is the most-established blockchain for building decentralized applications (referred to as `DApp`s). Due to this, the Ethereum DApp ecosystem is very diverse. However, one issue that plagues DApps is the fact that they are not fully decentralized. Specifically, to interface a "decentralized" application, one first needs to access a *centralized* website containing the DApp's front-end code, presenting a few issues. The following are some risks associated with using centralized websites to interface with decentralized applications: - Trust Minimization: An unnecessarily large number of entities need to be trusted - Censorship: A centralized website is not resistant to

RATIONALE:
The `request` method was chosen to be readonly because all data should be sent to the contract from the parsed DApp. Here are some reasons why: - Submitting a transaction to send a request would be costly and would require waiting for the transaction to be mined, resulting in bad user experience. - Complicated front-end logic should not be stored in the smart contract, as it would be costly to deploy and would be better run on the end-user's machine. - Separation of Concerns: the front-end contract shouldn't have to worry about interacting with the back-end smart contract.


=== ERC-7638 ===
TITLE: Batch Calls Encoding in SCA
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-26
REQUIRES: 

SUMMARY:
Batch Calls Encoding (BCE) outlines a solution for Smart Contract Account (SCA) wallets to consolidate multiple calls into a single call, encoding multiple parameters into bytes, compressing on-chain data, and saving gas. It can be used to implement atomic operations as well as non-atomic operations.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This ERC **REQUIRED** SCA to be implemented in the contract, where the Dapp communicates with the SCA wallet extension to communicate the user's intentions to the wallet, which uses Batch Calls Encoding to send multiple calls as bytes to the user's SCA contract. _Batch Calls_ comprises multiple `Call` bytes, each defined by the encoding of `to`\`value`\`data` as follows: ```mermaid graph LR A["to (20bytes)"] ---

MOTIVATION:
Typically, interactions between users and contracts involve a series of coherent operations, such as `approve`-`transferFrom`. While EOA wallets require users to confirm each operation sequentially, SCA wallets can confirm all operations with a single confirmation, completing all operations within a single call, thus achieving atomicity. If `approve` succeeds but `transferFrom` fails, it poses a security risk. The secure approach is to ensure that if one operation fails, all associated operations also fail, thereby ensuring atomicity. Therefore, we propose this encoding method to encode multiple parameters into bytes, compress on-chain data, and save gas. It can be used to

RATIONALE:
Each call encapsulates 3 parameters: `to`\`value`\`data`. The conventional approach involves packaging these 3 parameters into a struct and then placing multiple structs into an array. However, using a struct adds overhead as it also packages the types of `to`\`value`\`data`, increasing the size of the encoding. Since `to`\`value`\`data` have fixed types, this additional encoding can be omitted. In Solidity, reading data from `bytes calldata` using slice is a gas-efficient method. Considering these factors, _Batch Calls Encoding_ can compress on-chain data and save gas.


=== ERC-7572 ===
TITLE: Contract-level metadata via `contractURI()`
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-12-06
REQUIRES: 

SUMMARY:
This specification standardizes `contractURI()` to return contract-level metadata. This is useful for dapps and offchain indexers to show rich information about a contract, such as its name, description and image, without specifying it manually or individually for each dapp.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The contract MUST implement the below interface: ```solidity interface IERC7572 { function contractURI() external view returns (string memory); event ContractURIUpdated(); } ``` The string returned from `contractURI()` MAY be an offchain resource or onchain JSON data string (`data:application/json;utf8,{}`). The `ContractURIUpdated()` event SHOULD be emitted on updates to the contract metadata for offchain indexers to query the contract. If the underlying contract provides any methods

MOTIVATION:
Dapps have included supported for `contractURI()` for years without an ERC to reference. This standard also introduces the event `ContractURIUpdated()` to signal when to update the metadata.

RATIONALE:
The method name `contractURI()` was chosen based on its existing implementation in dapps. The event `ContractURIUpdated()` is specified to help offchain indexers to know when to refetch the metadata.


=== ERC-2981 ===
TITLE: NFT Royalty Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2020-09-15
REQUIRES: 165

SUMMARY:
This standard allows contracts, such as NFTs that support [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) interfaces, to signal a royalty amount to be paid to the NFT creator or rights holder every time the NFT is sold or re-sold. This is intended for NFT marketplaces that want to support the ongoing funding of artists and other NFT creators. The royalty payment must be voluntary, as transfer mechanisms such as `transferFrom()` include NFT transfers between wallets, and executing them does not always imply a sale occurred. Marketplaces and individuals implement this standard by retrieving the royalty payment information with `royaltyInfo()`, which specifies

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. **ERC-721 and ERC-1155 compliant contracts MAY implement this ERC for royalties to provide a standard method of specifying royalty payment information.** Marketplaces that support this standard **SHOULD** implement some method of transferring royalties to the royalty recipient. Standards for the actual transfer and notification of funds will be specified in future EIPs. Marketplaces **MUST** pay the royalty in the same unit of exchange as that of the `_salePrice` passed

MOTIVATION:
There are many marketplaces for NFTs with multiple unique royalty payment implementations that are not easily compatible or usable by other marketplaces. Just like the early days of ERC-20 tokens, NFT marketplace smart contracts are varied by ecosystem and not standardized. This EIP enables all marketplaces to retrieve royalty payment information for a given NFT. This enables accurate royalty payments regardless of which marketplace the NFT is sold or re-sold at. Many of the largest NFT marketplaces have implemented bespoke royalty payment solutions that are incompatible with other marketplaces. This standard implements standardized royalty information retrieval that can

RATIONALE:
### Optional royalty payments It is impossible to know which NFT transfers are the result of sales, and which are merely wallets moving or consolidating their NFTs. Therefore, we cannot force every transfer function, such as `transferFrom()` in ERC-721, to involve a royalty payment as not every transfer is a sale that would require such payment. We believe the NFT marketplace ecosystem will voluntarily implement this royalty payment standard to provide ongoing funding for artists/creators. NFT buyers will assess the royalty payment as a factor when making NFT purchasing decisions. ### Simple royalty payments to a single address


=== ERC-7506 ===
TITLE: Trusted Hint Registry
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-08-31
REQUIRES: 712

SUMMARY:
This EIP standardizes a system for managing on-chain metadata (hints), enabling claim interpretation, reliability, and verification. It structures these hints within defined namespaces and lists, enabling structured organization and retrieval, as well as permissioned write access. The system permits namespace owners to delegate hint management tasks, enhancing operational flexibility. It incorporates secure meta transactions via [EIP-712](./eip-712.md)-enabled signatures and offers optional ENS integration for trust verification and discoverability. The interface is equipped to emit specific events for activities like hint modifications, facilitating easy traceability of changes to hints. This setup aims to provide a robust, standardized framework for managing

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. This EIP specifies a contract called `TrustedHintRegistry` and standardizes a set of **REQUIRED** core hint functions, while also providing a common set of **OPTIONAL** management functions, enabling various ways for collaborative hint management. Ecosystems **MAY** use this specification to build their own hint registry contracts with ecosystem-specific, non-standardized features. Governance is deliberately excluded from this ERC and **MAY** be implemented according to an ecosystem's need. ### Definitions - `claim`:

MOTIVATION:
In an increasingly interconnected and decentralized landscape, the formation of trust among entities remains a critical concern. Ecosystems, both on-chain and off-chain—spanning across businesses, social initiatives, and other organized frameworks—frequently issue claims for or about entities within their networks. These claims serve as the foundational elements of trust, facilitating interactions and transactions in environments that are essentially untrustworthy by nature. While the decentralization movement has brought about significant improvements around trustless technologies, many ecosystems building on top of these are in need of technologies that build trust in their realm. Real-world applications have shown that verifiable claims alone

RATIONALE:
Examining the method signatures reveals a deliberate architecture and data hierarchy within this ERC: A namespace address maps to a hint list, which in turn maps to a hint key, which then reveals the hint value. ```solidity // namespace hint list hint key hint value mapping(address => mapping(bytes32 => mapping(bytes32 => bytes32))) hints; ``` This structure is designed to implicitly establish the initial ownership of all lists under a given namespace, eliminating the need for subsequent claiming actions. As a result, it simplifies the process of verifying and enforcing write permissions, thereby reducing potential attack surfaces. Additional data


=== ERC-7522 ===
TITLE: OIDC ZK Verifier for AA Account
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-20
REQUIRES: 4337

SUMMARY:
Account Abstraction facilitates new use cases for smart accounts, empowering users with the ability to tailor authentication and recovery mechanisms to their specific needs. To unlock the potential for more convenient verification methods such as social login, we inevitably need to connect smart accounts and OpenID Connect(OIDC), given its status as the most widely accepted authentication protocol. In this EIP, we proposed a [ERC-4337](./eip-4337.md) compatible OIDC ZK verifier. Users can link their ERC-4337 accounts with OIDC identities and authorize an OIDC verifier to validate user operations by verifying the linked OIDC identity on-chain.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Definitions **Identity Provider(IDP)**: The service to authenticate users and provide signed ID token **User**: The client to authenticate users and generate the ZK proof **ZK Aggregrator**: The offchain service to aggregate ZK proof from multiple users **OpenIdZkVerifier**: The on-chain contract to verify the ZK proof The **EntryPoint**, **Aggregator** and **AA Account** are defined at ERC-4337. ### Example Flow ![The example workflow](../assets/eip-7522/workflow.png) ### Interface ``` struct OpenIdZkProofPublicInput { bytes32 jwtHeaderAndPayloadHash;

MOTIVATION:
Connecting OIDC identity and smart accounts has been a very interesting but challenging problem. Verifying an OIDC issued IdToken is simple. IdToken are usually in the form of JWT and for common JWTs, they usually consist of three parts, a header section, a claim section and a signature section. The user claimed identity shall be included in the claim section and the signature section is usually an RSA signature of a well-known public key from the issuer against the hash of the combination of the header and claim section. The most common way of tackling the issue is

RATIONALE:
To verify identity ownership on-chain, **IOpenIdVerifier** needs at least three pieces of information: 1. the user ID to identify the user in the IDP. The **getIdHash** function returns the hash of the user id given smart account address. There may be multiple smart accounts linked to the same user ID. 2. the public key of the key pair used by identity provider to sign ID token. It is provided by the **getVerificationKeyOfIdp** function. 3. the ZK proof to verify the OIDC identity. The verification is done by the **verify** function. Besides the proof, the function takes two extra


=== ERC-6239 ===
TITLE: Semantic Soulbound Tokens
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-12-30
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 5, 1, 9, 2

SUMMARY:
This proposal extends [ERC-721](./eip-721.md) and [ERC-5192](./eip-5192.md) by introducing Resource Description Framework (RDF) triples to Soulbound Tokens' (‘SBTs‘) metadata.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. - The token **MUST** implement the following interfaces: 1. [ERC-165](./eip-165.md)’s `ERC165` (`0x01ffc9a7`) 1. [ERC-721](./eip-721.md)’s `ERC721` (`0x80ac58cd`) 1. [ERC-721](./eip-721.md)’s `ERC721Metadata` (`0x5b5e139f`) 1. [ERC-5192](./eip-5192.md)’s `ERC5192` (`0xb45a3c0e`) ### RDF Statement RDF statements come in various formats, we have selected the six most commonly used formats: `nt(N-Triples)`,`ttl(Turtle)`,`rdf(RDF/XML)`,`rj(RDF/JSON)`,`nq(N-Quads)` and `trig(TriG)`. The complete format of an RDF statement: ```text rdfStatements = {[format]}<statements> ``` In the following section, fragments surrounded by `{}` characters are OPTIONAL. In

MOTIVATION:
A Soulbound Token represents the commitments, credentials, and affiliations of accounts. RDF is a standard data model developed by the World Wide Web Consortium (‘W3C’) and is used to represent information in a structured format. Semantic SBTs are built on existing [ERC-721](./eip-721.md) and [ERC-5192](./eip-5192.md) standards to include RDF triples in metadata to capture and store the meaning of social metadata as a network of accounts and attributes. Semantic SBT provides a foundation for publishing, linking, and integrating data from multiple sources, and enables the ability to query and retrieve information across these sources, using inference to uncover new

RATIONALE:
RDF is a flexible and extensible data model based on creating subject-predicate-object relationships, often used to model graph data due to its semantic web standards, Linked Data concept, flexibility, and query capabilities. RDF allows graph data to be easily integrated with other data sources on the web, making it possible to create more comprehensive and interoperable models. The advantage of using RDF for semantic description is that it can describe richer information, including terms, categories, properties, and relationships. RDF uses standard formats and languages to describe metadata, making the expression of semantic information more standardized and unified. This


=== ERC-1484 ===
TITLE: Digital Identity Aggregator
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-10-12
REQUIRES: 191

SUMMARY:
This EIP proposes an identity management and aggregation framework on the Ethereum blockchain. It allows entities to claim an `Identity` via a singular `Identity Registry` smart contract, associate it with Ethereum addresses in a variety of meaningful ways, and use it to interact with smart contracts. This enables arbitrarily complex identity-related functionality. Notably (among other features) ERC-1484 `Identities`: are self-sovereign, can natively support [ERC-725](./eip-725.md) and [ERC-1056](./eip-1056.md) identities, are [DID compliant](https://github.com/NoahZinsmeister/ERC-1484/blob/master/best-practices/DID-Method.md), and can be fully powered by [meta-transactions](https://github.com/NoahZinsmeister/ERC-1484/tree/master/contracts/examples/Providers/MetaTransactions).

SPECIFICATION:
A digital identity in this proposal can be viewed as an omnibus account, containing more information about an identity than any individual identity application could. This omnibus identity is resolvable to an unlimited number of sub-identities called `Resolvers`. This allows an atomic entity, the `Identity`, to be resolvable to abstract data structures, the `Resolvers`. `Resolvers` recognize `Identities` by any of their `Associated Addresses`, or by their `EIN`. The protocol revolves around claiming an `Identity` and managing `Associated Addresses`, `Providers` and `Resolvers`. Identities can delegate much or all of this responsibility to one or more `Providers`, or perform it

MOTIVATION:
Emerging identity standards and related frameworks proposed by the Ethereum community (including ERCs/EIPs [725](./eip-725.md), [735](https://github.com/ethereum/EIPs/issues/735), [780](https://github.com/ethereum/EIPs/issues/780), [1056](./eip-1056.md), etc.) define and instrumentalize digital identity in a variety of ways. As existing approaches mature, new standards emerge, and isolated, non-standard approaches to identity develop, coordinating on identity will become increasingly burdensome for blockchain users and developers, and involve the unnecessary duplication of work. The proliferation of on-chain identity solutions can be traced back to the fact that each codifies a notion of identity and links it to specific aspects of Ethereum (claims protocols, per-identity smart contracts, signature verification schemes, etc.).

RATIONALE:
We find that at a protocol layer, identities should not rely on specific claim or attestation structures, but should instead be a part of a trustless framework upon which arbitrarily sophisticated claim and attestation structures may be built. The main criticism of existing identity solutions is that they're overly restrictive. We aim to limit requirements, keep identities modular and future-proof, and remain un-opinionated regarding any functionality a particular identity component may have. This proposal gives users the option to interact on the blockchain using an robust `Identity` rather than just an address.


=== ERC-4824 ===
TITLE: Common Interfaces for DAOs
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-02-17
REQUIRES: 

SUMMARY:
An API standard for decentralized autonomous organizations (DAOs), focused on relating on-chain and off-chain representations of membership and proposals.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Every contract implementing this EIP MUST implement the `IERC4824` interface below: ```solidity pragma solidity ^0.8.1; /// @title ERC-4824 DAOs /// @dev See <https://eips.ethereum.org/EIPS/eip-4824> interface IERC4824 { event DAOURIUpdate(address daoAddress, string daoURI); /// @notice A distinct Uniform Resource Identifier (URI) pointing to a JSON object following the "ERC-4824 DAO JSON-LD Schema". This JSON file splits into four subsidiary URIs: membersURI, proposalsURI, activityLogURI, and governanceURI. The membersURI SHOULD point to a

MOTIVATION:
DAOs, since being invoked in the Ethereum whitepaper, have been vaguely defined. This has led to a wide range of patterns but little standardization or interoperability between the frameworks and tools that have emerged. Standardization and interoperability are necessary to support a variety of use-cases. In particular, a standard daoURI, similar to tokenURI in [ERC-721](./eip-721), will enhance DAO discoverability, legibility, proposal simulation, and interoperability between tools. More consistent data across the ecosystem is also a prerequisite for future DAO standards.

RATIONALE:
In this standard, we assume that all DAOs possess at least two primitives: _membership_ and _behavior_. _Membership_ is defined by a set of addresses. _Behavior_ is defined by a set of possible contract actions, including calls to external contracts and calls to internal functions. _Proposals_ relate membership and behavior; they are objects that members can interact with and which, if and when executed, become behaviors of the DAO. ### APIs, URIs, and off-chain data DAOs themselves have a number of existing and emerging use-cases. But almost all DAOs need to publish data off-chain for a number of reasons:


=== ERC-6551 ===
TITLE: Non-fungible Token Bound Accounts
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-02-23
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 6, 7, ,,  , 1, 2, 7, 1

SUMMARY:
This proposal defines a system which assigns Ethereum accounts to all non-fungible tokens. These token bound accounts allow NFTs to own assets and interact with applications, without requiring changes to existing smart contracts or infrastructure.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview The system outlined in this proposal has two main components: - A singleton registry for token bound accounts - A common interface for token bound account implementations The following diagram illustrates the relationship between NFTs, NFT holders, token bound accounts, and the Registry: ![](../assets/eip-6551/diagram.png) ### Registry The registry is a singleton contract that serves as the entry point for all token bound

MOTIVATION:
The [ERC-721](./eip-721.md) standard enabled an explosion of non-fungible token applications. Some notable use cases have included breedable cats, generative artwork, and exchange liquidity positions. However, NFTs cannot act as agents or associate with other on-chain assets. This limitation makes it difficult to represent many real-world non-fungible assets as NFTs. For example: - A character in a role-playing game that accumulates assets and abilities over time based on actions they have taken - An automobile composed of many fungible and non-fungible components - An investment portfolio composed of multiple fungible assets - A punch pass membership card granting access

RATIONALE:
### Singleton Registry This proposal specifies a single, canonical registry that can be permissionlessly deployed to any chain at a known address. It purposefully does not specify a common interface that can be implemented by multiple registry contracts. This approach enables several critical properties. #### Counterfactual Accounts All token bound accounts are created using the create2 opcode, enabling accounts to exist in a counterfactual state prior to their creation. This allows token bound accounts to receive assets prior to contract creation. A singleton account registry ensures a common addressing scheme is used for all token bound account addresses.


=== ERC-5216 ===
TITLE: ERC-1155 Allowance Extension
TYPE: Standards Track ERC
STATUS: Last Call
CREATED: 2022-07-11
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 1, 1, 5, 5

SUMMARY:
This ERC defines standard functions for granular approval of [ERC-1155](./eip-1155.md) tokens by both `id` and `amount`. This ERC extends [ERC-1155](./eip-1155.md).

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Contracts using this ERC MUST implement the `IERC5216` interface. ### Interface implementation ```solidity /** * @title ERC-1155 Allowance Extension * Note: the ERC-165 identifier for this interface is 0x1be07d74 */ interface IERC5216 is IERC1155 { /** * @notice Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to * `id` and with an amount: `amount`. */ event Approval(address indexed account, address indexed operator, uint256 id,

MOTIVATION:
[ERC-1155](./eip-1155.md)'s popularity means that multi-token management transactions occur on a daily basis. Although it can be used as a more comprehensive alternative to [ERC-721](./eip-721.md), ERC-1155 is most commonly used as intended: creating multiple `id`s, each with multiple tokens. While many projects interface with these semi-fungible tokens, by far the most common interactions are with NFT marketplaces. Due to the nature of the blockchain, programming errors or malicious operators can cause permanent loss of funds. It is therefore essential that transactions are as trustless as possible. ERC-1155 uses the `setApprovalForAll` function, which approves ALL tokens with a specific `id`.

RATIONALE:
The name "ERC-1155 Allowance Extension" was chosen because it is a succinct description of this ERC. Users can approve their tokens by `id` and `amount` to `operator`s. By having a way to approve and revoke in a manner similar to [ERC-20](./eip-20.md), the trust level can be more directly managed by users: - Using the `approve` function, users can approve an operator to spend an `amount` of tokens for each `id`. - Using the `allowance` function, users can see the approval that an operator has for each `id`. The [ERC-20](./eip-20.md) name patterns were used due to similarities with [ERC-20](./eip-20.md)


=== ERC-7682 ===
TITLE: Auxiliary Funds Capability
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-09
REQUIRES: 5792

SUMMARY:
An [EIP-5792](./eip-5792.md) compliant capability that allows wallets to indicate to apps that they have access to funds beyond those that can be accounted for by looking up balances onchain given the wallet's address. A wallet's ability to access auxiliary funds is communicated to apps as part of its response to an [EIP-5792](./eip-5792.md) `wallet_getCapabilities` request. The following standard does not specify the source of these auxiliary funds, but some examples are: - Funds from offchain sources that can be onramped and used just-in-time - Wallets that manage many accounts, where assets across those accounts can be transfered to the

SPECIFICATION:
One new [EIP-5792](./eip-5792.md) wallet capability is defined. ### Wallet Implementation To conform to this specification, wallets that wish to indicate that they have access to auxiliary funds MUST, for each chain they have access to auxiliary funds on, respond to `wallet_getCapabilities` calls with an `auxiliaryFunds` object with a `supported` field set to `true`. Wallets may also optionally specify which assets they have additional access to with an `assets` field, which maps to an array of addresses representing the assets the wallet might have additional access to. If a wallet does not respond with this optional array of assets,

MOTIVATION:
Many applications check users' balances before letting them complete some action. For example, if a user wants to swap some amount of tokens on a dex, the dex will commonly block the user from doing so if it sees that the user does not have that amount of tokens at their address. However, more advanced wallets have features that let users access funds from other sources. Wallets need a way to tell apps that they have access to additional funds so that users using these more advanced wallets are not blocked by balance checks.

RATIONALE:
### Alternatives #### Advanced Balance Fetching An alternative we considered is defining a way for apps to fetch available auxiliary balances. This could be done, for example, by providing a URL as part of the `auxiliaryFunds` capability that apps could use to fetch auxiliary balance information. However, we ultimately decided that a boolean was enough to indicate to apps that they should not block user actions on the basis of balance checks, and it is minimally burdensome for apps to implement. The shape of this capability allows for a more advanced extension if apps feel more functionality is


=== ERC-5484 ===
TITLE: Consensual Soulbound Tokens
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-08-17
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This EIP defines an interface extending [EIP-721](./eip-721.md) to create soulbound tokens. Before issuance, both parties (the issuer and the receiver), have to agree on who has the authorization to burn this token. Burn authorization is immutable after declaration. After its issuance, a soulbound token can't be transferred, but can be burned based on a predetermined immutable burn authorization.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. - The token MUST implement the following interfaces: 1. [EIP-165](./eip-165.md)’s `ERC165` (`0x01ffc9a7`) 1. [EIP-721](./eip-721.md)’s `ERC721` (`0x80ac58cd`) - `burnAuth` SHALL be presented to receiver before issuance. - `burnAuth` SHALL be Immutable after issuance. - `burnAuth` SHALL be the sole factor that determines which party has the rights to burn token. - The issuer SHALL present token metadata to the receiver and acquire receiver's signature before issuance. - The issuer SHALL

MOTIVATION:
The idea of soulbound tokens has gathered significant attention since its publishing. Without a standard interface, however, soulbound tokens are incompatible. It is hard to develop universal services targeting at soulbound tokens without minimal consensus on the implementation of the tokens. This EIP envisions soulbound tokens as specialized NFTs that will play the roles of credentials, credit records, loan histories, memberships, and many more. In order to provide the flexibility in these scenarios, soulbound tokens must have an application-specific burn authorization and a way to distinguish themselves from regular EIP-721 tokens.

RATIONALE:
### Soulbound Token (SBTs) as an extension to EIP-721 We believe that soulbound token serves as a specialized subset of the existing EIP-721 tokens. The advantage of such design is seamless compatibility of soulbound token with existing NFT services. Service providers can treat SBTs like NFTs and do not need to make drastic changes to their existing codebase. ### Non-Transferable One problem with current soulbound token implementations that extend from [EIP-721](./eip-721.md) is that all transfer implementations throw errors. A much cleaner approach would be for transfer functions to still throw, but also enable third parties to check beforehand


=== ERC-7508 ===
TITLE: Dynamic On-Chain Token Attributes Repository
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-08-15
REQUIRES: 165

SUMMARY:
The Public On-Chain Non-Fungible Token Attributes Repository standard provides the ability for [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) compatible tokens to store their attributes on-chain available to any external smart contract interacting with them. This proposal introduces the ability to assign attributes to NFTs in a public non-gated repository smart contract that is accessible at the same address in all of the networks. The repository smart contract is designed to be a common-good repository, meaning that it can be used by any ERC-721 or ERC-1155 compatible token.

SPECIFICATION:
### Interface The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title ERC-7508 Public On-Chain NFT Attributes Repository /// @dev See https://eips.ethereum.org/EIPS/eip-7508 /// @dev Note: the ERC-165 identifier for this interface is 0x212206a8. pragma solidity ^0.8.21; interface IERC7508 is IERC165 { /** * @notice A list of supported access types. * @return The `Owner` type, where only the owner can manage the parameter. * @return The `Collaborator` type, where only the collaborators can manage the parameter.

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability to store token's attributes on chain allows for greater utility of tokens as it fosters cross-collection interactivity and provides perpetual store of attributes. This ERC introduces new utilities for [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) based tokens in the following areas: - [Cross-Collection interactivity](#cross-collection-interactivity) - [Perpetual Store of Attributes](#perpetual-store-of-attributes) - [Token Evolution](#token-evolution) - [Dynamic State Tracking](#dynamic-state-tracking) ### Cross-Collection Interactivity Storing attributes on-chain in a predictable format allows for

RATIONALE:
Designing the proposal, we considered the following questions: 1. **Should we refer to the values stored by the repository as propertiers or attributes?**\ Historically values defining characteristics of tokens have been called properties, but have evolved in to being called attributes. Referring to the dictionary, the property is defined as a quality or characteristic that something has, and the attribute is defined as a quality or feature of somebody/something. We felt that using the term attribute fits better and decided to use it. 2. **Should the proposal specify access control?**\ Designing the proposal, we had two options: either


=== ERC-2386 ===
TITLE: Ethereum 2 Hierarchical Deterministic Walletstore
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-11-21
REQUIRES: 2, 3, 3, 4, ,,  , 2, 3, 3, 5

SUMMARY:
Ethereum has the concept of keystores: pieces of data that define a key (see [EIP-2335](https://eips.ethereum.org/EIPS/eip-2335) for details). This adds the concept of walletstores: stores that define wallets and how keys in said wallets are created.

SPECIFICATION:
The elements of a hierarchical deterministic walletstore are as follows: ### UUID The `uuid` provided in the walletstore is a randomly-generated type 4 UUID as specified by [RFC 4122](https://tools.ietf.org/html/rfc4122). It is intended to be used as a 128-bit proxy for referring to a particular wallet, used to uniquely identify wallets. This element MUST be present. It MUST be a string following the syntactic structure as laid out in [section 3 of RFC 4122](https://tools.ietf.org/html/rfc4122#section-3). ### Name The `name` provided in the walletstore is a UTF-8 string. It is intended to serve as the user-friendly accessor. The only restriction on

MOTIVATION:
Hierarchical deterministic wallets create keys from a _seed_ and a _path_. The seed needs to be accessible to create new keys, however it should also be protected to the same extent as private keys to stop it from becoming an easy attack vector. The path, or at least the variable part of it, needs to be stored to ensure that keys are not duplicated. Providing a standard method to do this can promote interoperability between wallets and similar software. Given that a wallet has an amount of data and metadata that is useful when accessing existing keys and

RATIONALE:
A standard for walletstores, similar to that for keystores, provides a higher level of compatibility between wallets and allows for simpler wallet and key interchange between them.


=== ERC-6538 ===
TITLE: Stealth Meta-Address Registry
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-01-24
REQUIRES: 7, 1, 2, ,,  , 1, 2, 7, 1, ,,  , 5, 5, 6, 4

SUMMARY:
This specification defines a standardized way of storing and retrieving an entity's stealth meta-address, by extending [ERC-5564](./eip-5564.md). An entity may register their stealth meta-address directly. A third party can also register on behalf of an entity using a valid [EIP-712](./eip-712.md) or [EIP-1271](./eip-1271.md) signature. Once registered, the stealth meta-address for the entity can be retrieved by any smart contract or user. One can use the stealth meta-address with `generateStealthAddress` specified in [ERC-5564](./eip-5564.md) to send assets to the generated stealth address without revealing the entity's address.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. This contract defines an `ERC6538Registry` that stores the stealth meta-address for entities. These entities may be identified by an address, ENS name, or other identifier. This MUST be a singleton contract, with one instance per chain. The contract is specified below. A one byte integer is used to identify the stealth address scheme. This integer is used to differentiate between different stealth address schemes. This ERC outlines schemeId `1`

MOTIVATION:
The standardization of stealth address generation holds the potential to greatly enhance the privacy capabilities of Ethereum by enabling the recipient of a transfer to remain anonymous when receiving an asset. By introducing a central smart contract for users to store their stealth meta-addresses, EOAs and contracts can programmatically engage in stealth interactions using a variety of stealth address schemes.

RATIONALE:
Having a central smart contract for registering stealth meta-addresses has several benefits: 1. It guarantees interoperability with other smart contracts, as they can easily retrieve and utilize the registered stealth meta-addresses. This enables applications such as ENS or Gnosis Safe to use that information and integrate stealth addresses into their services. 2. It ensures that users are not dependent on off-chain sources to retrieve a user's stealth meta-address. 3. Registration of a stealth meta-address in this contract provides a standard way for users to communicate that they're ready to participate in stealth interactions. 4. By deploying the registry


=== ERC-7750 ===
TITLE: Decentralized Employment System
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2024-08-04
REQUIRES: 

SUMMARY:
This ERC proposes a Decentralized Employment System (DES) built on the Ethereum blockchain. The DES facilitates the creation and management of companies, records comprehensive employment histories through unique employee tokens, enables the formation and execution of labor contracts, automates salary payments via an escrow mechanism, incorporates a robust moderation system for dispute resolution, and implements a reputation-based review system for both employers and employees. By leveraging blockchain's transparency and immutability, the DES ensures accountability and trust throughout the employment lifecycle, from company creation and hiring to contract fulfillment and termination. The system operates post employee testing and prior

SPECIFICATION:
### Solidity Interface To provide a clear and standardized way for developers to interact with the DES, the following Solidity interface outlines the primary functions and events of the system: ```solidity pragma solidity ^0.8.0; /// @title Decentralized Employment System Interface interface IDecentralizedEmploymentSystem { // Events event CompanyRegistered(uint companyId, address owner, string name, string industry); event EmployeeTokenMinted(uint tokenId, address employee); event ContractCreated(uint contractId, uint companyId, uint employeeTokenId, uint salary, uint duration); event ContractExecuted(uint contractId); event SalaryDeposited(uint contractId, uint amount); event SalaryReleased(uint contractId, address employee); event DisputeRaised(uint contractId, address raisedBy); event DisputeResolved(uint contractId, bool decisionForEmployee); event ContractTerminated(uint contractId, string reason);

MOTIVATION:
Traditional employment systems are centralized, opaque, and often lack trust. The DES aims to introduce transparency, immutability, and trust into the employment process by leveraging blockchain technology. By recording employment history on-chain, enabling decentralized company creation, automating contract enforcement, and providing mechanisms for dispute resolution, the DES promotes a fairer and more transparent employment ecosystem. Additionally, the system streamlines the hiring process by securely managing employment records and automating contractual obligations.

RATIONALE:
1. **Employee Tokenization**: - Utilizing **Soulbound Tokens (SBTs)** to represent employees ensures that each employee has a unique, non-transferable identity on the blockchain. This design choice enhances the integrity of employment records, making them tamper-proof and verifiable. It also allows companies to access a comprehensive employment history before finalizing contracts, promoting transparency. 2. **Escrow System for Salary Payments**: - Implementing an escrow mechanism secures salary payments, ensuring that funds are only released when contractual obligations are met. This system protects both employees and companies by guaranteeing that salaries are available and that payments are contingent on contract fulfillment.


=== ERC-634 ===
TITLE: Storage of text records in ENS
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2017-05-17
REQUIRES: 1, 3, 7, ,,  , 1, 6, 5

SUMMARY:
This EIP defines a resolver profile for ENS that permits the lookup of arbitrary key-value text data. This allows ENS name holders to associate e-mail addresses, URLs and other informational data with a ENS name.

SPECIFICATION:
### Resolver Profile A new resolver interface is defined, consisting of the following method: ```solidity interface IERC634 { /// @notice Returns the text data associated with a key for an ENS name /// @param node A nodehash for an ENS name /// @param key A key to lookup text data for /// @return The text data function text(bytes32 node, string key) view returns (string text); } ``` The [EIP-165](./eip-165.md) interface ID of this interface is `0x59d1d43c`. The `text` data may be any arbitrary UTF-8 string. If the key is not present, the empty string must be returned. ###

MOTIVATION:
There is often a desire for human-readable metadata to be associated with otherwise machine-driven data; used for debugging, maintenance, reporting and general information. In this EIP we define a simple resolver profile for ENS that permits ENS names to associate arbitrary key-value text.

RATIONALE:
### Application-specific vs general-purpose record types Rather than define a large number of specific record types (each for generally human-readable data) such as `url` and `email`, we follow an adapted model of DNS's `TXT` records, which allow for a general keys and values, allowing future extension without adjusting the resolver, while allowing applications to use custom keys for their own purposes.


=== ERC-4341 ===
TITLE: Ordered NFT Batch Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-10-01
REQUIRES: 

SUMMARY:
This standard introduces a smart contract interface that can represent a batch of non-fungible tokens of which the ordering information shall be retained and managed. Such information is particularly useful if `tokenId`s are encoded with the sets of `unicodes` for logographic characters and emojis. As a result, NFTs can be utilized as carriers of meanings.

SPECIFICATION:
``` pragma solidity ^0.8.0; /** @title EIP-4341 Multi Ordered NFT Standard @dev See https://eips.ethereum.org/EIPS/eip-4341 */ interface ERC4341 /* is ERC165 */ { event Transfer(address indexed from, address indexed to, uint256 id, uint256 amount); event TransferBatch(address indexed from, address indexed to, uint256[] ids, uint256[] amounts); event ApprovalForAll(address indexed owner, address indexed operator, bool approved); function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external; function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external; function safePhraseTransferFrom(address from, address to, uint256[] calldata phrase, bytes calldata data) external; function balanceOf(address owner, uint256 id)

MOTIVATION:
Non-fungible tokens are widely accepted as carriers of crypto-assets, hence in both [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md), the ordering information of multiple NFTs is discarded. However, as proposed in [EIP-3754](./eip-3754.md), non-fungible tokens are thought of as basic units on a blockchain and can carry abstract meanings with unicoded `tokenId`s. Transferring such tokens is transmitting an ordered sequence of unicodes, thus effectively transmitting phrases or meanings on a blockchain. A **[logograph](https://en.wikipedia.org/wiki/Logogram)** is a written character that represents a word or morpheme, examples include _hanzi_ in Mandarin, _kanji_ in Japanese, _hanja_ in Korean, and etc. A [unicode](https://en.wikipedia.org/wiki/Unicode) is an information technology standard

RATIONALE:
In [ERC-1155](./eip-1155.md) and [ERC-721](./eip-721.md), NFTs are used to represent crypto-assets, and in this standard together with [EIP-3754](./eip-3754.md), NFTs are equipped with utilities. In this standard, the ordering information of a batch of NFTs is retained and managed through a construct `phrase`. ### Phrase A `phrase` is usually made of a handful of basic characters or an orderred sequence of unicodes and is able to keep the ordering information in a batch of tokens. Technically, it is stored in an array of unsigned integers, and is not supposed to be disseminated. A phrase does not increase or decrease the


=== ERC-6960 ===
TITLE: Dual Layer Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-30
REQUIRES: 

SUMMARY:
The dual-layer token combines the functionalities of [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), and [ERC-1155](./eip-1155.md) while adding a classification layer that uses `mainId` as the main asset type identifier and `subId` as the unique attributes or variations of the main asset. ![Dual Layer Token](../assets/eip-6960/eip-6960-dual-layer-token-dlt.png) The proposed token aims to offer more granularity in token management, facilitating a well-organized token ecosystem and simplifying the process of tracking tokens within a contract. This standard is particularly useful for tokenizing and enabling the fractional ownership of Real World Assets (RWAs). It also allows for efficient and flexible management of both fungible and non-fungible assets. The

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### DLT Interface ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity 0.8.17; /** * @title DLT token standard interface * @dev Interface for any contract that wants to implement the DLT standard */ interface IDLT { /** * @dev MUST emit when `subId` token is transferred from `sender` to `recipient` * @param sender is the address of the previous holder whose balance is decreased * @param

MOTIVATION:
The [ERC-1155](./eip-1155.md) standard has experienced considerable adoption within the Ethereum ecosystem; however, its design exhibits constraints when handling tokens with multiple classifications, particularly in relation to Real World Assets (RWAs) and fractionalization of assets. This EIP strives to overcome this limitation by proposing a token standard incorporating a dual-layer classification system, allowing for enhanced organization and management of tokens, especially in situations where additional sub-categorization of token types is necessary.

RATIONALE:
The two-level classification system introduced in this EIP allows for a more organized token ecosystem, enabling users to manage and track tokens with greater granularity. It is particularly useful for projects that require token classifications beyond the capabilities of the current ERC-1155 standard. As assets can have various properties or variations, our smart contract design reflects this by assigning a mainId to each asset category and a unique subId to each derivative or sub-category. This approach expands the capabilities of ERC-1155 to support a broader range of assets with complex requirements. Additionally, it enables tracking of mainBalance for


=== ERC-7673 ===
TITLE: Distinguishable base256emoji Addresses
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-04-01
REQUIRES: 

SUMMARY:
Introduce base256emoji for use as the primary input and display for account addresses in all user interfaces.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. User interfaces: - SHALL depict account addresses as a base256emoji string instead of hexadecimal. - SHALL accept base256emoji strings as input for user-supplied account address parameters. - SHOULD recognize and interpret strings of exactly 20 consecutive emoji as addresses when all of them are valid base256emoji. ### base256emoji encoding table | Emoji | Unicode codepoint | Byte Value | |:-:|:-:|:-:| | 🚀 | U+1F680

MOTIVATION:
Human users often fail to distinguish between long strings of hexadecimal characters, especially when they match at the beginning and at the end. This makes hexadecimal strings a poor format for human-readable account addresses. The problem is being exploited by several spoofing strategies that mine similar addresses and spoof [ERC-20](./eip-20.md) Transfer events with the goal of tricking the end user into copying the wrong recipient address. These address spoofing attacks have mislead tens of thousands of ether, and countless other tokens. Spoofers flooding the network with fake Transfer events waste network resources and complicate blockchain accounting. Improving the

RATIONALE:
Previous attempts to reduce spoofing and other copy errors such as [ERC-55](./eip-55.md) have not reduced the number of characters in an address. Any base-256 standard would achieve this goal but emoji were chosen to maximize human-distinguishability. Multiple base-256 emoji encodings have been proposed. The base256emoji encoding was chosen due to its acceptance into the multibase repository. This standard does not also recommend base256emoji for use in depicting other bytestrings such as transaction hashes and calldata. Transaction hashes are not yet being spoofed. Calldata is best decoded via the appropriate ABI. By only using base256emoji for addresses, addresses can


=== ERC-7517 ===
TITLE: Content Consent for AI/ML Data Mining
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-12
REQUIRES: 7, 2, 1, ,,  , 7, 0, 5, 3

SUMMARY:
This EIP proposes a standardized approach to declaring mining preferences for digital media content on the EVM-compatible blockchains. This extends digital media metadata standards like [ERC-7053](./eip-7053.md) and NFT metadata standards like [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md), allowing asset creators to specify how their assets are used in data mining, AI training, and machine learning workflows.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This EIP introduces a new property, `dataMiningPreference`, to the metadata standards which signify the choices made by the asset creators or license owners regarding the suitability of their asset for inclusion in data mining or AI/ML training workflows. `dataMiningPreference` is an object that can include one or more specific conditions. * `dataMining`: Allow the asset to be used in data mining for determining "patterns,

MOTIVATION:
As digital assets become increasingly utilized in AI and machine learning workflows, it is critical that the rights and preferences of asset creators and license owners are respected, and the AI/ML creators can check and collect data easily and safely. Similar to robot.txt to websites, content owners and creators are looking for more direct control over how their creativities are used. This proposal standardizes a method of declaring these preferences. Adding `dataMiningPreference` in the content metadata allows creators to include the information about whether the asset may be used as part of a data mining or AI/ML training

RATIONALE:
The technical decisions behind this EIP have been carefully considered to address specific challenges and requirements in the digital asset landscape. Here are the clarifications for the rationale behind: 1. Adoption of JSON schema: The use of JSON facilitates ease of integration and interaction, both manually and programmatically, with the metadata. 2. Detailed control with training types: The different categories like `aiGenerativeTraining`, `aiTraining`, and `aiInference` let creators control in detail, considering both ethics and computer resource needs. 3. Authorship options included: Options like `aiGenerativeTrainingWithAuthorship` and `aiTrainingWithAuthorship` make sure creators get credit, addressing ethical and legal issues. 4. Introduction


=== ERC-55 ===
TITLE: Mixed-case checksum address encoding
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2016-01-14
REQUIRES: 


=== ERC-4973 ===
TITLE: Account-bound Tokens
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-04-01
REQUIRES: 1, 6, 5, ,,  , 7, 1, 2, ,,  , 7, 2, 1, ,,  , 1, 2, 7, 1

SUMMARY:
Proposes a standard API for account-bound Tokens (ABT) within smart contracts. An ABT is a non-fungible token bound to a single account. ABTs don't implement a canonical interface for transfers. This EIP defines basic functionality to mint, assign, revoke and track ABTs.

SPECIFICATION:
### Solidity Interface The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ABTs _must_ implement the interfaces: - [ERC-165](./eip-165.md)'s `ERC165` (`0x01ffc9a7`) - [ERC-721](./eip-721.md)'s `ERC721Metadata` (`0x5b5e139f`) ABTs _must not_ implement the interfaces: - [ERC-721](./eip-721.md)'s `ERC721` (`0x80ac58cd`) An ABT receiver must be able to always call `function unequip(address _tokenId)` to take their ABT off-chain. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.6; /// @title Account-bound tokens /// @dev See https://eips.ethereum.org/EIPS/eip-4973 /// Note: the ERC-165 identifier for this interface is 0xeb72bb7c interface

MOTIVATION:
In the popular MMORPG World of Warcraft, its game designers intentionally took some items out of the world's auction house market system to prevent them from having a publicly-discovered price and limit their accessibility. Vanilla WoW's "Thunderfury, Blessed Blade of the Windseeker" was one such legendary item, and it required a forty-person raid, among other sub-tasks, to slay the firelord "Ragnaros" to gain the "Essence of the Firelord," a material needed to craft the sword once. Upon voluntary pickup, the sword permanently **binds** to a character's "soul," making it impossible to trade, sell or even swap it between

RATIONALE:
### Interface ABTs shall be maximally backward-compatible but still only expose a minimal and simple to implement interface definition. As [ERC-721](./eip-721.md) tokens have seen widespread adoption with wallet providers and marketplaces, using its `ERC721Metadata` interface with [ERC-165](./eip-165.md) for feature-detection potentially allows implementers to support ABTs out of the box. If an implementer of [ERC-721](./eip-721.md) properly built [ERC-165](./eip-165.md)'s `function supportsInterface(bytes4 interfaceID)` function, already by recognizing that [ERC-721](./eip-721.md)'s track and transfer interface component with the identifier `0x80ac58cd` is not implemented, transferring of a token should not be suggested as a user interface option. Still, since ABTs support [ERC-721](./eip-721.md)'s `ERC721Metadata` extension,


=== ERC-7409 ===
TITLE: Public Non-Fungible Tokens Emote Repository
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-07-26
REQUIRES: 165

SUMMARY:
❗️ **[ERC-7409](./eip-7409.md) supersedes [ERC-6381](./eip-6381.md).** ❗️ The Public Non-Fungible Tokens Emote Repository standard provides an enhanced interactive utility for [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) by allowing NFTs to be emoted at. This proposal introduces the ability to react to NFTs using Unicode standardized emoji in a public non-gated repository smart contract that is accessible at the same address in all of the networks.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title ERC-7409 Emotable Extension for Non-Fungible Tokens /// @dev See https://eips.ethereum.org/EIPS/eip-7409 /// @dev Note: the ERC-165 identifier for this interface is 0x1b3327ab. pragma solidity ^0.8.16; interface IERC7409 /*is IERC165*/ { /** * @notice Used to notify listeners that the token with the specified ID has been emoted to or that the reaction has been revoked. * @dev The event MUST only be emitted if the state of

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for anyone to interact with an NFT introduces an interactive aspect to owning an NFT and unlocks feedback-based NFT mechanics. This ERC introduces new utilities for [ERC-721](./eip-721.md) based tokens in the following areas: - [Interactivity](#interactivity) - [Feedback based evolution](#feedback-based-evolution) - [Valuation](#valuation) This proposal fixes the compatibility issue in the [ERC-6381](./eip-6381.md) interface specification, where emojis are represented using `bytes4` values. The introduction of variation flags and

RATIONALE:
Designing the proposal, we considered the following questions: 1. **Does the proposal support custom emotes or only the Unicode specified ones?**\ The proposal only accepts the Unicode identifier which is a `string` value. This means that while we encourage implementers to add the reactions using standardized emojis, the values not covered by the Unicode standard can be used for custom emotes. The only drawback being that the interface displaying the reactions will have to know what kind of image to render and such additions will probably be limited to the interface or marketplace in which they were made.


=== ERC-7758 ===
TITLE: Transfer With Authorization
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2020-09-28
REQUIRES: 2, 0, ,,  , 7, 1, 2

SUMMARY:
A set of functions to enable meta-transactions and atomic interactions with [ERC-20](./eip-20.md) token contracts via signatures conforming to the [EIP-712](./eip-712.md) typed message signing specification. This enables the user to: - delegate the gas payment to someone else, - pay for gas in the token itself rather than in ETH, - perform one or more token transfers and other operations in a single atomic transaction, - transfer ERC-20 tokens to another address, and have the recipient submit the transaction, - batch multiple transactions with minimal overhead, and - create and perform multiple transactions without having to worry about them

SPECIFICATION:
### Event ```solidity event AuthorizationUsed( address indexed authorizer, bytes32 indexed nonce ); // keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)") bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267; // keccak256("ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)") bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8; /** * @notice Returns the state of an authorization * @dev Nonces are randomly generated 32-byte data unique to the authorizer's * address * @param authorizer Authorizer's address * @param nonce Nonce of the authorization * @return True if the nonce is used */ function authorizationState( address authorizer, bytes32 nonce ) external view returns (bool); /** * @notice

MOTIVATION:
There is an existing spec, [EIP-2612](./eip-2612), that also allows meta-transactions, and it is encouraged that a contract implements both for maximum compatibility. The two primary differences between this spec and EIP-2612 are that: - EIP-2612 uses sequential nonces, but this uses random 32-byte nonces, and that - EIP-2612 relies on the ERC-20 `approve`/`transferFrom` ("ERC-20 allowance") pattern. The biggest issue with the use of sequential nonces is that it does not allow users to perform more than one transaction at time without risking their transactions failing, because: - DApps may unintentionally reuse nonces that have not yet been processed

RATIONALE:
### Unique Random Nonce, Instead of Sequential Nonce One might say transaction ordering is one reason why sequential nonces are preferred. However, sequential nonces do not actually help achieve transaction ordering for meta transactions in practice: - For native Ethereum transactions, when a transaction with a nonce value that is too-high is submitted to the network, it will stay pending until the transactions consuming the lower unused nonces are confirmed. - However, for meta-transactions, when a transaction containing a sequential nonce value that is too high is submitted, instead of staying pending, it will revert and fail immediately,


=== ERC-5753 ===
TITLE: Lockable Extension for EIP-721
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-10-05
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [EIP-721](./eip-721.md). It introduces lockable NFTs. The locked asset can be used in any way except by selling and/or transferring it. The owner or operator can lock the token. When a token is locked, the unlocker address (an EOA or a contract) is set. Only the unlocker is able to `unlock` the token.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. EIP-721 compliant contracts MAY implement this EIP to provide standard methods of locking and unlocking the token at its current owner address. If the token is locked, the `getLocked` function MUST return an address that is able to unlock the token. For tokens that are not locked, the `getLocked` function MUST return `address(0)`. The user MAY permanently lock the token by calling `lock(address(1), tokenId)`. When the token is locked,

MOTIVATION:
With NFTs, digital objects become digital goods, which are verifiably ownable, easily tradable, and immutably stored on the blockchain. That's why it's very important to continuously improve UX for non-fungible tokens, not just inherit it from one of the fungible tokens. In DeFi there is an UX pattern when you lock your tokens on a service smart contract. For example, if you want to borrow some $DAI, you have to provide some $ETH as collateral for a loan. During the loan period this $ETH is being locked into the lending service contract. Such a pattern works for $ETH

RATIONALE:
This approach proposes a solution that is designed to be as minimal as possible. It only allows to lock the item (stating who will be able to unlock it) and unlock it when needed if a user has permission to do it. At the same time, it is a generalized implementation. It allows for a lot of extensibility and any of the potential use cases (or all of them), mentioned in the Motivation section. When there is a need to grant temporary and/or redeemable rights for the token (rentals, purchase with instalments) this EIP involves the real transfer


=== ERC-1822 ===
TITLE: Universal Upgradeable Proxy Standard (UUPS)
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-03-04
REQUIRES: 

SUMMARY:
The following describes a standard for proxy contracts which is universally compatible with all contracts, and does not create incompatibility between the proxy and business-logic contracts. This is achieved by utilizing a unique storage position in the proxy contract to store the Logic Contract's address. A compatibility check ensures successful upgrades. Upgrading can be performed unlimited times, or as determined by custom logic. In addition, a method for selecting from multiple constructors is provided, which does not inhibit the ability to verify bytecode.

SPECIFICATION:
The Proxy Contract proposed here should be deployed _as is_, and used as a drop-in replacement for any existing methods of lifecycle management of contracts. In addition to the Proxy Contract, we propose the Proxiable Contract interface/base which establishes a pattern for the upgrade which does not interfere with existing business rules. The logic for allowing upgrades can be implemented as needed. ### Proxy Contract #### Functions ##### `fallback` The proposed fallback function follows the common pattern seen in other Proxy Contract implementations such as [Zeppelin][1] or [Gnosis][2]. However, rather than forcing use of a variable, the address

MOTIVATION:
- Improve upon existing proxy implementations to improve developer experience for deploying and maintaining Proxy and Logic Contracts. - Standardize and improve the methods for verifying the bytecode used by the Proxy Contract.


=== ERC-820 ===
TITLE: Pseudo-introspection Registry Contract
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-01-05
REQUIRES: 1, 6, 5, ,,  , 2, 1, 4

SUMMARY:
This standard defines a registry where smart contracts and regular accounts can publish which functionalities they implement---either directly or through a proxy contract. Anyone can query this registry to ask if a specific address implements a given interface and which smart contract handles its implementation. This registry MAY be deployed on any chain and shares the same address on all chains. Interfaces with zeroes (`0`) as the last 28 bytes are considered [ERC-165] interfaces, and this registry SHALL forward the call to the contract to see if it implements the interface. This contract also acts as an [ERC-165]

SPECIFICATION:
### [ERC-820] Registry Smart Contract > This is an exact copy of the code of the [ERC820 registry smart contract]. ``` solidity /* ERC820 Pseudo-introspection Registry Contract * This standard defines a universal registry smart contract where any address * (contract or regular account) can register which interface it supports and * which smart contract is responsible for its implementation. * * Written in 2018 by Jordi Baylina and Jacques Dafflon * * To the extent possible under law, the author(s) have dedicated all copyright * and related and neighboring rights to this software to the public domain

MOTIVATION:
There have been different approaches to define pseudo-introspection in Ethereum. The first is [ERC-165] which has the limitation that it cannot be used by regular accounts. The second attempt is [ERC-672] which uses reverse [ENS]. Using reverse [ENS] has two issues. First, it is unnecessarily complicated, and second, [ENS] is still a centralized contract controlled by a multisig. This multisig theoretically would be able to modify the system. This standard is much simpler than [ERC-672], and it is *fully* decentralized. This standard also provides a *unique* address for all chains. Thus solving the problem of resolving the correct

RATIONALE:
This standards offers a way for any type of address (externally owned and contracts) to implement an interface and potentially delegate the implementation of the interface to a proxy contract. This delegation to a proxy contract is necessary for externally owned accounts and useful to avoid redeploying existing contracts such as multisigs and DAOs. The registry can also act as a [ERC-165] cache in order to save gas when looking up if a contract implements a specific [ERC-165] interface. This cache is intentionally kept simple, without automatic cache update or invalidation. Anyone can easily and safely update the


=== ERC-7546 ===
TITLE: Upgradeable Clone for Scalable Contracts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-10-25
REQUIRES: 1, 6, 5, ,,  , 1, 9, 6, 7, ,,  , 7, 2, 0, 1

SUMMARY:
It has been a significant challenge for developers attempting to create cloneable and upgradeable contracts on the Ethereum Virtual Machine (EVM). While [ERC-2535](./eip-2535.md) Diamonds and other existing proxy standards offer partial solutions, a comprehensive answer has remained elusive. Our proposal addresses this gap through the introduction of two main features. ### Function-Level Upgradeability In alignment with [ERC-2535](./eip-2535.md), this functionality permits the selective redirection of implementation contracts for individual function calls. This granular control over upgrades allows for modifications on a per-function basis. Moreover, segmenting implementation contracts by function helps mitigate the limitations posed by the contract size cap

SPECIFICATION:
> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. In the EVM, contract accounts are characterized by four primary fields: *nonce*, *balance*, *code*, and *storage*. This ERC's architecture modularizes these functionalities into three distinct types of contracts, each serving a specific purpose when combined to represent a single account: 1. **Proxy Contract**: Maintains the state of the contract account, such as nonce, balance, and storage. This contract delegatecalls to the _Function Contract_

MOTIVATION:
Smart contract development often encounters hurdles due to the inherent limitations of the Ethereum Virtual Machine (EVM), such as the contract size limit and stack depth. Additionally, addressing vulnerabilities in both the smart contract logic and its compiler are persistent issues. While there is a desire to minimize reliance on trusted third parties for upgradeability, introducing complex governance structures for upgrade management can significantly increase the workload for crypto DevOps, adding to the apprehension developers may feel towards advancing their projects. This apprehension can restrict the complexity and innovation within smart contract development. Our approach seeks to simplify

RATIONALE:
### Comparison with [ERC-2535](./eip-2535.md) While both this ERC and ERC-2535 offer [Function-Level Upgradeability](#function-level-upgradeability), there is a key distinction in their approaches. ERC-2535 maintains a mapping of implementation contracts (referred to as Facets in ERC-2535) within the Proxy itself. In contrast, this ERC stores the mapping in an external _Dictionary Contract_. This externalization of the mapping facilitates another significant feature of this standard: [Factory/Clone-Friendly & Simultaneous Upgradeability](#factoryclone-friendly--simultaneous-upgradeability). By separating the mapping from the Proxy, this design allows for easier cloning of contracts and their simultaneous upgrade, which is not as straightforward in the ERC-2535 framework. ![Fig. Comparison with Diamond](../assets/eip-7546/images/comparison-with-diamond.svg)


=== ERC-6596 ===
TITLE: Cultural and Historical Asset Token
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-02-28
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP proposes the establishment of a comprehensive metadata standard for Cultural and Historical Asset Tokens (CHATs) on the Ethereum platform. These tokens represent cultural and historical assets such as artwork, artifacts, collectibles, and rare items, providing crucial context and provenance to substantiate their significance and value. While existing NFT standards ensure the immutability and decentralized ownership of assets on the blockchain, based on our research they do not adequately capture the cultural and historical importance and value of such assets needed for widespread adoption by institutions such as museums. The CHAT standard aims to overcome these limitations

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This EIP extends [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) with 48 additional properties to capture the cultural and historical significance of the underlying asset. Compatible contracts, besides implementing the relevant metadata schemas ("Metadata JSON Schema" for [ERC-721](./eip-721.md) contracts or "Metadata URI JSON Schema" for [ERC-1155](./eip-1155.md) contracts), must implement the following metadata interface. ### Cultural and Historical Asset Metadata Extension TypeScript Interface The following TypeScript interface defines the

MOTIVATION:
**Preserving context and significance** - Provenance and context are crucial for cultural and historical assets. The CHAT standard captures and preserves the provenance and history of these assets, as well as the changing contexts that emerge from new knowledge and information. This context and provenance substantiate the significance and value of cultural and historical assets. **Proof-based preservation** - The recent incidents of lost artifacts and data breaches at a number of significant international museums points to a need in reassessing our current record keeping mechanisms. While existing systems mostly operate on trust, blockchain technology offers opportunities to establish

RATIONALE:
### Choosing to Extend Off-Chain Metadata JSON Schema over On-Chain Interface Both the [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) provide natural extension points in the metadata JSON file associated with NFTs to supply enriched datasets about the underlying assets. Providing enriched datasets through off-chain metadata JSON files allows existing NFT contracts to adopt the new metadata structure proposed in this EIP without upgrading or migrating. The off-chain design enables flexible and progressive enhancement of any NFT collections to adopt this standard gradually. This approach allows NFT collections to be deployed using already-audited and battle-tested smart contract code without creating or adapting


=== ERC-165 ===
TITLE: Standard Interface Detection
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-01-23
REQUIRES: 214

SUMMARY:
Herein, we standardize the following: 1. How interfaces are identified 2. How a contract will publish the interfaces it implements 3. How to detect if a contract implements ERC-165 4. How to detect if a contract implements any given interface

SPECIFICATION:
### How Interfaces are Identified For this standard, an *interface* is a set of [function selectors as defined by the Ethereum ABI](https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector). This a subset of [Solidity's concept of interfaces](https://solidity.readthedocs.io/en/develop/abi-spec.html) and the `interface` keyword definition which also defines return types, mutability and events. We define the interface identifier as the XOR of all function selectors in the interface. This code example shows how to calculate an interface identifier: ```solidity pragma solidity ^0.4.20; interface Solidity101 { function hello() external pure; function world(int) external pure; } contract Selector { function calculateSelector() public pure returns (bytes4) { Solidity101 i; return i.hello.selector

MOTIVATION:
For some "standard interfaces" like [the ERC-20 token interface](./eip-20.md), it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with. Specifically for ERC-20, a version identifier has already been proposed. This proposal standardizes the concept of interfaces and standardizes the identification (naming) of interfaces.

RATIONALE:
We tried to keep this specification as simple as possible. This implementation is also compatible with the current Solidity version.


=== ERC-4907 ===
TITLE: Rental NFT, an Extension of EIP-721
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-03-11
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [EIP-721](./eip-721.md). It proposes an additional role (`user`) which can be granted to addresses, and a time where the role is automatically revoked (`expires`). The `user` role represents permission to "use" the NFT, but not the ability to transfer it or set users.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Contract Interface Solidity Interface with NatSpec & OpenZeppelin v4 Interfaces (also available at [`IERC4907.sol`](../assets/eip-4907/contracts/IERC4907.sol)): ```solidity interface IERC4907 { // Logged when the user of an NFT is changed or expires is changed /// @notice Emitted when the `user` of an NFT or the `expires` of the `user` is changed /// The zero address for user indicates that there is no user address event UpdateUser(uint256 indexed tokenId, address indexed user,

MOTIVATION:
Some NFTs have certain utilities. For example, virtual land can be "used" to build scenes, and NFTs representing game assets can be "used" in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a “user”. The actions that a “user” should be able to take with an NFT would be different from the “owner” (for instance, “users” usually shouldn’t be able to sell ownership of the NFT). In these situations, it makes sense to have separate roles that identify whether an

RATIONALE:
This model is intended to facilitate easy implementation. Here are some of the problems that are solved by this standard: ### Clear Rights Assignment With Dual “owner” and “user” roles, it becomes significantly easier to manage what lenders and borrowers can and cannot do with the NFT (in other words, their rights). Additionally, owners can control who the user is and it’s easy for other projects to assign their own rights to either the owners or the users. ### Simple On-chain Time Management Once a rental period is over, the user role needs to be reset and the


=== ERC-7726 ===
TITLE: Common Quote Oracle
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-06-20
REQUIRES: 7528

SUMMARY:
The following allows for the implementation of a standard API for data feeds providing the relative value of assets, forcing compliant contracts to use explicit token amounts instead of price factors. This approach has been shown to lead to better security and time-to-market outcomes.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions - base asset: The asset that the user needs to know the value for (e.g: USDC as in "I need to know the value of 1e6 USDC in ETH terms"). - quote asset: The asset in which the user needs to value the `base` (e.g: ETH as in "I need to know the value of 1e6 USDC in ETH terms"). - value:

MOTIVATION:
The information required to value assets is scattered over a number of major and minor sources, each one with their own integration API and security considerations. Many protocols over the years have implemented oracle adapter layers for their own use to abstract this complexity away from their core implementations, leading to much duplicated effort. This specification provides a standard API aimed to serve the majority of use cases. Preference is given to ease of integration and serving the needs of product teams with less knowledge, requirements and resources.

RATIONALE:
The use of `getQuote` doesn't require the consumer to be aware of any decimal partitions that might have been defined for the `base` or `quote` and should be preferred in most data processing cases. The spec doesn't include a `getPrice` function because it is rarely needed on-chain, and it would be a decimal number of difficult representation. The popular option for representing prices can be implemented for [ERC-20](./eip-20.md) with decimals as `oracle.getQuote(base, quote, 10\*\*base.decimals()) and will give the value of a whole unit of base in quote terms.


=== ERC-6229 ===
TITLE: Tokenized Vaults with Lock-in Period
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-12-21
REQUIRES: 4626

SUMMARY:
This standard extends [EIP-4626](./eip-4626.md) to support lock-in periods.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All vaults that follow this EIP MUST implement [EIP-4626](./eip-4626.md) to provide basic vault functions and [EIP-20](./eip-20.md) to represent shares. ### Definitions - asset: The underlying [EIP-20](./eip-20.md) token that the vault accepts and manages. - share: The EIP-20 token that the vault issued. - locked: A status of the vault. When the vault is locked, user can’t withdraw or deposit assets from the vault. -

MOTIVATION:
The [EIP-4626](./eip-4626.md) standard defines a tokenized vault allowing users (contracts or EOAs) to deposit and withdraw underlying tokens at any time. However, there exist cases where the vault needs to lock the underlying tokens (perhaps to execute certain strategies). During the lock-in period, neither withdrawals nor deposits should be allowed. This standard extends the EIP-4626 to support lock-in periods and handle scheduled deposits and withdrawals during them.

RATIONALE:
The standard is designed to be a minimal interface. Details such as the start and end of a lock-in period, and how the underlying tokens are being used during the lock-in period are not specified. There is no function for scheduling a withdrawal, since during the lock-in period, the share price is undetermined, so it is impossible to determine how many underlying tokens can be withdrawn.


=== ERC-5094 ===
TITLE: URL Format for Ethereum Network Switching
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-05-13
REQUIRES: 6, 8, 1, ,,  , 8, 3, 1

SUMMARY:
This standard includes all needed information for adding a network to a wallet via URL, by including parameters such as `chainId`, `rpc_url`, `chain_name` and others, such that the network configuration is provided through the URL itself.

SPECIFICATION:
### Syntax Network Switching URLs contain "ethereum" in their schema (protocol) part and are constructed as follows: network_add = erc831_part "add" "@" chain_id [ "/" ] "?" parameters erc831_part = "ethereum:network-" chain_id = 1*DIGIT parameters = parameter *( "&" parameter ) parameter = key "=" value key = required_keys / optional_keys required_keys = "rpc_url" / "chain_name" optional_keys = "name" / "symbol" / "decimals" / "explorer_url" / "icon_url" value = STRING / number number = 1*DIGIT `STRING` is a URL-encoded Unicode string of arbitrary length, where delimiters and the percentage symbol (`%`) are mandatorily hex-encoded with a `%` prefix.

MOTIVATION:
As observed with the use of [EIP-681](./eip-681.md) and its implementation in current mobile wallets, transactions can be made, approved, viewed, and used. However, if the wallet is instructed to perform a transaction on a chain they have not yet been configured before, the operation tends to fail. This is understandable, as the `chain_id` provided makes up only one part of what is required to connect to a network. This EIP aims to introduce a new type of URL for usage with deep-linking, QR, and more, to allow users to seamlessly add new networks to their (for ex. mobile)

RATIONALE:
In furtherance of the Ethereum URL saga, network configuration is a needed addition to the possibility of Ethereum URLs. This would improve functionality for URLs, and offer non-mainnet users a way to connect without needing to configure their wallet by hand. The URL follows [EIP-831](./eip-831.md) with the `PREFIX` being `network` and the `PAYLOAD` being a composite of `add` and [EIP-681](./eip-681.md)-like `chain_id` and parameters. The choice for `PREFIX` being `network` is to allow further expansion and allow variants following the pattern `network-x`. An example URL for adding the Optimism Network ```URL ethereum:network-add@10/?chain_name=Optimistic%20Ethereum &rpc_url=https%3A%2F%2Fmainnet.optimism.io&name=Ethereum&symbol=ETH&decimals=18&explorer_url=https%3A%2F%2Foptimistic.etherscan.io ``` The specification allows for a


=== ERC-4337 ===
TITLE: Account Abstraction Using Alt Mempool
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2021-09-29
REQUIRES: 7, 1, 2, ,,  , 7, 5, 6, 2

SUMMARY:
An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called a `UserOperation`. Users send `UserOperation` objects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making a `handleOps` call to a special contract, and that transaction then gets included in a block.

SPECIFICATION:
### Definitions * **UserOperation** - a structure that describes a transaction to be sent on behalf of a user. To avoid confusion, it is not named "transaction". * Like a transaction, it contains `to`, `calldata`, `maxFeePerGas`, `maxPriorityFeePerGas`, `nonce`, `signature`. * Unlike a transaction, it contains several other fields, described below. * Notably, the `signature` field usage is not defined by the protocol, but by the Smart Contract Account implementation. * **Sender** - the Smart Contract Account sending a `UserOperation`. * **EntryPoint** - a singleton contract to execute bundles of `UserOperations`. Bundlers MUST whitelist the supported `EntryPoint`. * **Bundler**

MOTIVATION:
See also `https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020` and the links therein for historical work and motivation, and [EIP-2938](./eip-2938.md) for a consensus layer proposal for implementing the same goal. This proposal takes a different approach, avoiding any adjustments to the consensus layer. It seeks to achieve the following goals: * **Achieve the key goal of Account Abstraction**: allow users to use Smart Contract Accounts containing arbitrary verification logic instead of EOAs as their primary account. Completely remove any need at all for users to also have EOAs, as required by both status quo Smart Contract Accounts and [EIP-7702](./eip-7702.md). * **Decentralization** * Allow any

RATIONALE:
The main challenge with a purely "Smart Contract Accounts" based Account Abstraction system is DoS safety: how can a block builder including an operation make sure that it will actually pay fees, without having to first execute the entire operation? Requiring the block builder to execute the entire operation opens a DoS attack vector, as an attacker could easily send many operations that pretend to pay a fee but then revert at the last moment after a long execution. Similarly, to prevent attackers from cheaply clogging the mempool, nodes in the P2P network need to check if an


=== ERC-1123 ===
TITLE: Revised Ethereum Smart Contract Packaging Standard
TYPE: Standards Track ERC
STATUS: Withdrawn
CREATED: 2018-06-01
REQUIRES: 


=== ERC-7272 ===
TITLE: Ethereum Access Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-03
REQUIRES: 712

SUMMARY:
An Ethereum Access Token (EAT) is an [EIP-712](./eip-712.md) conformant, signed message, used by off-chain services to grant Ethereum accounts access to specific on-chain resources. EATs share similarities with JSON Web Tokens (JWTs); both are used for short-lived authorizations. However Ethereum Access Tokens are specifically designed to be verified on-chain and tailored to authorize smart contract function calls.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview An example flow integrated in a DeFi application is the following: 1. A user interacts with the DeFi's off-chain service, providing sufficient input for the off-chain service to ensure the user meets its criteria (for example, authenticates the user and/or make sure they possess valid credentials) 2. If authorization is granted, an EAT is issued to the user 3. The user then

MOTIVATION:
While other proposals tackle authentication or authorization in a more narrow way, this specification allows developers to add a layer of access control to any function they create with minimal changes. It is best suited for use cases where end users should only be able to access specific on-chain resources themselves directly, by way of sending a transaction, provided they have been granted authorization by an off-chain service first. Examples of such scenarios include an off-chain verifier assessing eligibility requirements (e.g by verifying verifiable credentials) to mint a token or to interact with a smart contract that requires

RATIONALE:
- Single-use. The reference implementation guarantees non-replayability of EATs. But other implementations might favor a different approach. - Use of EIP-712. By conforming to EIP-712, EATs are interoperable with existing Ethereum infrastructure, and developers can use them to create access controls with minimal modifications to their existing code. It also ensures that EATs issued are bound to a specific chain. - Zero-knowledge proofs. Using ZKPs comes at a cost, including added complexity. EATs are not much more than signed messages which are simpler to reason around. While `ecrecover` is available in any Ethereum smart contract out of the


=== ERC-5247 ===
TITLE: Smart Contract Executable Proposal Interface
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2022-07-13
REQUIRES: 

SUMMARY:
This EIP presents an interface for "smart contract executable proposals": proposals that are submitted to, recorded on, and possibly executed on-chain. Such proposals include a series of information about function calls including the target contract address, ether value to be transmitted, gas limits and calldatas.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.17; interface IERC5247 { event ProposalCreated( address indexed proposer, uint256 indexed proposalId, address[] targets, uint256[] values, uint256[] gasLimits, bytes[] calldatas, bytes extraParams ); event ProposalExecuted( address indexed executor, uint256 indexed proposalId, bytes extraParams ); function createProposal( uint256 proposalId, address[] calldata targets, uint256[] calldata values, uint256[] calldata gasLimits, bytes[] calldata calldatas, bytes calldata extraParams ) external returns (uint256 registeredProposalId); function executeProposal(uint256 proposalId, bytes calldata

MOTIVATION:
It is oftentimes necessary to separate the code that is to be executed from the actual execution of the code. A typical use case for this EIP is in a Decentralized Autonomous Organization (DAO). A proposer will create a smart proposal and advocate for it. Members will then choose whether or not to endorse the proposal and vote accordingly (see `ERC-1202`). Finallym when consensus has been formed, the proposal is executed. A second typical use-case is that one could have someone who they trust, such as a delegator, trustee, or an attorney-in-fact, or any bilateral collaboration format, where

RATIONALE:
* Originally, this interface was part of part of `ERC-1202`. However, the proposal itself can potentially have many use cases outside of voting. It is possible that voting may not need to be upon a proposal in any particular format. Hence, we decide to *decouple the voting interface and proposal interface*. * Arrays were used for `target`s, `value`s, `calldata`s instead of single variables, allowing a proposal to carry arbitrarily long multiple functional calls. * `registeredProposalId` is returned in `createProposal` so the standard can support implementation to decide their own format of proposal id.


=== ERC-5169 ===
TITLE: Client Script URI for Token Contracts
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-05-03
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 7, 7, 7, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP provides a contract interface adding a `scriptURI()` function for locating executable scripts associated with the token.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. We define a scriptURI element using the `string[]`. Based on this, we define the smart contract interface below: ```solidity interface IERC5169 { /// @dev This event emits when the scriptURI is updated, /// so wallets implementing this interface can update a cached script event ScriptUpdate(string[] newScriptURI); /// @notice Get the scriptURI for the contract /// @return The scriptURI function scriptURI() external view returns(string[] memory); /// @notice Update the scriptURI ///

MOTIVATION:
Often, smart contract authors want to provide some user functionality to their tokens through client scripts. The idea is made popular with function-rich NFTs. It's important that a token's contract is linked to its client script, since the client script may carry out trusted tasks such as creating transactions for the user. This EIP allows users to be sure they are using the correct script through the contract by providing a URI to an official script, made available with a call to the token contract itself (`scriptURI`). This URI can be any RFC 3986-compliant URI, such as a

RATIONALE:
This method avoids the need for building secure and certified centralized hosting and allows scripts to be hosted anywhere: IPFS, GitHub or cloud storage.


=== ERC-7208 ===
TITLE: On-Chain Data Containers
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-06-09
REQUIRES: 165

SUMMARY:
This ERC defines a series of interfaces for the abstraction of storage of on-chain data by implementing the logic functions that govern such data on independent smart contracts. "On-chain Data Containers" (ODCs) refer to the separation and indexing of data storage away from data management. We propose that on-chain data can be abstracted and stored in smart contracts called "Data Objects" (DO), which answer to external data indexing mechanisms named "Data Points" (DP). This data can be accessed and modified by implementing (one or many) separate smart contracts identified as "Data Managers" (DM). We introduce two mechanisms for

SPECIFICATION:
### Terms **Data Point**: A uniquely identifiable reference to an on-chain data structure stored within one or many **Data Objects** and managed by one or many **Data Managers**. **Data Points** are issued by a **Data Point Registry**. **Data Object**: A Smart Contract implementing the low-level storage management of information indexed through **Data Points**. **Data Manager**: One or many Smart Contracts implementing the high-level logic and end-user interfaces for managing Data Objects. **Data Point Registry**: One or many Smart Contracts used for managing the issuance of **Data Points**. Additionally, a **Data Point Registry** defines a space of compatible or

MOTIVATION:
As the Ethereum ecosystem grows, so does the demand for on-chain functionalities. The market encourages a desire for broader adoption through more complex systems and there is a constant need for improved efficiency. We have seen times when an explosion of new standard token proposals was solely driven by market hype. While ultimately each standard serves its purpose, most of them require more flexibility to manage interoperability with other standards. A standard adapter mechanism is needed to enhance interoperability by driving the interactions between assets issued under different ERCs. Without such mechanisms, most projects have implemented bespoke solutions

RATIONALE:
The decision to encode **Data Points** as `bytes32` data pointers is primarily driven by flexibility and future-proofing. The use `bytes32` allows for a wide range of data encodings. This provides the developer with many options to accommodate diverse use cases. Furthermore, as Ethereum and its standards continue to evolve, encoding as `bytes32` ensures that the Standard Adapters built with the current ERC can reference future data types or structures without requiring significant changes to the adapter itself. The **Data Point** encoding should have a prefix so that the **Data Object** can efficiently identify compatibility issues when accessing the


=== ERC-2334 ===
TITLE: BLS12-381 Deterministic Account Hierarchy
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-09-30
REQUIRES: 2333

SUMMARY:
A standard for allocating keys generated by [EIP-2333](./eip-2333.md) to a specific purpose. It defines a `path` which is a string that parses into the indices to be used when traversing the tree of keys that [EIP-2333](./eip-2333.md) generates.

SPECIFICATION:
### Path The path traversed through the tree of keys is defined by integers (which indicate the sibling index) separated by `/` which denote ancestor relations. There are 4 levels (plus the master node) in the path and at least 4 (5 including the master node) MUST be used. ```text m / purpose / coin_type / account / use ``` #### Notation The notation used within the path is specified within the [EIP-2333](./eip-2333.md), but is summarized again below for convenience. * `m` Denotes the master node (or root) of the tree * `/` Separates the tree into depths,

MOTIVATION:
Ethereum 2.0 alongside many other projects will use BLS signatures over BLS12-381, an [IETF proposed standard](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/). This new scheme requires a new key derivation mechanism, which is established within [EIP-2333](./eip-2333.md). This new scheme is incompatible with the current form of this specification ([BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)) due to the: exclusive use of hardened keys, the increased number of keys per level, not using [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) for key derivation. It is therefore necessary to establish a new *path* for traversing the [EIP-2333](./eip-2333.md) key-tree. The path structure specified in this EIP aims to be more general than [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) by not having UTXO-centric features [which

RATIONALE:
`purpose`, `coin_type`, and `account` are widely-adopted terms as per [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) and [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) and therefore reusing these terms and their associated meanings makes sense. The purpose needs to be distinct from these standards as the KDF and path are not inter-compatible and `12381` is an obvious choice. `account` separates user activity into distinct categories thereby allowing users to separate their concerns however they desire. `use` will commonly be determined at the application level providing distinct keys for non-intersecting use cases. ### Eth2 Specific Parameters A new coin type is chosen for Eth2 keys to help ensure a clean separation


=== ERC-6147 ===
TITLE: Guard of NFT/SBT, an Extension of ERC-721
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-12-07
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It separates the holding right and transfer right of non-fungible tokens (NFTs) and Soulbound Tokens (SBTs) and defines a new role, `guard` with `expires`. The flexibility of the `guard` setting enables the design of NFT anti-theft, NFT lending, NFT leasing, SBT, etc.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ERC-721 compliant contracts MAY implement this EIP. A guard Must be valid only before expires. When a token has no guard or the guard is expired, `guardInfo` MUST return `(address(0), 0)`. When a token has no guard or the guard is expired, owner, authorised operators and approved address of the token MUST have permission to set guard and expires. When a token has a valid guard, owner, authorised operators and

MOTIVATION:
NFTs are assets that possess both use and financial value. Many cases of NFT theft currently exist, and current NFT anti-theft schemes, such as transferring NFTs to cold wallets, make NFTs inconvenient to be used. In current NFT lending, the NFT owner needs to transfer the NFT to the NFT lending contract, and the NFT owner no longer has the right to use the NFT while he has obtained the loan. In the real world, for example, if a person takes out a mortgage on his own house, he still has the right to use that house. For


=== ERC-4524 ===
TITLE: Safer ERC-20
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-12-05
REQUIRES: 2, 0, ,,  , 1, 6, 5

SUMMARY:
This standard extends [ERC-20](./eip-20.md) tokens with [EIP-165](./eip-165.md), and adds familiar functions from [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) ensuring receiving contracts have implemented proper functionality.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. In order to be compliant with this EIP, and ERC-20-compliant contract MUST also implement the following functions: ```solidity pragma solidity 0.8.10; import './IERC20.sol'; import './IERC165.sol'; // the EIP-165 interfaceId for this interface is 0x534f5876 interface SaferERC-20 is IERC20, IERC165 { function safeTransfer(address to, uint256 amount) external returns(bool); function safeTransfer(address to, uint256 amount, bytes memory data) external returns(bool); function safeTransferFrom(address from, address to, uint256 amount) external returns(bool); function safeTransferFrom(address from,

MOTIVATION:
[EIP-165](./eip-165.md) adds (among other things) the ability to tell if a target recipient explicitly signals compatibility with an ERC. This is already used in the EIPs for NFTs, [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md). In addition, EIP-165 is a valuable building block for extensions on popular standards to signal implementation, a trend we've seen in a number of NFT extensions. This EIP aims to bring these innovations back to ERC-20. The importance of [EIP-165](./eip-165.md) is perhaps felt most for app developers looking to integrate with a generic standard such as ERC-20 or ERC-721, while integrating newer innovations built atop these standards.

RATIONALE:
This EIP is meant to be minimal and straightforward. Adding EIP-165 to ERC-20 is useful for a number of applications, and outside of a minimal amount of code increasing contract size, carries no downside. The `safeTransfer` and `safeTransferFrom` functions are well recognized from ERC-721 and ERC-1155, and therefore keeping identical naming conventions is reasonable, and the benefits of being able to check for implementation before transferring are as useful for ERC-20 tokens as they are for ERC-721 and ERC-1155. Another easy backport from EIP721 and EIP1155 might be the inclusion of a metadata URI for tokens, allowing them


=== ERC-3589 ===
TITLE: Assemble assets into NFTs
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-05-24
REQUIRES: 721

SUMMARY:
The ERC-1155 multi-token contract defines a way to batch transfer tokens, but those tokens must be minted by the ERC-1155 contract itself. This EIP is an ERC-721 extension with ability to assemble assets such as ether, ERC-20 tokens, ERC-721 tokens and ERC-1155 tokens into one ERC-721 token whose token id is also the asset's signature. As assets get assembled into one, batch transfer or swap can be implemented very easily.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ERC-721 compliant contracts MAY implement this ERC to provide a standard method to assemble assets. `mint` and `safeMint` assemble assets into one ERC-721 token. `mint` SHOULD be implemented for normal ERC-20 tokens whose `_transfer` is lossless. `safeMint` MUST takes care for lossy token such as PIG token whose `_transfer` function is taxed. `_salt` of `hash` function MAY be implemented other way, even provided as user input. But the token

MOTIVATION:
As NFT arts and collectors rapidly increases, some collectors are not satisfied with traditional trading methods. When two collectors want to swap some of their collections, currently they can list their NFTs on the market and notify the other party to buy, but this is inefficient and gas-intensive. Instead, some collectors turn to social media or chat group looking for a trustworthy third party to swap NFTs for them. The third party takes NFTs from both collector A and B, and transfer A's collections to B and B's to A. This is very risky. The safest way to

RATIONALE:
There are many reasons why people want to pack their NFTs together. For example, a collector want to pack a set of football players into a football team; a collector has hundreds of of NFTs with no categories to manage them; a collector wants to buy a full collection of NFTs or none of them. They all need a way a assemble those NFTs together. The reason for choosing ERC-721 standard as a wrapper is ERC-721 token is already widely used and well supported by NFT wallets. And assembly token itself can also be assembled again. Assembly token


=== ERC-3000 ===
TITLE: Optimistic enactment governance standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-09-24
REQUIRES: 

SUMMARY:
ERC-3000 presents a basic on-chain spec for contracts to optimistically enact governance decisions made off-chain. The standard is opinionated in defining the 6 entrypoint functions to contracts supporting the standard. But it allows for any sort of resolver mechanism for the challenge/response games characteristic of optimistic contracts. While the authors currently believe resolving challenges [using a subjective oracle](https://aragon.org/blog/snapshot) is the right tradeoff, the standard has been designed such that changing to another mechanism is possible (a deterministic resolver like [Optimism's OVM](https://optimism.io) uses), even allowing to hot-swap it in the same live instance.

SPECIFICATION:
### Data structures Some data structures are defined which are later used in the standard interfaces: ```solidity library ERC3000Data { struct Container { Payload payload; Config config; } struct Payload { uint256 nonce; uint256 executionTime; address submitter; IERC3000Executor executor; Action[] actions; bytes proof; } struct Action { address to; uint256 value; bytes data; } struct Config { uint256 executionDelay; Collateral scheduleDeposit; Collateral challengeDeposit; Collateral vetoDeposit; address resolver; bytes rules; } struct Collateral { address token; uint256 amount; } } ``` ### Interface and events Given the data structures above, by taking advantage of the Solidity ABI encoder v2,

RATIONALE:
The authors believe that it is very important that this standard leaves the other open to any resolver mechanism to be implemented and adopted. That's why a lot of the function and variable names were left intentionally bogus to be compatible with future resolvers without changing the standard. ERC-3000 should be seen as a public good of top of which public infrastrastructure will be built, being way more important than any particular implementation or the interests of specific companies or projects.


=== ERC-7760 ===
TITLE: Minimal Upgradeable Proxies
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-08-19
REQUIRES: 1967

SUMMARY:
This standard defines minimal [ERC-1967](./eip-1967.md) proxies for three patterns: (1) transparent, (2) UUPS, (3) beacon. The proxies support optional immutable arguments which are appended to the end of their runtime bytecode. Additional variants which support onchain implementation querying are provided.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### General specifications All of the following proxies MAY have optional data bytecode appended to the end of their runtime bytecode. Emitting the ERC-1967 events during initialization is OPTIONAL. Indexers MUST NOT expect the initialization code to emit the ERC-1967 events. ### Onchain querying of implementation for I-variants The I-variants have logic that returns the implementation baked into their bytecode. When called with any

MOTIVATION:
Having standardized minimal bytecode for upgradeable proxies enables the following: 1. Automatic verification on block explorers. 2. Ability for immutable arguments to be queried onchain, as these arguments are stored at the same bytecode offset, 3. Ability for the implementation to be queried and verified onchain. The minimal nature of the proxies enables cheaper deployment and runtime costs.

RATIONALE:
### No usage of `PUSH0` opcode For more widespread EVM compatibility, the proxies deliberately do not use the `PUSH0` opcode proposed in [EIP-3855](./eip-3855.md). Converting the proxies to `PUSH0` variants may be done in a separate future ERC. ### Optimization priorities The proxies are first optimized for minimal runtime gas before minimal bytecode size. ### Minimal nature These proxies made from handcrafted EVM bytecode. While utmost efforts have been made to ensure that they are as minimal as possible at the time of development, it is possible that they can be further optimized. If a variant has already been


=== ERC-1328 ===
TITLE: WalletConnect URI Format
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2018-08-15
REQUIRES: 

SUMMARY:
This standard defines how the data to connect some application and a wallet can be encoded with a URI. This URI can then be shown either as a QR code or as a link.

SPECIFICATION:
### Syntax WalletConnect request URI with the following parameters: request = "wc" ":" topic [ "@" version ][ "?" parameters ] topic = STRING version = 1*DIGIT parameters = parameter *( "&" parameter ) parameter = key "=" value key = STRING value = STRING ### Semantics Required parameters are dependent on the WalletConnect protocol version: For WalletConnect v1.0 protocol (`version`=`1`) the parameters are: - `key` - symmetric key used for encryption - `bridge` - url of the bridge server for relaying messages For WalletConnect v2.0 protocol (`version`=`2`) the parameters are: - `symKey` - symmetric key used for

RATIONALE:
This proposal moves away from the JSON format used in the alpha version of the WalletConnect protocol because it suffered from very inefficient parsing of the intent of the QR code, thereby making it easier to create better QR code parsers APIs for wallets to implement. Also by using a URI instead of JSON inside the QR-Code the Android Intent system can be leveraged.


=== ERC-7769 ===
TITLE: JSON-RPC API for ERC-4337
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-08-23
REQUIRES: 1, 5, 5, ,,  , 4, 3, 3, 7, ,,  , 7, 5, 6, 2

SUMMARY:
Defines new JSON-RPC API methods which enable [ERC-4337](./eip-4337) wallets to communicate with `UserOpeation` mempool nodes and bundlers, matching the functionality that exists for Ethereum transactions. Additionally, a set of `debug` JSON-RPC API methods is defined in order to facilitate development, testing and debugging issues with ERC-4337 implementations.

SPECIFICATION:
### Definitions * **bundler**: a node exposing the APIs, in order to submit them to the network. A bundler collects one or more UserOperations into a bundle and submits them together to the `EntryPoint` in a single `handleOps` call. ### RPC methods (eth namespace) #### `eth_sendUserOperation` The `eth_sendUserOperation` method submits a `UserOperation` object to the UserOperation mempool. The client MUST validate the `UserOperation`, and return a result accordingly. The result SHOULD be set to the `userOpHash` if and only if the request passed simulation and was accepted in the client's UserOperation pool. If the validation, simulation, or UserOperation

MOTIVATION:
In ERC-4337, user transactions as defined in Ethereum are replaced with `UserOperation` objects, which contain all the information needed to perform the operations requested by the users. However, existing Ethereum JSON-RPC API methods are not suited to working with `UserOperation` objects. In order to facilitate the operation of the alternative `UserOperation` mempool it is important that all implementations of the ERC-4337 protocol have a standardized set of APIs that can be used interchangeably.


=== ERC-5173 ===
TITLE: NFT Future Rewards (nFR)
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-05-08
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal introduces the Non-Fungible Future Rewards (nFR) framework, extending [ERC-721](./eip-721.md) tokens (NFTs) features to let token holders benefit from value appreciation after transferring ownership. By integrating cooperative game theory, it aligns stakeholder incentives, addressing inefficiencies in asset transactions. The framework fosters collaboration, transparency, and equitable profit sharing. It improves equity and efficiency, recognizes all ownership stages, and establishes a cooperative asset transaction model.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. The following is an extension of the [ERC-721](./eip-721.md) standard. [ERC-721](./eip-721.md)-compliant contracts MAY implement this EIP for rewards to provide a standard method of rewarding future buyers and previous owners with realized profits in the future. Implementers of this standard MUST have all of the following functions: ```solidity pragma solidity ^0.8.0; import "@openzeppelin/contracts/utils/introspection/IERC165.sol"; /* * * @dev Interface for the Future Rewards Token Standard. * * A standardized way to

MOTIVATION:
Traditional financial markets are often characterized by inefficiencies, opaque practices, and systemic imbalances, resulting in significant disadvantages for the majority of participants. Although blockchain technology offers transaction transparency, current implementations do not adequately facilitate equitable value sharing or participant alignment. This proposal addresses these gaps by introducing structured collaboration and a fair compensation system, ensuring equitable rewards for contributions to asset value. ### Framework Components #### The Flow mechanism Each [ERC-5173](./eip-5173.md) token maintains an immutable record of ownership and price transitions, creating a dedicated network of historical token owners. This unique community collaborates to generate additional value and

RATIONALE:
### Fixed Percentage to 10^18 Considering Fixed-Point Arithmetic is to be enforced, it is logical to have 1e18 represent 100% and 1e16 represent 1% for Fixed-Point operations. This method of handling percents is also commonly seen in many Solidity libraries for Fixed-Point operations. ### Emitting Event for Payment Since each NFT contract is independent, and while a marketplace contract can emit events when an item is sold, choosing to emit an event for payment is important. As the royalty and FR recipient may not be aware of/watching for a secondary sale of their NFT, they would never know


=== ERC-7579 ===
TITLE: Minimal Modular Smart Accounts
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-12-14
REQUIRES: 1, 6, 5, ,,  , 1, 2, 7, 1, ,,  , 2, 7, 7, 1, ,,  , 4, 3, 3, 7

SUMMARY:
This proposal outlines the minimally required interfaces and behavior for modular smart accounts and modules to ensure interoperability across implementations. For accounts, the standard specifies execution, config and fallback interfaces as well as compliance to [ERC-165](./eip-165.md) and [ERC-1271](./eip-1271.md). For modules, the standard specifies a core interface, module types and type-specific interfaces.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions - **Smart account** - A smart contract account that has a modular architecture. - **Module** - A smart contract with self-contained smart account functionality. - Validator: A module used during the validation phase to determine if a transaction is valid and should be executed on the account. - Executor: A module that can execute transactions on behalf of the smart account via

MOTIVATION:
Contract accounts are gaining adoption with many accounts being built using a modular architecture. These modular contract accounts (hereafter smart accounts) move functionality into external contracts (modules) in order to increase the speed and potential of innovation, to future-proof themselves and to allow customizability by developers and users. However, currently these smart accounts are built in vastly different ways, creating module fragmentation and vendor lock-in. There are several reasons for why standardizing smart accounts is very beneficial to the ecosystem, including: - Interoperability for modules to be used across different smart accounts - Interoperability for smart accounts to

RATIONALE:
### Minimal approach Smart accounts are a new concept and we are still learning about the best ways to build them. Therefore, we should not be too opinionated about how they are built. Instead, we should define the most minimal interfaces that allow for interoperability between smart accounts and modules to be used across different account implementations. Our approach has been twofold: 1. Take learnings from existing smart accounts that have been used in production and from building interoperability layers between them 2. Ensure that the interfaces are as minimal and open to alternative architectures as possible ###


=== ERC-5313 ===
TITLE: Light Contract Ownership
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-07-22
REQUIRES: 1, 6, 5, ,,  , 1, 7, 3

SUMMARY:
This specification defines the minimum interface required to identify an account that controls a contract.

SPECIFICATION:
The key word “MUST” in this document is to be interpreted as described in RFC 2119. Every contract compliant with this EIP MUST implement the `EIP5313` interface. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.15; /// @title EIP-5313 Light Contract Ownership Standard interface EIP5313 { /// @notice Get the address of the owner /// @return The address of the owner function owner() view external returns(address); } ```

MOTIVATION:
This is a slimmed-down alternative to [EIP-173](./eip-173.md).

RATIONALE:
Key factors influencing the standard: - Minimize the number of functions in the interface - Backwards compatibility with existing contracts This standard can be (and has been) extended by other standards to add additional ownership functionality. The smaller scope of this specification allows more and more straightforward ownership implementations, see limitations explained in EIP-173 under "other schemes that were considered". Implementing [EIP-165](./eip-165.md) could be a valuable addition to this interface specification. However, this EIP is being written to codify existing protocols that connect contracts (often NFTs), with third-party websites (often a well-known NFT marketplace).


=== ERC-7776 ===
TITLE: Transparent Financial Statements
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-09-20
REQUIRES: 20

SUMMARY:
This proposal defines a standard API that enables EVM Blockchain-based companies (or also called "protocols") to publish their financial information, specifically Income Statements and Balance Sheets, on- chain in a transparent and accessible manner through solidity smart contracts. This standard aims to emulate the reporting structure used by publicly traded companies in traditional stocks markets, like the SEC 10-Q filings. The financial statements include key information, namely as Revenue, Cost of Goods Sold, Operating Expenses, Operating Income, Earnings before Interest, Taxes, Depreciation, and Amortization (EBITDA) and Earnings Per Share-Token (EPS), allowing investors to assess the financial health of

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All Transparent Financial Statements Standard implementations MUST implement ERC-20 to represent shares, and the financial numbers such as Revenue, Costs of Goods Sold, Operating Expenses, Operating Income, EBITDA, Other Income and Expenses, Net Income and Earnings Per Share MUST be displayed in the value of the protocol's stablecoin of choice. All Transparent Financial Statements MUST implement ERC-20's optional metadata extensions. The `name` and `symbol`

MOTIVATION:
The motivation of this ERC is to bring seriousness to the cryptocurrencies investments market. Currently, the situation is as follows: The current state of token investment analysis is opaque, with most information presented in an abstract and non-quantitative form. This standard API ensures a consistent and reliable way for investors to evaluate blockchain projects based on real financial data published directly on-chain, not just speculative promises. This will establish a greater trust in the cryptocurrency markets and align token analysis with the standards of traditional equity markets. Most [ERC-20](./eip-20.md) Tokens representing EVM Blockchain-based companies (or also called "protocols"),

RATIONALE:
ERC-20 is enforced because implementation details like Earnings Per Token calculation directly carry over to the accounting. This standardization makes the Transparent Financial Statements compatible with all ERC-20 use cases. This implementation enables the protocol to share their financial information both as their latest updated Balance Sheet (if the user chooses to just see a current snapshot of the financial state of the company) and as an Income Statement (if the user chooses to see the evolution of the financial state of the company between two different block timestamps) and also is thought to interact with other separated


=== ERC-7580 ===
TITLE: Advertisement Tracking Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-12-13
REQUIRES: 

SUMMARY:
This ERC proposes a standard interface for advertisement clients to track user actions in contracts and check corresponding rewards from advertisement protocols. Contracts implementing the interface use events to define a region of interest within a transaction. A Dapp could implement this interface to join an advertisement protocol, which enable projects to fund users for specific actions in a contract. While users could benefit from project funds, dapps would also get proportional rewards once they joined the protocol.

SPECIFICATION:
The keywords “MUST,” “MUST NOT,” “REQUIRED,” “SHALL,” “SHALL NOT,” “SHOULD,” “SHOULD NOT,” “RECOMMENDED,” “MAY,” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Interfaces This protocol standardizes how to keep track of inter-dapp operations, which initially offers 2 main methods `onTrackStart` and `onTrackEnd`. ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.10; interface IERCXXX { // Events /// @dev Emits when track starts. /// @param track_id track id /// @param contract_address the address of tracking contract /// @param function_hash the hash of tracking function with params event onTrackStartRecorded(uint256 track_id, address contract_address, bytes32 function_hash); ///

MOTIVATION:
Dapps would propsper due to mass adoption and there emerges surging demands for advertisement on chain. Compared with advertisements in web2, web3 has tremendous advantages on delivery and many other fields. We do need a set of standard tracking interfaces to facilitate advertisement related developments, which could create new economic cycles on chain, further boost dapp prosperity and ultimately benefit on chain users. Tracking interface standard should be designed with essential & universal support for tracking user actions, and minimum restriction, which could leave most innovative space for airdrop (or advertisement) protocol. The general routine would work like

RATIONALE:
The core mechanism for this proposal is to provide a shared tracking interface for inter-dapp operations, to improve the efficiency and fulfill the required tracking business. We provide two interface functions `onTrackStart` and `onTrackEnd` to fill the basic required info and connect the necessary dots. Sure there're more demands for more functions and it would be updated later.


=== ERC-7280 ===
TITLE: NFT Metadata Extension like JSON-LD
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-04
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 3, 5, 2, 5

SUMMARY:
This proposal expands the metadata format for Non-Fungible Tokens ([ERC-721](./eip-721.md), [ERC-1155](./eip-1155.md), [ERC-3525](./eip-3525.md), and others), adding support for linked data like JSON-LD format. The additional data is stored under the linked_data key in the metadata JSON.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The JSON-LD based metadata is stored under a new `linked_data` key in the metadata JSON. The `linked_data` key is an array of objects, where each object contains two keys: `schema` and `data`. | name | compliance level | type | description | | ------ | ---------------- | ------ | ------------------------------ | | schema | MUST | object | The schema of the linked data.

MOTIVATION:
The existing metadata format for Non-Fungible Tokens is limited and doesn't support the inclusion of structured and semantically meaningful data. By integrating JSON-LD (Linked Data), we can enhance the richness and interoperability of the metadata associated with NFTs. This allows for complex metadata structures that can link to external schemas and data, improving the contextual relevance and usability of NFTs across various applications.

RATIONALE:
For providing typical webpage for an NFT, it's much simple to include JSON-LD in HTML header tag with this extension. Just looking for JSON-LD compliant value's uri from `linked_data` array, fetch it and embed its content in HTML header tag. This means the minter of NFT can control the appearance in the search result of Google, for example. In more common case for interoperability, the NFT metadata can include any schema and data with this extension. This means the NFT metadata can be used as a data source for any application. With the schema, the implementation is much


=== ERC-4519 ===
TITLE: Non-Fungible Tokens Tied to Physical Assets
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2021-12-03
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This EIP standardizes an interface for non-fungible tokens representing physical assets, such as Internet of Things (IoT) devices. These NFTs are tied to physical assets and can verify the authenticity of the tie. They can include an Ethereum address of the physical asset, permitting physical assets to sign messages and transactions. Physical assets can operate with an operating mode defined by its corresponding NFT.

SPECIFICATION:
The attributes `addressAsset` and `addressUser` are, respectively, the Ethereum addresses of the physical asset and the user. They are optional attributes but at least one of them should be used in an NFT. In the case of using only the attribute `addressUser`, two states define if the token is assigned or not to a user. `Figure 1` shows these states in a flow chart. When a token is created, transferred or unassigned, the token state is set to `notAssigned`. If the token is assigned to a valid user, the state is set to `userAssigned`. ![Figure 1 : Flow

MOTIVATION:
This standard was developed because [EIP-721](./eip-721.md) only tracks ownership (not usage rights) and does not track the Ethereum addresses of the asset. The popularity of smart assets, such as IoT devices, is increasing. To permit secure and traceable management, these NFTs can be used to establish secure communication channels between the physical asset, its owner, and its user.

RATIONALE:
### Authentication This EIP uses smart contracts to verify the mutual authentication process since smart contracts are trustless. ### Tie Time This EIP proposes including the attribute timestamp (to register in Ethereum the last time that the physical asset checked the tie with its token) and the attribute timeout (to register the maximum delay time established for the physical asset to prove again the tie). These attributes avoid that a malicious owner or user could use the asset endlessly. When the asset calls `updateTimestamp`, the smart contract must call `block.timestamp`, which provides current block timestamp as seconds since


=== ERC-7644 ===
TITLE: ERC-721 Name Registry Extension
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-03-01
REQUIRES: 721

SUMMARY:
This extension defines an interface that adds a naming mechanism to [ERC-721](./eip-721.md) tokens. It allows each token to have a unique name with a set expiration date, ensuring uniqueness within the current NFT contract. The interface includes functions for assigning, updating, and querying names and their associated tokens, ensuring that names remain unique until they expire. The entity responsible for setting names depends on the specific use case scenario when utilizing this extension.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Implementers of this extension **MUST** have all of the following functions: ```solidity pragma solidity ^0.8.0; /** * @title INameRegistry * @dev Interface for the NameRegistry smart contract. * This interface allows interaction with a NameRegistry, * enabling the registration, management, and lookup of names * with associated expiry dates tied to specific tokens. */ interface IERC7644 /* is IERC721 */ { /** * @dev

MOTIVATION:
As decentralized domain registration methods evolve with the integration of NFTs, we see an opportunity to extend this paradigm to the realm of usernames. By associating token IDs with usernames, we enhance the intuitive identification of entities within decentralized ecosystems. This integration serves multiple purposes: - **Intuitiveness:** Numeric token IDs lack intuitive identification. By incorporating usernames, token IDs become more representative, improving usability. - **Username Economy Exploration:** The registration mechanism opens avenues for exploring the username economy, offering benefits such as identity verification and social interactions. - **Synergy with NFTs:** The fusion of usernames with NFTs unlocks synergistic

RATIONALE:
#### Name Expiry By implementing expiration periods for usernames, we introduce several advantages. This mechanism ensures a dynamic environment where unused or outdated usernames can be released, fostering a healthy ecosystem. It encourages turnover of usernames, preventing long-term hoarding and promoting active participation. Users are motivated to manage their username portfolio, renewing valuable names while relinquishing irrelevant ones. Ultimately, this fosters fairness and efficiency, ensuring naming resources are utilized effectively and refreshed to meet evolving needs. #### Name Uniqueness Enforcing unique usernames is crucial for maintaining a clear and intuitive identification system. It prevents confusion and enables seamless


=== ERC-6454 ===
TITLE: Minimal Transferable NFT detection interface
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-01-31
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
The Minimalistic Transferable interface for Non-Fungible Tokens standard extends [ERC-721](./eip-721.md) by introducing the ability to identify whether an NFT can be transferred or not. This proposal introduces the ability to prevent a token from being transferred from their owner, making them bound to the externally owned account, abstracted account, smart contract or token that owns it.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title EIP-6454 Minimalistic Non-Transferable interface for NFTs /// @dev See https://eips.ethereum.org/EIPS/eip-6454 /// @dev Note: the ERC-165 identifier for this interface is 0x91a6262f. pragma solidity ^0.8.16; interface IERC6454 /* is IERC165 */ { /** * @notice Used to check whether the given token is transferable or not. * @dev If this function returns `false`, the transfer of the token MUST revert execution. * @dev If the tokenId does

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability to prevent the tokens from being transferred introduces new possibilities of NFT utility and evolution. This proposal is designed in a way to be as minimal as possible in order to be compatible with any usecases that wish to utilize this proposal. This EIP introduces new utilities for [ERC-721](./eip-721.md) based tokens in the following areas: - [Verifiable attribution](#verifiable-attribution) - [Immutable properties](#immutable-properties) ### Verifiable attribution Personal

RATIONALE:
Designing the proposal, we considered the following questions: 1. **Should we propose another (Non-)Transferable NFT proposal given the existence of existing ones, some even final, and how does this proposal compare to them?**\ This proposal aims to provide the minimum necessary specification for the implementation of non-transferable NFTs, we feel none of the existing proposals have presented the minimal required interface. Unlike other proposals that address the same issue, this proposal requires fewer methods in its specification, providing a more streamlined solution. 2. **Why is there no event marking the token as Non-Transferable in this interface?**\ The token


=== ERC-5007 ===
TITLE: Time NFT, ERC-721 Time Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-04-13
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard is an extension of [ERC-721](./eip-721.md). It proposes some additional functions (`startTime`, `endTime`) to help with on-chain time management.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ```solidity /** * @dev the ERC-165 identifier for this interface is 0xf140be0d. */ interface IERC5007 /* is IERC721 */ { /** * @dev Returns the start time of the NFT as a UNIX timestamp. * * Requirements: * * - `tokenId` must exist. */ function startTime(uint256 tokenId) external view returns (uint64); /** * @dev Returns the end time of the NFT as a UNIX timestamp. * * Requirements: * *

MOTIVATION:
Some NFTs have a defined usage period and cannot be used outside of that period. With traditional NFTs that do not include time information, if you want to mark a token as invalid or enable it at a specific time, you need to actively submit a transaction—a process both cumbersome and expensive. Some existing NFTs contain time functions, but their interfaces are not consistent, so it is difficult to develop third-party platforms for them. By introducing these functions (`startTime`, `endTime`), it is possible to enable and disable NFTs automatically on chain.

RATIONALE:
### Time Data Type The max value of `uint64` is 18,446,744,073,709,551,615. As a timestamp, 18,446,744,073,709,551,615 is about year 584,942,419,325. `uint256` is too big for C, C++, Java, Go, etc, and `uint64` is natively supported by mainstream programming languages.


=== ERC-7829 ===
TITLE: Data Asset NFT
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-11-29
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal is an extension of [ERC-721](./eip-721.md). This proposal introduces a new role, Reader, who is granted by the Owner and allows multiple Readers for a single NFT. Additionally, this proposal extends the metadata interface of ERC-721, requiring that metadata should include at least a commitment, size, expire, and uploader's address. This proposal also proposes a storage proof mechanism to ensure the correctness of metadata information.

SPECIFICATION:
### Terms In this proposal, we divide data assets into three parts: - Storage Metadata: Includes commitment, size, expire, and uploader's address. Stored and maintained by storage contracts on the blockchain. - Permission Metadata: Includes information on ownership and reading rights, as well as which addresses can modify this information. Stored and maintained by permission contracts on the blockchain. - Data Content: Data uploaded by users to the storage system. Data content is stored in off-chain storage nodes. **Every compliant data permission contract must implement the Interface**: The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD

MOTIVATION:
ERC-721 proposed the NFTs to represent the ownership of digital or physical assets. Currently, the NFT metadata is considered the NFT content, and its scarcity determines the value of the NFT. NFT owners can convert the content value of NFTs into revenue by transferring the ownership of NFTs. However, due to the high transaction fees, storage costs, and other expenses, NFTs are currently only able to represent the ownership of high-value assets, which limits the range of assets that NFTs can represent. This is especially true for Data Assets, which refers to digital products created by creators, such

RATIONALE:
![arc](../assets/eip-7829/architect.svg) The biggest challenge for data asset NFTs is the visibility but inaccessibility of data content: after establishing access control permissions for NFT data content, i.e., accessing data content requires certain access permissions, how can users without data access permissions ensure that the data content exists when obtaining access permissions? To prevent users from making incorrect operations unknowingly, it is necessary to upload information about the data content to the chain, specifically, the expire of the data content should be uploaded to the chain. Users can access the expire of the data content to judge whether their NFT


=== ERC-7432 ===
TITLE: Non-Fungible Token Roles
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-07-14
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This standard introduces role management for NFTs. Each role assignment is associated with a single NFT and expires automatically at a given timestamp. Roles are defined as `bytes32` and feature a custom `data` field of arbitrary size to allow customization.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC-2119 and RFC-8174. Compliant contracts MUST implement the following interface: ```solidity /// @title ERC-7432 Non-Fungible Token Roles /// @dev See https://eips.ethereum.org/EIPS/eip-7432 /// Note: the ERC-165 identifier for this interface is 0xd00ca5cf. interface IERC7432 /* is ERC165 */ { struct Role { bytes32 roleId; address tokenAddress; uint256 tokenId; address recipient; uint64 expirationDate; bool revocable; bytes data; } /** Events **/ /// @notice Emitted when an NFT is locked (deposited or frozen).

MOTIVATION:
The NFT Roles interface aims to establish a standard for role management in NFTs. Tracking on-chain roles enables decentralized applications (dApps) to implement access control for privileged actions, e.g., minting tokens with a role (airdrop claim rights). NFT roles can be deeply integrated with dApps to create a utility-sharing mechanism. A good example is in digital real estate. A user can create a digital property NFT and grant a `keccak256("PropertyManager()")` role to another user, allowing them to delegate specific utility without compromising ownership. The same user could also grant a `keccak256("PropertyTenant(uint256)")` role to other users, allowing the recipient

RATIONALE:
[ERC-7432](./eip-7432.md) IS NOT an extension of [ERC-721](./eip-721.md). The main reason behind this decision is to enable it to be implemented externally or on the same contract as the NFT, allowing dApps to implement roles with immutable assets. This standard covers many crucial features, such as automatic expiration and custom data, but perhaps the most important one is its flexibility in implementation. ERC-7432 can be implemented in many ways, and for this reason, the neutral term "lock" is employed. This term can refer to an NFT being frozen (preventing transfers until roles expire) or deposited in an escrow contract.


=== ERC-6464 ===
TITLE: Multi-operator, per-token ERC-721 approvals.
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2023-02-02
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
[ERC-721](./eip-721.md) did not foresee the approval of multiple operators to manage a specific token on behalf of its owner. This lead to the establishment of `setApprovalForAll()` as the predominant way to authorise operators, which affords the approved address control over all assets and creates an unnecessarily broad security risk that has already been exploited in a multitude of phishing attacks. The presented EIP extends ERC-721 by introducing a fine-grained, on-chain approval mechanism that allows owners to authorise multiple, specific operators on a per-token basis; this removes unnecessary access permissions and shrinks the surface for exploits to a minimum.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. To comply with this EIP, a contract MUST implement `IERC6464` (defined herein) and the `ERC165` and `ERC721` interfaces; see [ERC-165](./eip-165.md) and ERC-721 respectively. ```solidity /** * @notice Extends ERC-721 to include per-token approval for multiple operators. * @dev Off-chain indexers of approvals SHOULD assume that an operator is approved if either of `ERC721.Approval(…)` or * `ERC721.ApprovalForAll(…, true)` events are witnessed without the corresponding revocation(s),

MOTIVATION:
The NFT standard defined in ERC-721 allows token owners to "approve" arbitrary addresses to control their tokens—the approved addresses are known as "operators". Two types of approval were defined: 1. `approve(address,uint256)` provides a mechanism for only a single operator to be approved for a given `tokenId`; and 2. `setApprovalForAll(address,bool)` toggles whether an operator is approved for *every* token owned by `msg.sender`. With the introduction of multiple NFT marketplaces, the ability to approve multiple operators for a particular token is necessary if sellers wish to allow each marketplace to transfer a token upon sale. There is, however, no mechanism

RATIONALE:
### Draft notes to be expanded upon 1. Approvals granted via the newly introduced methods are called *explicit* as a means of easily distinguishing them from those granted via the standard `ERC721.approve()` and `ERC721.setApprovalForAll()` functions. However they follow the same intent: authorising operators to act on the owner's behalf. 2. Abstracting `isApprovedFor()` into `IERC6464AnyApproval` interface, as against keeping it in `IERC6464` allows for modularity of plain `IERC6464` implementations while also standardising the interface for checking approvals when interfacing with specific implementations and any future approval EIPs. 3. Inclusion of an indexed owner address in `AllExplicitApprovalsRevoked(address,uint256)` assists off-chain indexing


=== ERC-7511 ===
TITLE: Minimal Proxy Contract with PUSH0
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-04
REQUIRES: 7, ,,  , 2, 1, 1, ,,  , 1, 1, 6, 7, ,,  , 3, 8, 5, 5

SUMMARY:
With the `PUSH0` opcode ([EIP-3855](./eip-3855.md)), introduced with the Shanghai upgrade, we optimized the previous Minimal Proxy Contract ([ERC-1167](./eip-1167.md)) by 200 gas at deployment and 5 gas at runtime, while retaining the same functionality.

SPECIFICATION:
### Standard Proxy Contract The exact runtime code for the minimal proxy contract with `PUSH0` is: ``` 365f5f375f5f365f73bebebebebebebebebebebebebebebebebebebebe5af43d5f5f3e5f3d91602a57fd5bf3 ``` where the bytes at indices 9 - 28 (inclusive) are replaced with the 20-byte address of the master implementation contract. The length of the runtime code is `44` bytes. The disassembly of the new minimal proxy contract code is: | pc | op | opcode | stack | |------|--------|----------------|--------------------| | [00] | 36 | CALLDATASIZE | cds | | [01] | 5f | PUSH0 | 0 cds | | [02] | 5f | PUSH0 | 0 0 cds |

MOTIVATION:
1. Reduce the contract bytecode size by `1` byte by removing a redundant `SWAP` opcode. 2. Reduce the runtime gas by replacing two `DUP` (cost `3` gas each) with two `PUSH0` (cost `2` gas each). 3. Increase the readability of the proxy contract by redesigning it from first principles with `PUSH0`.

RATIONALE:
The optimized contract is constructed with essential components of the proxy contract and incorporates the recently added `PUSH0` opcode. The core elements of the minimal proxy include: 1. Copy the calldata with `CALLDATACOPY`. 2. Forward the calldata to the implementation contract using `DELEGATECALL`. 3. Copy the returned data from the `DELEGATECALL`. 4. Return the results or revert the transaction based on whether the `DELEGATECALL` is successful. ### Step 1: Copy the Calldata To copy the calldata, we need to provide the arguments for the `CALLDATACOPY` opcodes, which are `[0, 0, cds]`, where `cds` represents calldata size. | pc


=== ERC-7093 ===
TITLE: Social Recovery Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-05-29
REQUIRES: 1271

SUMMARY:
This ERC proposes a standard interface for social recovery of smart contract accounts. It separates identity and policy verification from the recovery process, allowing more ways to authenticate (known as Guardians) than just on-chain accounts. It also lets users customize recovery policies without changing the account’s smart contract.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This EIP consists of four key concepts: - **Identity**: This denotes the representation of a Guardian's identity on the blockchain. It encapsulates traditional on-chain account types such as Externally Owned Accounts (EOA) and Smart Contract Accounts (SCA). More importantly, it extends to include any identity construct capable of producing construct able to be verified on-chain, like signatures and proofs. This could range from [Webauthn](https://www.w3.org/TR/2021/REC-webauthn-2-20210408/)/Passkey

MOTIVATION:
Vitalik Buterin has long advocated for social recovery as an essential tool for user protection within the crypto space. He posits that the value of this system rests in its ability to offer users, especially those less acquainted with the technicalities of cryptography, a robust safety net when access credentials are lost. By entrusting account recovery to a network of selected individuals or entities, dubbed "Guardians," users gain a safeguard against the risk of losing access to their digital assets. In essence, social recovery operates by verifying the identity of the user and the chosen Guardians, and then

RATIONALE:
A primary design rationale for this proposal is to extend a greater diversity of Guardian types and more flexible, customizable recovery policies for a RecoveryAccount. This is achieved by separating the verification logic from the social recovery process, ensuring that the basic logic of the account contract remains unaltered. The necessity of incorporating `Verifiers` from external contracts arises from the importance of maintaining the inherent recovery logic of the `RecoveryAccount`. The `Verifiers`'s logic is designed to be simple and clear, and its fixed invocation format means that any security risks posed by integrating external contracts can be effectively


=== ERC-223 ===
TITLE: Token with transaction handling model
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2017-05-03
REQUIRES: 

SUMMARY:
The following describes an interface and logic for fungible tokens that supports a `tokenReceived` callback to notify contract recipients when tokens are received. This makes tokens behave identical to ether.

SPECIFICATION:
Contracts intending to receive these tokens MUST implement `tokenReceived`. Token transfers to contracts not implementing `tokenReceived` as described below MUST revert. ### Token contract #### Token Methods ##### `totalSupply` ```solidity function totalSupply() view returns (uint256) ``` Returns the total supply of the token. The functionality of this method is identical to that of ERC-20. ##### `name` ```solidity function name() view returns (string memory) ``` Returns the name of the token. The functionality of this method is identical to that of ERC-20. OPTIONAL - This method can be used to improve usability, but interfaces and other contracts MUST NOT

MOTIVATION:
This token introduces a communication model for contracts that can be utilized to straighten the behavior of contracts that interact with such tokens. Specifically, this proposal: 1. Informs receiving contracts of incoming token transfers, as opposed to [ERC-20](./eip-20.md) where the recipient of a token transfer gets no notification. 2. Is more gas-efficient when depositing tokens to contracts. 3. Allows for `_data` recording for financial transfers.

RATIONALE:
This standard introduces a communication model by enforcing the `transfer` to execute a handler function in the destination address. This is an important security consideration as it is required that the receiver explicitly implements the token handling function. In cases where the receiver does not implements such function the transfer MUST be reverted. This standard sticks to the push transaction model where the transfer of assets is initiated on the senders side and handled on the receivers side. As the result, ERC-223 transfers are more gas-efficient while dealing with depositing to contracts as ERC-223 tokens can be deposited


=== ERC-5700 ===
TITLE: Bindable Token Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-09-22
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This standard defines an interface for [ERC-721](./eip-721.md) or [ERC-1155](./eip-155.md) tokens, known as "bindables", to "bind" to [ERC-721](./eip-721.md) NFTs. When bindable tokens "bind" to an NFT, even though their ownership is transferred to the NFT, the NFT owner may "unbind" the tokens and claim their ownership. This enables bindable tokens to transfer with their bound NFTs without extra cost, offering a more effective way to create and transfer N:1 token-to-NFT bundles. Until an NFT owner decides to unbind them, bound tokens stay locked and resume their base token functionalities after unbinding. This standard supports various use-cases such as: -

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### ERC-721 Bindable **Smart contracts implementing the ERC-721 bindable standard MUST implement the `IERC721Bindable` interface.** **Implementers of the `IER721Bindable` interface MUST return `true` if `0x82a34a7d` is passed as the identifier to the `supportsInterface` function.** ```solidity /// @title ERC-721 Bindable Token Standard /// @dev See https://eips.ethereum.org/ERCS/eip-5700 /// Note: the ERC-165 identifier for this interface is 0x82a34a7d. interface IERC721Bindable /* is IERC721 */ { /// @notice This event emits when an

MOTIVATION:
A standard interface for NFT binding offers a seamless and efficient way to bundle and transfer tokens with NFTs, ensuring compatibility with wallets, marketplaces, and other NFT applications. It eliminates the need for rigid, implementation-specific strategies for token ownership. In contrast with other standards that deal with token ownership at the account level, this standard aims to address token ownership at the NFT level. Its objective is to build a universal interface for token bundling, compatible with existing [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) standards.

RATIONALE:
A standard for token binding unlocks a new layer of composability for allowing wallets, applications, and protocols to interact with, trade, and display bundled NFTs. One example use-case of this is at Dopamine, where streetwear garments may be bundled with digital assets such as music, avatars, or digital-twins of the garments, by representing these assets as bindable tokens and binding them to microchips represented as NFTs. ### Binding Mechanism During binding, a bindable token's technical ownership is conferred to its bound NFT, while allowing the NFT owner to unbind at any time. A caveat of this lightweight design


=== ERC-7303 ===
TITLE: Token-Controlled Token Circulation
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-09
REQUIRES: 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 5, 6, 7, 9

SUMMARY:
This ERC introduces an access control scheme termed Token-Controlled Token Circulation (TCTC). By representing the privileges associated with a role as an [ERC-721](./eip-721.md) or [ERC-1155](./eip-1155.md) token (referred to as a `control token`), the processes of granting or revoking a role can be facilitated through the minting or burning of the corresponding `control token`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. 1. Smart contracts implementing the [ERC-7303](./eip-7303.md) standard MUST represent the privilege required by the role as an ERC-721 token or ERC-1155 token. The tokens that represent privileges are called `control tokens` in this ERC. The `control token` can be any type of token, and its transactions may be recursively controlled by another `control token`. 2. To associate the required `control token` with the role,

MOTIVATION:
There are numerous methods to implement access control for privileged actions. A commonly utilized pattern is "role-based" access control as specified in [ERC-5982](./eip-5982.md). This method, however, necessitates the use of an off-chain management tool to grant or revoke required roles through its interface. Additionally, as many wallets lack a user interface that displays the privileges granted by a role, users are often unable to comprehend the status of their privileges through the wallet. ### Use Cases This ERC is applicable in many scenarios where role-based access control as described in [ERC-5982](./eip-5982.md) is used. Specific use cases include: **Mint/Burn

RATIONALE:
The choice to utilize ERC-721 or ERC-1155 token as the control token for privileges enhances visibility of such privileges within wallets, thus simplifying privilege management for users. Generally, when realizing privileges as tokens, specifications like Soulbound Token (e.g., [ERC-5192](./eip-5192.md)) are used. Given that ERC-5192 inherits from ERC-721, this ERC has choiced ERC-721 as the requirement for the control token. Employing a transferable control token can cater to scenarios where role delegation is necessary. For example, when an authority within an organization is replaced or on vacation, the ability to transfer their privileges to another member becomes possible. The


=== ERC-3450 ===
TITLE: Standardized Shamir Secret Sharing Scheme for BIP-39 Mnemonics
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-03-29
REQUIRES: 

SUMMARY:
A standardized approach to splitting a BIP-39 mnemonic into _N_ BIP-39 mnemonics, called shares, so that _T_ shares are required to recover the original mnemonic and no information about the original mnemonic, other than its size, is leaked with less than _T_ shares.

SPECIFICATION:
### Shamir's Secret Sharing Scheme Shamir's Secret Sharing Scheme is a cryptographic method to split a secret into _N_ unique parts, where any _T_ of them are required to reconstruct the secret. First, a polynomial _f_ of degree _T_ − 1 is constructed. Then, each share is a point on the polynomial's curve: an integer _x_, and its corresponding _y_ point _f_(_x_). With any set of _T_ shares (or points), the initial polynomial can be recovered using polynomial interpolation. When constructing the initial polynomial, the secret is stored as the coefficient of x<sup>0</sup> and the rest of the

MOTIVATION:
We'd like to make it easier for less-technical users to store keys securely. Currently, many users use BIP-39 mnemonics to store entropy values underlying their keys. These mnemonics are a single point of failure. If lost, the user may never regain access to the assets locked by the keys. If stolen, a malicious actor can steal the assets. Shamir's Secret Sharing Scheme addresses this concern directly. It creates "shares" of the secret, such that a subset can be used to recover the secret, but only if a minimum threshold of shares is reached. Without the minimum, no information

RATIONALE:
### Choice of Field The field GF(256) was chosen, because the field arithmetic is easy to implement in any programming language and many implementations are already available since it is used in the AES cipher. Although using GF(256) requires that we convert the mnemonic to its underlying entropy as a byte-vector, this is also easy to implement and many implementations of it exist in a variety of programming languages. GF(2048) was also considered. Using GF(2048), we could have applied Shamir's Scheme directly to the mnemonic, using the word indexes as the values. This would have allowed us to


=== ERC-1078 ===
TITLE: Universal login / signup using ENS subdomains
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-05-04
REQUIRES: 1, 9, 1, ,,  , 6, 8, 1, ,,  , 7, 2, 5, ,,  , 1, 0, 7, 7

SUMMARY:
This presents a method to replace the usual signup/login design pattern with a minimal ethereum native scheme, that doesn’t require passwords, backing up private keys nor typing seed phrases. From the user's point of view it will be very similar to patterns they’re already used to with second factor authentication (without relying in a central server), but for dapp developers it requires a new way to think about ethereum transactions.


=== ERC-1948 ===
TITLE: Non-fungible Data Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-04-18
REQUIRES: 721

SUMMARY:
Non-fungible tokens (NFTs) are extended with the ability to store dynamic data. A 32 bytes data field is added and a read function allows to access it. The write function allows to update it, if the caller is the owner of the token. An event is emitted every time the data updates and the previous and new value is emitted in it.

SPECIFICATION:
An extension of [ERC-721](./eip-721.md) interface with the following functions and events is suggested: ``` solidity pragma solidity ^0.5.2; /** * @dev Interface of the ERC1948 contract. */ interface IERC1948 { /** * @dev Emitted when `oldData` is replaced with `newData` in storage of `tokenId`. * * Note that `oldData` or `newData` may be empty bytes. */ event DataUpdated(uint256 indexed tokenId, bytes32 oldData, bytes32 newData); /** * @dev Reads the data of a specified token. Returns the current data in * storage of `tokenId`. * * @param tokenId The token to read the data off. * * @return A

MOTIVATION:
The proposal is made to standardize on tokens with dynamic data. Interactions with bridges for side-chains like xDAI or Plasma chains will profit from the ability to use such tokens. Protocols that build on data tokens like [distributed breeding](https://ethresear.ch/t/a-distributed-breeding-function/5264) will be enabled.

RATIONALE:
The suggested data field in the NFT is used either for storing data directly, like a counter or address. If more data is required the implementer should fall back to authenticated data structures, like merkle- or patricia-trees. The proposal for this ERC stems from the [distributed breeding proposal](https://ethresear.ch/t/a-distributed-breeding-function/5264) to allow better integration of NFTs across side-chains. [ost.com](https://ost.com/), [Skale](https://skalelabs.com/), [POA](https://poa.network/), and [LeapDAO](https://leapdao.org/) have been part of the discussion.


=== ERC-927 ===
TITLE: Generalised authorisations
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-03-12
REQUIRES: 926

SUMMARY:
This EIP specifies a generic authorisation mechanism, which can be used to implement a variety of authorisation patterns, replacing approvals in ERC20, operators in ERC777, and bespoke authorisation patterns in a variety of other types of contract.

SPECIFICATION:
The generalised authorisation interface is implemented as a metadata provider, as specified in EIP 926. The following mandatory function is implemented: ```solidity function canCall(address owner, address caller, address callee, bytes4 func) view returns(bool); ``` Where: - `owner` is the owner of the resource. If approved the function call is treated as being made by this address. - `caller` is the address making the present call. - `callee` is the address of the contract being called. - `func` is the 4-byte signature of the function being called. For example, suppose Alice authorises Bob to transfer tokens on her behalf.

MOTIVATION:
Smart contracts commonly need to provide an interface that allows a third-party caller to perform actions on behalf of a user. The most common example of this is token authorisations/operators, but other similar situations exist throughout the ecosystem, including for instance authorising operations on ENS domains. Typically each standard reinvents this system for themselves, leading to a large number of incompatible implementations of the same basic pattern. Here, we propose a generic method usable by all such contracts. The pattern implemented here is inspired by [ds-auth](https://github.com/dapphub/ds-auth) and by OAuth.


=== ERC-5635 ===
TITLE: NFT Licensing Agreements
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-08-10
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 2, 9, 8, 1

SUMMARY:
This EIP standardizes an NFT licensing oracle to store (register) and retrieve (discover) granted licensing agreements for non-fungible token (NFT) derivative works, which are also NFTs but are created using properties of some other underlying NFTs. In this standard, an NFT derivative work is referred to as a **dNFT**, while the original underlying NFT is referred to as an **oNFT**. The NFT owner, known as the `licensor`, may authorize another creator, known as the `licensee`, to create a derivative works (dNFTs), in exchange for an agreed payment, known as a `Royalty`. A licensing agreement outlines terms and conditions

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. In general, there are three important roles in this standard: - oNFT: An original underlying NFT. The holder of an oNFT is a licensor. An oNFT can be any NFT. - dNFT: A derivative work based on one or more oNFTs. The holder of a dNFT is a licensee. - Registry: A trusted smart contract able to verify whether a credential is signed or released by the holder of

RATIONALE:
Licensing credentials from a dNFT's contract can be retrieved with `authorizedBy`, which specifies the details of a licensing agreement, which may include the oNFT. Those credentials may be verified with a `registry` service. Anyone can retrieve licensing royalty information with `licensingRoyalty` via the registry. While it is not possible to enforce the rules set out in this EIP on-chain, just like [EIP-2981](./eip-2981.md), we encourages NFT marketplaces to follow this EIP. ### Two stages: Licensing and Discovery Taking the moment when the dNFT is minted as the cut-off point, the stage before is called the **Licensing** stage, and the


=== ERC-7535 ===
TITLE: Native Asset ERC-4626 Tokenized Vault
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-10-12
REQUIRES: 2, 0, ,,  , 4, 6, 2, 6, ,,  , 7, 5, 2, 8

SUMMARY:
This standard is an extension of the [ERC-4626](./eip-4626.md) spec with an identical interface and behavioral overrides for handling Ether or any native asset as the underlying.

SPECIFICATION:
All [ERC-7535](./eip-7535.md) tokenized Vaults MUST implement ERC-4626 (and by extension ERC-20) with behavioral overrides for the methods `asset`, `deposit`, and `mint` specified below. ### ERC-4626 Breaking Changes * Any `assets` quantity refers to wei of Ether rather than ERC-20 balances. * Any ERC-20 `transfer` calls are replaced by Ether transfer (`send` or `call`) * Any ERC-20 `transferFrom` approval flows for `asset` are not implemented * `deposit` and `mint` have state mutability `payable` * `deposit` uses `msg.value` as the primary input and MAY ignore `assets` ### Methods #### asset MUST return `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [ERC-7528](./eip-7528.md). ```yaml - name: asset type:

MOTIVATION:
A standard for tokenized ETH Vaults has the same benefits as [ERC-4626](./eip-4626.md), particularly in the case of Liquid Staking Tokens, (i.e. fungible [ERC-20](./eip-20.md) wrappers around ETH staking). Maintaining the same exact interface as ERC-4626 further amplifies the benefits as the standard will be maximally compatible with existing ERC-4626 tooling and protocols.

RATIONALE:
This standard was designed to maximize compatibility with ERC-4626 while minimizing additional opinionated details on the interface. Examples of this decision rationale are described below: * maintaining the redundant `assets` input to the `deposit` function while making its usage optional * not enforcing a relationship between `msg.value` and `assets` in a `mint` call * not enforcing any behaviors or lack thereof for `fallback`/`__default__` methods, payability on additional vault functions, or handling ETH forcibly sent to the contract All breaking implementation level changes with ERC-4626 are purely to accomodate for the usage of Ether or any native asset instead


=== ERC-884 ===
TITLE: DGCL Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-02-14
REQUIRES: 

SUMMARY:
The recently amended 'Title 8 of the Delaware Code Relating to the General Corporation Law' now explicitly allows for the use of blockchains to maintain corporate share registries. This means it is now possible to create a tradable `ERC-20` token where each token represents a share issued by a Delaware corporation. Such a token must conform to the following principles over and above the `ERC-20` standard. 1. Token owners must have their identity verified. 2. The token contract must provide the following three functions of a `Corporations Stock ledger` (Ref: Section 224 of The Act): 1. Reporting: It

SPECIFICATION:
The `ERC-20` token provides the following basic features: contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } This will be extended as follows: /** * An `ERC20` compatible token that conforms to Delaware State Senate, * 149th

MOTIVATION:
1. Delaware General Corporation Law requires that shares issued by a Delaware corporation be recorded in a share registry. 2. The share registry can be represented by an `ERC-20` token contract that is compliant with Delaware General Corporation Law. 3. This standard can cover equity issued by any Delaware corporation, whether private or public. By using a `DGCL` compatible token, a firm may be able to raise funds via IPO, conforming to Delaware Corporations Law, but bypassing the need for involvement of a traditional Stock Exchange. There are currently no token standards that conform to the `DGCL` rules.

RATIONALE:
The proposed standard offers as minimal an extension as possible over the existing `ERC-20` standard in order to conform to the requirements of The Act. Rather than return a `bool` for successful or unsuccessful completion of state-changing functions such as `addVerified`, `removeVerified`, and `updateVerified`, we have opted to require that implementations `throw` (preferably by using the [forthcoming `require(condition, 'fail message')` syntax](https://github.com/ethereum/solidity/issues/1686#issuecomment-328181514)).


=== ERC-7617 ===
TITLE: Chunk support for ERC-5219 mode in Web3 URL
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-02-08
REQUIRES: 5, 2, 1, 9, ,,  , 6, 9, 4, 4

SUMMARY:
In the context of the [ERC-6860](./eip-6860.md) `web3://` standard, this ERC extends the [ERC-6944](./eip-6944.md) resolve mode: This standard defines a new optional ``web3-next-chunk`` HTTP header returned by the `request()` call, that contains a `web3://` URL pointing to the next data chunk of the resource data. Chunks are streamed to the `web3://` client, and it loops until the ``web3-next-chunk`` header is no longer present.

SPECIFICATION:
In the [ERC-6944](./eip-6944.md) resolve mode, this standard introduces the new optional ``web3-next-chunk`` HTTP header, to be returned in the `headers` `KeyValue` array of the `request()` method defined in [ERC-6944](./eip-6944.md). The value of the header is either a complete `web3://` URL, or a relative one. The target smart contract must use the [ERC-6944](./eip-6944.md) resolve mode. When processing the result of the initial `request()` call, the protocol return the HTTP status code, HTTP headers and body right away to the `web3://` client. If a ``web3-next-chunk`` header is present, it parse the URL. If the URL is invalid, or the target

MOTIVATION:
Ethereum RPC endpoints have a gas limit, which can be reached when serving large content. By adding a chunking feature, we add the possibility to serve arbitrary sized content.

RATIONALE:
The use of a header pointing to the next chunk was chosen because it does not require changes to the [ERC-6944](./eip-6944.md) `request()` interface, and the use of a `web3://` URL in the header add flexibility to the means to provide the next chunk.


=== ERC-6672 ===
TITLE: Multi-redeemable NFTs
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-02-21
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This EIP proposes an extension to the [ERC-721](./eip-721.md) standard for Non-Fungible Tokens (NFTs) to enable multi-redeemable NFTs. Redemption provides a means for NFT holders to demonstrate ownership and eligibility of their NFT, which in turn enables them to receive a physical or digital item. This extension would allow an NFT to be redeemed in multiple scenarios and maintain a record of its redemption status on the blockchain.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Redeem and Cancel Functions An operator SHALL only make an update to the redemption created by itself. Therefore, the `redeem()` and `cancel()` functions do not have an `_operator` parameter, and the `msg.sender` address MUST be used as the `_operator`. ### Redemption Flag Key-Value Pairs The combination of `_operator`, `_tokenId`, and `_redemptionId` MUST be used as the key in the redemption flag key-value pairs,

MOTIVATION:
The motivation behind our proposed NFT standard is to provide a more versatile and flexible solution compared to existing standards, allowing for multi-redeemable NFTs. Our proposed NFT standard enables multi-redeemable NFTs, allowing them to be redeemed in multiple scenarios for different campaigns or events, thus unlocking new possibilities for commerce use cases and breaking the limitation of one-time redemption per NFT. One use case for an NFT that can be redeemed multiple times in various scenarios is a digital concert ticket. The NFT could be redeemed for access to the online concert and then again for exclusive merchandise,

RATIONALE:
### Key Choices for Redemption Flag and Status The combination of `_operator`, `_tokenId`, and `_redemptionId` is chosen as the key because it provides a clear and unique identifier for each redemption transaction. - Operator wallet address, i.e. `_operator` It's possible that there are more than one party who would like to use the same NFT for redemption. For example, MisterPunks NFTs are eligible to be redeemed for both Event-X and Event-Y tickets, and each event's ticket redemption is handled by a different operator. - Token identifier, i.e. `_tokenId` Each NFT holder will have different redemption records created by


=== ERC-7399 ===
TITLE: ⚡ Flash Loans ⚡
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-07-25
REQUIRES: 20

SUMMARY:
A flash loan is a loan between lender and borrower smart contracts that must be repaid, plus an optional fee, before the end of the transaction. This ERC specifies interfaces for lenders to accept flash loan requests, and for borrowers to take temporary control of the transaction within the lender execution. The process for the safe execution of flash loans is also specified.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Under this standard a flash loan is a loan of an `amount` of an [ERC-20](./eip-20.md) `asset` from a `lender`. This loan can remain open for the span of a single `flash` call in the `lender`. This `amount` plus a `fee` defined by the `lender` in the same `asset` must be repaid before the end of `flash` call at a `repayment receiver` address defined by

MOTIVATION:
The current state of the flash loan ecosystem is fragmented and lacks standardization, leading to several challenges for both lenders and borrowers. The absence of a common interface results in increased integration efforts, as each flash loan provider implements its own unique approach. This lack of standardization is expected to become more problematic as the ecosystem grows, requiring more resources to maintain compatibility. A comprehensive analysis of the existing flash loan protocols reveals significant differences in their implementations, including: - Inconsistent syntax for initiating flash loans across different platforms. - Variations in the relationship between the loan receiver

RATIONALE:
The interfaces described in this ERC have been chosen as to cover the known flash lending use cases, while allowing for safe and gas efficient implementations. `maxFlashLoan` and `flashFee` return numerical values on impossible loans to allow sorting lenders without having to deal with reverts. `maxFlashLoan` returns a value that is consistent with an impossible loan when the `lender` is not able to serve the loan. `flashFee` returns a value that is consistent with an impossible loan when the `lender` is not able to serve the loan. `flash` has been chosen as a function name as a verb


=== ERC-6358 ===
TITLE: Cross-Chain Token States Synchronization
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-01-17
REQUIRES: 

SUMMARY:
This ERC standardizes an interface for contract-layer consensus-agnostic verifiable cross-chain bridging, through which we can define a new global token inherited from [ERC-20](./eip-20.md)/[ERC-721](./eip-721.md) over multi-chains. ### Figure.1 Architecture ![img](../assets/eip-6358/img/o-dlt.png) With this ERC, we can create a global token protocol, that leverages smart contracts or similar mechanisms on existing blockchains to record the token states synchronously. The synchronization could be made by trustless off-chain synchronizers.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Omniverse Account There SHOULD be a global user identifier of this ERC, which is RECOMMENDED to be referred to as Omniverse Account (`o-account` for short) in this article. The `o-account` is RECOMMENDED to be expressed as a public key created by the elliptic curve `secp256k1`. A [mapping mechanism](#mapping-mechanism-for-different-environments) is RECOMMENDED for different environments. ### Data Structure An Omniverse Transaction (`o-transaction` for short) MUST

MOTIVATION:
- The current paradigm of token bridges makes assets fragment. - If ETH was transferred to another chain through the current token bridge, if the chain broke down, ETH will be lost for users. The core of this ERC is synchronization instead of transferring, even if all the other chains break down, as long as Ethereum is still running, user’s assets will not be lost. - The fragment problem will be solved. - The security of users' multi-chain assets can be greatly enhanced.

RATIONALE:
### Architecture As shown in [Figure.1](#figure1-architecture), smart contracts deployed on multi-chains execute `o-transactions` of ERC-6358 tokens synchronously through the trustless off-chain synchronizers. - The ERC-6358 smart contracts are referred to as **Abstract Nodes**. The states recorded by the Abstract Nodes that are deployed on different blockchains respectively could be considered as copies of the global state, and they are ultimately consistent. - **Synchronizer** is an off-chain execution program responsible for carrying published `o-transactions` from the ERC-6358 smart contracts on one blockchain to the others. The synchronizers work trustless as they just deliver `o-transactions` with others' signatures, and details


=== ERC-5050 ===
TITLE: Interactive NFTs with Modular Environments
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-04-18
REQUIRES: 1, 6, 5, ,,  , 1, 7, 3, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 1, 8, 2, 0, ,,  , 4, 9, 0, 6

SUMMARY:
This standard defines a broadly applicable action messaging protocol for the transmission of user-initiated actions between tokens. Modular statefulness is achieved with optional state controller contracts (i.e. environments) that manage shared state, and provide arbitration and settlement of the action process.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. Smart contracts implementing this EIP standard MUST implement the [EIP-165](./eip-165.md) supportsInterface function and MUST return the constant value `true` if the `IERC5050Sender` interface ID `0xc8c6c9f3` and/or the `IERC5050Receiver` interface ID `0x1a3f02f4` is passed through the `interfaceID` argument (depending on which interface(s) the contract implements). ```solidity pragma solidity ^0.8.0; /// @param _address The address of the interactive object /// @param tokenId The token that is interacting (optional) struct Object {

MOTIVATION:
Tokenized item standards such as [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) serve as the objects of the Ethereum computing environment. A growing number of projects are seeking to build interactivity and *"digital physics"* into NFTs, especially in the contexts of gaming and decentralized identity. A standard action messaging protocol will allow this physics layer to be developed in the same open, Ethereum-native way as the objects they operate on. The messaging protocol outlined defines how an action is initiated and transmitted between tokens and (optional) shared state environments. It is paired with a common interface for defining functionality that allows off-chain

RATIONALE:
The critical features of this interactive token standard are that it 1) creates a common way to define, advertise, and conduct object interaction, 2) enables optional, brokered statefulness with *useful* validity assurances at minimum gas overhead, 3) is easy for developers to implement, and 4) is easy for end-users to use. ### Action Names & Selectors Actions are advertised using human-readable strings, and processed using function selectors (`bytes4(keccack256(action_key))`). Human-readable strings allow end-users to easily interpret functionality, while function selectors allow efficient comparison operations on arbitrarily long action keys. This scheme also allows for simple namespacing and sequence specification.


=== ERC-7785 ===
TITLE: Onchain registration of chain identifiers
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-09-26
REQUIRES: 2304

SUMMARY:
This ERC proposes to derive chain identifiers as a digest of their chain name (and other information) and to use ENS to map chain names to identifiers in place of the centralized list on GitHub. A solution to support existing chain identifiers that were not derived following this ERC is also proposed.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Extending chain identifiers Current chain identifiers are usually chosen arbitrarily to be short. While these identifiers are convenient on a small scale, as their number increases it is more desirable to draw them from a larger space. We propose to extend the size of identifiers to 32 bytes and to derive them using a cryptographic hash function. The input to the function MUST

MOTIVATION:
The mapping between chain names and identifiers, such as `Mainnet -> 0x1`, is currently maintained in a centralized list. However this solution has two main shortcomings: - It does not scale with the growing number of L2s. - The list maintainers are a single point of failure. Desired properties: - the ability to register new chain names and identifiers in a censorship-resistant way - the ability to resolve chain names and identifiers in a trustless way - maintain a unique mapping between names and identifiers ### Chain Identifier Spoofing and Replay Attacks An important property of the centralized

RATIONALE:
<!-- The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The current placeholder is acceptable for a draft. TODO: Remove this comment before submitting --> TBD


=== ERC-7555 ===
TITLE: Single Sign-On for Account Discovery
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-11-10
REQUIRES: 4337

SUMMARY:
This proposal establishes a standardized interface and functionality for applications to discover user accounts besides the readily available EOA. Specifically discovering normal accounts and smart accounts that may have been deployed or configured using a signing key that is not the standard Ethereum secp256k1 curve. The objective is to ensure uniformity of address retrieval across applications, and domains.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions - **Smart account** - An ERC-4337 compliant smart contract account that has a modular architecture. - **Domain** - A string of text acting as an identification to a server or website (eg: `ethereum.org` or `ABCDE12345.com.example.app`). - **EOA** - Accounts that are controlled by a single private key. - **Provider** - A third party service provider that is able to authenticate a user

MOTIVATION:
The recent progress in account abstraction has led to significantly increased flexibility enabling use cases such as multi-signature transactions, social recovery, contract/account whitelisting, session keys and much more. However, with increased flexibility there comes an increased complexity. One area of increased complexity is account fragmentation -both at the EOA and smart account level - following from the inability to correctly identify all existing addresses by a user. In this EIP we present a potential solution that aims to unify the discovery and handling of such accounts. Prior to [ERC-4337](./eip-4337.md), the standard approach to interacting with a smart contract

RATIONALE:
### Redirects Taking inspiration from how SSO functions in the web today. We implement a similar redirect pattern, consisting of a simple request/response. #### Application ##### Initial Request An application would redirect a user to a specified provider, only passing along the callback url information. This is to ensure the providers website can remain stateless, and not rely on web requests. ##### Response from provider When a user is redirected to the application, it can parse the response for a signer address, and associated smart account address. #### Provider Upon a user navigating to the provider website, the


=== ERC-2400 ===
TITLE: Transaction Receipt URI
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-11-05
REQUIRES: 1, 5, 5, ,,  , 6, 8, 1

SUMMARY:
A transaction hash is not very meaningful on its own, because it looks just like any other hash, and it might lack important information for reading a transaction. This standard includes all needed information for displaying a transaction and its details, such as `chainId`, `method` signature called, and `events` signatures emitted.

SPECIFICATION:
### Syntax Transaction receipt URLs contain "ethereum" in their schema (protocol) part and are constructed as follows: receipt = schema_part transaction_hash [ "@" chain_id ] [ "?" parameters ] schema_part = "ethereum:tx-" transaction_hash = "0x" 64*HEXDIG chain_id = 1*DIGIT parameters = parameter *( "&" parameter ) parameter = key "=" value key = "method" / "events" value = function_signature / event_list function_signature = function_name "(" TYPE *( "," TYPE) ")" function_name = STRING event_list = event_signature *( ";" event_signature ) event_signature = event_name "(" event_type *( "," event_type) ")" event_name = STRING event_type = ["!"] TYPE Where `TYPE`

MOTIVATION:
Interoperability between ethereum clients, allowing different systems to agree on a standard way of representing submitted transactions hashes, optionally with necessary information for decoding transaction details. ### Use-cases Transaction Receipt URIs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URI format allows for instant invocation of the user’s preferred transaction explorer application. Such as: - In web3 (dapps, mining pools, exchanges), links would automatically open user's preferred transaction explorer; - In wallets, for users sharing transaction receipts easier; - In chat applications, as a

RATIONALE:
The goal of this standard envolves only the transport of submitted transactions, and therefore transaction data must be loaded from blockchain or pending transaction queue, which also serves as a validation of the transaction existence. Transaction hash not found is normal in fresh transactions, but can also mean that effectively a transaction was never submitted or have been replaced (through "higher gasPrice" nonce override or through an uncle/fork). In order to decode transaction parameters and events, a part of the ABI is required. The transaction signer have to know the ABI to sign a transaction, and is also


=== ERC-1386 ===
TITLE: Attestation management contract
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2018-09-08
REQUIRES: 


=== ERC-3772 ===
TITLE: Compressed Integers
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-08-27
REQUIRES: 

SUMMARY:
This document specifies compression of `uint256` to smaller data structures like `uint64`, `uint96`, `uint128`, for optimizing costs for storage. The smaller data structure (represented as `cintx`) is divided into two parts, in the first one we store `significant` bits and in the other number of left `shift`s needed on the significant bits to decompress. This document also includes two specifications for decompression due to the nature of compression being lossy, i.e. it causes underflow.

SPECIFICATION:
In this specification, the structure for representing a compressed value is represented using `cintx`, where x is the number of bits taken by the entire compressed value. On the implementation level, an `uintx` can be used for storing a `cintx` value. ### Compression #### uint256 into cint64 (up to cint120) The rightmost, or least significant, 8 bits in `cintx` are reserved for storing the shift and the rest available bits are used to store the significant bits starting from the first `1` bit in `uintx`. ```solidity struct cint64 { uint56 significant; uint8 shift; } // ... struct cint120

MOTIVATION:
- Storage is costly, each storage slot costs almost $0.8 to initialize and $0.2 to update (20 gwei, 2000 ETHUSD). - Usually, we store money amounts in `uint256` which takes up one entire slot. - If it's DAI value, the range we work with most is 0.001 DAI to 1T DAI (or 10<sup>12</sup>). If it's ETH value, the range we work with most is 0.000001 ETH to 1B ETH. Similarly, any token of any scale has a reasonable range of 10<sup>15</sup> amounts that we care/work with. - However, uint256 type allows us to represent $10<sup>-18</sup> to $10<sup>58</sup>, and

RATIONALE:
- The `significant` bits are stored in the most significant part of `cintx` while `shift` bits in the least significant part, to help prevent obvious dev mistakes. For e.g. a number smaller than 2<sup>56</sup>-1 its compressed `cint64` value would be itself if the arrangement were to be opposite than specified. If a developer forgets to uncompress a value before using it, this case would still pass if the compressed value is the same as decompressed value. - It should be noted that using `cint64` doesn't render gas savings automatically. The solidity compiler needs to pack more data into


=== ERC-4931 ===
TITLE: Generic Token Upgrade Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2021-11-02
REQUIRES: 20

SUMMARY:
The following standard allows for the implementation of a standard API for [ERC-20](./eip-20.md) token upgrades. This standard specifies an interface that supports the conversion of tokens from one contract (called the "source token") to those from another (called the "destination token"), as well as several helper methods to provide basic information about the token upgrade (i.e. the address of the source and destination token contracts, the ratio that source will be upgraded to destination, etc.).

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Please Note: Methods marked with (Optional Ext.) are a part of the optional extension for downgrade functionality and may remain unimplemented if downgrade functionality is not required. ### Token Upgrade Interface Contract ``` solidity interface IEIP4931 { ``` #### Methods ##### upgradeSource Returns the address of the original (source) token that will be upgraded. ``` solidity /// @dev A getter to determine the contract that is being upgraded from

MOTIVATION:
Token contract upgrades typically require each asset holder to exchange their old tokens for new ones using a bespoke interface provided by the developers. This standard interface will allow asset holders as well as centralized and decentralized exchanges to conduct token upgrades more efficiently since token contract upgrade scripts will be essentially reusable. Standardization will reduce the security overhead involved in verifying the functionality of the upgrade contracts. It will also provide asset issuers clear guidance on how to effectively implement a token upgrade.

RATIONALE:
There have been several notable ERC20 upgrades (Ex. Golem: GNT -> GLM) where the upgrade functionality is written directly into the token contracts. We view this as a suboptimal approach to upgrades since it tightly couples the upgrade with the existing tokens. This EIP promotes the use of a third contract to facilitate the token upgrade to decouple the functionality of the upgrade from the functionality of the token contracts. Standardizing the upgrade functionality will allow asset holders and exchanges to write simplified reusable scripts to conduct upgrades which will reduce the overhead of conducting upgrades in the


=== ERC-6909 ===
TITLE: Minimal Multi-Token Interface
TYPE: Standards Track ERC
STATUS: Review
CREATED: 2023-04-19
REQUIRES: 165

SUMMARY:
The following specifies a multi-token contract as a simplified alternative to the [ERC-1155](./eip-1155.md) Multi-Token Standard. In contrast to ERC-1155, callbacks and batching have been removed from the interface and the permission system is a hybrid operator-approval scheme for granular and scalable permissions. Functionally, the interface has been reduced to the bare minimum required to manage multiple tokens under the same contract.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Every [ERC-6909](./eip-6909.md) compliant contract must implement the [ERC-165](./eip-165.md) interface in addition to the following interface. ### Definitions - infinite: The maximum value for a uint256 (`2 ** 256 - 1`). - caller: The caller of the current context (`msg.sender`). - spender: An account that transfers tokens on behalf of another account. - operator: An account that has unlimited transfer permissions on all token ids

MOTIVATION:
The ERC-1155 standard includes unnecessary features such as requiring recipient accounts with code to implement callbacks returning specific values and batch-calls in the specification. In addition, the single operator permission scheme grants unlimited allowance on every token ID in the contract. Backwards compatibility is deliberately removed only where necessary. Additional features such as batch calls, increase and decrease allowance methods, and other user experience improvements are deliberately omitted in the specification to minimize the required external interface. According to ERC-1155, callbacks are required for each transfer and batch transfer to contract accounts. This requires potentially unnecessary external calls

RATIONALE:
### Granular Approvals While the "operator model" from the ERC-1155 standard allows an account to set another account as an operator, giving full permissions to transfer any amount of any token id on behalf of the owner, this may not always be the desired permission scheme. The "allowance model" from [ERC-20](./eip-20.md) allows an account to set an explicit amount of the token that another account can spend on the owner's behalf. This standard requires both be implemented, with the only modification being to the "allowance model" where the token id must be specified as well. This allows an


=== ERC-7578 ===
TITLE: Physical Asset Redemption
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-08-01
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal is an extension of [ERC-721](./eip-721.md) and implements additional functionality and information pertaining to the NFT’s underlying physical asset by capturing information that enables the holder of physical asset backed NFTs to verify authenticity and facilitate redemption of the underlying physical assets. This proposal is primarily aimed at providing transparency by disclosing details of involved parties and provides opportunity to define and make readily available relevant legal relationship between NFT holder and the owner/holder of the respective underlying physical asset. This proposal makes the token issuer accountable to embed accurate information on a set of standardized information

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. When a token is minted, its properties SHOULD be initialized beforehand, with each field being defined as follows: - **Token issuer**: identification of an individual or entity minting the NFT <br> _The token issuer is the key person connecting the physical asset and the digital representation. By identifying and disclosing the token issuer, a reference point is made instantly available to the NFT holder which allows them to conduct a

MOTIVATION:
The first wave of NFT use cases encompass predominately the representation of ownership of digital assets. In view of the anticipated trend to tokenize any real-world asset, it is to be expected that the use cases of NFTs will rapidly grow and expand around physical assets. The absence of an embedded standardized set of information pertaining to the underlying physical asset together with lack of transparency of involved key parties, creates an unnecessary hurdle for NFT holders and potential users which might, as a result, hinder mass adoption of NFTs that are used as ownership representation of a

RATIONALE:
By not initializing a token's properties before minting, one risks that the asset's provenance represented by the token cannot be established. Contract level validation is not used on the properties as we believe the accuracy of the data declared is the responsibility of the token issuer. This builds trust on the token issuer and the token itself.


=== ERC-5380 ===
TITLE: ERC-721 Entitlement Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-03-11
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 0, 4, 6

SUMMARY:
This EIP proposes a new interface that allows [ERC-721](./eip-721.md) token owners to grant limited usage of those tokens to other addresses.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY" and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Base Compliant entitlement contracts MUST implement the following Solidity interface: ```solidity /// SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.0; interface ERC5380Entitlement is ERC165 { /// @notice Emitted when the amount of entitlement a user has changes. If user is the zero address, then the user is the owner event EntitlementChanged(address indexed user, address indexed contract, uint256 indexed tokenId); /// @notice Set the user associated with the given ERC-721 token as long

MOTIVATION:
There are many scenarios in which it makes sense for the owner of a token to grant certain properties to another address. One use case is renting tokens. If the token in question represents a trading card in an on-chain TCG (trading card game), one might want to be able to use that card in the game without having to actually buy it. Therefore, the owner might grant the renter the "property" of it being able to be played in the TCG. However, this property should only be able to be assigned to one person at a time,

RATIONALE:
[ERC-20](./eip-20.md) and [ERC-1155](./eip-1155.md) are unsupported as partial ownership is much more complex to track than boolean ownership.


=== ERC-7811 ===
TITLE: Wallet Asset Discovery
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-11-07
REQUIRES: 2, 0, ,,  , 1, 5, 5, ,,  , 7, 2, 1, ,,  , 5, 7, 9, 2

SUMMARY:
This ERC introduces a new RPC call, `wallet_getAssets`, for wallets to declare to the Dapp what assets are owned by the user. This allows for more accurate asset discovery and the use of assets that aren’t available on-chain but can be provided by the wallet

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Method: `wallet_getAssets` #### Request schema ```ts type Hex = `0x${string}`; type Address = Hex; type AssetType = "native" | "erc20" | "erc721" | string; type Address = Hex; type AddressOrNative = Address | "native"; type Eip155ChainId = Hex; type WalletGetAssetsRequest = { account: Address; assetFilter?: Record< Eip155ChainId, { address: AddressOrNative; type: AssetType; }[] >; assetTypeFilter?: AssetType[]; chainFilter?: Hex[]; }; ``` `account` is a **REQUIRED** field that indicates for

MOTIVATION:
Currently, Dapps primarily rely on on-chain data to determine a user's balance, which can be limiting. Furthermore, a Dapp might restrict the user from initiating actions that the wallet could otherwise resolve, as it cannot account for the total assets a user has across different accounts or chains. Wallets already have information about a user's assets, including those not visible on-chain, and need a way to communicate that information to Dapps.

RATIONALE:
<!-- TODO -->


=== ERC-7754 ===
TITLE: Tamperproof Web Immutable Transaction (TWIT)
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-07-29
REQUIRES: 1193

SUMMARY:
Introduces a new RPC method to be implemented by wallets, `wallet_signedRequest`, that enables dapps to interact with wallets in a tamperproof manner via "signed requests". The dapp associates a public key with its DNS record and uses the corresponding private key to sign payloads sent to the wallet via `wallet_signedRequest`. Wallets can then use the public key in the DNS record to validate the integrity of the payload.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Overview We propose to use the dapp's domain certificate of a root of trust to establish a trust chain as follow: 1. The user's browser verifies the domain certificate and displays appropriate warnings if overtaken 2. The DNS record of the dapp hosts a TXT field pointing to a URL where a JSON manifest is hosted - This file SHOULD be at a

MOTIVATION:
This standard aims to enhance the end user's experience by granting them confidence that requests from their dapps have not been tampered with. In essence, this is similar to how HTTPS is used in the web. Currently, the communication channel between dapps and wallets is vulnerable to man in the middle attacks. Specifically, attackers can intercept RPC requests by injecting JavaScript code in the page, via e.g. an XSS vulnerability or due to a malicious extension. Once an RPC request is intercepted, it can be modified in a number of pernicious ways, including: - Editing the calldata in

RATIONALE:
The proposed implementation does not modify any of the existing functionalities offered by [EIP-712](./eip-712.md) and [EIP-1193](./eip-1193.md). Its additive nature makes it inherently backward compatible. Its core design is modeled after existing solutions to existing problems (such as DKIM). As a result the proposed specification will be non disruptive, easy to implements for both wallets and dapps, with a predictable threat model.


=== ERC-7813 ===
TITLE: Store, Table-Based Introspectable Storage
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-11-08
REQUIRES: 

SUMMARY:
This standard introduces a flexible on-chain storage pattern that organizes data into structured tables that consist of records with fixed key and value schemas, similar to a traditional database. This storage pattern consists of a unified contract interface for data access, along with a compact binary encoding format for both static and dynamic data types. State changes are tracked through standardized events that enable automatic, schema-aware state replication by off-chain indexers. New tables can be dynamically registered at runtime through a special table that stores schema metadata for all tables, allowing the system to evolve without breaking existing

SPECIFICATION:
### Definitions #### Store A smart contract that implements the interface proposed by this ERC and organizes data in Tables. It emits events for each data operation so that off-chain components can replicate the state of all tables. #### Table A storage structure that holds **Records** sharing the same **Schema**. - **On-chain Table**: Stores its state on-chain and emits events for off-chain- indexers. - **Off-chain Table**: Does not store state on-chain but emits events for off-chain indexers. #### Record A piece of data stored in a **Table**, addressed by one or more keys. #### `ResourceId` A 32-byte value

MOTIVATION:
The absence of consistent standards for on-chain data management in smart contracts can lead to rigid implementations, tightly coupled contract logic with off-chain services, and challenges in updating or extending a contract’s data layout without breaking existing integrations. Using the storage mechanism defined in this ERC provides the following benefits: 1. **Automatic Indexing**: By emitting consistent, standardized events during state changes, off-chain services can automatically track on-chain state and provide schema-aware indexer APIs. 2. **Elimination of Custom Getter Functions**: Any contract or off-chain service can read stored data through a consistent interface, decoupling smart contract implementation from specific

RATIONALE:
### Splice Events While the `Store_SetRecord` event suffices for tracking the data of each record off-chain, including `Splice` events (`Store_SpliceStaticData` and `Store_SpliceDynamicData`) allows for more efficient partial updates. When only a portion of a record changes, emitting a full `SetRecord` event would be inefficient because the entire record data would need to be read from storage and emitted. `Splice` events enable the store to emit only the minimal necessary data for the update, reducing gas consumption. This is particularly important for records with large dynamic fields, as the cost of updating them doesn’t grow with the field’s size.


=== ERC-7795 ===
TITLE: Wallet Call Token Capabilities
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-22
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5, ,,  , 5, 7, 9, 2

SUMMARY:
This ERC extends [EIP-5792](./eip-5792.md) by defining capabilities that allow dApps to specify common token prerequisites for transactions, such as having certain [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), or [ERC-1155](./eip-1155.md) tokens. Wallets can then help users meet these requirements before executing the transactions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This ERC extends [EIP-5792](./eip-5792.md) by adding new capabilities that can be used with the `wallet_sendCalls` and `wallet_getCapabilities` methods. These capabilities allow specifying different types of transaction requirements for common token standards that wallets can handle. DApps **MAY** opt out of using this feature if they wish to handle requirement fulfillment themselves. ### ERC-20 Minimum Balance Capability A dApp can use the `erc20MinBalance` capability in

MOTIVATION:
It is fairly common for dApps to reside only on one network, but this comes at the cost of shrinking the direct liquidity that these dApps can access. This happens because most users only have funds on a limited number of networks. As the number of networks grows, the likelihood of intersection between the networks chosen by the dApp and the user decreases. Given that dApps don't have a way of communicating with the wallet about their "final intent", they can only use transaction requests to communicate the last action that the user should take. However, it is

RATIONALE:
This ERC extends [EIP-5792](./eip-5792.md) rather than defining new RPC methods because: 1. **Consistency**: Leverages existing capability discovery mechanism 2. **Composability**: Requirements can be combined with other [EIP-5792](./eip-5792.md) capabilities 3. **Flexibility**: Wallets can implement only the requirements they support 4. **Extensibility**: New requirement types can be added as additional capabilities The decision to split requirements into individual capabilities rather than a single capability type allows: 1. Granular support by wallets 2. Clear capability discovery 3. Independent versioning of requirement types 4. Simpler implementation for basic wallets


=== ERC-7765 ===
TITLE: Privileged Non-Fungible Tokens Tied To RWA
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-08-20
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This EIP defines an interface to carry a real world asset with some privileges that can be exercised by the holder of the corresponding NFT. The EIP standardizes the interface for non-fungible tokens representing real world assets with privileges to be exercised, such as products sold onchain which can be redeemed in the real world. And the privileges we describe here specifically refer to the rights and interests bound to the RWA NFT that can be executed by the holder in the real world.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This standard inherits the [ERC-721](./eip-721.md) NFT token standard for all transfer and approval logic. All transfer and approval functions are inherited from this token standard without changes. Additionally, this standard also inherits the ERC-721 Metadata standards for name, symbol, and metadata URI lookup. Any compliant contract following this EIP **MUST** implement the following interface: ``` pragma solidity >=0.7.0 <0.9.0; /// @title ERC-7765 Privileged Non-Fungible

MOTIVATION:
NFTs bound to real-world assets sometimes need to carry certain privileges that can be exercised by the holder. Users can initiate transactions onchain to specify the exercise of a certain privilege, thereby achieving real-world privileges that directly map the onchain privilege through subsequent operations. For example, if a certain product such as a pair of shoes is sold onchain in the representation of NFT, the NFT holder can exercise the privilege of exchanging physical shoes offchain, to achieve the purpose of interoperability between the blockchain and the real world. Having a standard interface enables interoperability for services, clients,

RATIONALE:
1. With the `PrivilegeExercised` event emitted onchain, we can determine that the user has confirmed the exercise of this privilege, so as to implement the privilege in the real world. 2. We choose to include an address `_to` for functions `exercisePrivilege`, `isExercisable` and `isExercised` so that a specific privilege of an NFT MAY be exercised for someone who will benefit from it other than the NFT holder nor the transaction initiator. And This EIP doesn't assume who has the power to perform this action, it's totally decided by the developers who are using this standard. 3. We choose


=== ERC-6944 ===
TITLE: ERC-5219 Resolve Mode
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-04-27
REQUIRES: 4, 8, 0, 4, ,,  , 5, 2, 1, 9

SUMMARY:
This EIP adds a new [ERC-4804](./eip-4804.md) `resolveMode` to resolve [ERC-5219](./eip-5219.md) contract resource requests.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Contracts wishing to use ERC-5219 as their ERC-4804 resolve mode must implement the following interface: ```solidity /// @dev IDecentralizedApp is the ERC-5219 interface interface IERC5219Resolver is IDecentralizedApp { // @notice The ERC-4804 resolve mode // @dev This MUST return "5219" (0x3532313900000000000000000000000000000000000000000000000000000000) for ERC-5219 resolution (case-insensitive). The other options, as of writing this, are "auto" for automatic resolution, or "manual" for manual resolution. function resolveMode()

RATIONALE:
[ERC-165](./eip-165.md) was not used because interoperability can be checked by calling `resolveMode`.


=== ERC-6381 ===
TITLE: Public Non-Fungible Token Emote Repository
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-01-22
REQUIRES: 165

SUMMARY:
The Public Non-Fungible Token Emote Repository standard provides an enhanced interactive utility for [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) by allowing NFTs to be emoted at. This proposal introduces the ability to react to NFTs using Unicode standardized emoji in a public non-gated repository smart contract that is accessible at the same address in all of the networks.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ```solidity /// @title ERC-6381 Emotable Extension for Non-Fungible Tokens /// @dev See https://eips.ethereum.org/EIPS/eip-6381 /// @dev Note: the ERC-165 identifier for this interface is 0xd9fac55a. pragma solidity ^0.8.16; interface IERC6381 /*is IERC165*/ { /** * @notice Used to notify listeners that the token with the specified ID has been emoted to or that the reaction has been revoked. * @dev The event MUST only be emitted if the state of

MOTIVATION:
With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for anyone to interact with an NFT introduces an interactive aspect to owning an NFT and unlocks feedback-based NFT mechanics. This ERC introduces new utilities for [ERC-721](./eip-721.md) based tokens in the following areas: - [Interactivity](#interactivity) - [Feedback based evolution](#feedback-based-evolution) - [Valuation](#valuation) ### Interactivity The ability to emote on an NFT introduces the aspect of interactivity to owning an NFT. This can either reflect the admiration

RATIONALE:
Designing the proposal, we considered the following questions: 1. **Does the proposal support custom emotes or only the Unicode specified ones?**\ The proposal only accepts the Unicode identifier which is a `bytes4` value. This means that while we encourage implementers to add the reactions using standardized emojis, the values not covered by the Unicode standard can be used for custom emotes. The only drawback being that the interface displaying the reactions will have to know what kind of image to render and such additions will probably be limited to the interface or marketplace in which they were made.


=== ERC-2470 ===
TITLE: Singleton Factory
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2020-01-15
REQUIRES: 1014

SUMMARY:
Some contracts are designed to be Singletons which have the same address no matter what chain they are, which means that should exist one instance for all, such as [EIP-1820] and [EIP-2429]. These contracts are usually deployed using a method known as [Nick]'s method, so anyone can deploy those contracts on any chain and they have a deterministic address. This standard proposes the creation of a CREATE2 factory using this method, so other projects requiring this feature can use this factory in any chain with the same setup, even in development chains.

SPECIFICATION:
### [ERC-2470] Singleton Factory > This is an exact copy of the code of the [ERC2470 factory smart contract]. ```solidity pragma solidity 0.6.2; /** * @title Singleton Factory (EIP-2470) * @notice Exposes CREATE2 (EIP-1014) to deploy bytecode on deterministic addresses based on initialization code and salt. * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH) */ contract SingletonFactory { /** * @notice Deploys `_initCode` using `_salt` for defining the deterministic address. * @param _initCode Initialization code. * @param _salt Arbitrary value to modify resulting address. * @return createdContract Created contract address. */ function deploy(bytes memory _initCode, bytes32

MOTIVATION:
Code reuse, using the factory becomes easier to deploy singletons.

RATIONALE:
SingletonFactory does not allow sending value on create2, this was done to prevent different results on the created object. SingletonFactory allows user defined salt to facilitate the creation of vanity addresses for other projects. If vanity address is not necessary, salt `bytes(0)` should be used. Contracts that are constructed by the SingletonFactory MUST not use `msg.sender` in their constructor, all variables must came through initialization data. This is intentional, as if allowing a callback after creation to aid initialization state would lead to contracts with same address (but different chains) to have the same address but different initial


=== ERC-5744 ===
TITLE: Latent Fungible Token
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-09-29
REQUIRES: 2, 0, ,,  , 2, 6, 1, 2

SUMMARY:
The following standard is an extension of [EIP-20](./eip-20.md) that enables tokens to become fungible after some initial non-fungible period. Once minted, tokens are non-fungible until they reach maturity. At maturity, they become fungible and can be transferred, traded, and used in any way that a standard EIP-20 token can be used.

SPECIFICATION:
All latent fungible tokens MUST implement EIP-20 to represent the token. The `balanceOf` and `totalSupply` return quantities for all tokens, not just the matured, fungible tokens. A new method called `balanceOfMatured` MUST be added to the ABI. This method returns the balance of matured tokens for a given address: ```solidity function balanceOfMatured(address user) external view returns (uint256); ``` An additional method called `getMints` MUST be added, which returns an array of all mint metadata for a given address: ```solidity struct MintMetadata { // Amount of tokens minted. uint256 amount; // Timestamp of the mint, in seconds. uint256 time;

MOTIVATION:
Example use cases include: - Receipt tokens that do not become active until a certain date or condition is met. For example, this can be used to enforce minimum deposit durations in lending protocols. - Vesting tokens that cannot be transferred or used until the vesting period has elapsed.

RATIONALE:
The `mints` method is optional because the ID is optional. In some use cases such as vesting where a user may have a maximum of one mint, an ID is not required. Similarly, vesting use cases may want to enforce non-transferrable tokens until maturity, whereas lending receipt tokens with a minimum deposit duration may want to support transfers at all times. It is possible that the number of mints held by a user is so large that it is impractical to return all of them in a single `eth_call`. This is unlikely so it was not included in


=== ERC-7512 ===
TITLE: Onchain Representation for Audits
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-05
REQUIRES: 712

SUMMARY:
The proposal aims to create a standard for an onchain representation of audit reports that can be parsed by contracts to extract relevant information about the audits, such as who performed the audits and what standards have been verified.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Audit Properties - Auditor - `name`: Name of the auditor (i.e. for displaying to the user) - `uri`: URI to retrieve more information about the auditor - `authors`: A list of authors that contributed to this audit. This SHOULD be the persons who audited the contracts and created the audit - Audit - `auditor`: Information on the auditor - `auditedContract`: MUST be the `chainId`

MOTIVATION:
Audits are an integral part of the smart contract security framework. They are commonly used to increase the security of smart contracts and ensure that they follow best practices as well as correctly implement standards such [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), and similar ERCs. Many essential parts of the blockchain ecosystem are facilitated by the usage of smart contracts. Some examples of this are: - Bridges: Most bridges consist of a bridgehead or a lockbox that secures the tokens that should be bridged. If any of these contracts are faulty it might be possible to bring the operation of the bridge

RATIONALE:
The current ERC deliberately does not define the `findings` of an audit. Such a definition would require alignment on the definition of what severities are supported, what data of a finding should be stored onchain vs off-chain, and other similar finding-related attributes that are hard to strictly describe. Given the complexity of this task, we consider it to be outside the scope of this EIP. It is important to note that this ERC proposes that a signed audit summary indicates that a specific contract instance (specified by its `chainId` and `deployment`) has undergone a security audit. Furthermore, it


=== ERC-7651 ===
TITLE: Fractionally Represented Non-Fungible Token
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-03-05
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal introduces a standard for fractionally represented non-fungible tokens, allowing NFTs to be managed and owned fractionally within a single contract. This approach enables NFTs to coexist with an underlying fungible representation seamlessly, enhancing liquidity and access without dividing the NFT itself, or requiring an explicit conversion step. The standard includes mechanisms for both fractional and whole token transfers, approvals, and event emissions. This specification draws from design in both [ERC-721](./eip-721.md) and [ERC-20](./eip-20.md), but is not fully compatible with either standard.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Fractionally Represented Non-Fungible Token Interface All [ERC-7651](./eip-7651.md) compliant contracts MUST implement the ERC-7651 and [ERC-165](./eip-165.md) interfaces. Compliant contracts MUST emit fractional Approval or Transfer events on approval or transfer of tokens in fractional representation. Compliant contracts MUST additionally emit non-fungible ApprovalForAll, Approval or Transfer on approval for all, approval, and transfer in non-fungible representation. Note that this interface draws from similarly defined functions

MOTIVATION:
Fractional ownership of NFTs has historically relied on external protocols that manage division and reconstitution of individual NFTs into fractional representations. The approach of dividing specific NFTs results in fragmented liquidity of the total token supply, as the fractional representations of two NFTs are not equivalent and therefore must be traded separately. Additionally, this approach requires locking of fractionalized NFTs, preventing free transfer until they are reconstituted. This standard offers a unified solution to fractional ownership, aiming to increase the liquidity and accessibility of NFTs without compromising transferability or flexibility.

RATIONALE:
This standard unifies the representation of fractional ownership with the non-fungible token model, aligning closely with [ERC-721](./eip-721.md) principles while enabling the functionality of [ERC-20](./eip-20.md) transfers. This dual compatibility aims to mitigate the integration complexity for existing protocols. Our goal is to implicitly support as high a degree of backwards compatibility with ERC-20 and ERC-721 standards as possible to reduce or negate integration lift for existing protocols. The core rationale for this fractional NFT standard centers on two main strategies: first, designing interfaces that clearly align with either ERC-721 or ERC-20 standards to avoid ambiguity; and second, detailing implementation


=== ERC-7802 ===
TITLE: Crosschain Token Interface
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-10-30
REQUIRES: 1, 6, 5, ,,  , 5, 6, 7, 9

SUMMARY:
This standard introduces a minimal interface, `IERC7802`, for tokens to enable standardized cross-chain communication. The interface consists of two functions, `crosschainMint` and `crosschainBurn`, which allow authorized bridge contracts to mint and burn token representations during cross-chain transfers. These functions serve as the entry points for bridge logic, enabling consistent handling of token supply across chains. The interface also defines two standardized events, `CrosschainMint` and `CrosschainBurn`, which emit metadata, including the target address, token amount, and caller. These events facilitate deterministic indexing and monitoring of cross-chain activities by off-chain agents, such as indexers, analytics tools, and auditors. `IERC7802` is

SPECIFICATION:
This ERC introduces the `IERC7802` interface. ### Interface Identification The interface identifier for `IERC7802` is **`0x33331994`**, calculated according to [ERC-165](./eip-165.md) as the XOR of the function selectors of the two functions in the interface: ```solidity bytes4 constant INTERFACE_ID_IERC7802 = bytes4(keccak256("crosschainMint(address,uint256)")) ^ bytes4(keccak256("crosschainBurn(address,uint256)")); ``` or via Solidity as ```solidity type(IERC7802).interfaceId ``` Implementors MUST ensure that the `supportsInterface` method of ERC-165 returns true for this interface ID to indicate support for `IERC7802`. ### Methods **`crosschainMint`** Mints `_amount` of token to address `_account`. This function works as the minting entry point for bridge contracts. Each implementation is responsible for its access

MOTIVATION:
All rollups and multiple important sidechains (Gnosis and Polygon PoS, among others) implement canonical bridges that embed their security into some part of the network's core architecture. These bridges do not have mint/burn rights over original tokens, so they usually lock (unlock) liquidity on the native chain and then mint (burn) a non-equivalent representation on the other. Mint/burn is used because the native token is non-existent on that side, so they must create a new representation. However, each bridge implements a different interface for minting/burning on non-native chains. This interface fragmentation is a massive issue in cross-chain communication

RATIONALE:
### Design philosophy The core design decisions behind this minimal interface are - Bridge agnosticism. - Extensibility. **Bridge agnosticism** This interface is designed so bridges, not tokens, contain the logic to process cross-chain actions. By maintaining this separation of concerns, token contracts remain simple, reducing their attack surface and easing auditing and upgradability. Offloading cross-chain complexities to bridge contracts ensures that tokens do not embed specific bridge logic. By implementing the proposed interface, tokens can be supported by different bridge designs: - Lock/unlock bridges can still operate and do not require any token modification. - Burn/mint bridges can


=== ERC-1967 ===
TITLE: Proxy Storage Slots
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2019-04-24
REQUIRES: 

SUMMARY:
Delegating **proxy contracts** are widely used for both upgradeability and gas savings. These proxies rely on a **logic contract** (also known as implementation contract or master copy) that is called using `delegatecall`. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract. To avoid clashes in storage usage between the proxy and logic contract, the address of the logic contract is typically saved in a specific storage slot (for example `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` in OpenZeppelin contracts) guaranteed to be never allocated by a compiler. This EIP proposes a set of

SPECIFICATION:
Monitoring of proxies is essential to the security of many applications. It is thus essential to have the ability to track changes to the implementation and admin slots. Unfortunately, tracking changes to storage slots is not easy. Consequently, it is recommended that any function that changes any of these slots SHOULD also emit the corresponding event. This includes initialization, from `0x0` to the first non-zero value. The proposed storage slots for proxy-specific information are the following. More slots for additional information can be added in subsequent ERCs as needed. ### Logic contract address Storage slot `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (obtained as

MOTIVATION:
Delegating proxies are widely in use, as a means to both support upgrades and reduce gas costs of deployments. Examples of these proxies are found in OpenZeppelin Contracts, Gnosis, AragonOS, Melonport, Limechain, WindingTree, Decentraland, and many others. However, the lack of a common interface for obtaining the logic address for a proxy makes it impossible to build common tools that act upon this information. A classic example of this is a block explorer. Here, the end user wants to interact with the underlying logic contract and not the proxy itself. Having a common way to retrieve the logic

RATIONALE:
This EIP standardises the **storage slot** for the logic contract address, instead of a public method on the proxy contract. The rationale for this is that proxies should never expose functions to end users that could potentially clash with those of the logic contract. Note that a clash may occur even among functions with different names, since the ABI relies on just four bytes for the function selector. This can lead to unexpected errors, or even exploits, where a call to a proxied contract returns a different value than expected, since the proxy intercepts the call and answers


=== ERC-190 ===
TITLE: Ethereum Smart Contract Packaging Standard
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2017-01-10
REQUIRES: 


=== ERC-5143 ===
TITLE: Slippage Protection for Tokenized Vault
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-06-09
REQUIRES: 2, 0, ,,  , 4, 6, 2, 6

SUMMARY:
The following standard extends the [EIP-4626](./eip-4626.md) Tokenized Vault standard with functions dedicated to the safe interaction between EOAs and the vault when price is subject to slippage.

SPECIFICATION:
This ERC is an extension of EIP-4626. Any contract implementing it MUST also implement EIP-4626. ### Methods #### deposit Overloaded version of ERC-4626's `deposit`. Mints `shares` Vault shares to `receiver` by depositing exactly `assets` of underlying tokens. MUST emit the `Deposit` event. MUST support [EIP-20](./eip-20.md) `approve` / `transferFrom` on `asset` as a deposit flow. MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the `deposit` execution, and are accounted for during `deposit`. MUST revert if all of `assets` cannot be deposited (due to deposit limit being reached, slippage, the user

MOTIVATION:
[EIP-4626](./eip-4626.md) security considerations section states that: > "If implementors intend to support EOA account access directly, they should consider adding an additional function call for deposit/mint/withdraw/redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved." Yet, EIP-4626 does not standardize the corresponding function signatures and behaviors. For improved interroperability, and better support by wallets, it is essential that this optional functions are also standardized.

RATIONALE:
This ERC's functions do not replace ERC-4626 equivalent mechanisms. They are additional (overloaded) methods designed to protect EOAs interacting with the vault. When smart contracts interact with an ERC-4626 vault, they can preview any operation using the dedicated functions before executing the operation. This can be done atomically, with no risk of price change. This is not true of EOA, which will preview their operations on a UI, sign a transaction, and have it mined later. Between the preview and the transaction being executed, the blockchain state might change, resulting in unexpected outcomes. In particular, frontrunning make EOA's


=== ERC-5485 ===
TITLE: Legitimacy, Jurisdiction and Sovereignty
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2022-08-17
REQUIRES: 1, 6, 5, ,,  , 5, 2, 4, 7

SUMMARY:
Provide a way for compliant smart contracts to declare their legitimacy lineage, jurisdiction they observe, and sovereignty if they choose to not fall onto any jurisdiction.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. 1. Compliant contract MUSTS implement the following interface. ```solidity interface IERC5485 { /// A function that returns the source of legitimacy in an address /// /// @returns address of EOA or contract that grants legitimacy status to this contract. /// See Specification #2 and #3 for more details. function sourceOfLegitimacy() public view returns (address); /// A function that returns the sovereign jurisdiction in an address /// /// @returns address

MOTIVATION:
Today, smart contracts have no standard way to specify their legitimacy lineage, jurisdiction, or sovereignty relationship. The introduction of such a standard, supports better integration with today's legal and regulative scenarios: 1. it supports a regulative body to allow or deny interoperability with smart contracts. 2. it also allows DAOs to clearly declare "self-sovereignty" by announcing via this interface by saying they do not assert legitimacy from any source other than themselves. A real-world example is that ContractA represents an **A company registered in a country**, ContractB represents a **The Secretary of State of the country**, and ContractC

RATIONALE:
Needs discussion.


=== ERC-4671 ===
TITLE: Non-Tradable Tokens Standard
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-01-13
REQUIRES: 165

SUMMARY:
A non-tradable token, or NTT, represents inherently personal possessions (material or immaterial), such as university diplomas, online training certificates, government issued documents (national id, driving license, visa, wedding, etc.), labels, and so on. As the name implies, non-tradable tokens are made to not be traded or transferred, they are "soulbound". They don't have monetary value, they are personally delivered to **you**, and they only serve as a **proof of possession/achievement**. In other words, the possession of a token carries a strong meaning in itself depending on **why** it was delivered.

SPECIFICATION:
### Non-Tradable Token A NTT contract is seen as representing **one type of certificate** delivered by **one authority**. For instance, one NTT contract for the French National Id, another for Ethereum EIP creators, and so on... * An address might possess multiple tokens. Each token has a unique identifier: `tokenId`. * An authority who delivers a certificate should be in position to revoke it. Think of driving licenses or weddings. However, it cannot delete your token, i.e. the record will show that you once owned a token from that contract. * The most typical usage for third-parties will

MOTIVATION:
We have seen in the past smart contracts being used to deliver university diplomas or driving licenses, for food labeling or attendance to events, and much more. All of these implementations are different, but they have a common ground: the tokens are **non-tradable**. The blockchain has been used for too long as a means of speculation, and non-tradable tokens want to be part of the general effort aiming to provide usefulness through the blockchain. By providing a common interface for non-tradable tokens, we allow more applications to be developed and we position blockchain technology as a standard gateway

RATIONALE:
### On-chain vs Off-chain A decision was made to keep the data off-chain (via `tokenURI()`) for two main reasons: * Non-tradable tokens represent personal possessions. Therefore, there might be cases where the data should be encrypted. The standard should not outline decisions about encryption because there are just so many ways this could be done, and every possibility is specific to the use-case. * Non-tradable tokens must stay generic. There could have been a possibility to make a `MetadataStore` holding the data of tokens in an elegant way, unfortunately we would have needed a support for generics in


=== ERC-7662 ===
TITLE: AI Agent NFTs
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-03-26
REQUIRES: 721

SUMMARY:
This proposal introduces a standard for AI agent NFTs. When AI Agents are created and traded as NFTs, it doesn't make sense to put the prompts in the token metadata, therefore it requires a standard custom struct. It also doesn't make sense to store the prompts directly onchain as they can be quite large, therefore this standard proposes they be stored as decentralized storage URLs. This standard also proposes two options on how this data should be made private to the owner of the NFT, with the favored implementation option being encrypting the data using custom contract parameters

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All ERC-XXXX compliant contracts MUST implement the standard [ERC-721](./eip-721.md) functionality for minting and transferring NFTs, and MUST additionally implement this standard's Agent interface ```solidity interface IERC7662 is IERC721 { function getAgentData(uint256 tokenId) external view returns ( string memory name, string memory description, string memory model, string memory userPromptURI, string memory systemPromptURI, bool promptsEncrypted ); event AgentUpdated(uint256 indexed tokenId); } ``` and MUST implement the

MOTIVATION:
The creation and trading of AI Agent NFTs are a natural fit and offer the potential for an entirely new onchain market. This requires some custom data to be embedded in the NFT through a custom struct and this needs to be standardized so that any marketplace or AI Agent management product, among others, know how to create and parse AI Agent NFTs. The goal of this standard is to provide a new utility for NFTs in the field of AI and also to provide new liquidity, through the NFT market, for AI Agents. If widely adopted by

RATIONALE:
This standard provides a unified way to create and parse AI Agent NFTs. This standard codifies the necessary parameters of Name, Description, Model, User Prompt, and System Prompt for creating and using AI Agent NFTs. It doesn't make practical sense to store the user and system prompts in an existing [ERC-721](./eip-721.md) as the only place to put would be in the token metadata that is open for anyone to access the prompts without owning the NFT. By storing the prompts in a custom Agent struct and restricting access to the prompts to the holder of the NFT. One


=== ERC-7575 ===
TITLE: Multi-Asset ERC-4626 Vaults
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-12-11
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 2, 7, 7, 1, ,,  , 4, 6, 2, 6

SUMMARY:
The following standard adapts [ERC-4626](./eip-4626.md) to support multiple assets or entry points for the same share token. This also enables Vaults which don't have a true share token but rather convert between two arbitrary external tokens. It adds a new `share` method to the Vault, to allow the [ERC-20](./eip-20.md) dependency to be externalized. It also adds Vault-to-Share lookup to the share token. Lastly, it enforces [ERC-165](./eip-165.md) support for Vaults and the share token.

SPECIFICATION:
### Definitions: The existing definitions from [ERC-4626](./eip-4626.md) apply. In addition, this spec defines: - Multi-Asset Vaults: A Vault which has multiple assets/entry points. The Multi-Asset Vault refers to the group of [ERC-7575](./eip-7575.md) contracts with the entry points for a specific asset, linked to one common `share` token. - Pipe: A converter from one token to another (unidirectional or bidirectional) ### Methods All [ERC-7575](./eip-7575.md) Vaults MUST implement [ERC-4626](./eip-4626.md) excluding the [ERC-20](./eip-20.md) methods and events. #### share The address of the underlying `share` received on deposit into the Vault. MUST return an address of an [ERC-20](./eip-20.md) share representation of the

MOTIVATION:
One missing use case that is not supported by [ERC-4626](./eip-4626.md) is Vaults which have multiple assets or entry points such as liquidity provider (LP) Tokens. These are generally unwieldy or non-compliant due to the requirement of ERC-4626 to itself be an [ERC-20](./eip-20.md).

RATIONALE:
This standard is intentionally flexible to support both existing [ERC-4626](./eip-4626.md) Vaults easily by the introduction of a single new method, but also flexible to support new use cases by allowing separate share tokens. ### Ability to externalize [ERC-20](./eip-20.md) Dependency By allowing `share != address(this)`, the Vault can have an external contract managing the [ERC-20](./eip-20.md) functionality of the Share. In the case of Multi-Asset, this avoids the confusion that might arise if each Vault itself were required to be an [ERC-20](./eip-20.md), which could confuse integrators and front-ends. This approach also enables the creation of new types of Vaults, such


=== ERC-6506 ===
TITLE: P2P Escrowed Governance Incentives
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2023-02-15
REQUIRES: 

SUMMARY:
The following EIP defines the interface for a contract that facilitates the exchange of a governance-incentive for users to vote in a designated direction on a DAO-proposal while escrowing funds until the vote can be verified.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The key words "BRIBE" and "INCENTIVE" are to be interpreted as the transfer of a digital-asset(s) from user A to user B in exchange for an assurance that user B will vote in a specific-direction, on a specific proposal, for a specified-DAO. If user B does not honor the arrangement, the digital-asset(s) will be returned to user A. The key words "BRIBER", "INCENTIVIZER", and

MOTIVATION:
While a ton of effort has gone into building bribe systems for DAOs like Curve, Frax, Convex, etc., not a lot of focus has been put on how bribes on other, more general DAO votes, may affect outcomes. Bribes are a lucrative market on many popular DAO’s, and it stands to reason that people are willing to accept them for voting on other proposals, especially if they have no personal stake in the outcome. There are however, problems with current systems: 1. Current bribe schemes for votes based on pro-rata distribution are economically innefficient and result in worse

RATIONALE:
This design was motivated by a few factors: 1. The issue of offering incentives for votes is an inevitability. There is no mechanism that can prevent users from colluding off-chain to vote a certain direction, and with enough obfuscation, can be completely hidden from the community's view. The solution is therefore to realign the incentives of these actors in a way that both creates transparency, while allowing for the decentralization of bribe-revenue. Flashbots is a relevant example. Since MEV could not be prevented, the solution was to make it more fairly distributed by incentivizing miners to use Flashbots-Geth


=== ERC-4950 ===
TITLE: Entangled Tokens
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-03-28
REQUIRES: 2, 0, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP defines an interface for delegating control of a smart contract wallet to pairs of users using entangled [ERC-721](./eip-721.md) non-fungible tokens.

SPECIFICATION:
An entangled token contract implements [ERC-721](./eip-721.md) with the additional restriction that it only ever mints exactly two tokens at contract deployment: one with a `tokenId` of `0`, the other with a `tokenId` of `1`. The entangled token contract also implements a smart contract wallet that can be operated by the owners of those two tokens. Also, a `tokenTransfer` function is to be be added in order to allow the token owners to transact with the [ERC-20](./eip-20.md) tokens owned by the contract/NFT itself. The function signature is as follows: ```solidity function tokenTransfer(IERC20 token, address recipient, uint256 amount) public onlyOwners;

MOTIVATION:
The motivation is to provide an easy way to share a wallet through NFTs, so that the act of buying an NFT (in a marketplace) gives the buyer the privilege to have access to a given wallet. This wallet could have budget in many tokens, or even be the owner of other NFTs. A use case is to keep contact between an artist and an buyer of its NFTs. If an artist T has created a digital piece of art P with an NFT, then T creates 2 entangled tokens A and B so that he keeps A

RATIONALE:
We decide to extend [ERC-721](./eip-721.md) ([ERC-1155](./eip-1155.md) could be also possible) because the main purpose of this is to be compatible with current marketplaces platforms. This entangled NFTs will be listed in a marketplace, and the user who buys it will have then the possibility to transact with the wallet properties (fungible and non fungible tokens).


=== ERC-2309 ===
TITLE: ERC-721 Consecutive Transfer Extension
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2019-10-08
REQUIRES: 721

SUMMARY:
The optional ERC-721 Consecutive Transfer Extension provides a standardized event which could be emitted during the creation/transfer of one, or many non-fungible tokens. This standard does not set the expectation of how you might create/transfer many tokens it is only concerned with the event emitted after the creation, or transfer of ownership of these tokens. This extension assumes that token identifiers are in consecutive order.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. **ERC-721 compliant contracts MAY implement this Consecutive Transfer Extension to provide a standard event to be emitted at the time of creation, burn, or transfer of one or many consecutive tokens** The address executing the transaction **MUST** own all the tokens within the range of `fromTokenId` and `toTokenId`, or **MUST** be an approved operator to act on the owners behalf. The `fromTokenId` and `toTokenId` **MUST** be a consecutive range

MOTIVATION:
This extension provides even more scalibility of the [ERC-721 specification](./eip-721.md). It is possible to create, transfer, and burn 2^256 non-fungible tokens in one transaction. However, it is not possible to emit that many `Transfer` events in one transaction. The `Transfer` event is part of the original specification which states: > This emits when ownership of any NFT changes by any mechanism. > This event emits when NFTs are created (`from` == 0) and destroyed > (`to` == 0). Exception: during contract creation, any number of NFTs > may be created and assigned without emitting Transfer. At the time

RATIONALE:
Standardizing the `ConsecutiveTransfer` event gives decentralized platforms a standard way of determining ownership of large quantities of non-fungible tokens without the need to support a new token standard. There are many ways in which the batch creation and transfer of NFTs can be implemented. The Consecutive Transfer Extension allows contract creators to implement batch creation, transfer, and burn methods however they see fit, but provides a standardized event in which all implementations can use. By specifying a range of consecutive token identifiers we can easily cover the transfer, or creation of 2^(256) tokens and decentralized platforms can react


=== ERC-5202 ===
TITLE: Blueprint contract format
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-06-23
REQUIRES: 170

SUMMARY:
Define a standard for "blueprint" contracts, or contracts which represent initcode that is stored on-chain.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. A blueprint contract MUST use the preamble `0xFE71<version bits><length encoding bits>`. 6 bits are allocated to the version, and 2 bits to the length encoding. The first version begins at 0 (`0b000000`), and versions increment by 1. The value `0b11` for `<length encoding bits>` is reserved. In the case that the length bits are `0b11`, the third byte is considered a continuation byte (that is, the version requires multiple

MOTIVATION:
To decrease deployer contract size, a useful pattern is to store initcode on chain as a "blueprint" contract, and then use `EXTCODECOPY` to copy the initcode into memory, followed by a call to `CREATE` or `CREATE2`. However, this comes with the following problems: - It is hard for external tools and indexers to detect if a contract is a "regular" runtime contract or a "blueprint" contract. Heuristically searching for patterns in bytecode to determine if it is initcode poses maintenance and correctness problems. - Storing initcode byte-for-byte on-chain is a correctness and security problem. Since the EVM does

RATIONALE:
- To save gas and storage space, the preamble should be as minimal as possible. - It is considered "bad" behavior to try to CALL a blueprint contract directly, therefore the preamble starts with `INVALID (0xfe)` to end execution with an exceptional halting condition (rather than a "gentler" opcode like `STOP (0x00)`). - To help distinguish a blueprint contract from other contracts that may start with `0xFE`, a "magic" byte is used. The value `0x71` was arbitrarily chosen by taking the last byte of the keccak256 hash of the bytestring "blueprint" (i.e.: `keccak256(b"blueprint")[-1]`). - An empty initcode is


=== ERC-5298 ===
TITLE: ENS Trust to hold NFTs under ENS name
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2022-07-12
REQUIRES: 1, 3, 7, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This EIP standardizes an interface for smart contracts to hold of [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) tokens on behalf of ENS domains.

SPECIFICATION:
1. Compliant contracts MUST implement `ERC721TokenReceiver`, as defined in [EIP-721](./eip-721.md). 2. Compliant contracts implement the following interface: ```solidity interface IERC_ENS_TRUST is ERC721Receiver, ERC1155Receiver { function claimTo(address to, bytes32 ensNode, address operator, uint256 tokenId) payable external; } ``` 3. `claimTo` MUST check if `msg.sender` is the owner of the ENS node identified by `bytes32 ensNode` (and/or approved by the domain in implementation-specific ways). The compliant contract then MUST make a call to the `safeTransferFrom` function of [EIP-721](./eip-712.md) or [EIP-1155](./eip-1155.md). 4. Any `ensNode` is allowed.

MOTIVATION:
Currently, if someone wants to receive a token, they have to set up a wallet address. This EIP decouples NFT ownership from wallet addresses.

RATIONALE:
1. ENS was chosen because it is a well-established scoped ownership namespace. This is nonetheless compatible with other scoped ownership namespaces. 2. We didn't expose getters or setters for ensRoot because it is outside of the scope of this EIP.


=== ERC-7524 ===
TITLE: PLUME Signature in Wallets
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-24
REQUIRES: 

SUMMARY:
ZK-SNARKs have enabled ideation for new identity applications based on anonymous proof-of-ownership. One of the primary technologies that would enable the jump from existing apps to systems that require anonymous uniqueness is the development of verifiably deterministic signatures. Because Ethereum is based on ECDSA, there is no way right now for someone to verify that a signature is generated deterministically, even with ‘deterministic’ ECDSA signatures: a ZK-SNARK proof would need someone’s private key to do so, and some hardware wallets do not even allow viewing of a private key. Broadly, we don’t want to export/copy-paste the private key

SPECIFICATION:
We propose a new signature standard that offers the following properties, to be implemented for standard ECDSA keys within wallets: 1. It produces signatures that contain a deterministic component and a nondeterministic component. The deterministic component may be used as a *nullifier*. 2. Signers can use existing secpk256k1 keypairs, such as those in hardware wallets that support Ethereum accounts. As a consequence, secret keys can remain in secure enclaves if there is a generator point multiplication API into the enclave (which Ledger for instance has). ### Parameters This scheme uses the secp256k1 curve, defined in [Standards for Efficient

MOTIVATION:
- Existing ZK applications have the advantage that there is no uniqueness constraint on the provers: that is, allowing the same wallet to prove itself as a member more than once is intended. However, many applications require a maximum of one action per user, especially protocols that desire Sybil resistance. Such protocols are not natively possible on Ethereum right now without mapping each address into an opt-in mapping that also maps a user’s private key to a new system, which adds complexity, loses atomicity, and does not benefit from the rich on-chain history of Ethereum accounts. - Specific

RATIONALE:
We will define a few specific properties we are looking for in a candidate algorithm, then define a few other intuitive algorithms and explain why they don’t actually work. - Noninteractivity - The importance of noninteractivity in ZK ID systems is that it enables a large anonymity set from the start, making it resistant to sybil attacks and spam, which would be possible if there was an interactive phase. This allows for new use cases such as ZK airdrops. - Noninteractivity enables the full set of eligible users to be part of the anonymity set, without requiring any


=== ERC-1973 ===
TITLE: Scalable Rewards
TYPE: Standards Track ERC
STATUS: Stagnant
CREATED: 2019-04-01
REQUIRES: 

SUMMARY:
The mintable token rewards interface allows DApps to build a token economy where token rewards are distributed equally among the active participants. The tokens are minted based on per block basis that are configurable (E.g. 10.2356 tokens per block, 0.1 token per block, 1350 tokens per block) and the mint function can be initiated by any active participant. The token rewards distributed to each participant is dependent on the number of participants in the network. At the beginning, when the network has low volume, the tokens rewards per participant is high but as the network scales the token

SPECIFICATION:
### Definitions `token amount per participant in the ecosytem or TPP (token per participant)`: TPP = (token amount to mint / total active participants) `roundMask`: the cumulative snapshot of TPP over time for the token contract. E.g. transactionOne = 10 tokens are minted with 100 available participants (TPP = 10 / 100) , transactionTwo = 12 tokens are minted with 95 participants (TPP = 12 / 95 ) roundMask = (10/100) + (12/95) `participantMask`: is used to keep track of a `msg.sender` (participant) rewards over time. When a `msg.sender` joins or leaves the ecosystem, the player mask is

MOTIVATION:
Distributing tokens through a push system to a large amount of participants fails due to block gas limit. As the number of participants in the network grow to tens of thousands, keeping track of the iterable registry of participants and their corresponding rewards in a push system becomes unmanagable. E.g. Looping through 5000 addresses to distribute 0.0000001 reward tokens is highly inefficient. Furthermore, the gas fees in these transactions are high and needs to be undertaken by the DApp developer or the respective company, leading to centralization concerns. A pull system is required to keep the application completely

RATIONALE:
Currently, there is no standard for a scalable reward distribution mechanism. In order to create a sustainable cryptoeconomic environment within DAPPs, incentives play a large role. However, without a scalable way to distribute rewards to tens of thousands of participants, most DAPPs lack a good incentive structure. The ones with a sustainable cryptoeconomic environment depend heavily on centralized servers or a group of selective nodes to trigger the smart contracts. But, in order to keep an application truly decentralized, the reward distribution mechanism must depend on the active participants itself and scale as the number of participants grow.


=== ERC-5507 ===
TITLE: Refundable Tokens
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2022-08-19
REQUIRES: 2, 0, ,,  , 1, 6, 5, ,,  , 7, 2, 1, ,,  , 1, 1, 5, 5

SUMMARY:
This ERC adds refund functionality for initial token offerings to [ERC-20](./eip-20.md), [ERC-721](./eip-721.md), and [ERC-1155](./eip-1155.md). Funds are held in escrow until a predetermined time before they are claimable. Until that predetermined time passes, users can receive a refund for tokens they have purchased.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. All implementations MUST use and follow the directions of [ERC-165](./eip-165.md). ### ERC-20 Refund Extension ```solidity // SPDX-License-Identifier: CC0-1.0 pragma solidity ^0.8.17; import "ERC20.sol"; import "ERC165.sol"; /// @notice Refundable ERC-20 tokens /// @dev The ERC-165 identifier of this interface is `0xf0ca2917` interface ERC20Refund is ERC20, ERC165 { /// @notice Emitted when a token is refunded /// @dev Emitted by `refund` /// @param _from The account whose assets are refunded ///

MOTIVATION:
The NFT and token spaces lack accountability. For the health of the ecosystem as a whole, better mechanisms to prevent rugpulls from happening are needed. Offering refunds provides greater protection for buyers and increases legitimacy for creators. A standard interface for this particular use case allows for certain benefits: - Greater Compliance with EU "Distance Selling Regulations," which require a 14-day refund period for goods (such as tokens) purchased online - Interoperability with various NFT-related applications, such as portfolio browsers, and marketplaces - NFT marketplaces could place a badge indicating that the NFT is still refundable on listings,

RATIONALE:
`refundDeadlineOf` uses blocks instead of timestamps, as timestamps are less reliable than block numbers. The function names of `refund`, `refundOf`, and `refundDeadlineOf` were chosen to fit the naming style of ERC-20, ERC-721, and ERC-1155. [ERC-165](./eip-165.md) is required as introspection by DApps would be made significantly harder if it were not. Custom ERC-20 tokens are not supported, as it needlessly increases complexity, and the `refundFrom` function allows for this functionality when combined with a DEx. Batch refunds are optional, as account abstraction would make atomic operations like these significantly easier. However, they might still reduce gas costs if properly


=== ERC-7565 ===
TITLE: Perpetual Contract NFTs as Collateral
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-11-27
REQUIRES: 7, 2, 1, ,,  , 4, 9, 0, 7

SUMMARY:
This ERC proposes a mechanism where a person (referred to as the "Asset Owner") can collateralize NFTs that represent locked deposits or assets, to borrow funds against them. These NFTs represent the right to claim the underlying assets, along with any accrued benefits, after a predefined maturity period. [^1] [^1]: ```csl-json { "container-title": "IEEE Access", "author": [ { "given": "Hyoungsung", "family": "Kim" }, { "given": "Hyun-Sik", "family": "Kim" }, { "given": "Yong-Suk", "family": "Park" } ], "DOI": "10.1109/ACCESS.2022.3225884", "URL": "https://ieeexplore.ieee.org/document/9967987", "type": "article-journal", "id": 9967987, "citation-label": "9967987", "issued": { "date-parts": [ [ 2022 ] ] }, "keyword": "Contracts;Nonfungible tokens;Cryptocurrency;Finance;Smart

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Contract Interface Solidity interface. ```solidity interface IPerpetualContractNFT { // Emitted when an NFT is collateralized for obtaining a loan event Collateralized(uint256 indexed tokenId, address indexed owner, uint256 loanAmount, uint256 interestRate, uint256 loanDuration); // Emitted when a loan secured by an NFT is fully repaid, releasing the NFT from collateral event LoanRepaid(uint256 indexed tokenId, address indexed owner); // Emitted when a loan defaults, resulting

MOTIVATION:
The rapidly evolving landscape of DeFi has introduced various mechanisms for asset locking, offering benefits like interest and voting rights. However, one of the significant challenges in this space is maintaining liquidity while these assets are locked. This ERC addresses this challenge by proposing a method to generate profit from locked assets using [ERC-721](./eip-721.md) and [ERC-4907](./eip-4907.md). In DeFi services, running Automated Market Maker (AMM), liquidity providers contribute assets to pools and receive NFTs representing their stake. These NFTs denote the rights to the assets and the associated benefits, but they also lock the assets in the pool, often

RATIONALE:
### Design Motivation The design of this standard is driven by the need to address specific challenges in the DeFi sector, particularly concerning the liquidity and management of assets locked as collateral. Traditional mechanisms in DeFi often require asset holders to lock up their assets for participation in activities such as lending, staking, or yield farming, which results in a loss of liquidity. This standard aims to introduce a more flexible approach, allowing asset holders to retain some liquidity while their assets are locked, thereby enhancing the utility and appeal of DeFi products. ### Design Decision - Dual-Role


=== ERC-7527 ===
TITLE: Token Bound Function Oracle AMM
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-09-03
REQUIRES: 1, 6, 5, ,,  , 7, 2, 1

SUMMARY:
This proposal outlines interfaces for wrapping [ERC-20](./eip-20.md) or ETH to [ERC-721](./eip-721.md) and unwrap ERC-721 to ERC-20 or ETH. A function oracle feeds mint/burn prices based on an embedded equation of Function Oracle Automated Market Maker(FOAMM), which executes and clears the mint and burn of NFT.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Contract Interfaces: Three interfaces are included here: `Agency`, `App`, and `Factory`. `Agency` and `App` MAY be implemented by the same contract or MAY be separately implemented. If separately implemented, they SHALL be mutually bounded and not upgradable after initialization. `Agency` and `App` should implement `iconstructor` interface to initialize the parameters within the contract and validate the configuration parameters. If factory is used to deploy

MOTIVATION:
Liquidity can be a significant challenge in decentralized systems, especially for unique or less commonly traded tokens like NFTs. To foster a trustless NFT ecosystem, the motivation behind Function Oracle Automated Market Maker(FOAMM) is to provide automated pricing solutions for NFTs with liquidity through transparent, smart contract mechanisms. This ERC provides innovative solutions for the following aspects: - Automated Price Discovery - Liquidity Enhancement ### Automated Price Discovery Transactions under FOAMM can occur without the need for a matching counterparty. When interacting directly with the pool, FOAMM automatically feeds prices based on the oracle with predefined function. ###

RATIONALE:
### Prior Interfaces [ERC-5679](./eip-5679.md) proposed `IERC5679Ext721` interface for introducing a consistent way to extend [ERC-721](./eip-721.md) token standards for minting and burning. To ensure the backward compatibility, considering some contracts which do not implement `ERC721TokenReceiver`, `IERC7527App` employ `mint` function instead of `safeMint`. To ensure the safety and the uniqueness of mutual bound, the `_from` parameter of the `burn` function in `IERC5679Ext721` must be the contract address of the bounded agency. Thus, `burn` function in `IERC7527App` does not contain the `_from` parameter. ### Mutual Bound Implement contracts for `IERC7527App` and `IERC7527Agency` so that they are each other's only owner. The


=== ERC-7582 ===
TITLE: Modular Accounts with Delegated Validation
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2023-12-25
REQUIRES: 4337

SUMMARY:
This proposal standardizes a method for adding plugins and composable logic to smart contract accounts built on existing interfaces like [ERC-4337](eip-4337.md) (e.g., ERC-4337's `IAccount`). Specifically, by formalizing how applications can use the ERC-4337 Entry Point `NonceManager` and the emission of the `IEntryPoint` `UserOperationEvent` to account for plugin interactions, as well, as how to extract designated validators (in this case, by means of `IAccount`'s `validateUserOp`), accounts can specify how they call plugin contracts and grant special executory access for more advanced operations. Furthermore, this minimalist plugin approach is developer-friendly and complimentary to existing account abstraction standards by not requiring

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ![diagram showing proposed flow](../assets/eip-7582/base-flow.svg) We leverage the key in ERC-4337 semi-abstracted nonce as the pointer to `validator` identifier. If a non-sequential key (`>type(uint64).max`) is used as an ERC-4337 Entry Point `UserOperation` (userOp) `nonce`, the `validateUserOp` function in the `sender` contract account MUST extract the validator identifier, this MAY be the address itself or a pointer to the validator address in storage. Once the validator

MOTIVATION:
Smart contract accounts (contract accounts) are a powerful tool for managing digital assets and executing transactions by allowing users to program their interactions with blockchains. However, they are often limited in their functionality and flexibility without sufficient consensus around secure abstraction designs (albeit, the adoption of ERC-4337 is the preferred path of this proposal). For example, contract accounts are often unable to support social recovery, payment schedules, and other features that are common in traditional financial systems without efficient and predictable schemes to delegate execution and other access rights to approximate the UX of custodial and more specialized


=== ERC-6809 ===
TITLE: Non-Fungible Key Bound Token
TYPE: Standards Track ERC
STATUS: Final
CREATED: 2023-03-31
REQUIRES: 721

SUMMARY:
A standard interface for Non-Fungible Key Bound Tokens (**NFKBT/s**), a subset of the more general Key Bound Tokens (**KBT/s**). The following standardizes an API for tokens within smart contracts and provides basic functionality to the [addBindings](#addbindings-function) function. This function designates **Key Wallets**[^1], which are responsible for conducting a **Safe Transfer**[^2]. During this process, **NFKBT's** are safely approved so they can be spent by the user or an on-chain third-party entity. The premise of **NFKBT's** is to provide fully optional security features built directly into the non-fungible asset, via the concept of _allow_ found in the [allowTransfer](#allowtransfer-function) and [allowApproval](#allowapproval-function)

SPECIFICATION:
### `IKBT721` (Token Contract) **NOTES**: - The following specifications use syntax from Solidity `0.8.17` (or above) - Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned! ```solidity interface IKBT721 { event AccountSecured(address indexed _account, uint256 _noOfTokens); event AccountResetBinding(address indexed _account); event SafeFallbackActivated(address indexed _account); event AccountEnabledTransfer( address _account, uint256 _tokenId, uint256 _time, address _to, bool _anyToken ); event AccountEnabledApproval( address _account, uint256 _time, uint256 _numberOfTransfers ); event Ingress(address _account, uint256 _tokenId); event Egress(address _account, uint256 _tokenId); struct AccountHolderBindings { address firstWallet; address secondWallet; } struct FirstAccountBindings { address accountHolderWallet; address

MOTIVATION:
In this fast-paced technologically advancing world, people learn and mature at different speeds. The goal of global adoption must take into consideration the target demographic is of all ages and backgrounds. Unfortunately for self-custodial assets, one of the greatest pros is also one of its greatest cons. The individual is solely responsible for their actions and adequately securing their assets. If a mistake is made leading to a loss of funds, no one is able to guarantee their return. From January 2021 through March 2022, the United States Federal Trade Commission received more than 46,000[^5] crypto scam reports.

RATIONALE:
The intent from individual technical decisions made during the development of **NFKBTs** focused on maintaining consistency and backward compatibility with ERC-721s, all the while offering self-custodial security features to the user. It was important that **NFKBT's** inherited all of ERC-721s characteristics to comply with requirements found in dApps which use non-fungible tokens on their platform. In doing so, it allowed for flawless backward compatibility to take place and gave the user the choice to decide if they want their **NFKBTs** to act with **Default Behaviors**[^4]. We wanted to ensure that wide-scale implementation and adoption of **NFKBTs** could take


=== ERC-7604 ===
TITLE: ERC-1155 Permit Approvals
TYPE: Standards Track ERC
STATUS: Draft
CREATED: 2024-01-27
REQUIRES: 1, 6, 5, ,,  , 7, 1, 2, ,,  , 1, 1, 5, 5, ,,  , 1, 2, 7, 1, ,,  , 2, 0, 9, 8, ,,  , 5, 2, 1, 6

SUMMARY:
The "permit" approval flow for both [ERC-20](./eip-20.md) and [ERC-721](./eip-721.md) are large improvements for the existing UX of the token underlying each ERC. This ERC extends the "permit" pattern to [ERC-1155](./eip-20.md) tokens, borrowing heavily upon both [ERC-4494](./eip-4494.md) and [ERC-2612](./eip-2612.md). The structure of [ERC-1155](./eip-1155.md) tokens requires a new ERC to account for the token standard's use of both token IDs and balances (also why this ERC requires [ERC-5216](./eip-5216.md)).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Three new functions must be added to ERC-1155 and ERC-5216. ```solidity interface IERC1155Permit { function permit(address owner, address operator, uint256 tokenId, uint256 value, uint256 deadline, bytes memory sig) external; function nonces(address owner, uint256 tokenId) external view returns (uint256); function DOMAIN_SEPARATOR() external view returns (bytes32); } ``` The semantics of which are as follows: For all addresses `owner`, `spender`, uint256's `tokenId`, `value`, `deadline`, and `nonce`,

MOTIVATION:
The permit structures outlined in both [ERC-4494](./eip-4494) and [ERC-2612](./eip-2612) allows a signed message to create an approval, but are only applicable to their respective underlying tokens ([ERC-721](./eip-721) and [ERC-20](./eip-20)).

RATIONALE:
The `permit` function is sufficient for enabling a `safeTransferFrom` transaction to be made without the need for an additional transaction. The format avoids any calls to unknown code. The `nonces` mapping is given for replay protection. A common use case of permit has a relayer submit a Permit on behalf of the owner. In this scenario, the relaying party is essentially given a free option to submit or withhold the Permit. If this is a cause of concern, the owner can limit the time a Permit is valid for by setting deadline to a value in the near
