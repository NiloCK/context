=== EIP-7612 ===
TITLE: Verkle state transition via an overlay tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-01-25
REQUIRES: 4, 7, 6, 2, ,,  , 6, 8, 0, 0, ,,  , 7, 5, 4, 5

SUMMARY:
This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT “laid over” the hexary MPT. The historical MPT state is

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants | Parameter | value | Description | | ----------- | ----- | --------------------------------------------

MOTIVATION:
The Ethereum state is growing, and VKTs offer a good mitigation strategy to stem this growth and enable weak statelessness. Owing to the difficulty of translating contracts with large storage while they are being accessed, proposals for migrating the current MPT state are complex and will require client teams

RATIONALE:
This approach doesn't convert the state, which is left to a subsequent EIP. This is meant as a stopgap in case we decide to push the conversion itself to a later time. It has the advantage of simplicity, which means that the Verge fork could happen at the same


=== EIP-3026 ===
TITLE: BW6-761 curve operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-05
REQUIRES: 2539

SUMMARY:
This precompile adds operations for the BW6-761 curve (from the EY/Inria **Optimized and secure pairing-friendly elliptic curves suitable for one layer proof composition** research paper) as a precompile in a set necessary to *efficiently* perform verification of one-layer composed zkSNARKs proofs. If `block.number >= X` we introduce *seven* separate

SPECIFICATION:
Curve parameters: The BW6-761 `y^2=x^3-1` curve is fully defined by the following set of parameters: ``` Base field modulus = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008b A coefficient = 0x0 B coefficient = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008a Main subgroup order = 0x1ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001 Extension tower: Fp3 construction: (Fp3 = Fp[u]/u^3+4) Fp cubic non-residue = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d000000000087 Twist parameters: Twist

MOTIVATION:
This EIP is based on and tends to replace matter-labs' proposal for significant performance reasons. In most applications, BW6-761 is used as an outer curve to BLS12-377 considered in [EIP-2539](./eip-2539.md). The motivation of this precompile is to allow efficient one-layer composition of SNARK proofs. Currently this is done by

RATIONALE:
Gas costs are based on [EIP-1962](./eip-1962.md) estimation strategy (but do not fully include yet parsing of ABI, decoding and encoding of the result as a byte array). ### Gas estimation strategy Gas cost is derived by taking the average timing of the same operations over different implementations and assuming


=== EIP-7873 ===
TITLE: EOF - TXCREATE and InitcodeTransaction type
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-01-31
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 3, 8, 6, 0, ,,  , 7, 6, 2, 0

SUMMARY:
EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an empty `to` field), `CREATE` or `CREATE2` instructions. We introduce a new instruction: `TXCREATE`, as well as a new transaction type (`InitcodeTransaction`), to provide a way to create contracts using EOF containers in transaction data.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Parameters | Constant | Value | |-----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| | `INITCODE_TX_TYPE` | `Bytes1(0x06)` | | `MAX_INITCODE_COUNT`

MOTIVATION:
This EIP uses terminology from the [EIP-3540](./eip-3540.md) which introduces the EOF format. Creation transaction and creation instructions `CREATE` and `CREATE2` are means provided by legacy EVM to deploy new code, but per requirement of removing code observability, they are not allowed to deploy EOF code. To allow Externally Owned

RATIONALE:
### `TXCREATE` failure modes `TXCREATE` has two "light" failure modes in case the initcontainer is not present and in case the EOF validation is unsuccessful. An alternative design where both cases led to a "hard" failure (consuming the entire gas available) was considered. We decided to have the more


=== EIP-7840 ===
TITLE: Add blob schedule to EL config files
TYPE: Informational 
STATUS: Final
CREATED: 2024-12-12
REQUIRES: 

SUMMARY:
Add a new object to client configuration files `blobSchedule` which lists the target blob count per block and max blob count per block for each fork.

SPECIFICATION:
Extend client configuration files with the object `blobSchedule`, which has the following shape: ```json "blobSchedule": { "cancun": { "target": 3, "max": 6, "baseFeeUpdateFraction": 3338477 }, "prague": { "target": 6, "max": 9, "baseFeeUpdateFraction": 5007716 } } ``` Clients must configure the target, max and baseFeeUpdateFraction per-fork. The behavior when the

MOTIVATION:
- ensure there is a way to dynamically adjust the target and max blob counts per block - ensure there is a way to dynamically adjust the blob base fee update fraction - avoid complex handshake over engine API

RATIONALE:
Although maintaining the target and max blob only in the consensus client is desirable, we acknowledge the reality that execution clients need these values for various activities. For example, the `eth_feeHistory` RPC method returns a field `blobGasUsedRatio` that does require the max, even though the core protocol doesn't specifically


=== EIP-8068 ===
TITLE: Neutral effective balance design
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-28
REQUIRES: 7251

SUMMARY:
This EIP proposes a neutral effective balance (EB) design to ensure `0x01` (skimming) and `0x02` (compounding) validators receive equal yields. Currently, validators that compound their balance have poor capital efficiency and lower yields as their idle balance (not contributing to EB) is 0.75 ETH, significantly higher than that of

SPECIFICATION:
### Parameters Change two existing constants: | Constant | Value | - | - | | `HYSTERESIS_DOWNWARD_MULTIPLIER` | `3` | | `HYSTERESIS_UPWARD_MULTIPLIER` | `2` | ### Containers Two new fields are added to the state: ```python class BeaconState(Container): ... temporary_upward_threshold: List[Gwei, VALIDATOR_REGISTRY_LIMIT] reset_eb_flags: List[boolean, VALIDATOR_REGISTRY_LIMIT] ``` On upgrade, both

MOTIVATION:
The roadmap for fast finality hinges on stake consolidation, where staking service providers (SSPs) transition from running 32-ETH validators with `0x01` credentials to compounding validators with `0x02` credentials. A roadblock to this transition is that `0x01` validators have close-to-ideal capital efficiency, whereas `0x02` validators have poor capital efficiency during

RATIONALE:
### Relative change in staking yield The figure shows the impact of the current EB bands and hysteresis design on validator yields for different validator configuations. The relative change in staking yield is plotted against a baseline 0 which corresponds to what compounding `0x02` validators would earn if $E=b$,


=== EIP-6189 ===
TITLE: Alias Contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2, 9, 2, 9, ,,  , 6, 1, 8, 8

SUMMARY:
This EIP allows contracts to be turned into "alias contracts" using a magic nonce. Alias contracts automatically forward calls to other contracts.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions A contract is an alias contract if its nonce is `2^64-1`, and its contract code

MOTIVATION:
This EIP is not terribly useful on its own, as it adds additional computation and gas costs without any useful side effects. However, in conjunction with [EIP-6190](./eip-6190.md), it can be used to make SELFDESTRUCT compatible with Verkle trees.

RATIONALE:
The additional gas cost of `25` represents the cost of fetching the nonce and comparing it to the given value. `eth_getStorageAt` was modified to throw an error because of alias contracts' special behavior. The nonce of `2^64-1` was chosen since it is the nonce protected by [EIP-6188](./eip-6188.md). The contract


=== EIP-3085 ===
TITLE: wallet_addEthereumChain RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-11-01
REQUIRES: 155

SUMMARY:
This EIP adds a wallet-namespaced RPC method: `wallet_addEtherereumChain`, providing a standard interface for adding chains to Ethereum wallets.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal defines a new RPC method, `wallet_addEthereumChain`. ### `wallet_addEthereumChain` The `wallet_addEthereumChain` method is used to suggest to the wallet

RATIONALE:
The design of `wallet_addEthereumChain` is deliberately ignorant of what it means to "add" a chain to a wallet. The meaning of "adding" a chain to a wallet depends on the wallet implementation. When calling the method, specifying the `chainId` will always be necessary, since in the universe of Ethereum


=== EIP-7503 ===
TITLE: Zero-Knowledge Wormholes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-08-14
REQUIRES: 2, 7, 1, 8, ,,  , 4, 8, 4, 4, ,,  , 7, 7, 0, 8

SUMMARY:
While researching on privacy solutions and applications of ZKP, we discovered a technique, by which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, and later build a ZK proof showing that some amount of tokens reside in an account that are unspendable,

SPECIFICATION:
### Parameters * `MAGIC_ADDRESS`: `0xfe` (one byte) * `MAGIC_NULLIFIER`: `0x01` (one byte) * `MAGIC_POW`: `0x02` (one byte) * `MAGIC_CHANGE`: `0x0404040404040404040404040404040404040404040404040404040404040404` * `POW_LOG_DIFFICULTY`: `24` * `MAX_DEPOSIT`: `32 * 10**18` wei * `WormholeTxType`: `TBD` * `WORMHOLE_NULLIFIER_ADDRESS`: `TBD` * `RECEIPT_PREFIX`: `TBD` (datatype `List[bool]`) - - - We define a new [EIP-2718](./eip-2718.md) transaction


=== EIP-3044 ===
TITLE: Adds `baseFee` to `eth_getBlockByNumber`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getBlockByNumber` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getBlockByNumber` #### Description Returns information about a block specified by number. Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-6913 ===
TITLE: SETCODE instruction
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2023-04-20
REQUIRES: 

SUMMARY:
Introduce the `SETCODE` (`0xfc`) instruction, which replaces the code of the executing account from memory.

SPECIFICATION:
When within a read-only execution scope like the recursive kind created by `STATICCALL`, `SETCODE` causes an exceptional abort. When the currently executing code does not equal the code of the executing account, such as can happen inside of `DELEGATECALL` or `CREATE`, `SETCODE` causes an exceptional abort. Otherwise, `SETCODE` consumes

MOTIVATION:
Many contracts are upgradeable in order to facilitate improvement or defer decisions without migrating to a new address. Contracts presently do this in several ways: The oldest method uses `CALL`. The limitation of this method is that internal state must be modifiable by all future implementations. Second, `DELEGATECALL` can

RATIONALE:
The behavior of `CODECOPY`, `CODESIZE`, `EXTCODESIZE`, and `EXTCODECOPY` match the behavior of `DELEGATECALL` and `CREATE`, where it is also possible for executing code to differ from the code of the executing account. The gas cost of `SETCODE` is comparable to `CREATE` but excludes `Gcreate` because no execution context is


=== EIP-7886 ===
TITLE: Delayed execution
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-02-18
REQUIRES: 1, 5, 5, 9, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4, ,,  , 7, 6, 2, 3, ,,  , 7, 7, 0, 2

SUMMARY:
This proposal introduces a mechanism to make execution blocks statically verifiable through minimal checks that only require the previous state, without requiring execution of the block's transactions. This enables validators to attest to a block's validity without completing its execution.

SPECIFICATION:
### Header Changes The block header structure is extended to support delayed execution: ```python @dataclass class Header: # Existing fields parent_hash: Hash32 ommers_hash: Hash32 coinbase: Address # Pre-execution state root - this is the state root before executing transactions pre_state_root: Root # Deferred execution outputs from parent block parent_transactions_root:

MOTIVATION:
The primary advantage of this proposal is **asynchronous block validation**. In the current Ethereum protocol, blocks must be fully executed before validators can attest to them. This requirement creates a bottleneck in the consensus process, as attestors must wait for execution results before committing their votes, limiting the network's

RATIONALE:
### Deferred Execution Outputs The core innovation of deferring execution outputs to the next block enables static and stateful validation without requiring immediate execution. The `pre_state_root` provides a cryptographically verifiable starting point for validation, while parent execution outputs create a chain of deferred execution results that maintains the integrity


=== EIP-747 ===
TITLE: wallet_watchAsset RPC Method
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2018-08-13
REQUIRES: 2, 0, ,,  , 1, 0, 4, 6, ,,  , 1, 1, 9, 3

SUMMARY:
This EIP standardizes a new wallet-scoped RPC method, `wallet_watchAsset`, to allow a client to suggest a token for the user's wallet to track.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A new RPC method, `wallet_watchAsset` is added. `wallet_watchAsset` requests that a specified asset be listed

MOTIVATION:
Today, one of the major uses of Ethereum wallets is to track users' assets. Without this EIP, each wallet either needs to pre-load a list of approved assets, or users must manually add assets to their wallet. In the first case, wallets are burdened with both the security of

RATIONALE:
Displaying a user's assets is a basic feature that every modern DApp user expects. Most wallets currently either manage their own asset lists, which they store client-side, or they query a centralized API for balances, which reduces decentralization and allows correlating account holders with IP addresses. Additionally, refreshing/polling an


=== EIP-6190 ===
TITLE: Verkle-compatible SELFDESTRUCT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2, 9, 2, 9, ,,  , 6, 1, 8, 8, ,,  , 6, 1, 8, 9

SUMMARY:
Changes `SELFDESTRUCT` to only cause a finite number of state changes.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Prerequisites [EIP-6188](./eip-6188.md) and [EIP-6189](./eip-6189.md) must be used for this EIP to function correctly. ### `SELFDESTRUCT` Behaviour

MOTIVATION:
The `SELFDESTRUCT` instruction has a fixed price, but is unbounded in storage/account changes (it needs to delete all keys). This has been an outstanding concern for some time. Furthermore, with *Verkle trees* accounts will be organised differently. Account properties, including storage, would have individual keys. It would not be

RATIONALE:
This EIP is designed to be a step towards supporting `SELFDESTRUCT` in Verkle trees while making the minimum amount of changes. The `5000` base gas cost and additional alias contracts represents the cost of setting the account nonce and first storage slot. The [EIP-2929](./eip-2929.md) gas cost increase is preserved


=== EIP-234 ===
TITLE: Add `blockHash` to JSON-RPC filter options.
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-03-24
REQUIRES: 1474

SUMMARY:
This addition would allow clients to fetch logs for specific blocks, whether those blocks were in the current main chain or not. This resolves some issues that make it difficult/expensive to author robust clients due to the nature of chain reorgs, unreliable network connections and the result set not

SPECIFICATION:
The filter options used by `eth_newFilter` would have an additional optional parameter named `blockHash` whose value is a single block hash. The Ethereum node responding to the request would either send back an error if the block hash was not found or it would return the results matching the

RATIONALE:
A client (dApp) who needs reliable notification of both log additions (on new blocks) and log removals (on chain reorgs) cannot achieve this while relying solely on subscriptions and filters. This is because a combination of a network or remote node failure during a reorg can result in the


=== EIP-6968 ===
TITLE: Contract Secured Revenue on an EVM based L2
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-05-01
REQUIRES: 


=== EIP-658 ===
TITLE: Embedding transaction status code in receipts
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-06-30
REQUIRES: 140

SUMMARY:
This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.

SPECIFICATION:
For blocks where block.number >= BYZANTIUM_FORK_BLKNUM, the intermediate state root is replaced by a status code, 0 indicating failure (due to any operation that can cause the transaction or top-level call to revert) and 1 indicating success.

MOTIVATION:
With the introduction of the REVERT opcode in EIP140, it is no longer possible for users to assume that a transaction failed iff it consumed all gas. As a result, there is no clear mechanism for callers to determine whether a transaction succeeded and the state changes contained in

RATIONALE:
This constitutes a minimal possible change that permits fetching the success/failure state of transactions, preserving existing capabilities with minimum disruption or additional work for Metropolis.


=== EIP-606 ===
TITLE: Hardfork Meta: Homestead
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 2, ,,  , 7, ,,  , 8

SUMMARY:
This specifies the changes included in the hard fork named Homestead.

SPECIFICATION:
- Codename: Homestead - Activation: - Block >= 1,150,000 on Mainnet - Block >= 494,000 on Morden - Block >= 0 on future testnets - Included EIPs: - [EIP-2](./eip-2.md) (Homestead Hard-fork Changes) - [EIP-7](./eip-7.md) (DELEGATECALL) - [EIP-8](./eip-8.md) (Networking layer: devp2p Forward Compatibility Requirements for Homestead)


=== EIP-1057 ===
TITLE: ProgPoW, a Programmatic Proof-of-Work
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
ProgPoW is a proof-of-work algorithm designed to close the efficiency gap available to specialized ASICs. It utilizes almost all parts of commodity hardware (GPUs), and comes pre-tuned for the most common hardware utilized in the Ethereum network. This document presents an overview of the algorithm and examines what it

SPECIFICATION:
ProgPoW can be tuned using the following parameters. The proposed settings have been tuned for a range of existing, commodity GPUs: * `PROGPOW_PERIOD`: Number of blocks before changing the random program * `PROGPOW_LANES`: The number of parallel lanes that coordinate to calculate a single hash instance * `PROGPOW_REGS`: The

MOTIVATION:
Ever since the first bitcoin mining ASIC was released, many new Proof of Work algorithms have been created with the intention of being “ASIC-resistant”. The goal of “ASIC-resistance” is to resist the centralization of PoW mining power such that these coins couldn’t be so easily manipulated by a few


=== EIP-5283 ===
TITLE: Semaphore for Reentrancy Protection
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-07-17
REQUIRES: 2, 0, ,,  , 1, 2, 8, 3, ,,  , 1, 3, 5, 2

SUMMARY:
This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage,

SPECIFICATION:
Starting from an activation block (TBD) a new precompiled contract `Semaphore` is created at address `0x0A`. When `Semaphore` is called, if the caller address is present more than once in the call stack, the contract behaves as if the first instruction had been a `REVERT`, therefore the CALL returns

MOTIVATION:
The typical smart contract RPG uses a contract storage cell. The algorithm is simple: the code checks that a storage cell is 0 (or any other predefined constant) on entry, aborting if not, and then sets it to 1. After executing the required code, it resets the cell back

RATIONALE:
The address `0x0A` is the next one available within the range defined by [EIP-1352](./eip-1352). ### Sample usage ```solidity pragma solidity ^0.8.0; abstract contract ReentrancyGuard2 { uint8 constant SemaphoreAddress = 0x0A; /** * @dev Prevents a contract from calling itself, directly or indirectly. * Calling a `nonReentrant` function from another


=== EIP-7547 ===
TITLE: Inclusion lists
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-24
REQUIRES: 

SUMMARY:
Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.

SPECIFICATION:
### Constants | Name | Value | | - | - | | `MAX_TRANSACTIONS_PER_INCLUSION_LIST` | `2**4 = 16` | | `MAX_GAS_PER_INCLUSION_LIST` | `2**21` | | `MIN_SLOTS_FOR_INCLUSION_LIST_REQUEST` | `1` | #### Reference Objects ``` class InclusionListSummaryEntry(Container): address: ExecutionAddress gas_limit: uint64 ``` ``` class InclusionListSummary(Container) slot: Slot proposer_index: ValidatorIndex summary: List[InclusionListSummaryEntry,

MOTIVATION:
Since the merge, validators have started outsourcing almost all block production to a specialized set of builders who compete to extract the most MEV (this is commonly referred to as Proposer-Builder Separation). As of October 2023, nearly 95% of blocks are built by builders rather than the proposer. While

RATIONALE:
We consider a few design decisions present in this EIP. 1. `ReducedSummary` versus `Summary` - The original proposal tries to improve data efficiency by using a `ReducedSummary` and a `Rebuilder`. This allows the full summary to be reconstructed. - This adds a lot of complexity to the spec, so


=== EIP-2997 ===
TITLE: IMPERSONATECALL Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-24
REQUIRES: 

SUMMARY:
Add a new opcode, `IMPERSONATECALL` at `0xf6`, which is similar in idea to `CALL (0xF1)`, except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.

SPECIFICATION:
`IMPERSONATECALL`: `0xf6`, takes 7 operands: - `gas`: the amount of gas the code may use in order to execute; - `to`: the destination address whose code is to be executed; - `in_offset`: the offset into memory of the input; - `in_size`: the size of the input in bytes; -

MOTIVATION:
This proposal enables native multi-user wallets (wallets that serve multiple users) that can be commanded by EIP-712 based messages and therefore enable meta-transactions. Multi-user wallets also enable the aggregation of transfer operations in batches similar to rollups, but maintaining the same address space as normal onchain transactions, so the

RATIONALE:
Even if `IMPERSONATECALL` requires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn't not compensate increasing the complexity of the implementation. We use the zeros32 field to base address derivation in a pre-image of similar size than CREATE2 and


=== EIP-7957 ===
TITLE: EVM64 - EOF support
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-26
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 7, 9, 3, 7

SUMMARY:
This EIP defines EOF support for EVM64 with its additional code validation rules and `RJUMPI`, `RJUMPV` opcodes.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. We define the following gas cost constant: | Name | Gas | |------|-----| | `G_RJUMPIV64`

MOTIVATION:
EOF defines a stricter code validation rule to improve efficiency. Due to EVM64 using multibyte opcode (the mode opcode `C0`), a small adaptation is needed. This EIP also additionally defines a 64-bit mode `RJUMPI` and `RJUMPV` to be 64-bit.

RATIONALE:
For detailed rationale discussion, please see the core EVM64 definition [EIP-7937](./eip-7937.md).


=== EIP-1895 ===
TITLE: Support for an Elliptic Curve Cycle
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-03-31
REQUIRES: 

SUMMARY:
Adds supports for the following operations through precompiles: * `ecadd` on MNT4 * `ecmul` on MNT4 * `ecpairing` on MNT4

SPECIFICATION:
### The curve The proposed cycle has been introduced in [Scalable Zero Knowledge via Cycles of Elliptic Curves](https://eprint.iacr.org/2014/595.pdf). ### MNT4 definition The groups `G_1` and `G_2` are cyclic groups of prime order : ```. q = 475922286169261325753349249653048451545124878552823515553267735739164647307408490559963137 ``` `G_1` is defined over the field `F_p` of prime order :

MOTIVATION:
Elliptic curve is the basic block of recursive SNARKs (ie: verifying a SNARK inside a SNARK) and this addresses the issue of scalable zero-knowledge. More generally this addresses partly the scalability issue as SNARKs verification are constant time in the size of the circuit being verified. More concretely, today

RATIONALE:
The curve has 80 bits of security (whereas MNT6 has 120 bits) which might not be considered enough for critical security level, (for instance transferring several billions), but enough for others. If it turns out this is not enough security for adoption, there is another option : another cycle


=== EIP-7980 ===
TITLE: Ed25519 transaction support
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2025-06-25
REQUIRES: 7932

SUMMARY:
This EIP adds a new [EIP-7932](./eip-7932.md) algorithm of type `0x0` for supporting Ed25519 signatures.

SPECIFICATION:
This EIP defines a new [EIP-7932](./eip-7932.md) algorithmic type with the following parameters: | Constant | Value | | - | - | | `ALG_TYPE` | `Bytes1(0x0)` | | `GAS_PENALTY`| `1000` | | `MAX_SIZE` | `96` | ```python def verify(signature_info: bytes, payload_hash: Hash32) -> ExecutionAddress: assert(len(signature_info) == 96) signature =

MOTIVATION:
Ed25519 is one of the most widely used forms of Elliptic Curve Cryptography and is one of the defaults for SSH keys, this makes it a good contender to be able to sign transactions with. It also provides an algorithm to write test cases against during the implementation phase

RATIONALE:
### Additional 1000 gas penalty The gas penalty discourages people from attempting to migrate off current secp256k1 accounts, and also covers the additional overhead (in regards to hashing) that the ed25519 curve applies. ### Why Ed25519? Ed25519 has significant tooling backing it, this makes it a good candidate for


=== EIP-158 ===
TITLE: State clearing
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-16
REQUIRES: 


=== EIP-2025 ===
TITLE: Block Rewards Proposal for funding Eth1.x
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-04-20
REQUIRES: 1890

SUMMARY:
This EIP extends the mechanism established in EIP-1890 to add `0.0055 ETH` to the block reward for a specific distribution period of `3,100,000 BLOCKS`(≈ 18 months). The `RECIPIENT_ADDRESS` is set to a smart contract with hardcoded denominations that distributes incoming ETH to a set of addresses for the purpose

SPECIFICATION:
Two constants will be introduced: - `REWARD_DURATION_IN_BLOCKS`, which specifies the number of blocks after `ISTANBUL_BLOCK_HEIGHT` when the reward collection will terminate (i.e., at block `ISTANBUL_BLOCK_HEIGHT + REWARD_DURATION_IN_BLOCKS`) - `BENEFICIARY_ADDRESSES`, a list of tuples containing the address and the amount to be transferred to this address per block. These amounts

MOTIVATION:
The context for this proposal came from attending the [Core Dev Eth1.X Meeting](https://www.youtube.com/watch?v=Au1Qll-86v0) in Berlin. Development is needed to move Eth1.X forward, and I observed that a lack of funding is the primary barrier to this work. This work can only be effectively conducted by working groups forming around

RATIONALE:
There has been great public debate concerning EIP-1890, and one of the primary concerns is that it is difficult to evaluate the proposal without more complete information on how funds would be raised, how they would be administered, and how they would be used. There is a need for


=== EIP-7801 ===
TITLE: etha - Sharded Blocks Subprotocol
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2024-10-30
REQUIRES: 7642

SUMMARY:
This EIP proposes the creation of a new subprotocol, `etha`, enabling Ethereum nodes to communicate available block spans via a bitmask. Each bit represents a 106_496-block span within each 1_064_960 block range of chain history. Nodes use this bitmask to signal stored spans and commit to storing future spans

SPECIFICATION:
### Subprotocol Handshake - Introduce a new subprotocol named `etha`. - Define the handshake message for the `etha` subprotocol as follows: - Handshake packet: `[version: P, networkid: P, blockhash: B_32, genesis: B_32, forkid, blockBitmask]` - `blockBitmask` is a 10-bit bitmask, with each bit representing a 106_496-block range per 1_064_960

MOTIVATION:
With [EIP-4444](./eip-4444.md), nodes may prune historical data while others continue serving it. Determining data availability by connecting and requesting blocks is inefficient consuming unnecessary bandwidth. This EIP addresses this inefficiency by enabling nodes to shard chain history into 106_496 block segments and signal availability via a bitmask. By introducing

RATIONALE:
The bitmask approach provides a flexible means to represent and retain block data while committing to future spans. This mechanism aligns with the pruning proposed in EIP-4444, while ensuring that historical and future data spans remain available across the network. A similar bitlist approach is already used in the


=== EIP-2474 ===
TITLE: Coinbase calls
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-01-19
REQUIRES: 

SUMMARY:
_In proof-of-work blockchains, validators are known as miners._ The validator might want to execute functions directly, without having to sign a transaction. Some examples might be presenting a proof in a contract for a change which also benefits the validator. A notable example would be when a validator want

SPECIFICATION:
The calls to be executed by `block.coinbase` would be included first at block, and would consume normally the gas of block, however they won't pay/cost gas, instead the call logic would pay the validator in other form. Would be valid to execute any calls without a transaction by the

MOTIVATION:
In order to reduce the overhead of calls that don't use `msg.sender` and are being called by validator with `tx.gasPrice = 0`.

RATIONALE:
TBD


=== EIP-3416 ===
TITLE: Median Gas Premium
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-18
REQUIRES: 

SUMMARY:
There is a base fee per gas in protocol, which can move up or down by a maximum of 1/8 in each block. The base fee per gas is adjusted by the protocol to target an average gas usage per block instead of an absolute gas usage per block.

SPECIFICATION:
### Definitions This is a classic fork without a long migration time. * `FORK_BLOCK_NUMBER`: TBD. Block number at or after which EIP-3416 transactions are valid. * `GAS_TARGET_MAX_CHANGE`: `1 // 1024`. * `BLOCK_GAS_USED`: total gas consumed by transaction included in the block. * `PARENT_GAS_USED`: same as `BLOCK_GAS_USED` for parent block.

MOTIVATION:
We target the following goals: * Gas prices spikes are mathematically smoothed out. EIP1559 does not seems to really tackle gas premium volatility and UX. * Maintain gas price preference, i.e. transaction senders willing to pay extra in fees will be rewarded with early preferential inclusion in the blocks,


=== EIP-609 ===
TITLE: Hardfork Meta: Byzantium
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 0, 0, ,,  , 1, 4, 0, ,,  , 1, 9, 6, ,,  , 1, 9, 7, ,,  , 1, 9, 8, ,,  , 2, 1, 1, ,,  , 2, 1, 4, ,,  , 6, 0, 7, ,,  , 6, 4, 9, ,,  , 6, 5, 8

SUMMARY:
This specifies the changes included in the hard fork named Byzantium.

SPECIFICATION:
- Codename: Byzantium - Aliases: Metropolis/Byzantium, Metropolis part 1 - Activation: - Block >= 4,370,000 on Mainnet - Block >= 1,700,000 on Ropsten testnet - Included EIPs: - [EIP-100](./eip-100.md) (Change difficulty adjustment to target mean block time including uncles) - [EIP-140](./eip-140.md) (REVERT instruction in the Ethereum Virtual Machine) -


=== EIP-7807 ===
TITLE: SSZ execution blocks
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-28
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 4, 9, 5, ,,  , 7, 7, 0, 6, ,,  , 7, 7, 9, 9

SUMMARY:
This EIP defines a migration process of execution blocks to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Gas amounts The different kinds of gas amounts are combined into a single structure,

MOTIVATION:
With [EIP-6404](./eip-6404.md) SSZ transactions, [EIP-6466](./eip-6466.md) SSZ receipts, and [EIP-6465](./eip-6465.md) SSZ withdrawals, all Merkle-Patricia Tries (MPT) besides the state trie are converted to SSZ. This enables the surrounding data structure, the execution block itself, to also convert to SSZ, achieving a unified block representation across both Consensus Layer and Execution

RATIONALE:
This completes the transition to SSZ for everything except the execution state trie. ### Future - With SSZ `Log`, the withdrawals mechanism and validator requests could be redefined to be based on logs (similar to deposits, originally, but without the delay), possibly removing the need for `withdrawals_root` and `requests_hash`.


=== EIP-7266 ===
TITLE: Remove BLAKE2 compression precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-03
REQUIRES: 

SUMMARY:
This EIP removes the [`blake2f`](./eip-152.md) (`0x09`) precompile by changing the precompile behaviour to result in an exceptional abort.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All `CALL`, `CALLCODE`, `DELEGATECALL`, and `STATICCALL` invocations to the `blake2f` precompile address `0x09` MUST result

MOTIVATION:
[EIP-152](./eip-152.md) has never capitalised on a real-world use case. This fact is clearly reflected in the number of times the address `0x09` has been invoked (numbers from the date this EIP was created): - The most recent call took place on 6 October 2022. - Since its gone live

RATIONALE:
The EVM should be optimised for simplicity and future-proofness. The original Yellow Paper states: _these are so-called 'precompiled' contracts, meant as a preliminary piece of architecture that may later become native extensions_. Considering that no use cases have been realised in the last 3.5 years, we can conclude that


=== EIP-4803 ===
TITLE: Limit transaction gas to a maximum of 2^63-1
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-02
REQUIRES: 

SUMMARY:
Limit transaction gas to be between `0` and `2^63-1`.

SPECIFICATION:
Introduce one new restriction retroactively from genesis: any transaction is invalid and not includeable in a block, where the gas limit exceeds `2^63-1`.

MOTIVATION:
The gas limit field in the transaction is specified to be an arbitrary long unsigned integer, but various clients put limits on this value. This EIP brings a reasonable limit into consensus.

RATIONALE:
### `2^63-1` vs `2^64-1` `2^63-1` is chosen because it allows representing the gas value as a signed integer, and so the out of gas check can be done as a simple "less than zero" check after subtraction. ### Consider `2^31-1` An alternative is considering a lower limit, because this


=== EIP-7954 ===
TITLE: Increase Maximum Contract Size
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-06-09
REQUIRES: 1, 7, 0, ,,  , 3, 8, 6, 0

SUMMARY:
This EIP proposes to raise the maximum allowed size for contract code deployed on Ethereum from 24,576 bytes to 32,768 bytes.

SPECIFICATION:
1. Update the [EIP-170](./eip-170.md) contract code size limit of 24KiB (`0x6000` bytes) to 32KiB (`0x8000` bytes). 2. Update the [EIP-3860](./eip-3860.md) initcode size limit of 48KiB (`0xC000` bytes) to 64KiB (`0x10000` bytes).

MOTIVATION:
The current 24KiB contract size limit can be restrictive for complex contracts and applications. Increasing the limit to 32KiB allows for more feature-rich contracts while maintaining reasonable constraints on block and state growth.

RATIONALE:
- **Developer Flexibility:** Enables more complex contracts and features. - **Backward Compatibility:** Existing contracts are unaffected. - **Simplicity:** Only the size limit is changed, with no other protocol modifications.


=== EIP-8072 ===
TITLE: Transaction Inclusion Subscription
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2025-10-31
REQUIRES: 

SUMMARY:
This EIP extends the existing `eth_subscribe` JSON-RPC method with a new subscription type `transactionInclusion` that enables clients to receive real-time notifications when transactions are included in blocks. This subscription-based approach provides efficient transaction confirmation monitoring without blocking connections, supporting both combined transaction submission and monitoring in a single call,

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### New Subscription Type A new subscription type `transactionInclusion` is added to the `eth_subscribe` method.

MOTIVATION:
Current transaction submission workflows require separate calls to `eth_sendRawTransaction` followed by repeated polling of `eth_getTransactionReceipt`, creating unnecessary latency and network overhead. While [EIP-7966](./eip-7966.md) proposes `eth_sendRawTransactionSync` to address this through a synchronous blocking approach, blocking HTTP connections presents significant drawbacks: - **Connection hogging**: Each transaction blocks one HTTP connection until

RATIONALE:
### Why Subscription Over Synchronous? Subscriptions provide several advantages over the synchronous approach proposed in EIP-7966: - **Non-blocking**: Clients can perform other operations while waiting for confirmation - **Multiplexing**: Multiple transactions can be monitored over a single WebSocket connection - **No timeout complexity**: Subscriptions naturally handle varying confirmation times


=== EIP-4396 ===
TITLE: Time-Aware Base Fee Calculation
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-10-28
REQUIRES: 

SUMMARY:
This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle,

SPECIFICATION:
Using the pseudocode language of [EIP-1559](./eip-1559.md), the updated base fee calculation becomes: ```python ... BASE_FEE_MAX_CHANGE_DENOMINATOR = 8 BLOCK_TIME_TARGET = 12 MAX_GAS_TARGET_PERCENT = 95 class World(ABC): def validate_block(self, block: Block) -> None: parent_gas_limit = self.parent(block).gas_limit parent_block_time = self.parent(block).timestamp - self.parent(self.parent(block)).timestamp parent_base_gas_target = parent_gas_limit // ELASTICITY_MULTIPLIER parent_adjusted_gas_target = min(parent_base_gas_target * parent_block_time

MOTIVATION:
The current base fee calculation chooses the gas usage of a block as the signal to determine whether demand for block space is too low (indicating that the base fee should be lowered) or too high (indicating that the base fee should be increased). While simple, this choice of

RATIONALE:
### Mechanism The proposed new base fee calculation only adjusts the block gas target by scaling it with the block time, capped at a maximum percent of the overall block gas limit: #### Current Base Fee Calculation ![](../assets/eip-4396/old_formula.png) #### Proposed Base Fee Calculation ![](../assets/eip-4396/new_formula.png) This new calculation thus targets


=== EIP-211 ===
TITLE: New opcodes: RETURNDATASIZE and RETURNDATACOPY
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
Please see summary.

SPECIFICATION:
If `block.number >= BYZANTIUM_FORK_BLKNUM`, add two new opcodes and amend the semantics of any opcode that creates a new call frame (like `CALL`, `CREATE`, `DELEGATECALL`, ...) called call-like opcodes in the following. It is assumed that the EVM (to be more specific: an EVM call frame) has a new

MOTIVATION:
In some situations, it is vital for a function to be able to return data whose length cannot be anticipated before the call. In principle, this can be solved without alterations to the EVM, for example by splitting the call into two calls where the first is used to

RATIONALE:
Other solutions that would allow returning dynamic data were considered, but they all had to deduct the gas from the call opcode and thus were both complicated to implement and specify ([5/8](https://github.com/ethereum/EIPs/issues/8)). Since this proposal is very similar to the way calldata is handled, it fits nicely into the


=== EIP-6953 ===
TITLE: Network Upgrade Activation Triggers
TYPE: Informational 
STATUS: Final
CREATED: 2023-04-28
REQUIRES: 2, 9, 8, 2, ,,  , 3, 6, 7, 5, ,,  , 6, 1, 2, 2

SUMMARY:
This EIP outlines the various network upgrade activation triggers used on Ethereum over time, from the proof-of-work era to the first post-merge network upgrade, Shanghai/Capella, across both the execution and consensus layers.

SPECIFICATION:
### Proof-of-Work Network Upgrades During the proof-of-work era, network upgrades on Ethereum were triggered based on specific block numbers. The following upgrades followed this pattern: | Upgrade Name | Activation Block Number | |--------------------|-------------------------| | Frontier | `1` | | Frontier Thawing | `200000` | | Homestead | `1150000`

MOTIVATION:
This EIP aims to provide users and developers with a single source of truth for understanding the various upgrade activation patterns used throughout Ethereum's history. It does not aim to be a comprehensive, ongoing record, of upgrades and their activations mechanism. Readers should assume that future upgrades use the

RATIONALE:
### Blocks and Epochs Blocks and epochs serve as natural trigger points for upgrades, as they represent the levels at which state transitions occur on Ethereum. ### Terminal Total Difficulty For the Terminal Total Difficulty mechanism, the rationale can be found in [EIP-3675](./eip-3675.md). ### Timestamps Due to the possibility


=== EIP-8058 ===
TITLE: Contract Bytecode Deduplication Discount
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-22
REQUIRES: 2930

SUMMARY:
This proposal introduces a gas discount for contract deployments when the bytecode being deployed already exists in the state. By leveraging EIP-2930 access lists, any contract address included in the access list automatically contributes its code hash to a deduplication check. When the deployed bytecode matches an existing code

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Implicit Deduplication via Access Lists This proposal leverages the existing EIP-2930 access list structure

MOTIVATION:
Currently, deploying duplicate bytecode costs the same as deploying new bytecode, even though execution clients don't store duplicated code in their databases. When the same bytecode is deployed multiple times, clients store only one copy and have multiple accounts point to the same code hash. Under EIP-8037's proposed gas

RATIONALE:
### Why Access-List Based Deduplication? The access-list approach provides several critical properties: 1. Deterministic behavior: The result depends only on the transaction's access list and current state, not on local database contents. All nodes compute the same gas cost. 2. No reverse index requirement: Unlike other approaches, this doesn't


=== EIP-7619 ===
TITLE: Precompile Falcon512 generic verifier
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-07-03
REQUIRES: 

SUMMARY:
Include a precompiled signature verification function using Falcon-512. Falcon-512 is a candidate for standardization by the National Institute of Standards and Technology (NIST) and is quantum resistant with security level I.

SPECIFICATION:
A clean implementation for Falcon-512 algorithm was brought from the PQClean project. The precompiled signature verification function runs at address `0x65`. The required inputs are: - `public key` - Falcon Public key of 897 bytes - `signature` - 666 bytes (max size) - `message` - an arbitrary number of

MOTIVATION:
The advent of quantum computing threatens blockchain protocols and networks because they utilize non-quantum resistant cryptographic algorithms. When quantum computers become robust enough to run Shor’s algorithm (a quantum algorithm to find the prime factors of an integer) on a large scale, the most used asymmetric algorithms, utilized for

RATIONALE:
Falcon-512 is a good candidate for a new signature implementation. Key sizes in Falcon-512 are relatively small compared to other post-quantum signature algorithms. The following table shows a summary of the typical values for keys and the approximate amount of time taken per second to execute signature verifications as


=== EIP-7937 ===
TITLE: EVM64 - 64-bit mode EVM opcodes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-04-23
REQUIRES: 

SUMMARY:
This EIP introduces multibyte opcodes prefixed by `C0` for 64-bit arithmetic (`C001`-`C00B`), comparison (`C010`-`C015`), bitwise (`C016`-`C019`) and flow (`C056` and `C057`) operations.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Prefix opcode behavior This EIP uses the prefix opcode `C0`, and it only occupies

MOTIVATION:
Not all computations in EVM can utilize the full 256-bit integer width. It can therefore be beneficial to have a "64-bit mode" to avoid unnecessary cycles. This EIP uses a "prefix" opcode `C0`, essentially forming multibyte opcodes to avoid polluting the EVM opcode space too much.

RATIONALE:
When a smart contract uses the 64-bit mode, it's expected that once entered, it will want to stay in 64-bit mode, and only exit to non-64-bit mode when the computationally intensive function is finished. This EIP is designed particularly with this fact in mind. All 64-bit opcodes only operates


=== EIP-5022 ===
TITLE: Increase price of SSTORE from zero to non-zero to 40k gas
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-20
REQUIRES: 

SUMMARY:
Increase the price of the SSTORE opcode from `20_000` gas to `40_000` gas when the original slot is zero and the resultant slot is non-zero. ### Motivation The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage

SPECIFICATION:
| Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `NEW_STORAGE_PRICE` | `40_000` For blocks where `block.number >= FORK_BLOCK`, a new gas schedule applies. Make `SSTORE_SET_GAS`, the price when a slot is set from zero to non-zero, equal `NEW_STORAGE_PRICE`. All other costs remain

MOTIVATION:
The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage slot has not increased. All resources are merged into the same pricing mechanism. If the price for creating new storage slots is fixed, then it needs to

RATIONALE:
### Why not also raise the cost of non-zero to non-zero? Rewriting storage does not affect state growth, which is the main issue this EIP is addressing. Rewriting storage may also be underpriced. Increasing the price of state growth will, at least, incentivize developers to reuse storage instead. ###


=== EIP-7872 ===
TITLE: Max blob flag for local builders
TYPE: Meta 
STATUS: Review
CREATED: 2025-01-30
REQUIRES: 

SUMMARY:
This EIP adds a flag to the block builder in order to allow them to include a client configured maximum amount of blobs. This is an execution layer only change.

SPECIFICATION:
- Create a parameter in block builder's configuration called `USER_CONFIGURED_MAX_BLOBS_PER_BLOCK` - Take the minimum out of the `MAX_BLOB_GAS_PER_BLOCK` and the `USER_CONFIGURED_MAX_BLOBS_PER_BLOCK` - If the minimum is zero, set the minimum to one. - Use the minimum to decide how many blobs to include in the block Note: By default

MOTIVATION:
Currently a builder will include all blobs in their local mempool, up to the maximum amount that the protocol requires. If a builder has low bandwidth, they may include too many blobs and subsequently end up not being able to convince the network that the blobs are available.

RATIONALE:
By adding a flag for the local block builder, they are able to specify how many blobs they can include in a block.


=== EIP-7761 ===
TITLE: EXTCODETYPE instruction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-09-01
REQUIRES: 3, 5, 4, 0, ,,  , 7, 6, 9, 2

SUMMARY:
Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing an `EXTCODETYPE` instruction.

SPECIFICATION:
### Parameters | Constant | Value | |---------------------------|--------------------------------------------------------------------| | `FORK_BLKNUM` | tbd | | `GAS_COLD_ACCOUNT_ACCESS` | Defined as `2600` in the [Ethereum Execution Layer Spec Constants] | | `GAS_WARM_ACCESS` | Defined as `100` in the [Ethereum Execution Layer Spec Constants] | | `TYPE_NONE` | 0 | | `TYPE_LEGACY_CONTRACT` |

MOTIVATION:
EOFv1 as scoped in [EIP-7692] removes code introspection capabilities from the EVM, including the `EXTCODESIZE` instruction (in [EIP-3540]). This makes it hard for [ERC-721] and [ERC-1155] standard contracts to be implemented, as they rely on discovering whether a token's `safeTransfer` call target was an EOA or a contract account:

RATIONALE:
### Alternative solutions There have been other solutions proposed to alleviate the problems related to lack of code introspection required for ERC-721 and ERC-1155 standards: 1. Extra status code for `EXT*CALL` instruction - allowing to discriminate a result coming from calling an EOA 2. Extra argument for `EXT*CALL` (a


=== EIP-3143 ===
TITLE: Increase block rewards to 5 ETH
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-12-01
REQUIRES: 

SUMMARY:
Starting with `FORK_BLKNUM` block rewards will be increased to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Adjust Block, Uncle, and Nephew rewards Adjust the block reward to `new_block_reward`, where new_block_reward = 5_000_000_000_000_000_000 if block.number >= FORK_BLKNUM else block.reward (5E18 wei, or 5,000,000,000,000,000,000 wei, or 5 ETH). Analogue, if an uncle is included in a block for `block.number >= FORK_BLKNUM` such that `block.number - uncle.number

MOTIVATION:
Currently, the transaction fees (tx fees) portion of the mining rewards makes up a significant portion of the total rewards per block, at times almost exceeded the block reward of 2 ETH. This have resulted in situations where at times of low tx fees, POW miners decide to point

RATIONALE:
A 5 ETH base reward was chosen as a middle ground between wanting to prevent too high of an inflation rate (10.4% per annum for the first year at 5 ETH per block) and converting as many POW miners as possible into POS validators by making it easier to


=== EIP-2015 ===
TITLE: wallet_updateEthereumChain RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-05-12
REQUIRES: 155

SUMMARY:
This EIP adds a wallet-namespaced RPC endpoint, `wallet_updateEthereumChain`, providing a standard interface for switching chains. The method takes the minimal parameters of `chainId`, `chainName`, `rpcUrl`, `nativeCurrency` and `blockExplorerUrl`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal adds a method to a wallet's web3 provider API: `wallet_updateEthereumChain`. ### `wallet_updateEthereumChain` The `wallet_updateEthereumChain` method is used to

RATIONALE:
The `wallet_updateEthereumChain` method is designed to be as simple as possible, while still providing the necessary information for a wallet to switch to a new chain. The `chainId` is the only required parameter, as it is the only parameter that is guaranteed to be unique. The `chainName` is included


=== EIP-3068 ===
TITLE: Precompile for BN256 HashToCurve Algorithms
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-23
REQUIRES: 1, 9, 8, ,,  , 1, 1, 0, 8

SUMMARY:
There is currently no inexpensive way to perform BLS signature verification for arbitrary messages. This stems from the fact that there is no precompiled contract in the EVM for a hash-to-curve algorithm for the BN256 elliptic curve. The gas cost of calling a deterministic hash-to-curve algorithm written in Solidity

SPECIFICATION:
Here is the pseudocode for the `HashToG1` function: ``` function HashToG1(msg) fieldElement0 = HashToBase(msg, 0x00, 0x01) fieldElement1 = HashToBase(msg, 0x02, 0x03) curveElement0 = BaseToG1(fieldElement0) curveElement1 = BaseToG1(fieldElement1) g1Element = ECAdd(curveElement0, curveElement1) return g1Element end function ``` Here is the pseudocode for `HashToBase`; `msg` is the byte slice to be

MOTIVATION:
The precompiled contracts in [EIP-198](./eip-198.md) and [EIP-1108](./eip-1108.md) increased usage of cryptographic operations in the EVM by reducing the gas costs. In particular, the cost reduction from [EIP-1108](./eip-1108.md) helps increase the use of SNARKs in Ethereum via an elliptic curve pairing check; however, a hash-to-curve algorithm enabling arbitrary BLS signature

RATIONALE:
The BaseToG1 algorithm is based on the original Fouque and Tibouchi [paper](../assets/eip-3068/latincrypt12.pdf) with modifications based on Wahby and Boneh's [paper](../assets/eip-3068/2019-403_BLS12_H2C.pdf). There is freedom in choosing the HashToBase function and this could easily be changed. Within HashToBase, the particular hashing algorithm (Keccak256 in our case) could also be modified. It


=== EIP-3455 ===
TITLE: SUDO Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-01
REQUIRES: 

SUMMARY:
A new opcode, `SUDO`, is introduced with the same parameters as `CALL`, plus another parameter to specify the sender address.

SPECIFICATION:
Adds a new opcode (`SUDO`) at `0xf8`. `SUDO` pops 8 parameters from the stack. Besides the sender parameter, the parameters shall match `CALL`. 1. Gas: Integer; Maximum gas allowance for message call, safely using current gas counter if the counter is lower 2. Sender: Address, truncated to lower 40

MOTIVATION:
There are many use cases for being able to set the sender. Many tokens are stuck irretrievably because nobody has the key for the owner address. In particular, at address zero there is approximately 17 billion USD in tokens and ether, according to etherscan. With `SUDO`, anyone could free

RATIONALE:
The `GAS` parameter is first so that callers can tediously compute how much of their remaining gas to send at the last possible moment. The remaining parameters inherited from `CALL` are in the same order, with sender inserted between.


=== EIP-2124 ===
TITLE: Fork identifier for chain compatibility checks
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2019-05-03
REQUIRES: 

SUMMARY:
There are many public and private Ethereum networks, but the discovery protocol doesn't differentiate between them. The only way to check if a peer is good or bad (same chain or not), is to establish a TCP/IP connection, wrap it with RLPx cryptography, then execute an `eth` handshake. This

SPECIFICATION:
Each node maintains the following values: - **`FORK_HASH`**: IEEE CRC32 checksum (`[4]byte`) of the genesis hash and fork blocks numbers that already passed. - The fork block numbers are fed into the CRC32 checksum in ascending order. - If multiple forks are applied at the same block, the block

MOTIVATION:
Peer-to-peer networking is messy and hard due to firewalls and network address translation (NAT). Generally only a small fraction of nodes have publicly routed addresses and P2P networks rely mainly on these for forwarding data for everyone else. The best way to maximize the utility of the public nodes

RATIONALE:
##### Why flatten `FORK_HASH` into 4 bytes? Why not share the entire genesis and fork list? Whilst the `eth` devp2p protocol permits arbitrarily much data to be transmitted, the discovery protocol's total space allowance for all ENR entries is 300 bytes. Reducing the `FORK_HASH` into a 4 bytes checksum


=== EIP-1470 ===
TITLE: Smart Contract Weakness Classification (SWC)
TYPE: Informational 
STATUS: Stagnant
CREATED: 2018-09-18
REQUIRES: 

SUMMARY:
The SWC is a smart contract specific software weakness classification scheme for developers, tool vendors and security practitioners. The SWC is loosely aligned to the terminologies and structure used in the [Common Weakness Enumeration - CWE](https://cwe.mitre.org) scheme while overlaying a wide range of weakness variants that are specific to

SPECIFICATION:
Before discussing the SWC specification it is important to describe the terminology used: - Weakness: A software error or mistake that in the right conditions can by itself or coupled with other weaknesses lead to a vulnerability. - Vulnerability: A weakness or multiple weaknesses which directly or indirectly lead

MOTIVATION:
In the software security industry, it is a widely accepted practice to use a common terminology and to classify security related bugs and errors with a standardized scheme. While this has not stopped vulnerabilities from appearing in software, it has helped communities focusing on web applications, network protocols, IOT


=== EIP-7906 ===
TITLE: Restricted Behavior Transaction Type
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-02-21
REQUIRES: 

SUMMARY:
This proposal allows the transaction payload to define write protections for balances and storage slots that are enforced at the protocol level. These protected transactions empower Ethereum users to restrict the behavior of the deployed on-chain smart contracts without needing to perform a deep analysis of their EVM bytecode.

SPECIFICATION:
### Constants | Name | Value | |------------|-------| | RESTRICTED_TX_COST | TBD | |TRACE_CALL_GAS_COST|TBD| |GET_TRACE_CALL_ADDRESS|TBD| |RESTRICTED_EXECUTION_TX_TYPE|TBD| ### New Transaction Type We introduce a new [EIP-2718](./eip-2718.md) transaction, "restricted execution transaction", where the `TransactionType` is `RESTRICTED_EXECUTION_TX_TYPE` and the `TransactionPayload` is the RLP serialization of the following: ``` rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas,

MOTIVATION:
The total value of crypto assets that have been stolen to date exceeds the yearly GDP of a medium-sized nation. This level of loss and waste is indefensible and has a long list of negative consequences for everyone involved. Specifically, one of the major ways in which Ethereum users

RATIONALE:
### New Transaction Type and Assertion Frame One of the main advantages of a new Transaction Type for the Restricted Behaviour feature is the ability to protect all existing EOAs, and not just smart accounts. This makes it preferable to introduce a new Transaction Type instead of any other


=== EIP-7797 ===
TITLE: Double speed for hash_tree_root
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-10-23
REQUIRES: 

SUMMARY:
This EIP explains how to customize [`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md#merkleization) to double its performance.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### SHA-256 preprocessing Before SHA-256 hash computation begins, the input message is preprocessed. A single

MOTIVATION:
Hashing is a dominant performance bottleneck for Consensus Layer implementations. To support large validator counts, it is critical to optimize hashing performance. Consensus Layer hashes are based on [`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md#merkleization), a mechanism that splits up the data into chunks and then forms a tree by recursively combining two adjacent chunks

RATIONALE:
Doubling the throughput of the underlying hash algorithm allows scaling to more validators on the same hardware, or allows using the freed CPU time for other tasks. Even when caching rarely-changed intermediate hashes across computations such as the `validators` list of a `BeaconState`, and employing hardware-accelerated SHA-256 implementations that


=== EIP-7591 ===
TITLE: BLS signed transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-01-10
REQUIRES: 

SUMMARY:
This EIP introduces a new [EIP-2718](./eip-2718.md) transaction type that is signed with BLS signatures.

SPECIFICATION:
BLS_TX_TYPE = Bytes1(0x04) ### Transaction Type The transaction type will have the following format: ``` [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, sender, signature] ``` with `sender` being the BLS public key of an account with address `address = [0:20](keccak256(sender))`. The signature value `signature` is calculated by

MOTIVATION:
The BLS signature scheme allows for easy aggregation and verification of aggregated signatures. If a substantial number of transactions on mainnet were BLS signed transactions, we can aggregate signatures in a block and batch-verify them. This will reduce growth of the chain history.

RATIONALE:
Removing the ECDSA signature from a transaction saves 65 bytes. The BLS public key is 48 bytes, the aggregated signature is 96 bytes. Thus we save `-96 + (65-48)* #transactions` bytes per block. With ~7000 blocks per day, 1.000.000 transactions per day, the average block contains roughly 150 transactions.


=== EIP-2733 ===
TITLE: Transaction Package
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-06-16
REQUIRES: 2718

SUMMARY:
Introduce a new transaction type which includes a list of transactions that must be executed serially by clients. Execution information (e.g. success, gas_used, etc.) will be propagated forward to the next transaction.

SPECIFICATION:
Introduce a new [EIP-2718](./eip-2718.md) transaction type where `id = 2`. #### Structure ``` struct TransactionPackage { chain_id: u256, children: [ChildPackage], nonce: u64, gas_price: u256, v: u256, r: u256, s: u256 } ``` ##### Hash `keccak256(rlp([2, chain_id, children, nonce, gas_price, v, r, s])` ##### Signature Hash `keccak256(rlp([2, chain_id, children, nonce,

MOTIVATION:
Onboarding new users to Ethereum has been notoriously difficult due to the need for new users to acquire enough ether to pay for their transactions. This hurdle has seen a significant allocation of resources over the years to solve. Today, that solution is meta-transactions. This is, unfortunately, a brittle

RATIONALE:
### Each `Child` has its own signature For simplicity, the author has chosen to require each child package to specify its own signature, even if the signer is the same as the package signer. This choice is made to allow for maximum flexibility, with minimal client changes. This transaction


=== EIP-7676 ===
TITLE: EOF - Prepare for Address Space Extension
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-03
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 7, 0, 6, 9

SUMMARY:
Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This EIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve bytes need to be zero or an exceptional halt is raised.

SPECIFICATION:
We introduce one new instruction: - `EXTBALANCE` (`tbd`) with arguments `(target_address)`, returning `balance` `EXTBALANCE` will pop one stack item off of the stack, the address of another account or contract. The balance of that account or contract will be pushed onto the stack. If `EXTBALANCE` is invoked with any

MOTIVATION:
There have been proposals to extend Ethereum Addresses from 160 bits to 256, such as one that would use the extra bits for state expiry (such as the ethereum magicians forum topic "Increasing the address size from 20 to 32 bytes"). One issue ground the work to a halt:

RATIONALE:
### New Opcode There is no need to ban the `BALANCE` opcode as it does not cause any problems that would require banning it within an EOF container. Adding a new opcode also allows the existing opcode to behave the same in EOF and legacy code, reducing potential friction


=== EIP-7921 ===
TITLE: Skip `JUMPDEST` immediate argument check
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-03-26
REQUIRES: 

SUMMARY:
Allow `JUMP` and `JUMPI` to arrive at any byte matching `JUMPDEST` (`0x5b`), even if that byte is an immediate argument.

SPECIFICATION:
When activated, all `0x5b` bytes are valid `JUMPDEST` for `JUMPI` and `JUMP` opcodes.

MOTIVATION:
Immediate arguments are opcode parameters supplied within the code rather than the stack. Currently determining the validity of a `JUMPDEST` requires determining which bytes are immediate arguments to other opcodes, such as `PUSH1`. This presents several problems: 1. Codesize is a linear DoS vector because code must be preprocessed

RATIONALE:
Removing the check solves several problems while reducing EVM complexity.


=== EIP-1559 ===
TITLE: Fee market change for ETH 1.0 chain
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-04-13
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new [EIP-2718](./eip-2718.md) transaction type, with the format `0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`. There is a base fee per gas in protocol, which can move up or down each block according to a formula which is a function

SPECIFICATION:
Block validity is defined in the reference implementation below. The `GASPRICE` (`0x3a`) opcode **MUST** return the `effective_gas_price` as defined in the reference implementation below. As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` 2. The intrinsic cost of the new transaction is inherited from [EIP-2930](./eip-2930.md), specifically `21000

MOTIVATION:
Ethereum historically priced transaction fees using a simple auction mechanism, where users send transactions with bids ("gasprices") and miners choose transactions with the highest bids, and transactions that get included pay the bid that they specify. This leads to several large sources of inefficiency: * **Mismatch between volatility of


=== EIP-2515 ===
TITLE: Implement Difficulty Freeze
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-10
REQUIRES: 

SUMMARY:
The difficulty Freeze is a mechanism that is easy to predict and model, and the pressures of missing it are more readily felt by the core developers and client maintainers. The client maintainers are also positioned as the group that is most able to respond to an incoming Difficulty

SPECIFICATION:
Add variable `DIFFICULTY_FREEZE_HEIGHT` The logic of the Difficulty Freeze is defined as follows: ``` if (BLOCK_HEIGHT <= DIFFICULTY_FREEZE_HEIGHT): block_diff = parent_diff + parent_diff // 2048 * max( 1 - (block_timestamp - parent_timestamp) // 10, -99) else: block_diff = parent_diff + parent_diff * 0.01 ``` **Optional Implementation** Add the variable

MOTIVATION:
The current difficulty bombs' effect on the Block Time Targeting mechanism is rather complex to model, and it has both appeared when it was not expected (Muir Glacier) and negatively affected miners when they are not the target (in the case of delaying forks due to technical difficulties). Miners

RATIONALE:
Block height is very easy to predict and evaluate within the system. This removes the effect of the Difficulty Bomb on block time, simplifying the block time targeting mechanism. The addition of an increase in the difficulty was added after feedback that the game theory of the mechanism did


=== EIP-3267 ===
TITLE: Giving Ethereum fees to Future Salaries
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-02-13
REQUIRES: 

SUMMARY:
Transfer a part (exact fractions - TBD) of mining/transfer fees + (probably: TBD) some minted ETH to the `DonateETH` contract configured to transfer to `SalaryWithDAO` contract.

SPECIFICATION:
(TBD) `SalaryWithDAO` = `TBD` (`address`) `DefaultDAOInterface` = `TBD` (`address`) `MintPerPeriod` = `TBD` (`uint256`) `TransferFraction` = `TBD` (0..1) `MineFraction` = `TBD` (0..1) [The contract's source](../assets/eip-3267/contracts/README.md) Prior to `FORK_BLOCK_NUMBER`, `SalaryWithDAO` and `DefaultDAOInterface` contracts will be deployed to the network and exist at the above specified addresses. Change the Ethereum clients to

MOTIVATION:
This proposal solves two problems at once: 1. It provides a big amount of "money" to common good producers. That obviously personally benefits common good producers, allowing them to live better human lives, it increases peoples' and organizations' both abilities and incentives to produce common goods. That benefits the

RATIONALE:
The Future Salaries is the _only_ known system of distributing significant funds to common good producers. (Quadratic funding aimed to do a similar thing, but in practice as we see on GitCoin it favors a few developers, ignores project of highly advanced scientific research that is hard to explain


=== EIP-8046 ===
TITLE: Uniform price auction over inclusion lists
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-16
REQUIRES: 7805

SUMMARY:
This EIP proposes a uniform price auction over inclusion lists (UPIL), which ranks transactions by their offered ranking fee per gas. When the block is full, no transaction is allowed to displace an inclusion-list (IL) transaction that passes regular inclusion criteria and offers a higher ranking fee per gas.

SPECIFICATION:
### New transaction format and ranking fee A new field `max_ranking_fee_per_gas` is added to a new [EIP-2718](./eip-2718.md) transaction with `TransactionType` = `RANK_TX_TYPE`. The `TransactionPayload` for this transaction is: <-- TODO --> ```Python # TODO: To be defined after scheduling this EIP relative to EIP-7999 and EIP-8011, etc. ``` The

MOTIVATION:
Censorship resistance (CR) is a key property of decentralized blockchains. To ensure that transactions cannot be censored by the entity building the block (denoted "builder" in this EIP, which may sometimes be the proposer), a mechanism called fork-choice enforced inclusion lists (FOCIL) has been proposed in [EIP-7805](./eip-7805.md). A set

RATIONALE:
### Updated inclusion check #### Conservative balance The reason for using a conservative balance in (3b) when validating `T` is to avoid the circular dependencies that can emerge when a transaction is made executable by a lower-ranked transaction. Consider three transactions `A`, `B`, and `C` ranked as `A>B>C`. Without


=== EIP-7610 ===
TITLE: Revert creation in case of non-empty storage
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-02-02
REQUIRES: 

SUMMARY:
This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. If a contract creation is attempted due to a creation transaction, the `CREATE` opcode, the

RATIONALE:
EIP-684 defines two conditions for contract deployment: the destination address must have zero nonce and zero code length. Unfortunately, this is not sufficient. Before [EIP-161](./eip-161.md) was applied, the nonce of a newly deployed contract remained set to zero. Therefore, it was entirely possible to create a contract with a


=== EIP-7650 ===
TITLE: Programmable access lists
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-10
REQUIRES: 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new precompiled contract named `prefetch`, which accepts an `accessList`. The `accessList` specifies a list of addresses and local storage keys; these addresses and local storage keys are added into the `accessed_addresses` and `accessed_storage_keys` global sets (introduced in [EIP-2929](./eip-2929.md)). Similar to [EIP-2930](./eip-2930.md), prefetching data through this precompile

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Parameters | Constant | Value | | ----------------------------- | ----- | | `FORK_BLOCK_NUMBER` | `TBD` | | `PREFETCH_PRECOMPILE_ADDRESS` | `TBD`

MOTIVATION:
The primary goal of this EIP is to enhance EIP-2930 by enabling contracts to add access lists programmatically. The advantage of implementing this precompile within a contract is the sustained reduction in gas costs for data access operations, leveraging the concurrent computing and IOs that most nodes have.

RATIONALE:
### Charging less for accesses in the access list Similar to EIP-2930, we encourage contract developers to use the `prefetch` precompile as much as possible, especially assuming the nodes have some decent concurrent capabilities (e.g., some cores and IO bandwidth). ### Allowing duplicates Similar to EIP-2930, we allow duplicates


=== EIP-7569 ===
TITLE: Hardfork Meta - Dencun
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-01
REQUIRES: 1, 1, 5, 3, ,,  , 4, 7, 8, 8, ,,  , 4, 8, 4, 4, ,,  , 5, 6, 5, 6, ,,  , 6, 7, 8, 0, ,,  , 7, 0, 4, 4, ,,  , 7, 0, 4, 5, ,,  , 7, 5, 1, 4, ,,  , 7, 5, 1, 6, ,,  , 7, 5, 6, 8

SUMMARY:
This Meta EIP lists the EIPs included in the Dencun network upgrade across both Ethereum's execution and consensus layers. See [EIP-7568](./eip-7568.md) for the specifications of past upgrades.

SPECIFICATION:
### Included EIPs * [EIP-1153](./eip-1153.md): Transient storage opcodes * [EIP-4788](./eip-4788.md): Beacon block root in the EVM * [EIP-4844](./eip-4844.md): Shard Blob Transactions * [EIP-5656](./eip-5656.md): MCOPY - Memory copying instruction * [EIP-6780](./eip-6780.md): SELFDESTRUCT only in same transaction * [EIP-7044](./eip-7044.md): Perpetually Valid Signed Voluntary Exits * [EIP-7045](./eip-7045.md): Increase Max Attestation Inclusion Slot

RATIONALE:
This Meta EIP provides a global view of all changes included in the Dencun network upgrade, as well as links to full specification.


=== EIP-8015 ===
TITLE: Remove `deposit` and `eth1data` fields
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-22
REQUIRES: 6, 1, 1, 0, ,,  , 7, 7, 3, 2

SUMMARY:
This EIP removes the legacy `deposits` and `eth1_data` fields from the `BeaconBlockBody` structure after [EIP-6110](./eip-6110.md) has been fully finalized. These fields become obsolete once all validators have transitioned to the new in-protocol deposit processing mechanism introduced in EIP-6110.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### Consensus Layer #### Activation Conditions This EIP SHALL only be activated when both of

MOTIVATION:
EIP-6110 introduced in-protocol deposit processing by moving validator deposits to the execution layer as part of the EIP-7685 request framework. This change eliminated the need for the consensus layer's proposer voting mechanism for deposits. However, during the transition period, both the legacy deposit mechanism (using `deposits` and `eth1_data` fields)

RATIONALE:
### Timing of Removal The fields are removed after EIP-6110 finalization to ensure: - All pending deposits from the legacy system have been processed - No validator can be affected by the removal - The transition is complete and irreversible - State consistency is maintained across all honest nodes


=== EIP-2035 ===
TITLE: Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-16
REQUIRES: 

SUMMARY:
It is part of the State Rent roadmap. This particular change prepares Ethereum for introduction of the block proofs (current understanding is that they can be introuced without a hard fork). The introduction of the block proofs allows any Ethereum node that wishes to receive them, to process transactions

SPECIFICATION:
Not very formal at the moment, but will be formalised with more research and prototyping. Gas of operations `SLOAD` and `SSTORE` increases by `X` gas when the storage slots accessed (read by `SLOAD` or written by `SSTORE`) were not previously accessed (by another `SLOAD` or `SSTORE`) during the same

MOTIVATION:
There is [empirical analysis](https://github.com/holiman/vmstats/blob/master/README.md) showing that `SLOAD` opcode is currently underpriced in terms of execution latency it adds to the block processing. The hypothesis is that it is due to the latency of the database accesses. In the same analysis, `SSTORE` is not considered, because its effect on the

RATIONALE:
[EIP-1884](./eip-1884.md) seeks to increase the gas cost of `SLOAD` but using a different justification (latency of the execution as described in the Motivation). This EIP is likely to increase the cost of `SLOAD` by a larger amount, therefore partially (because EIP-1884 also proposed other increases) supersedes EIP-1884. [EIP-2028](./eip-2028.md) describes


=== EIP-7819 ===
TITLE: SETDELEGATE instruction
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-18
REQUIRES: 7702

SUMMARY:
Introduce a new instruction that allows smart contracts to create (and update) delegation accounts that match [EIP-7702](./eip-7702.md)'s design. These accounts can be used similarly to [ERC-1167](./eip-1167.md) clones, with significant advantages.

SPECIFICATION:
A new instruction (`SETDELEGATE`) is added at `0xf6`. ### Behavior Executing this instruction does the following: 1. deduct `EMPTY_ACCOUNT_COST` gas 2. halt if the current frame is in `static-mode` 3. pop `salt`, `target` from the operand stack 4. calculate `location` as `keccak256(DESIGNATOR ++ address ++ salt)[12:]` 5. add `location`

MOTIVATION:
Many on-chain applications involve creating multiple instances of the same code at different locations. These applications often rely on clones, or proxies, to reduce deployment costs. Clones, such as the one described in ERC-1167 are minimal pieces of code that contain the target address directly in the code. That

RATIONALE:
### Gas cost The execution of the `SETDELEGATE` instruction involves fewer moving pieces than what EIP-7702 gas costs account for: - there is no signature recovery - there is no dedicated calldata that must be accounted for that is not already paid for at the transaction level - there


=== EIP-1571 ===
TITLE: EthereumStratum/2.0.0
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-11-09
REQUIRES: 

SUMMARY:
This draft contains the guidelines to define a new standard for the Stratum protocol used by Ethereum miners to communicate with mining pool servers. ### Conventions The key words `MUST`, `MUST NOT`, `REQUIRED`, `SHALL`, `SHALL NOT`, `SHOULD`, `SHOULD NOT`, `RECOMMENDED`, `MAY`, and `OPTIONAL` in this document are to be

SPECIFICATION:
The Stratum protocol is an instance of [JSON-RPC-2.0](https://www.jsonrpc.org/specification). The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of a `session`. A session starts at the moment a client opens a TCP connection to the server till the moment either

RATIONALE:
Ethereum does not have an official Stratum implementation yet. It officially supports only getWork which requires miners to constantly pool the work provider. Only recently go-ethereum have implemented a [push mechanism](https://github.com/ethereum/go-ethereum/pull/17347) to notify clients for mining work, but whereas the vast majority of miners do not run a node,


=== EIP-7686 ===
TITLE: Linear EVM memory limits
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-15
REQUIRES: 

SUMMARY:
Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of

SPECIFICATION:
Change `memory_cost` from: ```python memory_size_word = (memory_byte_size + 31) / 32 memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word) ``` To: ```python memory_size_word = (memory_byte_size + 31) / 32 memory_cost = 3 * memory_size_word ``` Additionally, if a memory expansion would lead to `memory_byte_size` strictly exceeding

MOTIVATION:
Today, memory pricing rules are complicated: we have the quadratic cost for expanding memory as well as the 63/64 rule for how much gas can go into a child call. This also makes it extremely hard to calculate a maximum possible amount of memory required to process a given

RATIONALE:
With this EIP, there is a simple EVM implementation that can process an N-gas call using an N-byte bytearray as memory: allocate all bytes to the current context, when doing a child call use the remaining memory starting from the position `memory_byte_size` for the child call's memory, and so


=== EIP-858 ===
TITLE: Reduce block reward and delay difficulty bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-01-29
REQUIRES: 

SUMMARY:
The current public Ethereum network has a hashrate that corresponds to a tremendous level of energy consumption. As this energy consumption has a correlated environmental cost the network participants have an ethical obligation to ensure this cost is not higher than necessary. At this time, the most direct way

SPECIFICATION:
Delay difficulty bomb by 2,000,000 blocks Adjust block, uncle, and nephew rewards to reflect a new block reward of 1 ETH.

MOTIVATION:
The current public Ethereum network has a hashrate of 296 TH/s. This hashrate corresponds to a power usage of roughly [1 TW](../assets/eip-858/calculations.md) and yearly energy consumption of 8.8 TWh (roughly 0.04% of [total](https://en.wikipedia.org/wiki/List_of_countries_by_electricity_consumption) global electricity consumption). A future switch to full Proof of Stake will solve this issue entirely.

RATIONALE:
This will delay the difficulty bomb by roughly a year. The difficulty bomb remains a community supported mechanism to aid a future transition to POS. The network hashrate provides security by reducing the likelihood that an adversary could mount a 51% attack. A static block reward means that factors


=== EIP-7514 ===
TITLE: Add Max Epoch Churn Limit
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-09-07
REQUIRES: 

SUMMARY:
Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.

SPECIFICATION:
### Constants | Name | Value | | ---- | ----- | | `MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT` | 8 | ### Execution layer This requires no changes to the Execution Layer. ### Consensus layer - Add `get_validator_activation_churn_limit` with upper bound `MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT` - Modify `process_registry_updates` to use bounded activation churn limit The full

MOTIVATION:
This proposal aims to mitigate the negative externalities of very high level of total ETH supply staked before a proper solution is implemented. In other words, this proposal accepts the complexities of changing the rewards curve and is meant only to slow down growth. In the event that the

RATIONALE:
### `MAX_PER_EPOCH_CHURN_LIMIT` value Depending on the specific constant selection the churn can _decrease_ at the activation fork epoch. The Beacon chain spec can handle this without issues. During 2023 Q4 (projected Dencun activation) the churn value will range 14-16. The table below compares the projected validator set assuming a


=== EIP-7742 ===
TITLE: Uncouple blob count between CL and EL
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-07-12
REQUIRES: 4844

SUMMARY:
Update blob maximum and target verification from [EIP-4844](./eip-4844.md). The execution layer no longer verifies the blob maximum and receives the target dynamically from the consensus layer.

SPECIFICATION:
### Block structure and validity Upon activation of this EIP, execution clients **MUST** extend the header schema with an additional 64-bit field: the `target_blobs_per_block`. This value is set to the current target blob count. The Engine API is modified along with this EIP to provide the `target_blobs_per_block` with each

MOTIVATION:
Following EIP-4844, the execution layer (EL) maintains a hard-coded blob target value and blob maximum value. Given the relationship of the EL and the consensus layer (CL) node software, the verification of the blob maximum is redundant so it can be removed entirely without any change in security. The

RATIONALE:
### Why not have the CL also compute the blob base fee and remove any notion of blob counts from EL processing? Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack. The CL


=== EIP-3045 ===
TITLE: Adds `baseFee` to `eth_getUncleByBlockHashAndIndex`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getUncleByBlockHashAndIndex` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getUncleByBlockHashAndIndex` #### Description Returns information about an uncle specified by block hash and uncle index position Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-4488 ===
TITLE: Transaction calldata gas cost reduction with total calldata limit
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-11-23
REQUIRES: 

SUMMARY:
Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.

SPECIFICATION:
| Parameter | Value | | - | - | | `NEW_CALLDATA_GAS_COST` | `3` | | `BASE_MAX_CALLDATA_PER_BLOCK` | `1,048,576` | | `CALLDATA_PER_TX_STIPEND` | `300` | Reduce the gas cost of transaction calldata to `NEW_CALLDATA_GAS_COST` per byte, regardless of whether the byte is zero or nonzero. Add a rule that

MOTIVATION:
Rollups are in the short and medium term, and possibly the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups are

RATIONALE:
A natural alternative proposal is to decrease `NEW_CALLDATA_GAS_COST` without adding a limit. However, this presents a security concern: today, the average block size [is 60-90 kB](https://etherscan.io/chart/blocksize), but the _maximum_ block size is `30M / 16 = 1,875,000` bytes (plus about a kilobyte of block and tx overhead). Simply decreasing


=== EIP-7762 ===
TITLE: Increase MIN_BASE_FEE_PER_BLOB_GAS
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-08-31
REQUIRES: 4844

SUMMARY:
This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob base fee spike.

SPECIFICATION:
### `MIN_BASE_FEE_PER_BLOB_GAS` Increase The main specification change introduced by this EIP is setting MIN_BASE_FEE_PER_BLOB_GAS to 2**25: ```diff + MIN_BASE_FEE_PER_BLOB_GAS = 2**25 - MIN_BASE_FEE_PER_BLOB_GAS = 1 ``` ### `excess_blob_gas` Reset To avoid a blob base fee spike, the `calc_excess_blob_gas` is modified to reset `excess_blob_gas` to 0 at the fork. To

MOTIVATION:
When scoping 4844, the thinking was that blobs would only enter price discovery once, relatively quickly after the blob rollout; however, this has not been the case. In fact, blobs have entered price discovery several times, and the frequency of price discovery events is likely to increase in the

RATIONALE:
The current MIN_BASE_FEE_PER_BLOB_GAS is 1 wei. This is many orders of magnitude lower than the prevailing price of blobs when blobs enter price discovery. Whenever demand for blobs exceeds supply, blobs enter price discovery, but traversing the 8 orders of magnitude between 1 wei and the point where elasticity


=== EIP-4573 ===
TITLE: Procedures for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-12-16
REQUIRES: 2, 3, 1, 5, ,,  , 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 3, 7, 7, 9, ,,  , 4, 2, 0, 0

SUMMARY:
Five EVM instructions are introduced to define, call, and return from named EVM _procedures_ and access their _call frames_ in memory - `ENTERPROC`, `LEAVEPROC`, `CALLPROC`, `RETURNPROC`, and `FRAMEADDRESS`.

SPECIFICATION:
### Instructions #### ENTERPROC (0x??) dest_section: uint8, dest_offset: uint8, n_inputs: uint16, n_outputs: uint16, n_locals: uint16 ``` frame_stack.push(FP) FP -= n_locals * 32 PC +- <length of immediates> ``` Marks the entry point to a procedure * at offset `dest_offset` from the beginning of the `dest_section`. * taking `n_inputs` arguments

MOTIVATION:
Currently, Ethereum bytecode has no syntactic structure, and _subroutines_ have no defined interfaces. We propose to add _procedures_ -- delimited blocks of code that can be entered only by calling into them via defined interfaces. Also, the EVM currently has no automatic management of memory for _procedures_. So we

RATIONALE:
There is actually not much new here. It amounts to [EIP-615](./eip-615.md), refined and refactored into bite-sized pieces, along lines common to other machines. This proposal uses the [EIP-2315](./eip-2315.md) return stack to manage calls and returns, and steals ideas from [EIP-615](./eip-615.md), [EIP-3336](./eip-3336.md), and [EIP-4200](./eip-4200.md). `ENTERPROC` corresponds to `BEGINSUB` from EIP-615.


=== EIP-7788 ===
TITLE: Dynamic target blob count
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2024-10-15
REQUIRES: 7742

SUMMARY:
This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.

SPECIFICATION:
### Parameters | Parameter | Value | | - | - | | `FORK_TIMESTAMP` | TBD | | `TARGET_BLOB_COUNT_CHANGE_RATE` | `1` | | `MIN_TARGET_BLOB_COUNT` | `1` | | `MAX_TARGET_BLOB_COUNT` | `3` | | `BLOB_COST_CHANGE_MARGIN` | `2^48` | | `TARGET_BLOB_COST` | `2^49` | ### Dynamic targeting The target blob count

MOTIVATION:
Ethereum currently uses a target of 50% capacity for blob count, with [EIP-1559](./eip-1559.md) smoothing out short-term spikes and pushing average throughput towards the target. A dynamic target is orthogonal to EIP-1559, tweaking the target itself over a longer timescale to aim for some desired blob cost. With static targeting

RATIONALE:
### Constant blob cost target A constant blob cost target can keep L2 transaction costs affordable for end users. Volatility in the price of ETH would affect affordability, but is unlikely to be significant compared to normal fluctuations in blob gas costs due to spikes in activity. In future


=== EIP-2936 ===
TITLE: EXTCLEAR Opcode For SELFDESTRUCTed contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-03
REQUIRES: 

SUMMARY:
Changes `SELFDESTRUCT` (`0xff`) to not clear any storage and adds a new `EXTCLEAR` (`0x5c`) opcode that will clear a specific storage slot for a contract that has previously been self destructed.

SPECIFICATION:
After `FORK_BLOCK_NUM`, a new opcode, `EXTCLEAR`, is enabled at `0x5C` to clear storage for `SELFDESTRUCT`ed contracts. `EXTCLEAR`: * does not push any words onto the stack * pops two words off the stack: the destroyed contract address and a storage address * if the contract exists, charge the same

MOTIVATION:
`SELFDESTRUCT` (`0xFF`) is unnecessarily complex because it clears an unbounded amount of contract storage. It is computationally expensive for nodes to track all of the storage used in every contract in case the contract `SELFDESTRUCT`s. Further, contracts can be re-initialized using `CREATE2` (`0xF5`), and then `SLOAD` (`0x54`) prior storage.

RATIONALE:
`0x5C` is available in the same range as `SSTORE` and `SLOAD`.


=== EIP-2657 ===
TITLE: Ephemeral Testnet Yolo
TYPE: Meta 
STATUS: Stagnant
CREATED: 2020-04-19
REQUIRES: 

SUMMARY:
The specification for Ephemeral Testnet Yolo. Clients who wish to sync need to implement the following features into their client. It is for testing basic infrastructure and will be nuked.


=== EIP-3675 ===
TITLE: Upgrade consensus to Proof-of-Stake
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-22
REQUIRES: 2124

SUMMARY:
This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented in [EIP-2982](./eip-2982.md). Full specification of the beacon chain can be found in the `ethereum/consensus-specs` repository. This document specifies

SPECIFICATION:
### Definitions * **PoW block**: Block that is built and verified by the existing proof-of-work mechanism. In other words, a block of the Ethereum network before the consensus upgrade. * **PoS block**: Block that is built and verified by the new proof-of-stake mechanism. * **Terminal PoW block**: A PoW

MOTIVATION:
The beacon chain network has been up and running since December 2020. Neither safety nor liveness failures were detected during this period of time. This long period of running without failure demonstrates the sustainability of the beacon chain system and its readiness to become a security provider for the

RATIONALE:
The changes specified in this EIP target a minimal requisite set of consensus and client software modifications to safely replace the existing proof-of-work consensus algorithm with the new proof-of-stake consensus represented by the already in-production beacon chain. This EIP was designed to minimize the complexity of hot-swapping the live


=== EIP-2565 ===
TITLE: ModExp Gas Cost
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-03-20
REQUIRES: 198

SUMMARY:
To accurately reflect the real world operational cost of the `ModExp` precompile, this EIP specifies an algorithm for calculating the gas cost. This algorithm approximates the multiplication complexity cost and multiplies that by an approximation of the iterations required to execute the exponentiation.

SPECIFICATION:
As of `FORK_BLOCK_NUMBER`, the gas cost of calling the precompile at address `0x0000000000000000000000000000000000000005` will be calculated as follows: ``` def calculate_multiplication_complexity(base_length, modulus_length): max_length = max(base_length, modulus_length) words = math.ceil(max_length / 8) return words**2 def calculate_iteration_count(exponent_length, exponent): iteration_count = 0 if exponent_length <= 32 and exponent == 0: iteration_count =

MOTIVATION:
Modular exponentiation is a foundational arithmetic operation for many cryptographic functions including signatures, VDFs, SNARKs, accumulators, and more. Unfortunately, the ModExp precompile is currently over-priced, making these operations inefficient and expensive. By reducing the cost of this precompile, these cryptographic functions become more practical, enabling improved security, stronger randomness

RATIONALE:
After benchmarking the ModExp precompile, we discovered that it is ‘overpriced’ relative to other precompiles. We also discovered that the current gas pricing formula could be improved to better estimate the computational complexity of various ModExp input variables. The following changes improve the accuracy of the `ModExp` pricing: ###


=== EIP-6873 ===
TITLE: Preimage retention
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-14
REQUIRES: 

SUMMARY:
Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Let `T_p` be the timestamp of the fork preceding the verge, and `T_v` the timestamp

RATIONALE:
Switching to verkle trees require a complete rehashing of all tree keys. Most execution clients store all keys hashed, without their preimages, which as the time of print take up 70GB on mainnet. In order to make these preimages available to everyone, the following course of action are available


=== EIP-160 ===
TITLE: EXP cost increase
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-20
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, increase the gas cost of EXP from 10 + 10 per byte in the exponent to 10 + 50 per byte in the exponent. ### Rationale Benchmarks suggest that EXP is currently underpriced by a factor of about 4–8. ### References 1. EIP-160 issue and

RATIONALE:
Benchmarks suggest that EXP is currently underpriced by a factor of about 4–8. ### References 1. EIP-160 issue and discussion: https://github.com/ethereum/EIPs/issues/160


=== EIP-7791 ===
TITLE: GAS2ETH opcode
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-08-13
REQUIRES: 2929

SUMMARY:
This EIP introduces a new `GAS2ETH` opcode that enables the direct conversion of gas into ether (ETH).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A new opcode, `GAS2ETH` (`0xFC`), is introduced to enable direct conversion of gas into ETH

MOTIVATION:
This EIP is based on the premise that smart contract authors, compiler teams, and public goods projects in general should be compensated for their contributions. Moreover, their compensation should _scale_ with the usage of their contracts. A widely used and popular contract offers significant value to its users through

RATIONALE:
- `GAS2ETH` vs. pro-rata: The pro-rata model incentivizes inflating contract gas usage to artificially increase fees. In contrast, this proposal allows contract authors to charge their desired amount directly, eliminating the need for unnecessary gas consumption. - Target address vs. simply increasing balance of the currently executing contract: Using


=== EIP-7864 ===
TITLE: Ethereum state using a unified binary tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-01-20
REQUIRES: 

SUMMARY:
Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which are grouped by 256 in order to provide some locality.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Notable changes from the hexary structure - The account and storage tries are merged into

MOTIVATION:
Ethereum's long-term goal is to allow blocks to be proved with validity proof so that chain verification is as simple and fast as possible. One of the most challenging parts of achieving that goal is proving the state of the tree, which is required for EVM execution. The current

RATIONALE:
This EIP defines a new Binary Tree that starts empty. Only new state changes are stored in the tree. The MPT continues to exist but is frozen. This sets the stage for a future hard fork that migrates the MPT data to this Binary Tree ([EIP-7748](./eip-7748.md)). ### Single tree


=== EIP-7716 ===
TITLE: Anti-correlation attestation penalties
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-25
REQUIRES: 

SUMMARY:
The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with

SPECIFICATION:
| Parameter | Value | | - | - | | `PENALTY_ADJUSTMENT_FACTOR` | `4096` | | `MAX_PENALTY_FACTOR` | `4` | Add a variable `NET_EXCESS_PENALTIES` to the beacon state. Let `penalty_factor` be determined through ``` min( (non_attesting_balance * PENALTY_ADJUSTMENT_FACTOR) // (NET_EXCESS_PENALTIES * total_active_balance + 1), MAX_PENALTY_FACTOR ) ``` Let `NET_EXCESS_PENALTIES`

MOTIVATION:
As of now, during times of usual network operation, there are no economic incentives to diversify node operations through using multiple different nodes, geographical locations, clients, ISP providers, etc., except for reducing the risk of penalties affecting all validators simultaneously, thereby limiting the impact to only a fraction of

RATIONALE:
### PENALTY_ADJUSTMENT_FACTOR This variable impacts the sensitivity of the `NET_EXCESS_PENALTIES`. Given stable participation, the `penalty_factor` is one. If participation decreases, the `penalty_factor` will temporarily increase above one until `net_excess_penalties` catches up. If participation increases, the `penalty_factor` will temporarily be zero until `net_excess_penalties` catches up. The `PENALTY_ADJUSTMENT_FACTOR` regulates how fast


=== EIP-8038 ===
TITLE: State-access gas cost update
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-03
REQUIRES: 2, 9, 2, 6, ,,  , 7, 9, 2, 8, ,,  , 8, 0, 3, 2

SUMMARY:
This EIP updates the gas cost of state-access operations to reflect Ethereum’s larger state and the consequent slowdown of these operations. It raises the base costs for `GAS_STORAGE_UPDATE`, `GAS_COLD_SLOAD`, and `GAS_COLD_ACCOUNT_ACCESS` and updates the access cost for `EXTCODESIZE` and `EXTCODECOPY`. The design coordinates with EIP-8032: before EIP-8032, parameters assume

SPECIFICATION:
### Parameters Upon activation of this EIP, the following parameters of the gas model are renamed: | **Parameter** | **New name** | |:---:|:---:| | `GAS_STORAGE_UPDATE` | `GAS_COLD_STORAGE_WRITE` | | `GAS_COLD_SLOAD` | `GAS_COLD_STORAGE_ACCESS` | The following parameters of the gas model updated: | **Parameter** | **Current value** | **New value**

MOTIVATION:
The gas price of accessing state has not been updated for quite some time. [EIP-2929](eip-2929.md) was included in the Berlin fork in March 2021 and raised the costs of state-accessing opcodes. Yet, since then, Ethereum's state has grown significantly, thus deteriorating the performance of these operations. This proposal further

RATIONALE:
### Benchmarking This proposal does not yet have finalized numbers. To achieve this, we require stateful benchmarks, which are currently in development. Once we collect that data, we will set the final numbers. <-- TODO --> ### Special case for `EXTCODESIZE` and `EXTCODECOPY` Differently from other account read operations,


=== EIP-8075 ===
TITLE: Adaptive state cost to cap growth & scale L1
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-02
REQUIRES: 1, 5, 5, 9, ,,  , 4, 8, 4, 4, ,,  , 8, 0, 3, 7

SUMMARY:
This EIP precisely caps state growth while at the same time facilitating between 50%-300% more non-state operations per block compared to when solely raising the state gas cost. The cap is achieved by tracking state creation and having a dedicated [EIP-4844](./eip-4844.md) style fee market mechanism set the cost, to

MOTIVATION:
Ethereum is currently focused on scaling the layer 1, with a rapid expansion of the block gas limit foreseen in the near-term from compute and memory optimization, as well as via headliner proposals [EIP-7732](./eip-7732.md) and [EIP-7928](./eip-7928.md). Unfortunately, if the gas cost for state creation is kept fixed, state would

RATIONALE:
### Potential concerns with current EIP-8037 EIP-8037 sets a fixed price of 1900 gas per byte, which can lead to a range of outcomes, depending on, e.g., the price-elasticity of demand for state creation. A specific concern is that since EIP-8037 counts state gas against the regular block gas


=== EIP-1588 ===
TITLE: Hardfork Meta: Ethereum ProgPoW
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-11-16
REQUIRES: 1057

SUMMARY:
This meta-EIP specifies the changes included in the alternative Ethereum hardfork named Ethereum ProgPoW.

SPECIFICATION:
- Codename: Ethereum ProgPoW - Aliases: N/A - Activation: - `Block >= 7280000` on the Ethereum mainnet - Included EIPs: - [EIP-1057](./eip-1057.md): ProgPoW, a Programmatic Proof-of-Work


=== EIP-152 ===
TITLE: Add BLAKE2 compression function `F` precompile
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-04
REQUIRES: 

SUMMARY:
This EIP introduces a new precompiled contract which implements the compression function `F` used in the BLAKE2 cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and Zcash, as well as introducing more flexible cryptographic hash primitives to the EVM.

SPECIFICATION:
We propose adding a precompiled contract at address `0x09` wrapping the [BLAKE2 `F` compression function](https://tools.ietf.org/html/rfc7693#section-3.2). The precompile requires 6 inputs tightly encoded, taking exactly 213 bytes, as explained below. The encoded inputs are corresponding to the ones specified in the [BLAKE2 RFC Section 3.2](https://tools.ietf.org/html/rfc7693#section-3.2): - `rounds` - the number

MOTIVATION:
Besides being a useful cryptographic hash function and SHA3 finalist, BLAKE2 allows for efficient verification of the Equihash PoW used in Zcash, making a BTC Relay - style SPV client possible on Ethereum. A single verification of an Equihash PoW verification requires 512 iterations of the hash function, making

RATIONALE:
BLAKE2 is an excellent candidate for precompilation. BLAKE2 is heavily optimized for modern 64-bit CPUs, specifically utilizing 24 and 63-bit rotations to allow parallelism through SIMD instructions and little-endian arithmetic. These characteristics provide exceptional speed on native CPUs: 3.08 cycles per byte, or 1 gibibyte per second on an


=== EIP-8116 ===
TITLE: Replace cumulative receipt fields
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-12-30
REQUIRES: 

SUMMARY:
This EIP describes how to change the on-chain receipt data to track gas per transaction instead of cumulatively.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### `Receipt` construction All receipts emitted after this EIP activates track the individual transaction's `gasUsed`

MOTIVATION:
Currently, on-chain receipts track a `cumulativeGasUsed` field which contains the running sum of all gas spent for all transactions in the block so far. This has a number of shortcomings: 1. **Inefficient verification:** RPC clients that want to verify individual transaction `gasUsed` requires computation based on `cumulativeGasUsed` across consecutive

RATIONALE:
This EIP is a step towards aligning on-chain data with the RPC data actually being consumed by client applications. Stateful components of receipts (`cumulativeGasUsed` / `logIndex`) are replaced with per-transaction equivalents.


=== EIP-969 ===
TITLE: Modifications to ethash to invalidate existing dedicated hardware implementations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-03
REQUIRES: 

SUMMARY:
There are companies who currently have dedicated hardware based ethereum miners in production, and may be actively mining. This EIP aims to "poison the well" by modifying the block mining algorithm in a low risk manner that may *"break"* these miners if they are in-fact built as traditional ASICs.

SPECIFICATION:
If `block.number >= ASIC_MITIGATION_FORK_BLKNUM`, require that the ethash solution sealing the block has been mined using `ethashV2`.

MOTIVATION:
ASIC-based miners will have lower operational costs than GPU-based miners, which will result in GPU-based mining quickly becoming unprofitable. Given that production of ASIC-based miners has a high barrier to entry and few market players, this will cause a trend towards centralization of mining power. Risks include market dominance

RATIONALE:
This EIP is aimed at breaking existing ASIC-based miners via small changes to the existing ethash algorithm. We hope to accomplish the following: 1. Break existing ASIC-based miners. 2. Demonstrate a willingness to fork in the event of future ASIC miner production. Goal #1 is something that we can


=== EIP-3521 ===
TITLE: Reduce access list cost
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-15
REQUIRES: 2, 0, 2, 8, ,,  , 2, 9, 3, 0

SPECIFICATION:
Treat the first occurrence of `tx.to` in an access list as `calldata` for gas accounting purposes. Do not charge `ACCESS_LIST_ADDRESS_COST` for it. Storage keys underneath the address are unaffected. If `tx.to == nil`, `tx.to` is defined be the derived contract address created by the transaction.

MOTIVATION:
Currently, a transaction must read at least 25 distinct storage slots in `tx.to` before it's more expensive to forego an access list. ``` ACCESS_LIST_ADDRESS_COST + (ACCESS_LIST_STORAGE_KEY_COST + WARM_STORAGE_READ_COST) * x = COLD_SLOAD_COST * x x = 24 ``` EIP-2930 requires the address under which the storage keys reside be


=== EIP-8011 ===
TITLE: Multidimensional Gas Metering
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-22
REQUIRES: 

SUMMARY:
This proposal introduces multidimensional gas metering, changing the way we account for gas used at the block level. This enables Ethereum to increase throughput and better control excessive resource usage, with minimal changes to the protocol and the UX. During transaction execution, gas is metered for each resource dimension,

SPECIFICATION:
### Operation gas costs Under the multidimensional metering model, EVM operations are assigned a cost vector whose components correspond to their gas cost on each resource dimension. Each cost has 6 dimensions: `gas_cost_vector = (compute_cost, access_cost, size_cost, memory_cost, state_cost, history_cost)`. #### Pure compute operations The operations listed in [compute_ops](../assets/eip-8011/compute_ops.md)

MOTIVATION:
This proposal separates *transaction pricing* (i.e., the way of measuring consumption of resources by transactions) from *block metering* (i.e., the way of controlling resource limits and ensure that blocks do not overload the network). More concretely, it introduces a multidimensional metering scheme that accounts for the different EVM resources

RATIONALE:
### Why are we choosing this resource split? Ethereum’s slot-based structure introduces a strict temporal constraint: all attestations must be processed, aggregated, and propagated within a single slot. This fact makes time a fundamental resource. To maintain network health, validators must execute blocks, validate them, and gossip attestations quickly


=== EIP-7883 ===
TITLE: ModExp Gas Cost Increase
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-02-11
REQUIRES: 2565

SUMMARY:
This EIP is modifying the `ModExp` precompile pricing algorithm introduced in [EIP-2565](./eip-2565.md).

SPECIFICATION:
Upon activation of this EIP, the gas cost of calling the precompile at address `0x0000000000000000000000000000000000000005` will be calculated as follows: ``` def calculate_multiplication_complexity(base_length, modulus_length): max_length = max(base_length, modulus_length) words = math.ceil(max_length / 8) multiplication_complexity = 16 if max_length > 32: multiplication_complexity = 2 * words**2 return multiplication_complexity def calculate_iteration_count(exponent_length,

MOTIVATION:
Currently the `ModExp` precompile is underpriced in certain scenarios relative to its resource consumption. By adjusting the pricing formula, this EIP aims to address these discrepancies, making `ModExp` sufficiently efficient to enable potential increases in the block gas limit.

RATIONALE:
Benchmarking the `ModExp` precompile revealed several scenarios where its gas cost was significantly underestimated. Pricing adjustments are designed to rectify underpriced edge cases by modifying the existing `ModExp` pricing formula parameters. Specifically, the minimum cost for `ModExp` will rise from 200 to 500 (a 150% increase), the general cost


=== EIP-7851 ===
TITLE: Deactivate/Reactivate a Delegated EOA's Key
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-12-27
REQUIRES: 7702

SUMMARY:
This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts via [EIP-7702](./eip-7702) to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Parameters | Constant | Value | |-----------------------------------|----------------------| | `PRECOMPILE_ADDRESS` | `0xTBD` | | `PRECOMPILE_GAS_COST`

MOTIVATION:
[EIP-7702](./eip-7702) enables EOAs to gain smart contract capabilities, but the private key of the EOA still retains full control over the account. With this EIP, EOAs can fully migrate to smart contract wallets, while retaining private key recovery options with reactivation. The flexible deactivate and reactivate design also paves

RATIONALE:
### Cost of Precompiled Contract The `PRECOMPILE_GAS_COST` represents the gas required to validate and potentially update an account's code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node: * Reading the code of the address: `2600`. * Changing the code


=== EIP-7706 ===
TITLE: Separate gas type for calldata
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-13
REQUIRES: 1, 5, 5, 9, ,,  , 4, 8, 4, 4

SUMMARY:
Add a new type of gas for transaction calldata. Add a new transaction type that provides `max_basefee` and `priority_fee` as a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters * `FORK_BLKNUM` = `TBD` * `NEW_TX_TYPE` = `TBD` * `CALLDATA_GAS_PER_TOKEN` = `4` * `TOKENS_PER_NONZERO_BYTE` = `4` * `CALLDATA_GAS_LIMIT_RATIO` =

MOTIVATION:
A major argument against raising the Ethereum gas limit, making calldata cheaper, or increasing the [EIP-4844](./eip-4844.md) blob count before technologies like PeerDAS become available, is that the theoretical maximum size of an Ethereum block is already too large, and we cannot afford to increase it further. However, there is

RATIONALE:
### Conversion of all gas-related mechanics into vectors This allows the same logic that is used for handling gas to handle all three types of gas. As a result, it's arguably a net simplification of protocol gas handling logic, despite the fact that the total number of gas types


=== EIP-3238 ===
TITLE: Difficulty Bomb Delay to Q2/2022
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-01-25
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting eleven million blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 11_000_000) if block.number >= FORK_BLOCK_NUMBER else block.number

MOTIVATION:
Even after the Ethereum 2.0 mainnet launch, Ethash proof-of-work mining on the legacy chain should be feasible. It should allow miners sealing new blocks every 13~15 seconds on average for another ten months and allow both Ethereum 1.x and Ethereum 2.0 developers to conclude the merge.

RATIONALE:
This will delay the ice age by another ~26 million seconds (approximately ~9.89 months), so the chain would be back at ~30 second block times in Q2/2022. Hopefully, by then the Eth1-to-Eth2 merge will be concluded and the ice age fulfilled its task.


=== EIP-2027 ===
TITLE: State Rent C - Net contract size accounting
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-14
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces initial, net accounting of the number of the contract storage slots. Though not very useful on its own, it makes it possible to introduce gross accounting of the number of storage slots, which is useful for number

SPECIFICATION:
Each contract (account with `codeHash` field not equal to 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, which the hash of the empty code) gets a new uint64 field, called `storagesize`. On and after block `C`, the semantics of the operation `SSTORE` (`location`, `value`) changes as follows: - If previous value of the [`location`] is 0,

MOTIVATION:
Ethereum currently does not track the number of contract storage slots at all, and producing such number given the downloaded state cannot be done in constant *O(1)* time.

RATIONALE:
A mechanism for estimation of contract storage size has been proposed [here](https://medium.com/@akhounov/estimation-approximate-of-the-size-of-contracst-in-ethereum-4642fe92d6fe). But it does have a big drawback of introducing a lot of complexity into the consensus (in the form of estimation algorithm, which has quite a few edge cases to cater for different sizes of the storage).


=== EIP-8071 ===
TITLE: Prevent using consolidations as withdrawals
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-29
REQUIRES: 

SUMMARY:
Cancels a consolidation request if the effective balance of the target validator would exceed the max effective balance after processing it, which would result in the excess balance being withdrawn. This is an unintended way to speed up withdrawals when the consolidation queue is faster than the exit queue.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). Starting from the beginning of the epoch when this EIP is activated, Consensus Layer client

MOTIVATION:
The existing design of consolidation mechanism leaves an opportunity to use consolidation queue for exits which becomes appealing to be abused when there is an imbalance between exit and consolidation queues favoring the latter. At the date of writing this EIP, the consolidation flaw is being heavily exploited. There

RATIONALE:
### Iterating over pending consolidations The new design introduces an iteration over pending consolidations which increases complexity of consolidation processing. This is done to handle the case when there are multiple consolidations with the same target and each of them doesn't exceed the max effective balance while all of


=== EIP-3779 ===
TITLE: Safer Control Flow for the EVM
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-08-30
REQUIRES: 

SUMMARY:
We define a safe EVM contract as one that cannot encounter an exceptional halting state. In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset. This EIP specifies validity rules to ensure that: > Valid contracts will not halt with an exception unless

SPECIFICATION:
### Validity > In theory, theory and practice are the same. In practice, they're not. -- Albert Einstein We define a _safe_ EVM contract as one that cannot encounter an exceptional halting state. We validate _safety_ at initialization time to the extent practical. #### *Exceptional Halting States* The *execution*

MOTIVATION:
### Safety For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state. From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain. Unsafe code can attempt to overflow stack, underflow stack, execute invalid

RATIONALE:
Demanding *static* destinations for all jumps means that all jump destinations can be validated at initialization time, not runtime. Bounding the stack pointers catches all `data stack` and non-recursive`return stack` overflows. Requiring a consistently aligned`data stack` prevents stack underflow. It can also catch such errors as misaligned stacks due


=== EIP-7199 ===
TITLE: Linter Scope
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2023-06-20
REQUIRES: 

SUMMARY:
Currently in practice EIP linter tools (EIPW, for example) will block a Pull Request for lint errors even if that lint errors was not introduced in that Pull Request. This EIP make it explicit that lint errors for untouched lines shall be considered ignorable except for status change.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. In an update to an EIP, A Pull Request SHOULD NOT be required to fix linter errors in untouched lines

RATIONALE:
This policy allows micro contributions for anyone who just want to fix a typo or change a section of a section in a large EIP.


=== EIP-8077 ===
TITLE: eth/XX - announce transactions with nonce
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2025-11-07
REQUIRES: 7642

SUMMARY:
This EIP improves mempool propagation, extending the devp2p 'eth' protocol's `NewPooledTransactionHashes` message to also announce each transaction's source address and nonce together with the already announced hash, type, and size.

SPECIFICATION:
### NewPooledTransactionHashes message changes Modify the NewPooledTransactionHashes (0x08) message as follows: (eth/69): [txtypes: B, [txsize₁: P, txsize₂: P, ...], [txhash₁: B_32, txhash₂: B_32, ...]] (eth/XX): [txtypes: B, [txsize₁: P, txsize₂: P, ...], [txhash₁: B_32, txhash₂: B_32, ...], [txsource₁: B_20, txsource₂: B_20, ...], [txnonce₁: P, txnonce₂: P, ...]] ### Changes

MOTIVATION:
Transactions are propagated in the Mempool using the devp2p protocol in two modalities. Eager push is only used for small transactions, and only towards a few nodes, while the rest of nodes receive only announcements. For large transactions and for type 3 transactions, only announcements are sent. This announcement

RATIONALE:
To solve the transaction propagation issues mentioned in the Motivation section, nodes require more information about a transaction then its hash, size, and type. By adding the source and the nonce, the receiver has enough information to make better fetch decisions. ### Overhead The modification adds a significant overhead


=== EIP-4747 ===
TITLE: Simplify EIP-161
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-02
REQUIRES: 161

SUMMARY:
Simplify the definition of [EIP-161](./eip-161.md), removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Retroactively replace EIP-161, starting from its introduction in block 2675000, with the following rules: a. When creating an account, set

MOTIVATION:
EIP-161 is overly complex and has a number of edge cases that are poorly documented and tested. This EIP takes advantage of the complete removal of all remaining empty accounts in block 14049881 (tx `0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d`) to clarify it, and allows implementors to not implement various edge cases that never

RATIONALE:
EIP-161 provides that empty accounts (accounts that have zero nonce, zero balance and no code, but that might have storage) can no longer be created and provides mechanism to remove old empty accounts. The last empty accounts were removed in block 14049881 (tx `0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d`). The complete removal of all


=== EIP-7623 ===
TITLE: Increase calldata cost
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-02-13
REQUIRES: 

SUMMARY:
The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB. This EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users. This is achieved by

SPECIFICATION:
| Parameter | Value | | ---------------------------- | ----- | | `STANDARD_TOKEN_COST` | `4` | | `TOTAL_COST_FLOOR_PER_TOKEN` | `10` | Let `tokens_in_calldata = zero_bytes_in_calldata + nonzero_bytes_in_calldata * 4`. Let `isContractCreation` be a boolean indicating the respective event. Let `execution_gas_used` be the gas used for EVM execution with the gas

MOTIVATION:
The block gas limit has not been increased since [EIP-1559](./eip-1559.md), while the average size of blocks has continuously increased due to the growing number of rollups posting data to Ethereum. Moreover, calldata costs have remained unchanged since [EIP-2028](./eip-2028). [EIP-4844](./eip-4844.md) introduces blobs as a preferred method for data availability (DA).

RATIONALE:
The current maximum EL payload size is approximately 1.79 MB (`30_000_000/16`). It is possible to create payloads filled with zero bytes that expand to 7.15 MB. However, since blocks are typically compressed with Snappy at the P2P layer, zero-byte-heavy EL payloads generally compress to under 1.79 MB. The implementation


=== EIP-3978 ===
TITLE: Gas refunds on reverts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-09-16
REQUIRES: 2929

SUMMARY:
For reverted state modification operations, keep access cost, but refund modification cost.

SPECIFICATION:
For each callframe, track `revert_gas_refund`, initially 0. The set of operations that modify `revert_gas_refund` are: - SSTORE - LOG0, LOG1, LOG2, LOG3, LOG4 - CALL - CREATE, CREATE2 - SELFDESTRUCT They increase `revert_gas_refund` as follows: ```javascript call.revert_gas_refund += operation.gas - WARM_STORAGE_READ_COST ``` And in case of revert let's use

MOTIVATION:
Reverting a transaction, or any of its sub-calls, drops any state modifications that happened inside. But now, users are being charged for the dropped modifications as if they persisted. Since [EIP-3298](./eip-3298.md), the gas refund mechanism works for storage restores only inside the same transaction. But on revert, the gas

RATIONALE:
Gas should reflect the cost of use. The revert cost reflects the cost of access during execution, but not the cost of modification.


=== EIP-5792 ===
TITLE: Wallet Call API
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-10-17
REQUIRES: 1193

SUMMARY:
Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls. Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional,

SPECIFICATION:
Four new JSON-RPC methods are added: three are for handling batches of onchain calls, and one is for querying support for wallet capabilities, such as to make better use of the three batching methods. Apps may begin using these first three methods immediately, falling back to `eth_sendTransaction` and `eth_getTransactionReceipt`

MOTIVATION:
The current methods used to send transactions from the user wallet and check their status are `eth_sendTransaction` and `eth_getTransactionReceipt`. The current methods used to send transactions from the user wallet and check their status do not meet modern developer demands and cannot accommodate new transaction formats. Even the name–-

RATIONALE:
### On Naming We considered modifying `eth_sendTransaction` to add support for these new capabilities, but the method is ultimately an artifact of when nodes were used to sign transactions. We decided it is better to move forward with `wallet_`-namespaced methods that better describe what they are used for. We


=== EIP-6810 ===
TITLE: Ex Post Facto Cascading Revert
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-01
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 2, 9

SUMMARY:
A new transaction type reverts one of a sender's prior transactions, and other transactions dependent on that state, recursively.

SPECIFICATION:
### Parameters A new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` `0x5a`. The [EIP-2718](./eip-2718.md) `TransactionPayload` for this transaction is `rlp([chainId, nonce, revertNonce, budget, signatureYParity, signatureR, signatureS])`. The `signatureYParity, signatureR, signatureS` elements of this transaction represent a secp256k1 signature over `keccak256(0x5a || rlp([chainId, nonce, revertNonce, budget]))`. The [EIP-2718](./eip-2718.md) `ReceiptPayload` for this

MOTIVATION:
While Ethereum has the capability of reversible transactions through smart contracts, instant settlement is the default. But sometimes users make mistakes. Most mistakes are discovered quickly. However, once the transaction is confirmed, it is settled. There are many use cases for reverting settled transactions. Some of the most-common mistakes

RATIONALE:
The transaction must fill the entire block to prevent MEV attacks. While some cascading reverts are highly consequential, others are considerably simpler. The budget ensures the full network cost of the operation is paid. For example, reversing a token transfer to the wrong recipient would be relatively cheap. On


=== EIP-3529 ===
TITLE: Reduction in refunds
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-04-22
REQUIRES: 2, 2, 0, 0, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `MAX_REFUND_QUOTIENT` | 5 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. 1. Remove the `SELFDESTRUCT` refund. 2. Replace `SSTORE_CLEARS_SCHEDULE` (as defined in [EIP-2200](./eip-2200.md)) with `SSTORE_RESET_GAS + ACCESS_LIST_STORAGE_KEY_COST` (4,800

MOTIVATION:
Gas refunds for `SSTORE` and `SELFDESTRUCT` were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, the benefits of this technique have proven to be far lower than anticipated, and gas refunds have

RATIONALE:
In [EIP-2200](./eip-2200.md#specification), three cases for refunds were introduced: 1. If the original value is nonzero, and the new value is zero, add `SSTORE_CLEARS_SCHEDULE` (currently 15,000) gas to the refund counter 2. If the original value is zero, the current value is nonzero, and the new value is zero, add


=== EIP-6811 ===
TITLE: To The Moon—10 Minute Blocks
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-01
REQUIRES: 

SUMMARY:
This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth's solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. * The time between blocks MUST be changed from 12 seconds to 600 seconds (10

MOTIVATION:
It is impossible for today's Ethereum to literally "go to the moon" due to a limitation in the protocol: the block length. Should validators attempt to validate on the surface of the moon, they would find that the ~1.25 second communication delay (caused by the speed of light) might

RATIONALE:
* The block gas limit is multiplied by fifty to compensate for the time between blocks being multiplied by fifty. * The per-block validator reward is also multiplied by fifty to compensate for the time between blocks being multiplied by fifty. * Epochs are changed to be 2 blocks


=== EIP-2711 ===
TITLE: Sponsored, expiring and batch transactions.
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-06-11
REQUIRES: 2718

SUMMARY:
An EIP-2718 transaction with the type number `2` is a new type of transaction that includes support for: 1. **Sponsored Transactions**: an optional additional signature from which the account that will pay for gas (`GAS_PAYER`) can be recovered 2. **Batch Transactions**: multiple transactions from the same sender that will

SPECIFICATION:
### Definitions **`TransactionType`** 2. See [EIP-2718](./eip-2718.md) **`TransactionSubtype`** is either 1, 2, 3, or 4. **`ChainId`** The transaction is valid if this value is `0` or it is included in a block on a chain whose ID is equal to this value. **`ValidUntil`** The transaction is valid if this value

MOTIVATION:
### Sponsored Transactions With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account. Some users don't want to be exposed to the perceived volatility of ETH

RATIONALE:
### One Monolithic EIP This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type. Alternatively, each of the subtypes could be a unique TransactionType. The reason we chose to go with a single EIP with subtypes is because these


=== EIP-2014 ===
TITLE: Extended State Oracle
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-10
REQUIRES: 140

SUMMARY:
Introduce a new system contract with an extensible interface following the [Contract ABI Encoding] to access extended data sets, such as chain identifiers, block hashes, etc. This allows Ethereum contract languages to interact with this contract as if it were a regular contract and not needing any language support.

SPECIFICATION:
A new system contract ("precompile") is introduced at address `0x0000000000000000000000000000000000000009` called ESO (Extended State Oracle). It can be queried using `CALL` or `STATICCALL` and follows the [Contract ABI Encoding] for the inputs and outputs. Using elementary types in the ABI encoding is encouraged to keep complexity low. In the

MOTIVATION:
Over the past couple of years several proposals were made to extend the EVM with more data. Some examples include extended access to block hashes ([EIP-210]) and chain identifiers ([EIP-1344]). Adding them as EVM opcodes seems to be using the scarce opcode space for relatively less frequently used features,

RATIONALE:
TBA


=== EIP-2046 ===
TITLE: Reduced gas cost for static calls made to precompiles
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-17
REQUIRES: 2, 1, 4, ,,  , 1, 3, 5, 2

SUMMARY:
Reduce the base gas cost of calling precompiles using `STATICCALL` from 700 to 40. This should allow more efficient use of precompiles as well as precompiles with a total cost below 700.

SPECIFICATION:
After block `HF` the `STATICCALL` (`0xfa`) instruction charges different basic gas cost (G<sub>call</sub> in [Yellow Paper]'s notation) depending on the destination address provided: - for precompiles (address range as per [EIP-1352]) the cost is `40` - for every other address the cost remains unchanged (`700`)

MOTIVATION:
The Spurious Dragon hard fork increased the cost of calls significantly to account for loading contract code from the state without making an exception for precompiles, whose "code" is always loaded. This made use of certain precompiles impractical. FIXME: extend this with recent reasoning about ECC repricings.

RATIONALE:
Only the `STATICCALL` instruction was changed to reduce the impact of the change. This should not be a limiting factor, given precompiles (currently) do not have a state and cannot change the state. However, contracts created and deployed before Byzantium likely will not use `STATICCALL` and as a result


=== EIP-7709 ===
TITLE: Read BLOCKHASH from storage and update cost
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-18
REQUIRES: 2935

SUMMARY:
Update the `BLOCKHASH (0x40)` opcode to read and serve from the system contract storage and charge the **additional** (cold or warm) storage costs.

SPECIFICATION:
| Parameter | Value | | ------------------------- | ------ | | `FORK_TIMESTAMP` | TBD | | `HISTORY_STORAGE_ADDRESS` | `0x0000F90827F1C53a10cb7A02335B175320002935` | | `BLOCKHASH_SERVE_WINDOW` | `256` | The `BLOCKHASH` opcode semantics remains the same as before. From the `fork_block` (defined as `fork_block.timestamp >= FORK_TIMESTAMP and fork_block.parent.timestamp < FORK_TIMESTAMP`), the `BLOCKHASH` instruction

MOTIVATION:
The `BLOCKHASH (0x40)` opcode currently assumes that the client has knowledge of the previous blocks, which in Verkle [EIP-6800](./eip-6800.md) would prevent stateless execution. However with [EIP-2935](./eip-2935.md) blockhashes can be retrieved and served from its system contract storage which allows Verkle blocks to include a storage access witness for stateless

RATIONALE:
* The reason behind the updated gas cost is to match the real operation, which is equivalent to an `SLOAD`. * The [EIP-2935](./eip-2935.md) system contract execution charges (and accesses) are not applied to keep the gas low and to keep things simple for clients which choose to resolve `BLOCKHASH`


=== EIP-2045 ===
TITLE: Particle gas costs for EVM opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-17
REQUIRES: 

SUMMARY:
According to recent benchmarks, EVM opcodes for computation (`ADD`, `SUB`, `MUL`, etc.) are generally overpriced relative to opcodes for storage I/O (`SLOAD`, `SSTORE`, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5,

SPECIFICATION:
A new gas counter `particlesUsed` is added to the EVM, in addition to the existing gas counter `gasUsed`. The unit 1 gas is equal to 10000 particles (`PARTICLES_PER_GAS`). The `particlesUsed` counter is only increased for opcodes priced in particles (i.e. opcodes that cost less than 1 gas). If increasing

MOTIVATION:
The transaction capacity of an Ethereum block is determined by the gas cost of transactions relative to the block gas limit. One way to boost the transaction capacity is to raise the block gas limit. Unfortunately, raising the block gas limit would also increase the rate of state growth,

RATIONALE:
Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept of `particles` need not be exposed to Ethereum users nor most contract authors, but only to EVM implementers


=== EIP-161 ===
TITLE: State trie clearing (invariant-preserving alternative)
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-24
REQUIRES: 

SPECIFICATION:
a. Account creation transactions and the `CREATE` operation SHALL, prior to the execution of the initialisation code, **increment** the **nonce** over and above its normal starting value by **one** (for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different). b. Whereas

RATIONALE:
Same as #158 except that several edge cases are avoided since we do not break invariants: - ~~that an account can go from having code and storage to not having code or storage mid-way through the execution of a transaction;~~ [corrected] - that a newly created account cannot be


=== EIP-8 ===
TITLE: devp2p Forward Compatibility Requirements for Homestead
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2015-12-18
REQUIRES: 

SUMMARY:
This EIP introduces new forward-compatibility requirements for implementations of the devp2p Wire Protocol, the RLPx Discovery Protocol and the RLPx TCP Transport Protocol. Clients which implement EIP-8 behave according to Postel's Law: > Be conservative in what you do, be liberal in what you accept from others. ### Specification

SPECIFICATION:
Implementations of **the devp2p Wire Protocol** should ignore the version number of hello packets. When sending the hello packet, the version element should be set to the highest devp2p version supported. Implementations should also ignore any additional list elements at the end of the hello packet. Similarly, implementations of

MOTIVATION:
Changes to the devp2p protocols are hard to deploy because clients running an older version will refuse communication if the version number or structure of the hello (discovery ping, RLPx handshake) packet does not match local expectations. Introducing forward-compatibility requirements as part of the Homestead consensus upgrade will ensure

RATIONALE:
The proposed changes address forward compatibility by applying Postel's Law (also known as the Robustness Principle) throughout the protocol stack. The merit and applicability of this approach has been studied repeatedly since its original application in RFC 761. For a recent perspective, see ["The Robustness Principle Reconsidered" (Eric Allman,


=== EIP-7377 ===
TITLE: Migration Transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-21
REQUIRES: 1, 7, 0, ,,  , 1, 5, 5, 9, ,,  , 2, 2, 0, 0, ,,  , 2, 7, 1, 8

SUMMARY:
Introduce a new [EIP-2718](./eip-2718.md) transaction type with the format `0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])` which sets the sending account's `code` field in the state trie to the `code` value at `codeAddr` and applies the storage tuples to the sender's

SPECIFICATION:
At the fork block `X`, introduce the migration transaction type. ### Migration Transaction #### Definition | field | type | |------------------------|-----------| | `chainId` | `uint256` | | `nonce` | `uint64` | | `maxFeePerGas` | `uint256` | | `maxPriorityFeePerGas` | `uint256` | | `gasLimit` | `uint64` | | `codeAddr` |

MOTIVATION:
Smart contract wallets have long been touted as the solution to Ethereum's user experience woes. As early as 2015, there were proposals for allowing smart contracts to originate transactions in hopes that new users would flock to smart contract wallets to store their assets. So far, only a fraction

RATIONALE:
### No `to` address field This transaction is only good for one-time use to migrate an EOA to a smart contract. It is designed to immediately call the deployed contract, which is at the sender's address, after deployment to allow the sender to do any kind of further processing.


=== EIP-4 ===
TITLE: EIP Classification
TYPE: Meta 
STATUS: Final
CREATED: 2015-11-17
REQUIRES: 


=== EIP-1295 ===
TITLE: Modify Ethereum PoW Incentive Structure and Delay Difficulty Bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-05
REQUIRES: 

SUMMARY:
Starting with CNSTNTNPL_FORK_BLKNUM the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 6 million blocks later than previously specified with the Homestead fork. Furthermore, Uncle rewards will be adjusted and Nephew rewards will be removed to

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 6_000_000) if block.number >= CNSTNTNPL_FORK_BLKNUM else block.number #### Adjust Uncle and Nephew rewards If an

MOTIVATION:
Network scalability and security are at the forefront of risks to the Ethereum protocol. With great strides being made towards on and off chain scalability, the existence of an artificial throughput limiting device in the protocol is not warranted. Removing the risk of reducing throughput through the initialization of

RATIONALE:
The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the growing ecosystem’s security are paramount. At the same time, the ancillary issuance benefits of the Ethereum protocol can be adjusted to reduce the overall issuance profile. Aggressively adjusting Uncle and removing


=== EIP-2700 ===
TITLE: JavaScript Provider Event Emitter
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2020-06-05
REQUIRES: 

SUMMARY:
This standard provides the description of an object that is made available to JavaScript applications which they can use to receive notifications from an Ethereum Provider. This standard only describes the notification mechanism, it does not specify the payloads that are valid nor does it specify how the client

SPECIFICATION:
### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Interface ```ts interface EthereumProvider { on(eventName: string, listener: (...params: unknown[]) => void): void removeListener(eventName: string, listener: (...params: unknown[])

MOTIVATION:
When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime. Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or

RATIONALE:
This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn't a lot of room for improving things such as by using a discriminated union object for listener parameters or having a tighter definition of `on`. The specific events are intentionally left out


=== EIP-706 ===
TITLE: DEVp2p snappy compression
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-09-07
REQUIRES: 

SUMMARY:
The base networking protocol (DEVp2p) used by Ethereum currently does not employ any form of compression. This results in a massive amount of bandwidth wasted in the entire network, making both initial sync as well as normal operation slower and laggier. This EIP proposes a tiny extension to the

SPECIFICATION:
Bump the advertised DEVp2p version number from `4` to `5`. If during handshake, the remote side advertises support only for version `4`, run the exact same protocol as until now. If the remote side advertises a DEVp2p version `>= 5`, inject a Snappy compression step right before encrypting the

MOTIVATION:
Synchronizing the Ethereum main network (block 4,248,000) in Geth using fast sync currently consumes 1.01GB upload and 33.59GB download bandwidth. On the Rinkeby test network (block 852,000) it's 55.89MB upload and 2.51GB download. However, most of this data (blocks, transactions) are heavily compressible. By enabling compression at the message


=== EIP-7784 ===
TITLE: GETCONTRACT opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-10-07
REQUIRES: 

SUMMARY:
This is a proposal to add a new opcode, `GETCONTRACT`. The `GETCONTRACT` opcode would return the address containing the bytecode by its hash.

SPECIFICATION:
### Opcode Definition * **Mnemonic:** `GETCONTRACT` * **Opcode Value:** `0x4f` * **Input:** * `codehash`: A single 32-byte code hash from the stack. * **Output:** * `address`: If the `codehash` exists in the state, pushes the corresponding contract address onto the stack. Otherwise, pushes 0. * **Gas Cost:** 150 *

MOTIVATION:
Content addressing by hash is a common pattern in database design. It allows to store and retrieve data by its unique footprint in the storage. This pattern is widely used in the industry and it allows abstracting the actual storage location and allows reusing the same bytecode in multiple

RATIONALE:
**Bytecode over Addresses**: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable. **Do not re-index**: There is small, yet non-zero probability of hash collision attack. Disallowing updates to indexed location of bytecode coupes with this. **Gas cost**: This operation is more complex than simple


=== EIP-7705 ===
TITLE: NONREENTRANT and REENTRANT opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-09
REQUIRES: 

SUMMARY:
Add two opcodes, `NONREENTRANT` and `REENTRANT`, which set and clear a contract's reentrancy status. After invoking `NONREENTRANT`, a contract cannot be `CALL`ed (or `STATICCALL`ed, or `DELEGATECALL`ed) until `REENTRANT` is invoked.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Two new opcodes are introduced, `NONREENTRANT` (0xF6) and `REENTRANT` (0xF7), which set and clear a

MOTIVATION:
Reentrancy attacks account for a substantial portion of user funds stolen on EVM chains, including the famous "DAO hack". However, due to the cost of preventing reentrancy attacks in application code, developers often opt-out of reentrancy protection. This cost has come down with the advent of transient storage ([EIP-1153](./eip-1153.md)),

RATIONALE:
The computational cost of pushing the current value to the call stack (for handling reverts) is accounted for in the overhead cost of the `*CALL` opcodes. An alternative design could be considered which only introduces one opcode. This opcode, `NONREENTRANT`, would take a single stack item and set the


=== EIP-3220 ===
TITLE: Crosschain Identifier Specification
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-21
REQUIRES: 

SUMMARY:
The crosschain-id is a 32 byte hex string and with some bytes extracted from blockchain hash and some manually defined to characterize a blockchain. We also propose a registration and lookup service to retrieve blockchain metadata from the crosschain-id.

SPECIFICATION:
### Definition of a 32 byte crosschain id | Name | Size(bytes) | Description | |---------------|-------------|-------------| | Truncated Block Hash | 16 | This is the block hash of the genesis block or the block hash of the block immediate prior to the fork for a fork of a

MOTIVATION:
With the success of Bitcoin and Ethereum, various blockchains such as EOS, Ripple, Litecoin, Besu, Wanchain and the like have been developed and are growing at a fast pace. There are also other private and consortium blockchains such as Hyperledger Fabric, Hyperledger Besu, Stellar, Corda, Quorum that only allow

RATIONALE:
We have considered various alternative specifications such as using a random unique hex string to represent a blockchain. The drawback of this method is that the random id can not be used to verify a blockchain's intrinsic identity such as the blockhash of the genesis block. A second alternative


=== EIP-1884 ===
TITLE: Repricing for trie-size-dependent opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-03-28
REQUIRES: 1, 5, 0, ,,  , 1, 0, 5, 2

SUMMARY:
The growth of the Ethereum state has caused certain opcodes to be more resource-intensive at this point than they were previously. This EIP proposes to raise the `gasCost` for those opcodes.

SPECIFICATION:
At block `N`, - The `SLOAD` (`0x54`) operation changes from `200` to `800` gas, - The `BALANCE` (`0x31`) operation changes from `400` to `700` gas, - The `EXTCODEHASH` (`0x3F`) operation changes from `400` to `700` gas, - A new opcode, `SELFBALANCE` is introduced at `0x47`. - `SELFBALANCE` pops `0`

MOTIVATION:
An imbalance between the price of an operation and the resource consumption (CPU time, memory etc) has several drawbacks: - It could be used for attacks, by filling blocks with underpriced operations which causes excessive block processing time. - Underpriced opcodes cause a skewed block gas limit, where sometimes

RATIONALE:
Here are two charts, taken from a full sync using Geth. The execution time was measured for every opcode, and aggregated for 10K blocks. These bar charts show the top 25 'heavy' opcodes in the ranges 5M to 6M and 6M to 7M: ![bars1](../assets/eip-1884/run3.total-bars-5.png) ![bars2](../assets/eip-1884/run3.total-bars-6.png) Note: It can also


=== EIP-7577 ===
TITLE: Versioning Scheme for EIPs
TYPE: Meta 
STATUS: Stagnant
CREATED: 2023-12-13
REQUIRES: 

SUMMARY:
This EIP introduces a versioning scheme for [Standards Track](./eip-1.md#eip-types) EIPs by applying [Semantic Versioning 2.0.0](../assets/eip-7577/semver.md) based on changes made to the EIP's Specification section once its status has changed from `Draft` to `Review`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Once an EIP has moved out of "Draft" status, it MUST use the EIP versioning

MOTIVATION:
EIP specifications often receive increasing modifications as more people review them, which is generally the case as client teams start implementing the specifications and the community gains a better understanding of their interaction with the rest of the protocol. These changes can be difficult to track. In particular, as

RATIONALE:
Making the version available in the EIP's metadata header allows for programmatic parsing of the version number by tooling used in reference tests or by client teams. Currently, the execution-spec-tests repository, which contains consensus tests for Ethereum execution clients, implements a rudimentary EIP version checker: EIP spec tests are


=== EIP-1186 ===
TITLE: RPC-Method to get Merkle Proofs - eth_getProof
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-06-24
REQUIRES: 1474

SUMMARY:
Ethereum uses a [Merkle Tree](https://github.com/ethereum/eth-wiki/blob/master/fundamentals/patricia-tree.md) to store the state of accounts and their storage. This allows verification of each value by simply creating a Merkle Proof. But currently, the standard RPC-Interface does not give you access to these proofs. This EIP suggests an additional RPC-Method, which creates Merkle Proofs

SPECIFICATION:
As Part of the eth-Module, an additional Method called `eth_getProof` should be defined as follows: #### eth_getProof Returns the account- and storage-values of the specified account including the Merkle-proof. ##### Parameters 1. `DATA`, 20 Bytes - address of the account. 2. `ARRAY`, 32 Bytes - array of storage-keys which

MOTIVATION:
In order to create a MerkleProof access to the full state db is required. The current RPC-Methods allow an application to access single values (`eth_getBalance`,`eth_getTransactionCount`,`eth_getStorageAt`,`eth_getCode`), but it is impossible to read the data needed for a MerkleProof through the standard RPC-Interface. (There are implementations using leveldb and accessing the

RATIONALE:
This one Method actually returns 3 different important data points: 1. The 4 fields of an account-object as specified in the yellow paper `[nonce, balance, storageHash, codeHash ]`, which allows storing a hash of the account-object in order to keep track of changes. 2. The MerkleProof for the account


=== EIP-5988 ===
TITLE: Add Poseidon hash function precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-11-15
REQUIRES: 

SUMMARY:
This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Parameters | Constant | Value | | ----------------------------- | ----- | | `FORK_BLKNUM` | `TBD` | | `GAS_COST` | `TBD`

MOTIVATION:
[Poseidon](../assets/eip-5988/papers/poseidon_paper.pdf) is an arithmetic hash function that is designed to be efficient for Zero-Knowledge Proof Systems. Ethereum adopts a rollup centric roadmap and hence must adopt facilities for L2s to be able to communicate with the EVM in an optimal manner. ZK-Rollups have particular needs for cryptographic hash functions

RATIONALE:
TODO: Add rationale TODO: Add rationale for gas cost e.g. benchmark and computation cost estimation.


=== EIP-7 ===
TITLE: DELEGATECALL
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-15
REQUIRES: 

SPECIFICATION:
`DELEGATECALL`: `0xf4`, takes 6 operands: - `gas`: the amount of gas the code may use in order to execute; - `to`: the destination address whose code is to be executed; - `in_offset`: the offset into memory of the input; - `in_size`: the size of the input in bytes; -

RATIONALE:
Propagating the sender and value from the parent scope to the child scope makes it much easier for a contract to store another address as a mutable source of code and ''pass through'' calls to it, as the child code would execute in essentially the same environment (except for


=== EIP-2242 ===
TITLE: Transaction Postdata
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-08-16
REQUIRES: 

SUMMARY:
A paradigm shift in how blockchains are used has been seen recently in Eth 2.0, with the rise of [_Execution Environments_](https://notes.ethereum.org/w1Pn2iMmSTqCmVUTGV4T5A?view) (EEs), and [_stateless clients_](https://ethresear.ch/t/the-stateless-client-concept/172). This shift involves blockchains serving as a secure data availability and arbitration layer, _i.e._, they provide a globally-accepted source of available data, and process

SPECIFICATION:
We propose a consensus modification, beginning at `FORK_BLKNUM`: An additional optional field, `postdata`, is added to transactions. Serialized transactions now have the format: ``` "from": bytes20, "to": bytes20, "startGas": uint256, "gasPrice": uint256, "value": uint256, "data": bytes, "nonce": uint256, ["postdata": bytes], ``` with witnesses signing over the [RLP encoding](https://github.com/ethereum/wiki/wiki/RLP) of

MOTIVATION:
While [EIP-2028](./eip-2028.md) provides a reduction in gas cost of calldata, and is a step in the right direction of encouraging use of history rather than state, the EVM does not actually need to see all data that is posted on-chain. Following the principle of "don't pay for what you

RATIONALE:
The changes proposed are as minimal and non-disruptive to the existing EVM and transaction format as possible while also supporting possible [future extensions](https://ethresear.ch/t/multi-threaded-data-availability-on-eth-1/5899) through a version code.


=== EIP-7658 ===
TITLE: Light client data backfill
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-21
REQUIRES: 

SUMMARY:
This EIP defines a mechanism for syncing [light client data](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md) between beacon nodes.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Containers #### New containers ##### `SyncData` ```python class SyncData(Container): # Sync committee aggregate signature

MOTIVATION:
[Light client data](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md) is collected by beacon nodes to assist [light clients](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/light-client.md) to sync with the network. The [sync protocol](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md) defines a mechanism to sync forward in time. However, it cannot be used to sync backward. Collecting light client data is challenging because beacon nodes need to have access

RATIONALE:
### How to rank `SyncAggregate`? The EIP reuses the [`is_better_update`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md#is_better_update) function from existing specs. To ensure deterministic selection when participation and finality are equal, implementations MUST break ties by preferring the lower `signature_slot`; if equal, the existing selection SHOULD be retained. ### How could a backfill protocol use this?


=== EIP-7932 ===
TITLE: Secondary Signature Algorithms
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-04-12
REQUIRES: 

SUMMARY:
This EIP: - Creates a unified registry & standardized interface for introducing additional signature algorithms for the use of deriving account addresses. - Introduces a precompile at address `SIGRECOVER_PRECOMPILE_ADDRESS` for decoding these newly introduced algorithms.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Unless explicitly noted, integer encoding MUST be in big-endian format. ### Parameters | Constant |

MOTIVATION:
As quantum computers become more advanced, several new post-quantum (PQ) algorithms have been designed. These algorithms all have certain drawbacks, such as large key sizes (>1KiB), large signature sizes, or long verification times. These issues make them more expensive to compute and store than the currently used secp256k1 curve.

RATIONALE:
### ERC-4337 interoperability While initial drafts of this EIP were competing with ERC-4337, current versions of this EIP support it via the sigrecover precompile. This allows any ERC-4337 implementation to have the same signature verification logic and address derivation logic for any given private key. This also works agnostic


=== EIP-7923 ===
TITLE: Linear, Page-Based Memory Costing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-27
REQUIRES: 

SUMMARY:
This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation is included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.

SPECIFICATION:
Consider the following constants: ```python ALLOCATE_PAGE_COST = 100 PAGE_SIZE = 4096 MAXIMUM_MEMORY_SIZE = 64 * 1024 * 1024 ``` The memory costing algorithm is changed as follows: 1. For each page touched by an instruction, charge `ALLOCATE_PAGE_COST` gas if it has not been touched before in this message call,

MOTIVATION:
The EVM currently uses a quadratic pricing model for its memory. This was originally put in place to defend against DoS attacks. However, the memory model has several drawbacks. 1. It is anachronistic. Even at a gas limit of 30 million gas, users can only use 3MB of memory

RATIONALE:
Benchmarks were performed on a 2019-era CPU, with the ability to `keccak256` around 256MB/s, giving it a gas-to-ns ratio of 20 ns per 1 gas (given that `keccak256` costs 6 gas per 32 bytes). The following benchmarks were performed: - Time to allocate a fresh page: 1-2us - Time


=== EIP-5003 ===
TITLE: Insert Code into EOAs with AUTHUSURP
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2022-03-26
REQUIRES: 3, 0, 7, 4, ,,  , 3, 6, 0, 7

SUMMARY:
This EIP introduces a new opcode, `AUTHUSURP`, which deploys code at an [EIP-3074](./eip-3074.md) authorized address. For externally owned accounts (EOAs), together with [EIP-3607](./eip-3607.md), this effectively revokes the original signing key's authority.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Conventions - **`top - N`** - the `N`th most recently pushed value on the EVM stack, where `top -

MOTIVATION:
EOAs currently hold a significant amount of user-controlled value on Ethereum blockchains, but are limited by the protocol in a variety of critical ways. These accounts do not support rotating keys for security, batching to save gas, or sponsored transactions to reduce the need to hold ether yourself. There

RATIONALE:
`AUTHUSURP` does not check the nonce of the `authorized` account because it must work with accounts that have previously sent transactions. When using `AUTHUSURP`, if the initcode were to deploy a zero-length contract, there would be no way to prevent using `AUTHUSURP` again later. The account's code must be


=== EIP-712 ===
TITLE: Typed structured data hashing and signing
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-09-12
REQUIRES: 1, 5, 5, ,,  , 1, 9, 1

SUMMARY:
This is a standard for hashing and signing of typed structured data as opposed to just bytestrings. It includes a * theoretical framework for correctness of encoding functions, * specification of structured data similar to and compatible with Solidity structs, * safe hashing algorithm for instances of those structures,

SPECIFICATION:
The set of signable messages is extended from transactions and bytestrings `𝕋 ∪ 𝔹⁸ⁿ` to also include structured data `𝕊`. The new set of signable messages is thus `𝕋 ∪ 𝔹⁸ⁿ ∪ 𝕊`. They are encoded to bytestrings suitable for hashing and signing as follows: * `encode(transaction : 𝕋)

MOTIVATION:
Signing data is a solved problem if all we care about are bytestrings. Unfortunately in the real world we care about complex meaningful messages. Hashing structured data is non-trivial and errors result in loss of the security properties of the system. As such, the adage "don't roll your own

RATIONALE:
The `encode` function is extended with a new case for the new types. The first byte of the encoding distinguishes the cases. For the same reason it is not safe to start immediately with the domain separator or a `typeHash`. While hard, it may be possible to construct a


=== EIP-2029 ===
TITLE: State Rent A - State counters contract
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-15
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces a place in the Ethereum state where various state counters can be stored. At this point, the most important counter is the total number of transactions happened, and this counter will be used to populate the nonces

SPECIFICATION:
Prior to the block A, a contract is deployed with the following code: `0x60 0x20 0x60 0x00 0x80 0x80 0x35 0x54 0x90 0x52 0xF3`, which corresponds to this assembly: `PUSH1 32 PUSH1 0 DUP1 DUP1 CALLDATALOAD SLOAD SWAP1 MSTORE RETURN` Call to this contract accepts one 32-byte argument, `x`,

MOTIVATION:
Ethereum currently does not have a special place in the state for tracking state counters such as number of transactions or number of accounts.

RATIONALE:
Two alternative solutions were considered so far: 1. Extending the structure of the Ethereum state to introduce more fields, and hence change the way the state root is constructed. The main downside of this approach is the impact on the software what is currently coupled with the particular way


=== EIP-1240 ===
TITLE: Remove Difficulty Bomb
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-07-21
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty without considering the current block number.

SPECIFICATION:
#### Remove Difficulty For the purposes of `calc_difficulty`, if `block.number >= FORK_BLOCK_NUMBER` then change the epsilon component to `0` rather than having it be a function of block number.

MOTIVATION:
The difficulty bomb operates under the assumption that miners decide what code economic participants are running, rather than economic participants deciding for themselves. In reality, miners will mine whatever chain is most profitable and the most profitable chain is the one that economic participants use. If 99% of miners

RATIONALE:
With the difficulty bomb removed, when Casper is released it will be up to economic participants to decide whether they want the features that Casper enables or not. If they do not want Casper, they are free to continue running unpatched clients and participating in the Ethereum network as


=== EIP-3368 ===
TITLE: Increase block rewards to 3 ETH, with 2 Year Decay to 1 ETH Scheduled
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-12
REQUIRES: 

SUMMARY:
Set the block reward to 3 ETH and then decrease it slightly every block for 4,724,000 blocks (approximately 2 years) until it reaches 1 ETH.

SPECIFICATION:
Adjust block, uncle, and nephew rewards ### Constants * `TRANSITION_START_BLOCK_NUMBER: TBD` * `TRANSITION_DURATION: 4_724_000` (about two years) * `TRANSITION_END_BLOCK_NUMBER: FORK_BLOCK_NUMBER + TRANSITION_DURATION` * `STARTING_REWARD: 3_000_000_000_000_000_000` * `ENDING_REWARD: 1_000_000_000_000_000_000` * `REWARD_DELTA: STARTING_REWARD - ENDING_REWARD` ### Block Reward ```py if block.number >= TRANSITION_END_BLOCK_NUMBER: block_reward = ENDING_REWARD elif block.number = TRANSITION_START_BLOCK_NUMBER: block_reward

MOTIVATION:
A sudden drop in PoW mining rewards could result in a sudden precipitous decrease in mining profitability that may drive miners to auction off their hashrate to the highest bidder while they figure out what to do with their now "worthless" hardware. If enough hashrate is auctioned off in

RATIONALE:
2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort


=== EIP-999 ===
TITLE: Restore Contract Code at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-04-04
REQUIRES: 

SUMMARY:
The `WalletLibrary` contract was used by the [Parity Wallet](https://www.parity.io/) to reduce gas costs for users deploying multi-signature wallets on the Ethereum blockchain. It contained basic functionality such as confirming or revoking multi-signature transactions for any wallet deployed that depends on this library. The [accidental self-destruction](https://github.com/paritytech/parity/issues/6995) of the library contract

SPECIFICATION:
The self-destructed contract code at [`0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4`](https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code) shall be replaced with a patched version of the [`walletLibrary.sol`](https://github.com/parity-contracts/0x863df6bfa4/blob/master/contracts/walletLibrary.sol) as reviewed, tested, and approved in [parity-contracts/0x863df6bfa4](https://github.com/parity-contracts/0x863df6bfa4): ```json { "object": "606060405234156200000d57fe5b5b6000808054806001018281620000259190620002d9565b916000526020600020900160005b6000909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506200012081805480602002602001604051908101604052809291908181526020018280548015620000fd57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311620000b2575b505050505060016000620001286401000000000262001d46176401000000009004565b5b5062000330565b600060015411156200013a5760006000fd5b6200015981620001806401000000000262001d71176401000000009004565b620001798383620001c26401000000000262001d9c176401000000009004565b5b5b505050565b60006001541115620001925760006000fd5b80600281905550620001b7620002c16401000000000262001bcf176401000000009004565b6004819055505b5b50565b600060006001541115620001d65760006000fd5b600082111515620001e75760006000fd5b81835110151515620001f95760006000fd5b8251600181905550600090505b8251811015620002b35782818151811015156200021f57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff16600582600101610100811015156200025357fe5b0160005b508190555080600101610105600085848151811015156200027457fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80600101905062000206565b816000819055505b5b505050565b60006201518042811515620002d257fe5b0490505b90565b815481835581811511620003035781836000526020600020918201910162000302919062000308565b5b505050565b6200032d91905b80821115620003295760008160009055506001016200030f565b5090565b90565b611ebf80620003406000396000f300606060405236156100ef576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063173825d91461016d5780632f54bf6e146101a35780634123cb6b146101f157806352375093146102175780635c52c2f51461023d578063659010e71461024f5780637065cb4814610275578063746c9171146102ab578063797af627146102d1578063b20d30a91461030d578063b61d27f61461032d578063b75c7dc61461039c578063ba51a6df146103c0578063c2cf7326146103e0578063c41a360a1461043b578063f00d4b5d1461049b578063f1736d86146104f0575b61016b5b6000341115610168577fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c3334604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b5b565b005b341561017557fe5b6101a1600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610516565b005b34156101ab57fe5b6101d7600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610659565b604051808215151515815260200191505060405180910390f35b34156101f957fe5b610201610691565b6040518082815260200191505060405180910390f35b341561021f57fe5b610227610697565b6040518082815260200191505060405180910390f35b341561024557fe5b61024d61069d565b005b341561025757fe5b61025f6106d7565b6040518082815260200191505060405180910390f35b341561027d57fe5b6102a9600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506106dd565b005b34156102b357fe5b6102bb610829565b6040518082815260200191505060405180910390f35b34156102d957fe5b6102f360048080356000191690602001909190505061082f565b604051808215151515815260200191505060405180910390f35b341561031557fe5b61032b6004808035906020019091905050610dcc565b005b341561033557fe5b61037e600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919080359060200190820180359060200191909192905050610e06565b60405180826000191660001916815260200191505060405180910390f35b34156103a457fe5b6103be60048080356000191690602001909190505061127d565b005b34156103c857fe5b6103de6004808035906020019091905050611392565b005b34156103e857fe5b61042160048080356000191690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190505061141a565b604051808215151515815260200191505060405180910390f35b341561044357fe5b610459600480803590602001909190505061149c565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34156104a357fe5b6104ee600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506114bf565b005b34156104f857fe5b610500611672565b6040518082815260200191505060405180910390f35b600060003660405180838380828437820191505092505050604051809103902061053f81611678565b156106535761010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561057f57610652565b600160015403600054111561059357610652565b6000600583610100811015156105a557fe5b0160005b5081905550600061010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506105e6611890565b6105ee6119d0565b7f58619076adf5bb0943d100ef88d52d7c3fd691b19d3a9071b555b651fbf418da83604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b5b505050565b6000600061010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541190505b919050565b60015481565b60045481565b6000366040518083838082843782019150509250505060405180910390206106c481611678565b156106d35760006003819055505b5b5b50565b60035481565b60003660405180838380828437820191505092505050604051809103902061070481611678565b156108245761071282610659565b1561071c57610823565b610724611890565b60fa600154101515610739576107386119d0565b5b60fa60015410151561074a57610823565b6001600081548092919060010191905055508173ffffffffffffffffffffffffffffffffffffffff1660056001546101008110151561078557fe5b0160005b508190555060015461010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507f994a936646fe87ffe4f1e469d3d6aa417d6b855598397f323de5b449f765f0c382604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b5b5050565b60005481565b600060008261083d81611678565b15610dc45760006101086000866000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415806108c757506000610108600086600019166000191681526020019081526020016000206001015414155b80610906575060006101086000866000191660001916815260200190815260200160002060020180546001816001161561010002031660029004905014155b15610dc25760006101086000866000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415610a5057610a496101086000866000191660001916815260200190815260200160002060010154610108600087600019166000191681526020019081526020016000206002018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610a3f5780601f10610a1457610100808354040283529160200191610a3f565b820191906000526020600020905b815481529060010190602001808311610a2257829003601f168201915b5050505050611b37565b9150610b71565b6101086000856000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166101086000866000191660001916815260200190815260200160002060010154610108600087600019166000191681526020019081526020016000206002016040518082805460018160011615610100020316600290048015610b4a5780601f10610b1f57610100808354040283529160200191610b4a565b820191906000526020600020905b815481529060010190602001808311610b2d57829003601f168201915b505091505060006040518083038185876185025a03f1925050501515610b705760006000fd5b5b7fe3a3a4111a84df27d76b68dc721e65c7711605ea5eee4afd3a9c58195217365c338561010860008860001916600019168152602001908152602001600020600101546101086000896000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661010860008a6000191660001916815260200190815260200160002060020187604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200186600019166000191681526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825284818154600181600116156101000203166002900481526020019150805460018160011615610100020316600290048015610d475780601f10610d1c57610100808354040283529160200191610d47565b820191906000526020600020905b815481529060010190602001808311610d2a57829003601f168201915b505097505050505050505060405180910390a16101086000856000191660001916815260200190815260200160002060006000820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556001820160009055600282016000610db79190611be6565b505060019250610dc3565b5b5b5b5050919050565b600036604051808383808284378201915050925050506040518091039020610df381611678565b15610e0157816002819055505b5b5b5050565b60006000610e1333610659565b1561127357600084849050148015610e305750610e2f85611b51565b5b80610e3d57506001600054145b15610fed5760008673ffffffffffffffffffffffffffffffffffffffff161415610ea457610e9d8585858080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050611b37565b9050610ef3565b8573ffffffffffffffffffffffffffffffffffffffff168585856040518083838082843782019150509250505060006040518083038185876185025a03f1925050501515610ef25760006000fd5b5b7f9738cd1a8777c86b011f7b01d87d484217dc6ab5154a9d41eda5d14af8caf292338688878786604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281038252858582818152602001925080828437820191505097505050505050505060405180910390a1611271565b6000364360405180848480828437820191505082815260200193505050506040518091039020915060006101086000846000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16148015611099575060006101086000846000191660001916815260200190815260200160002060010154145b80156110d85750600061010860008460001916600019168152602001908152602001600020600201805460018160011615610100020316600290049050145b1561118f57856101086000846000191660001916815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550846101086000846000191660001916815260200190815260200160002060010181905550838361010860008560001916600019168152602001908152602001600020600201919061118d929190611c2e565b505b6111988261082f565b1515611270577f1733cbb53659d713b79580f79f3f9ff215f78a7c7aa45890f3b89fc5cddfbf328233878988886040518087600019166000191681526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018281038252848482818152602001925080828437820191505097505050505050505060405180910390a15b5b5b5b5b50949350505050565b60006000600061010560003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054925060008314156112be5761138c565b8260020a9150610106600085600019166000191681526020019081526020016000209050600082826001015416111561138b5780600001600081548092919060010191905055508181600101600082825403925050819055507fc7fb647e59b18047309aa15aad418e5d7ca96d173ad704f1031a2c3d7591734b3385604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182600019166000191681526020019250505060405180910390a15b5b50505050565b6000366040518083838082843782019150509250505060405180910390206113b981611678565b15611415576001548211156113cd57611414565b816000819055506113dc611890565b7facbdb084c721332ac59f9b8e392196c9eb0e4932862da8eb9beaf0dad4f550da826040518082815260200191505060405180910390a15b5b5b5050565b600060006000600061010660008760001916600019168152602001908152602001600020925061010560008673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561147f5760009350611493565b8160020a9050600081846001015416141593505b50505092915050565b6000600560018301610100811015156114b157fe5b0160005b505490505b919050565b60006000366040518083838082843782019150509250505060405180910390206114e881611678565b1561166b576114f683610659565b156115005761166a565b61010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561153b5761166a565b611543611890565b8273ffffffffffffffffffffffffffffffffffffffff166005836101008110151561156a57fe5b0160005b5081905550600061010560008673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508161010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507fb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c8484604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019250505060405180910390a15b5b5b50505050565b60025481565b600060006000600061010560003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054925060008314156116bb57611888565b6101066000866000191660001916815260200190815260200160002091506000826000015414156117455760005482600001819055506000826001018190555061010780548091906001016117109190611cae565b826002018190555084610107836002015481548110151561172d57fe5b906000526020600020900160005b5081600019169055505b8260020a90506000818360010154161415611887577fe1c52dc63b719ade82e8bea94cc41a0d5d28e4aaf536adb5e9cccc9ff8c1aeda3386604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182600019166000191681526020019250505060405180910390a16001826000015411151561185e57610107610106600087600019166000191681526020019081526020016000206002015481548110151561180a57fe5b906000526020600020900160005b5060009055610106600086600019166000191681526020019081526020016000206000600082016000905560018201600090556002820160009055505060019350611888565b8160000160008154809291906001900391905055508082600101600082825417925050819055505b5b5b505050919050565b60006000610107805490509150600090505b818110156119bc576101086000610107838154811015156118bf57fe5b906000526020600020900160005b50546000191660001916815260200190815260200160002060006000820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905560018201600090556002820160006119269190611be6565b505060006001026101078281548110151561193d57fe5b906000526020600020900160005b5054600019161415156119b05761010660006101078381548110151561196d57fe5b906000526020600020900160005b505460001916600019168152602001908152602001600020600060008201600090556001820160009055600282016000905550505b5b8060010190506118a2565b61010760006119cb9190611cda565b5b5050565b6000600190505b600154811015611b33575b60015481108015611a095750600060058261010081101515611a0057fe5b0160005b505414155b15611a1b5780806001019150506119e2565b5b6001600154118015611a4557506000600560015461010081101515611a3d57fe5b0160005b5054145b15611a625760016000815480929190600190039190505550611a1c565b60015481108015611a8b57506000600560015461010081101515611a8257fe5b0160005b505414155b8015611aac5750600060058261010081101515611aa457fe5b0160005b5054145b15611b2e57600560015461010081101515611ac357fe5b0160005b505460058261010081101515611ad957fe5b0160005b508190555080610105600060058461010081101515611af857fe5b0160005b50548152602001908152602001600020819055506000600560015461010081101515611b2457fe5b0160005b50819055505b6119d7565b5b50565b600081516020830184f09050803b15610000575b92915050565b6000611b5c33610659565b15611bc957600454611b6c611bcf565b1115611b89576000600381905550611b82611bcf565b6004819055505b600354826003540110158015611ba55750600254826003540111155b15611bc3578160036000828254019250508190555060019050611bc8565b600090505b5b5b919050565b60006201518042811515611bdf57fe5b0490505b90565b50805460018160011615610100020316600290046000825580601f10611c0c5750611c2b565b601f016020900490600052602060002090810190611c2a9190611cfc565b5b50565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10611c6f57803560ff1916838001178555611c9d565b82800160010185558215611c9d579182015b82811115611c9c578235825591602001919060010190611c81565b5b509050611caa9190611cfc565b5090565b815481835581811511611cd557818360005260206000209182019101611cd49190611d21565b5b505050565b5080546000825590600052602060002090810190611cf89190611d21565b5b50565b611d1e91905b80821115611d1a576000816000905550600101611d02565b5090565b90565b611d4391905b80821115611d3f576000816000905550600101611d27565b5090565b90565b60006001541115611d575760006000fd5b611d6081611d71565b611d6a8383611d9c565b5b5b505050565b60006001541115611d825760006000fd5b80600281905550611d91611bcf565b6004819055505b5b50565b600060006001541115611daf5760006000fd5b600082111515611dbf5760006000fd5b81835110151515611dd05760006000fd5b8251600181905550600090505b8251811015611e85578281815181101515611df457fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1660058260010161010081101515611e2757fe5b0160005b50819055508060010161010560008584815181101515611e4757fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b806001019050611ddd565b816000819055505b5b5050505600a165627a7a7230582016889f0740f073d397f9d00b0d19900fb050b957e3e2942f861085beb9baab180029", "opcodes": "PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH3 0xD JUMPI INVALID JUMPDEST JUMPDEST PUSH1 0x0 DUP1 DUP1 SLOAD DUP1 PUSH1 0x1

MOTIVATION:
This proposal is necessary because the Ethereum protocol does not allow the restoration of self-destructed contracts and there is no other simple way to enable the affected users and companies regaining access to their tokens and Ether. In opposite to previously discussed proposals, this will not change any EVM

RATIONALE:
The design decision to restore the `WalletLibrary` contract code in a single state transition was made after lengthy discussions of [alternate proposals](https://gist.github.com/5chdn/a9bb8617cc8523a030126a3d1c60baf3) that explored different ways to improve the Ethereum protocol to allow contract revivals by adding different built-in contracts. It was eventually concluded that all of these proposals


=== EIP-6046 ===
TITLE: Replace SELFDESTRUCT with DEACTIVATE
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-11-25
REQUIRES: 2, 6, 8, 1, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 2, 9

SUMMARY:
Change `SELFDESTRUCT` to not delete all storage keys, and to use a special value in the account nonce to signal *deactivated* accounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction to `DEACTIVATE`.

SPECIFICATION:
1. Change the rules introduced by [EIP-2681](./eip-2681.md) such that regular nonce increase is bound by `2^64-2` instead of `2^64-1`. This applies from genesis. 2. The behaviour of `SELFDESTRUCT` is changed such that: - Does not delete any storage keys and also leave the account in place. - Transfer the

MOTIVATION:
The `SELFDESTRUCT` instruction currently has a fixed price, but is unbounded in terms of how many storage/account changes it performs (it needs to delete all keys). This has been an outstanding concern for some time. Furthermore, with *Verkle trees*, accounts will be organised differently: account properties, including storage, will

RATIONALE:
There have been various proposals of removing `SELFDESTRUCT` and many would just outright remove the deletion capability. This breaks certain usage patterns, which the *deactivation* option leaves intact, albeit with minor changes. This only affects *newly* deployed code, and not existing one. All the proposals would leave data in


=== EIP-2666 ===
TITLE: Repricing of precompiles and Keccak256 function
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-05-22
REQUIRES: 1, 3, 5, 2, ,,  , 2, 0, 4, 6, ,,  , 2, 5, 6, 5

SUMMARY:
Costs of many precompiles and built-in functions are invalid at the current state of the clients. This EIP contains a list of changes to the pricing formulas to better reflect underlying computations' structure.

SPECIFICATION:
If `block_number >= X` set the gas cost of the following precompiles and Keccak256 opcode: - SHA256 (precompile `0x02`): `10 + ((len(input) + 8)/64 + 1) * 9` - RIPEMD (precompile `0x03`): `6 + ((len(input) + 8)/64 + 1) * 12` - KECCAK256 (`0x20`): `13 + (len(input)/136 + 1)*15`

MOTIVATION:
Historical pricing for these functions in EVM does not reflect inner structure of the underlying computations (inner structure of the hash functions). - EIP-2046 changes a `STATICCALL (0xfa)` cost to precompile and it may be necessary to adjust costs of some precompiles that *may* have taken old large cost

RATIONALE:
Cost of functions being executed must accurately reflect real CPU time spent on computations, so benchmarking was performed for current precompiles and Keccak256 function to measure running time versus input parameters. ### Detailed summary of repricing approach This EIP relies on two facts: - apriori knowledge of the inner


=== EIP-2780 ===
TITLE: Reduce intrinsic transaction gas
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2020-07-11
REQUIRES: 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
Reduce the intrinsic cost `TX_BASE_COST` from `21,000` to `4,500` and define a consistent gas accounting model based on actual state operations. This more granular approach makes a simple ETH transfer `6,000` from additional costs related to the `to` account. If a non-create transaction has `value > 0` and targets

SPECIFICATION:
After `FORK_BLOCK`, set the following parameters and rules: ### Parameters | Name | Value | Description | | -------------------------- | -----: | ----------------------------------------------------------------------- | | `TX_BASE_COST` | 4,500 | Base cost of any transaction | | `GAS_NEW_ACCOUNT` | 25,000 | Surcharge when a value-transferring transaction creates a new account

MOTIVATION:
**Monetary Context** Money has three basic functions: a unit of account, a medium of exchange, and a store of value. ETH already meets the last two by design. It carries value without an issuer and settles with finality. Where it falls short is in everyday exchange - the friction

RATIONALE:
Price only what every transaction always does: ECDSA recovery, warming `sender` and `to`, and one account-leaf write for the sender (nonce + balance change). That sums to `4,500` gas. Anything not universal should be metered separately. Calldata remains metered per byte. No calldata allowance is folded into the base.


=== EIP-3041 ===
TITLE: Adds `baseFee` to `eth_getBlockByHash`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-13
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getBlockByHash` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getBlockByHash` #### Description Returns information about a block specified by hash. Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-1153 ===
TITLE: Transient storage opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-06-15
REQUIRES: 2, 2, 0, 0, ,,  , 3, 5, 2, 9

SUMMARY:
This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, and `TSTORE` is not subject to the gas stipend check as defined in [EIP-2200](./eip-2200.md). In other words, the values of transient storage are never deserialized from

SPECIFICATION:
Two new opcodes are added to EVM, `TLOAD` (`0x5c`) and `TSTORE` (`0x5d`). (Note that previous drafts of this EIP specified the values `0xb3` and `0xb4` for `TLOAD` and `TSTORE` respectively to avoid conflict with other EIPs. The conflict has since been removed.) They use the same arguments on stack

MOTIVATION:
Running a transaction in Ethereum can generate multiple nested frames of execution, each created by `CALL` (or similar) instructions. Contracts can be re-entered during the same transaction, in which case there are more than one frame belonging to one contract. Currently, these frames can communicate in two ways: via

RATIONALE:
Another option to solve the problem of inter-frame communication is repricing the `SSTORE` and `SLOAD` opcodes to be cheaper for the transient storage use case. This has already been done as of [EIP-2200](./eip-2200.md). However, [EIP-3529](./eip-3529.md) reduced the maximum refund to only 20% of the transaction gas cost, which means


=== EIP-6404 ===
TITLE: SSZ transactions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-01-30
REQUIRES: 1, 5, 5, ,,  , 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4, ,,  , 7, 4, 9, 5, ,,  , 7, 7, 0, 2, ,,  , 7, 9, 1, 6, ,,  , 7, 9, 3, 2, ,,  , 8, 0, 1, 6

SUMMARY:
This EIP defines a migration process of [EIP-2718](./eip-2718.md) Recursive-Length Prefix (RLP) transactions to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated

MOTIVATION:
RLP transactions have a number of shortcomings: 1. **Linear hashing:** The signing hash (`sig_hash`) and unique identifier (`tx_hash`) of an RLP transaction are computed by linear keccak256 hashes across its serialization. Even if only partial data is of interest, linear hashes require the full transaction data to be present,

RATIONALE:
### Forward compatibility The proposed transaction design is extensible with new fee types, new signature types, and entirely new transaction features (e.g., CREATE2), while retaining compatibility with the proposed transactions. ### Verifier improvements The `transactions_root` is effectively constructed from the list of `tx_root`, enabling transaction inclusion proofs. Further, partial


=== EIP-7749 ===
TITLE: Add wallet_signIntendedValidatorData method
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2024-06-21
REQUIRES: 1, 9, 1, ,,  , 7, 1, 2

SUMMARY:
This EIP introduces a new JSON-RPC method, `wallet_signIntendedValidatorData`, which allows signing data with an intended validator address using [ERC-191](./eip-191.md) version 0x00 with this format: ```bash 0x19 <0x00> <intended validator address> <data to sign> ```

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `wallet_signIntendedValidatorData` MUST calculate an Ethereum signature using `sign(keccak256("\x19\x00<intended validator address><data to sign>"))`. This method

MOTIVATION:
Currently, signing messages relies heavily on ERC-191 version 0x45 (`eth_sign`) and [EIP-712](./eip-712.md) (`eth_signTypedData`). While EIP-712 provides a more structured approach, it is often seen as complex. On the other hand, ERC-191 version 0x45 is widely used but poses significant phishing risks due to the lack of data parsing. ERC-191

RATIONALE:
The `wallet_signIntendedValidatorData` method aims to bridge the gap between the simplicity of ERC-191 version 0x45 and the structured approach of EIP-712. By specifying the intended validator address, it reduces phishing risks and provides a more secure signing method for smart contract accounts and other use cases requiring a specific


=== EIP-4758 ===
TITLE: Deactivate SELFDESTRUCT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP renames the `SELFDESTRUCT` opcode to `SENDALL`, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.

SPECIFICATION:
* The `SELFDESTRUCT` opcode is renamed to `SENDALL`, and now only immediately moves all ETH in the account to the target; it no longer destroys code or storage or alters the nonce * All refunds related to `SELFDESTRUCT` are removed

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root

RATIONALE:
Getting rid of the `SELFDESTRUCT` opcode has been considered in the past, and there are currently no strong reasons to use it. Disabling it will be a requirement for statelessness.


=== EIP-908 ===
TITLE: Reward clients for a sustainable network
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-03-01
REQUIRES: 

SUMMARY:
The tragedy of the commons is a phenomenon that is well known in many sectors, most notably in regard to sustainability. It involves the over-utilization of shared finite resources, which detriments all participants and stakeholders involved (which in the case of a global public good can be everyone, including

SPECIFICATION:
Add a new field to each block called `PrevBlockVerifications`, which is an arbitrary, unlimited size byte array. When a client verifies that a previous block is [valid](https://ethereum.github.io/yellowpaper/paper.pdf#subsubsection.4.3.2), the client appends a user agent to PrevBlockVerifications via an opcode in a transaction, PREV_BLOCK_VERIF. The user agent is a vector with

MOTIVATION:
Currently there is a lack of incentives for anyone to run a full node, while joining a mining pool is not really economical if one has to purchase a mining rig (several GPUs) now, since there is unlikely to be a return on investment by the time that Ethereum

RATIONALE:
### A rough qualitative analysis of fees As of May 4 2018, there are [16428 nodes](https://web.archive.org/web/20180504051128/https://ethernodes.org/network/1). Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented,


=== EIP-7480 ===
TITLE: EOF - Data section access instructions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-08-11
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Four new instructions are introduced, that allow to read EOF container's data section: `DATALOAD` loads 32-byte word to stack, `DATALOADN` loads 32-byte word to stack where the word is addressed by a static immediate argument, `DATASIZE` loads data section size and `DATACOPY` copies a segment of data section to

SPECIFICATION:
We introduce four new instructions on the same block number [EIP-3540](./eip-3540.md) is activated on: 1. `DATALOAD` (0xd0) 2. `DATALOADN` (0xd1) 3. `DATASIZE` (0xd2) 4. `DATACOPY` (0xd3) If the code is legacy bytecode, all of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*) If

MOTIVATION:
Clear separation between code and data is one of the main features of EOF1. Data section may contain anything, e.g. compiler's metadata, but to make it useful for smart contracts, EVM has to have instructions that allow to read from data section. Previously existing instructions for bytecode inspection (`CODECOPY`,

RATIONALE:
### Zero-padding on out of bounds access Existing instructions for reading other kinds of data implicitly pad with zeroes on out of bounds access, with the only exception of return data copying. It is beneficial to avoid exceptional failures, because compilers can employ optimizations like removing a code that


=== EIP-5081 ===
TITLE: Expirable Transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-05-06
REQUIRES: 1, 5, 5, ,,  , 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
This EIP adds a new transaction type of that includes expiration with a blocknum.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters - `FORK_BLKNUM` = `TBD` - `CHAIN_ID` = `TBD` - `TX_TYPE` = TBD, > 0x02 ([EIP-1559](./eip-1559.md)) As of `FORK_BLOCK_NUMBER`,

MOTIVATION:
When a user sends a transaction `tx0` with a low gas price, sometimes it might not be high enough to be executed. A common resolution is for the user to submit the transaction again with the same nonce and higher gas price. That previous `tx0` can theoretically be included

RATIONALE:
TODO


=== EIP-7783 ===
TITLE: Add Controlled Gas Limit Increase Strategy
TYPE: Informational 
STATUS: Stagnant
CREATED: 2024-10-06
REQUIRES: 


=== EIP-2464 ===
TITLE: eth/65: transaction announcements and retrievals
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-01-13
REQUIRES: 2364

SUMMARY:
This EIP introduces three additional message types into the `eth` protocol (releasing a new version, `eth/65`): `NewPooledTransactionHashes (0x08)` to announce a set of transactions without their content; `GetPooledTransactions (0x09)` to request a batch of transactions by their announced hash; and `PooledTransactions (0x0a)` to reply to a transaction request. This

SPECIFICATION:
Add three new message types to the `eth` protocol: * `NewPooledTransactionHashes (0x08): [hash_0: B_32, hash_1: B_32, ...]` * Specify one or more transactions that have appeared in the network and which have **not yet been included in a block**. To be maximally helpful, nodes should inform peers of all

MOTIVATION:
The `eth` network protocol has two ways to propagate a newly mined block: it can be broadcast to a peer in its entirety (via `NewBlock (0x07)` in `eth/64` and prior or it can be announced only (via `NewBlockHashes (0x01)`). This duality allows nodes to do the high-bandwidth broadcasting (10s-100s

RATIONALE:
**Q: Why limit `GetPooledTransactions (0x09)` to retrieving items from the pool?** Apart from the transaction pool, transactions in Ethereum are always bundled together by the hundreds in block bodies and existing network retrievals honor this data layout. Allowing direct access to individual transactions in the database has no actionable


=== EIP-4760 ===
TITLE: SELFDESTRUCT bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP renames the `SELFDESTRUCT` opcode to `SENDALL`, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller. In order to give apps more warning even if their developers are completely unaware of the EIP process, this version will

SPECIFICATION:
### Constants | Name | Value | Comment | |------|-------|---------| | `OLD_SELFDESTRUCT_COST` | 5000 | Current gas cost of `SELFDESTRUCT` opcode | | `HARD_FORK_BLOCK` | TBD | (Shanghai HF block height) | | `DOUBLING_SLOTS` | `2**16` | (Time for gas price to double, ca. 9 days) | | `DOUBLINGS_BEFORE_SENDALL`

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root

RATIONALE:
The idea behind this EIP is to disable `SELFDESTRUCT` in a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However,


=== EIP-8045 ===
TITLE: Exclude slashed validators from proposing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-16
REQUIRES: 7917

SUMMARY:
This EIP proposes a modification to the beacon chain proposer selection process to exclude slashed validators from being selected as proposers.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). The `get_beacon_proposer_indices` function in the consensus specifications is modified to exclude slashed validators from the

MOTIVATION:
Currently, slashed validators can still be selected as proposers, though their blocks are considered invalid by the state transition function, resulting in missed slots. This is in particular problematic after a mass slashing event, at which point there can be a long period with degraded chain performance, until all

RATIONALE:
### Why exclude slashed validators? Slashed validators are already prevented from successfully proposing blocks through the state transition validation. The `process_block` function checks that the proposer is not slashed, and blocks from slashed proposers are considered invalid. Therefore, selecting slashed validators as proposers serves no purpose and only results


=== EIP-1051 ===
TITLE: Overflow checking for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.

SPECIFICATION:
Two new flags are added to the EVM state: overflow (`ovf`) and signed overflow (`sovf`). The `ovf` flag is set in the following circumstances: - When an `ADD` (`0x01`) opcode, with both inputs treated as unsigned integers, produces an ideal output in excess of 2^256 - 1. - When

MOTIVATION:
The correct functioning of many contracts today is dependent on detecting and preventing overflow of arithmetic operations. Since the EVM operates on mod 2^256 integers and provides no built-in overflow detection or prevention, this requires manual checks on every arithmetic operation. In the interests of facilitating efficient and secure

RATIONALE:
Any change to implement overflow protection needs to preserve behaviour of existing contracts, which precludes many changes to the arithmetic operations themselves. One option would be to provide an opcode that enables overflow protection, causing a throw or revert if an overflow happens. However, this limits the manner in


=== EIP-3338 ===
TITLE: Limit account nonce to 2^52
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-07
REQUIRES: 

SUMMARY:
Limit account nonce to be between `0` and `2^52`.

SPECIFICATION:
If `block.number >= FORK_BLOCK` introduce two new restrictions: 1. Consider any transaction invalid, where the nonce exceeds `2^52`. 2. The `CREATE` instruction to abort with an exceptional halt, where the account nonce is `2^52`.

MOTIVATION:
Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way. Additionally it could prove beneficial to transaction formats, where some improvements

RATIONALE:
1. It is unlikely for any nonce to reach or exceed the proposed limit. If one would want to reach that limit via external transactions, it would cost at least `21000 * (2^64-1) = 387_381_625_547_900_583_915_000` gas. 2. It must be noted that in the past, in the Morden testnet,


=== EIP-8052 ===
TITLE: Precompile for Falcon support
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-17
REQUIRES: 

SUMMARY:
This proposal creates a precompiled contract that performs signature verifications using the Falcon-512 signature scheme by given parameters of the message hash, signature, and public key. This allows any EVM chain -- principally Ethereum roll-ups -- to integrate this precompiled contract easily. The signature scheme can be instantiated in

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Falcon can be instantiated with polynomials of degree $512$ or $1024$, leading to a different

MOTIVATION:
Quantum computers pose a long-term risk to classical cryptographic algorithms. In particular, signature algorithms based on the hardness of the Elliptic Curve Discrete Logarithm Problem (ECDLP) such as secp256k1, are widely used in Ethereum and threaten by quantum algorithms. This exposes potentially on-chain assets and critical infrastructure to quantum

RATIONALE:
The Falcon signature scheme was selected as a NIST-standardized post-quantum cryptographic algorithm due to its strong security guarantees and efficiency. Falcon is a signature algorithm build from lattice-based cryptography. Specifically, its hardness relies on the Short Integer Solution (SIS) problem over NTRU lattices, which is believed to be hard


=== EIP-7912 ===
TITLE: Pragmatic stack manipulation tools
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-03-25
REQUIRES: 

SUMMARY:
Add `SWAP17`-`SWAP24`, `DUP17` - `DUP24`, `SWAPN`, `DUPN`, and `EXCHANGE` instructions. The arbitrary depth operations must be preceded by `PUSH1` instructions defining operands.

SPECIFICATION:
Let `top - N` be the `N`th most recently pushed value on the stack, and `top - 0` be the most recent. If any of the following instructions reference a stack element beyond the current length of the stack, causing a stack underflow, abort with an exceptional halt. ###

MOTIVATION:
Due to the nature of some compilers, deeper stack access is a desirable VM feature. Previous attempts either required code versioning, like the EVM Object Format (EOF), or caused the behavior of some deployed contracts to change, due to the interpretation of new immediates. This is a pragmatic approach

RATIONALE:
### Constant and Dynamic `SWAP`s and `DUP`s The main trade off between using the constant `SWAPXX` or `DUPXX` instructions versus the dynamic `SWAPN` or `DUPN` instructions is that the dynamic instructions require an additional two bytes in the form of a preceding `PUSH1` operation, whereas the constant versions require


=== EIP-2593 ===
TITLE: Escalator fee market change for ETH 1.0 chain
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-03-13
REQUIRES: 

SUMMARY:
Based on [The Agoric Papers](https://agoric.com/papers/incentive-engineering-for-computational-resource-management/full-text/). Each transaction would have the option of providing parameters that specify an "escalating" bid, creating a time-based auction for validators to include that transaction. This creates highly efficient price discovery, where the price will always immediately fall to the highest bid price, which is

SPECIFICATION:
**Client-Wide Parameters** * `INITIAL_FORK_BLKNUM`: TBD **Transaction Parameters** The transaction `gasPrice` parameter is now optional, and if excluded can be replaced by these parameters instead: * `START_PRICE`: The lowest price that the user would like to pay for the transaction. * `START_TIME`: The first time that this transaction is valid

MOTIVATION:
Ethereum currently prices transaction fees using a simple first-price auction, which leads to well documented inefficiencies (some of which are documented in [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md)) when users are trying to estimate what price will get a transaction included in a block, especially during times of price volatility and full blocks. EIP


=== EIP-7960 ===
TITLE: EOF - Extended types section
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-28
REQUIRES: 3540

SUMMARY:
This EIP extends the definition of `types_section` in EOF format ([EIP-3540](./eip-3540.md)) with an additional `type` parameter.

SPECIFICATION:
`types_section`, as defined in EIP-3540, is changed to be of the following format `(type, reserved, inputs, outputs, max_stack_increase)`. `type` is `uint8`, `reserved` is 24 bits, and `inputs`, `outputs`, `max_stack_increase` are defined as `uint8`, `uint8`, `uint16` respectively, the same as before. The only valid `type` defined in this EIP is

MOTIVATION:
An additional `type` parameter allows the EOF EVM interpreter to identify the "type" of a code section. This allows the interpreter to "interpret" each code section differently, allowing EOF function calls to, for example, invoke pure EVM64 code or even later support RISC-V.

RATIONALE:
The new `type` parameter allows a contract to "dispatch" to different variants of the interpreter to better suit its need. * The portion of the code where it mainly interacts with Ethereum addresses, balances, storages may run "normal" EVM. * The portion of the code that is computationally heavy


=== EIP-3014 ===
TITLE: eth_symbol JSON-RPC method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-09-30
REQUIRES: 

SUMMARY:
The new method `eth_symbol` (`eth_`-namespaced) has no parameters and returns a string of the native coin of the network. For the Ethereum mainnet this will be `ETH`, other networks will have other symbols.

SPECIFICATION:
Method: `eth_symbol`. Params: none. Returns: `result` - the native coin symbol, string Example: ```js curl -X POST --data '{"jsonrpc":"2.0","method":"eth_symbol","params":[],"id":1}' // Result { "id": 1, "jsonrpc": "2.0", "result": "ETH" } ```

MOTIVATION:
Wallets that deal with multiple networks need some basic information for every blockchain that they connect to. One of those things is the symbol of the native coin of the network. Instead of requiring the user to research and manually add the symbol it could be provided to the

RATIONALE:
This endpoint is similar to [EIP-695](./eip-695.md) but it provides the symbol instead of `chainId`. It provides functionality that is already there for [ERC-20](./eip-20.md) tokens, but not yet for the native coin of the network. Alternative naming of `eth_nativeCurrencySymbol` was considered, but the context and the fact that it just


=== EIP-7830 ===
TITLE: Contract size limit increase for EOF
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-11-29
REQUIRES: 1, 7, 0, ,,  , 3, 5, 4, 0, ,,  , 3, 8, 6, 0

SUMMARY:
Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.

SPECIFICATION:
[EIP-170](./eip-170.md) specifies `MAX_CODE_SIZE` as 24576 bytes, and [EIP-3860](./eip-3860.md) specifies `MAX_INITCODE_SIZE` as `2 * MAX_CODE_SIZE` (49152 bytes). Starting `FORK_BLOCK`, for EOF initcode/code (code starting with the `0xEF 0x00` bytes) the limit is changed:`MAX_CODE_SIZE` is set to 65536 bytes (64 KiB). This means `MAX_INITCODE_SIZE` becomes 131072 bytes (128 KiB).

MOTIVATION:
The contract size limit was introduced as a measure against DoS attacks. `JUMPDEST`-analysis is required for legacy contracts, and many of the algorithms performing it are not linear and/or have unknown unknowns. This is one of the reasons for the hesitance of a limit increase. For contract developers the

RATIONALE:
The 64 KiB limit is over 2x of existing limit, while it is not a significant increase, it is the realistic increase given the limitations of initcode. In EOF deployment the to-be-deployed code is stored as a section ("subcontainer"), which has a size limit of 64 KiB, therefore it


=== EIP-4762 ===
TITLE: Statelessness gas cost changes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.

SPECIFICATION:
### Helper functions ```python def get_storage_slot_tree_keys(storage_key: int) -> [int, int]: if storage_key < (CODE_OFFSET - HEADER_STORAGE_OFFSET): pos = HEADER_STORAGE_OFFSET + storage_key else: pos = MAIN_STORAGE_OFFSET + storage_key return ( pos // 256, pos % 256 ) ``` ### Access events Whenever the state is read, one or more of

MOTIVATION:
The introduction of Verkle trees into Ethereum requires fundamental changes and as a preparation, this EIP is targeting the fork coming right before the verkle tree fork, in order to incentivize Dapp developers to adopt the new storage model, and ample time to adjust to it. It also incentivizes

RATIONALE:
### Gas reform Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design. `WITNESS_CHUNK_COST` is set to charge 6.25 gas per byte for chunks, and `WITNESS_BRANCH_COST` is set to charge ~13,2 gas per byte for branches on


=== EIP-3337 ===
TITLE: Frame pointer support for memory load and store operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-06
REQUIRES: 3336

SUMMARY:
This EIP introduces four new opcodes, `MLOADFP`, `MSTOREFP`, `GETFP` and `SETFP` that allow for more efficient memory access offset by a user-controlled quantity called the "frame pointer". This permits compilers to more efficiently offload ephemeral data such as local variables to memory instead of the EVM's evaluation stack, which

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. ### Frame pointer A new EVM internal state variable called the "frame pointer" is introduced. This is a signed integer that starts

MOTIVATION:
In most commonly used VMs, ephemeral data such as local variables, function arguments, and return addresses is stored in a region of memory called the stack. In contrast to the EVM's evaluation stack, this area of memory is randomly accessible, and thus can store an arbitrary amount of data,

RATIONALE:
### Cost of new opcodes The cost of the new opcodes `MLOADFP` and `MSTOREFP` reflects the cost of `MLOAD` and `MSTORE`. They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost. The cost of the new opcodes `SETFP` and `GETFP` is


=== EIP-1109 ===
TITLE: PRECOMPILEDCALL opcode (Remove CALL costs for precompiled contracts)
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-22
REQUIRES: 

SUMMARY:
This EIP tries to resolve the problem of high gas consumption when calling precompiled contracts with a small gas cost. Using this opcode for calling precompiled contracts allows to define precompiled contracts whose effective cost it is less than 700.

SPECIFICATION:
If `block.number >= XXXXX`, define a new opcode named `PRECOMPILEDCALL` with code value `0xfb`. The gas cost of the OPCODE is 2 (Gbase) plus the Specific gas cost defined for each specific precompiled smart contract. The OPCODE takes 5 words from the stack and returns 1 word to the

MOTIVATION:
Each precompiled contract has an already defined cost for calling it. It does not make sense to add the implicit extra gas cost of the CALL opcode. As an example, SHA256 precompiled contract costs 60 and ECADD costs 500 (proposed to costs only 50 in [EIP-1108](./eip-1108.md) . When a

RATIONALE:
There was a first proposal for removing the gast consts for the `CALL`, but it looks that it's easier to implement and test a new opcode just for that. The code is just the next opcode available after the `STATICCALL` opcode.


=== EIP-3374 ===
TITLE: Predictable Proof-of-Work (POW) Sunsetting
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
Sets the block reward to 3 ETH and then incrementally decreases it every block for 2,362,000 blocks (approximately 1 year) until it reaches 1 ETH.

SPECIFICATION:
### Constants * `TRANSITION_START_BLOCK_NUMBER: TBD` * `TRANSITION_DURATION: 2_362_000` // (about one year) * `TRANSITION_END_BLOCK_NUMBER: FORK_BLOCK_NUMBER + TRANSITION_DURATION` * `STARTING_REWARD: 3_000_000_000_000_000_000` * `ENDING_REWARD: 1_000_000_000_000_000_000` * `REWARD_DELTA: STARTING_REWARD - ENDING_REWARD` ### Block Reward ```py if block.number >= TRANSITION_END_BLOCK_NUMBER: block_reward = ENDING_REWARD elif block.number == TRANSITION_START_BLOCK_NUMBER: block_reward = STARTING_REWARD elif block.number >

MOTIVATION:
Unnecessarily abrupt changes to the Ethereum ecosystem cause disruption and disharmony resulting in the disenfranchisement of community members while undermining stability and confidence. While moves from Proof-of-Work to Proof-of-Stake will undoubtedly cause friction between those community members vested in either, all benefit from a measured, predictable transition. This proposal:

RATIONALE:
Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame. Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner


=== EIP-2583 ===
TITLE: Penalty for account trie misses
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-21
REQUIRES: 

SUMMARY:
This EIP adds a gas penalty for accesses to the account trie, where the address being looked up does not exist. Non-existing accounts can be used in DoS attacks, since they bypass cache mechanisms, thus creating a large discrepancy between 'normal' mode of execution and 'worst-case' execution of an

SPECIFICATION:
We define the constant `penalty` as `TBD` (suggested `2000` gas). For opcodes which access the account trie, whenever the operation is invoked targeting an `address` which does not exist in the trie, then `penalty` gas is deducted from the available `gas`. ### Detailed specification These are the opcodes which

MOTIVATION:
As the ethereum trie becomes more and more saturated, the number of disk lookups that a node is required to do in order to access a piece of state increases too. This means that checking e.g. `EXTCODEHASH` of an account at block `5` was _inherently_ a cheaper operation that

RATIONALE:
With this scheme, we could continue to price these operations based on the 'normal' usage, but gain protection from attacks that try to maximize disk lookups/cache misses. This EIP does not modify anything regarding storage trie accesses, which might be relevant for a future EIP. However, there are a


=== EIP-7543 ===
TITLE: EVM arbitrary precision decimal math
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-22
REQUIRES: 

SUMMARY:
This EIP adds *arbitrary precision decimal float* OPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for

SPECIFICATION:
### Decimal A decimal is defined as c * 10^q where c and q are int256. Notationwise: a = ac * 10^aq b = bc * 10^bq etc. ### OPCODE defs 0xd0 DECADD a+b -> c : (ac, aq, bc, bq, precision) -> (cc, cq) 0xd1 DECNEG -a ->

MOTIVATION:
Currently, to take a power, a^b, of non integer values, requires vast amounts of Solidity code. The simplest task in trading e.g. is to convert volatilities from yearly to daily, which involves taking the 16th root. Giving users/devs the same ability that scientific calculators have allows for the creation

RATIONALE:
### gas All the above OPCODEs are deterministic, hence the gas cost can be determined. At the same time, the calculations are complex and depend on the input. It is crucial to have accurate gas costs to avoid energy attacks on nodes. To this end, the underlying uint256 lib


=== EIP-214 ===
TITLE: New opcode STATICCALL
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
This proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present). Any opcode that attempts to perform such a modification (see below for details) will result in an exception

SPECIFICATION:
Introduce a new `STATIC` flag to the virtual machine. This flag is set to `false` initially. Its value is always copied to sub-calls with an exception for the new opcode below. Opcode: `0xfa`. `STATICCALL` functions equivalently to a `CALL`, except it takes only 6 arguments (the "value" argument is

MOTIVATION:
Currently, there is no restriction about what a called contract can do, as long as the computation can be performed with the amount of gas provided. This poses certain difficulties about smart contract engineers; after a regular call, unless you know the called contract, you cannot make any assumptions

RATIONALE:
This allows contracts to make calls that are clearly non-state-changing, reassuring developers and reviewers that re-entrancy bugs or other problems cannot possibly arise from that particular call; it is a pure function that returns an output and does nothing else. This may also make purely functional HLLs easier to


=== EIP-3607 ===
TITLE: Reject transactions from senders with deployed code
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-06-10
REQUIRES: 

SUMMARY:
Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated `2**80` computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this

SPECIFICATION:
Any transaction where `tx.sender` has a `CODEHASH != EMPTYCODEHASH` MUST be rejected as invalid, where `EMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`. The invalid transaction MUST be rejected by the client and not be included in a block. A block containing such a transaction MUST be considered invalid.

MOTIVATION:
### Generating address collisions By creating keys for `2**80` EOAs and simulating the deployment of `2**80` contracts from these EOAs (one each), one expects to find about one collision where an EOA has the same address as one contract. This very simple form of the attack requires the storage

RATIONALE:
We note that it was always expected that a contract account's behaviour is constrained by the code in that contract -- which means that the account's funds should not suddenly be spendable by some private key. It was just implicitly assumed in the past that a 160 bit address


=== EIP-7833 ===
TITLE: Scheduled function calls
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-12-06
REQUIRES: 

SUMMARY:
Ethereum's smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers—like MEV attacks—can prevent timely execution. To address these challenges, this Ethereum

SPECIFICATION:
Adding bot-like behavior to an EVM function is achieved by recursively scheduling a call to the same function in the next block. We propose introducing a new EVM opcode, OFFERCALL, which, as the name implies, offers ETH to be burnt to the block producer of the next block in

RATIONALE:
The rationale behind this Ethereum Improvement Proposal (EIP) stems from the need to enhance the reliability and fairness of smart contract execution on the Ethereum network. While Ethereum’s smart contracts allow for a high degree of programmability and automation, the execution of these contracts often depends on external triggers,


=== EIP-1803 ===
TITLE: Rename opcodes for clarity
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2017-07-28
REQUIRES: 141

SUMMARY:
Rename the `BALANCE`, `SHA3`, `NUMBER`, `GASLIMIT`, `GAS` and `INVALID` opcodes to reflect their true meaning.

SPECIFICATION:
Rename the opcodes as follows: - `BALANCE` (`0x31`) to `EXTBALANCE` to be in line with `EXTCODESIZE`, `EXTCODECOPY` and `EXTCODEHASH` - `SHA3` (`0x20`) to `KECCAK256` - `NUMBER` (`0x43`) to `BLOCKNUMBER` - `GASLIMIT` (`0x45`) to `BLOCKGASLIMIT` to avoid confusion with the gas limit of the transaction - `GAS` (`0x5a`) to `GASLEFT`


=== EIP-7642 ===
TITLE: eth/69 - history expiry and simpler receipts
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2024-02-29
REQUIRES: 5793

SUMMARY:
This EIP modifies the 'eth' p2p protocol to announce the historical block range served by the node. We also simplify the handshake to remove total difficulty information, which isn't used anymore after the merge. Additionally we propose to remove the `Bloom` field from receipts transferred over the protocol.

SPECIFICATION:
### Status message changes Modify the `Status (0x00)` message as follows: - (eth/68): `[version: P, networkid: P, td: P, blockhash: B_32, genesis: B_32, forkid]` - (eth/69): `[version: P, networkid: P, genesis: B_32, forkid, earliestBlock: P, latestBlock: P, latestBlockHash: B_32]` Note `blockhash` has moved to the end to match `BlockRangeUpdate`.

MOTIVATION:
### Block range in Status message In the history expiry working group, it was decided that clients may drop pre-merge history from their storage after May 1, 2025. For clients that want to sync history through the 'eth' protocol, it is essential to know whether a peer still serves

RATIONALE:
### Status changes After the merge, the `TD` field of the `Status` message became meaningless since the difficulty of post-merge blocks are 0. It could in theory be used to distinguish synced with unsynced nodes, but the same thing can be accomplished with the forkid as well. The new


=== EIP-5920 ===
TITLE: PAY opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-03-14
REQUIRES: 2, 1, 4, ,,  , 2, 9, 2, 9, ,,  , 7, 5, 2, 3

SUMMARY:
This EIP introduces a new opcode, `PAY`, taking two stack parameters, `addr` and `val`, that transfers `val` wei to the address `addr` without calling any of its functions.

SPECIFICATION:
### Constants | Constant | Definition | | -------------------------- | ------------------------- | | `WARM_STORAGE_READ_COST` | [EIP-2929](./eip-2929.md) | | `COLD_ACCOUNT_ACCESS_COST` | [EIP-2929](./eip-2929.md) | | `GAS_NEW_ACCOUNT` | [EELS][gna] | | `GAS_CALL_VALUE` | [EELS][gcv] | [gna]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L52 [gcv]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L53 ### Behavior A new opcode is introduced: `PAY` (`0xfc`), which: - Halt with

MOTIVATION:
Currently, to send ether to an address requires you to call into that address, which transfers execution context to that address, which creates several issues: - First of all, it opens a reentrancy attack vector, as the recipient can call back into the sender. More generally, the recipient can

RATIONALE:
### Argument order The order of arguments mimics that of `CALL`, which pops `addr` before `val`. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, so `PAY` always appears immediately after `COINBASE`. ### Halting for invalid address The halting behavior is designed to allow for Address Space Extension.


=== EIP-7907 ===
TITLE: Meter Contract Code Size And Increase Limit
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-14
REQUIRES: 1, 7, 0, ,,  , 2, 9, 2, 9, ,,  , 3, 8, 6, 0, ,,  , 7, 7, 0, 2

SUMMARY:
This EIP increases the contract code size limit from 24KB (24576 bytes) introduced in [EIP-170](./eip-170.md) to 64KB (65536 bytes), and adds gas metering for excess code loading. It introduces a gas cost of 2 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of

SPECIFICATION:
### Definitions | Name | Value | Description | | --- | --- | --- | | `COLD_SLOAD_COST` | `2100` | The cost charged for cold loading storage as defined by [EIP-2929](./eip-2929.md). | | `WARM_STORAGE_READ_COST` | `100` | The cost charged for loading warm storage as defined by [EIP-2929](./eip-2929.md).

MOTIVATION:
EIP-170 introduced a 24KB contract code size limit to prevent potential DoS attacks, as large contract code requires O(n) resource cost in terms of disk reads, VM preprocessing, and Merkle proof sizes, all of which are not directly compensated by gas fees. However, this limit restricts legitimate use cases

RATIONALE:
The gas cost of 2 per word was chosen to account for: 1. The additional disk I/O for retrieving larger contract code 2. The increased computational resources for preprocessing larger code for execution (a.k.a. "JUMPDEST analysis"). 3. The growth in Merkle proof sizes for blocks containing larger contracts This


=== EIP-2384 ===
TITLE: Muir Glacier Difficulty Bomb Delay
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-11-20
REQUIRES: 

SUMMARY:
Starting with `MUIR_GLACIER_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9 million blocks later than the Homestead fork, which is also 7 million blocks later than the Byzantium fork and 4 million blocks later

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 9_000_000) if block.number >= MUIR_GLACIER_FORK_BLKNUM else block.number

MOTIVATION:
The difficulty bomb started to become noticeable again on October 5th 2019 at block 8,600,000. Block times have been around 13.1s on average and now as of block 8,900,000 are around 14.3s. This will start to accelerate exponentially every 100,000 blocks. Estimating the added impact from the difficulty bomb

RATIONALE:
This will delay the ice age by 52 million seconds (approximately 611 days), so the chain would be back at 20 second block times around July 2021. It's important to note this pushes the ice age 4,000,000 blocks from ~block 8,800,000 NOT from when this EIP is activated in


=== EIP-7044 ===
TITLE: Perpetually Valid Signed Voluntary Exits
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-18
REQUIRES: 

SUMMARY:
Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.

SPECIFICATION:
### Consensus Layer Specification changes are built into the Consensus Specs Deneb upgrade. The specific makes one change to the state transition function: - Modify [`process_voluntary_exit`](https://github.com/ethereum/consensus-specs/blob/75971a8c218b1d76d605dd8b88a08d39c42de221/specs/deneb/beacon-chain.md#modified-process_voluntary_exit) to compute the signing domain and root fixed on `CAPELLA_FORK_VERSION`. Additionally, the `voluntary_exit` gossip conditions are implicitly modified to support this change. To

MOTIVATION:
Currently, signed voluntary exits are valid up-to only two upgrades for block inclusion due to the Beacon Chain state considering only the current and previous fork version. This limitation increases the complexity of some staking operations, specifically those in which the staking operator (holder of active key) is distinct

RATIONALE:
Perpetually valid signed voluntary exits allow simpler staking operation designs. It also aligns the UX of such objects to `BLSToExecutionChanges` and deposits, such that downstream tooling does not need to be updated with fork version information.


=== EIP-8079 ===
TITLE: Native rollups
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-11-13
REQUIRES: 

SUMMARY:
Expose the state transition function to the execution layer via a new `EXECUTE` precompile.

SPECIFICATION:
### Parameters <!-- TODO --> | Constant | Value | | - | - | | `PROOF_TX_TYPE` | `Bytes1(TBD)` | | `EXECUTE_PRECOMPILE_ADDRESS` | `TBD` | | `ANCHOR_ADDRESS` | `TBD` | ### `EXECUTE` precompile Add a precompile at `EXECUTE_PRECOMPILE_ADDRESS` that verifies a state transition function with the provided inputs. The

MOTIVATION:
Today, EVM-equivalent rollups need to implement and maintain complex proof systems just to be able to replicate what Ethereum already provides on L1. Such complexity significantly increases the probability of encountering bugs and prevents projects from getting rid of security councils and from moving to Stage 2. EVM-equivalent projects

RATIONALE:
### Programmable "consensus layer" The `EXECUTE` precompile allows rollups to define their own inputs and constrained their behaviour through smart contract. For example, in contrast to Ethereum's own consensus layer, a rollup can decide to: - Restrict the use of transactions that are sequenced by a permissioned entity, allowing


=== EIP-7910 ===
TITLE: eth_config JSON-RPC Method
TYPE: Standards Track Interface
STATUS: Last Call
CREATED: 2025-03-18
REQUIRES: 

SUMMARY:
This document describes an RPC method that provides node-relevant configuration data for the current, next, and last known forks.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Clients MUST expose a new RPC method to report the current functional configuration and the

MOTIVATION:
Throughout Ethereum's history, there have been multiple instances where a client was not correctly configured for an upcoming hard fork, causing it to fall out of consensus when the fork boundary was crossed. Most incidents have been minor, such as a single client forking the chain in proof-of-work or

RATIONALE:
### Why Enumerate Precompiles? (And in General, Why Track a Particular Config Item?) The purpose of this specification is to enable nodes to advertise, prior to a fork, that they have the correct configurations loaded and ready. Past testnet and Ethereum Mainnet forks have revealed clients with incorrect precompile


=== EIP-7587 ===
TITLE: Reserve Precompile Address Range for RIPs
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-21
REQUIRES: 

SUMMARY:
This EIP reserves precompile ranges to ensure there are no conflicts with those used by the Rollup Improvement Proposal (RIP) process.

SPECIFICATION:
The address range between `0x0000000000000000000000000000000000000100` and `0x00000000000000000000000000000000000001ff` is reserved for use by the RIP process.

MOTIVATION:
As L2s begin to deploy RIPs, it is necessary to reserve an address range for use by the RIP process so as to ensure there are no conflicts between precompile addresses used by RIPs and EIPs.

RATIONALE:
By reserving an address range for RIPs, it allows the RIP process to maintain its own registry of precompiles that are not (necessarily) deployed on L1 mainnet, the EIP process is freed from having to maintain a registry of RIP precompiles while still having 255 addresses for its own


=== EIP-2294 ===
TITLE: Explicit bound to Chain ID size
TYPE: Informational 
STATUS: Stagnant
CREATED: 2019-09-19
REQUIRES: 155

SUMMARY:
This EIP informationally defines the "Safe Range" and "Max Range" of ChainId based on a few known restrictions such as [EIP-155](./eip-155.md) and major wallet and JSON-RPC representation of ChainId.

SPECIFICATION:
We declared the following chainID range 1. (1, 2^31 - 1): "Safe Range", the higher bound is decided by Javascript number 2. (1, MAX_CHAIN_ID); "Max Range", in which `MAX_CHAIN_ID := floor(MAX_UINT64 / 2) - 36 = 9,223,372,036,854,775,771`:

MOTIVATION:
1. We want chainId to be safe across the different components of the ecosystem such as smart contract, wallet, dApp and JSON-RPC etc. 2. We want to enable Cross-Chain function call 3. We want to ensure [EIP-712](./eip-712.md) domains have a clear definition of how to pack ChainID. 4. Enable

RATIONALE:
### Beyond "Max Range", the EIP-155 will overflow as discussed below The `MAX_CHAIN_ID` is calculated to avoid overflow when performing uint64 math. For reference, a value of 0 or less is also disallowed. Due to how the calculation for chain ID is performed, the maximum value seen during the


=== EIP-779 ===
TITLE: Hardfork Meta: DAO Fork
TYPE: Meta 
STATUS: Final
CREATED: 2017-11-26
REQUIRES: 606

SUMMARY:
This documents the changes included in the hard fork named "DAO Fork". Unlike other hard forks, the DAO Fork did not change the protocol; all EVM opcodes, transaction format, block structure, and so on remained the same. Rather, the DAO Fork was an "irregular state change" that transferred ether

SPECIFICATION:
- Codename: DAO Fork - Activation: - Block == 1,920,000 on Mainnet See references [1] and [2] for the original, full specification. It is summarized here for convenience. At block 1880000, the following accounts are encoded into a list `L`: * The DAO (`0xbb9bc244d798123fde783fcc1c72d3bb8c189413`) * its extraBalance (`0x807640a13483f8ac783c557fcdf27be11ea4ac7a`) *


=== EIP-2930 ===
TITLE: Optional access lists
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-08-29
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 2, 9

SUMMARY:
We introduce a new [EIP-2718](./eip-2718.md) transaction type, with the format `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])`. The `accessList` specifies a list of addresses and storage keys; these addresses and storage keys are added into the `accessed_addresses` and `accessed_storage_keys` global sets (introduced in

SPECIFICATION:
### Definitions **`TransactionType`** `1`. See [EIP-2718](./eip-2718.md) **`ChainId`** The transaction only valid on networks with this `chainID`. **`YParity`** The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature. ### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | 12244000 |

MOTIVATION:
This EIP serves two functions: 1. Mitigates contract breakage risks introduced by [EIP-2929](./eip-2929.md), as transactions could pre-specify and pre-pay for the accounts and storage slots that the transaction plans to access; as a result, in the actual execution, the SLOAD and EXT* opcodes would only cost 100 gas: low

RATIONALE:
### Charging less for accesses in the access list This is done to encourage transactions to use the access list as much as possible, and because processing transactions is easier when their storage reads are predictable (because clients can pre-load the data from databases and/or ask for witnesses at


=== EIP-3372 ===
TITLE: 5 FNV primes for ethash
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
This EIP is to kick current ASIC implementations out of the network to keep the Ethereum network secure and healthy by changing the `fnv` constants.

SPECIFICATION:
If `block.number >= ETHASH11_BLKNUM`, activate the `ethash1.1` algorithm version. ### ethash1.1 Prior to this change, `fnv` hash function is used throughout the `hashimoto` function. `fnv` is identical for all steps, `ethash1.1` will introduce additional `fnvA`, `fnvB`, `fnvC`, `fnvD`, and `fnvE` functions. All those functions will have different FNV constants.

MOTIVATION:
ASICs provide a severe centralization risk for the Ethereum network. If we do not get rid of them, small GPU miners will be forced to exit the Ethereum mining because EIP-1559 will make them mining at a loss. Furthermore, ASIC production will be concentrated only at one or two

RATIONALE:
ASIC Miners have become a threat to the future of Ethereum and a hard fork is required to remove them from the network before additional damage is caused. EIP-3372 proposes the minimum necessary to do so and will not affect ETH stakeholders or the network like Ethash 2.0 would.


=== EIP-8053 ===
TITLE: Milli-gas for High-precision Gas Metering
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-17
REQUIRES: 

SUMMARY:
This proposal introduces the `milli-gas` counter as the EVM’s internal gas accounting. Gas costs are defined in `milli_gas` and internal EVM gas accounting is entirely carried out in `milli_gas`. At the end of transaction execution,`milli_gas` is rounded up to `gas`. Gas limits and transaction fees are still computed and

SPECIFICATION:
This proposal introduces a new `Uint` counter to the EVM, `milli_gas_left`. Gas costs are defined in `milli_gas` and internal EVM gas accounting is entirely carried out in `milli_gas`. Transaction fees, transaction gas limits, and block gas limits are still computed and verified using the current `gas_used` counter. There are

MOTIVATION:
Currently, most EVM compute operations (`ADD`, `SUB`, `MUL`, etc.) are significantly underpriced when compared with state operations (`SSTORE`, `SLOAD`, `CREATE`, etc.). There are two factors contributing to this mismatch. On one hand, client optimizations and hardware improvements have made pure compute operations more efficient. On the other hand, with

RATIONALE:
### New counter vs. new variable type A possible approach to allow for fractional gas would be to change the variable type of all gas-related variables from an integer to a float or a base fractional. Although simple in concept, the implementation of such a change in the EVM


=== EIP-607 ===
TITLE: Hardfork Meta: Spurious Dragon
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 5, 5, ,,  , 1, 6, 0, ,,  , 1, 6, 1, ,,  , 1, 7, 0, ,,  , 6, 0, 8

SUMMARY:
This specifies the changes included in the hard fork named Spurious Dragon.

SPECIFICATION:
- Codename: Spurious Dragon - Aliases: State-clearing - Activation: - Block >= 2,675,000 on Mainnet - Block >= 1,885,000 on Morden - Included EIPs: - [EIP-155](./eip-155.md) (Simple replay attack protection) - [EIP-160](./eip-160.md) (EXP cost increase) - [EIP-161](./eip-161.md) (State trie clearing) - [EIP-170](./eip-170.md) (Contract code size limit)


=== EIP-6049 ===
TITLE: Deprecate SELFDESTRUCT
TYPE: Meta 
STATUS: Final
CREATED: 2022-11-27
REQUIRES: 

SUMMARY:
This EIP deprecates the `SELFDESTRUCT` opcode and warns against its use. A breaking change to this functionality is likely to come in the future.

SPECIFICATION:
Documentation of the `SELFDESTRUCT` opcode is updated to warn against its use and to note that a breaking change may be forthcoming.

MOTIVATION:
Discussions about how to change `SELFDESTRUCT` are ongoing. But there is a strong consensus that *something* will change.

RATIONALE:
As time goes on, the cost of doing something increases, because any change to `SELFDESTRUCT` will be a breaking change. The Ethereum Blog and other official sources have not provided any warning to developers about a potential forthcoming change.


=== EIP-3198 ===
TITLE: BASEFEE opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-01-13
REQUIRES: 1559

SUMMARY:
Add a `BASEFEE (0x48)` that returns the value of the base fee of the current block it is executing in.

SPECIFICATION:
Add a `BASEFEE` opcode at `(0x48)`, with gas cost `G_base`. | Op | Input | Output | Cost | |:----: |:-----: |:------: |:----: | | 0x48 | 0 | 1 | 2 |

MOTIVATION:
The intended use case would be for contracts to get the value of the base fee. This feature would enable or improve existing use cases, such as: - Contracts that need to set bounties for anyone to "poke" them with a transaction could set the bounty to be `BASEFEE

RATIONALE:
### Gas cost The value of the base fee is needed to process transactions. That means it's value is already available before running the EVM code. The opcode does not add extra complexity and additional read/write operations, hence the choice of `G_base` gas cost.


=== EIP-698 ===
TITLE: OPCODE 0x46 BLOCKREWARD
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-08-28
REQUIRES: 

SUMMARY:
In the EVM, the 0x40 opcodes are reserved for `Block Information`. Currently reserved opcodes are: * `0X40 BLOCKHASH` * `0X41 COINBASE` * `0X42 TIMESTAMP` * `0X43 NUMBER` * `0X44 DIFFICULTY` * `0X45 GASLIMIT` This EIP would add an additional opcode, `0x46 BLOCKREWARD`, which would return the block reward for

SPECIFICATION:
After block `n` all clients should process opcode `0x46` as follows: * Value: `0x46` * Mnemonic: `BLOCKREWARD` * δ:` 0` nothing removed from stack * α:`1` block reward added to stack * Description: `Get the block's reward emission` * GasCost: `G<sub>base</sub>` Where:`µ'<sub>s</sub>[0] ≡ I<sub>HR</sub>`

MOTIVATION:
Per EIP-649 ( #669 ) periodic block reward reductions/variance are now planned in the roadmap, however, this EIP is consensus system agnostic and is most useful in decentralized pool operations and for any contract that benefits from knowing a block reward payout(i.e. Merge mined tokens)

RATIONALE:
### Contract Mining Pools For distributed consensus systems(staking pools and mining pools) ad hoc groups combine resources in order to reduce variance in payouts. Broadly, pool operations function by allowing a collective of miners / stakers to verify their contribution to solving PoW or staking share by periodically submitting


=== EIP-7773 ===
TITLE: Hardfork Meta - Glamsterdam
TYPE: Meta 
STATUS: Draft
CREATED: 2024-09-26
REQUIRES: 7, 6, 0, 7, ,,  , 7, 7, 2, 3

SUMMARY:
This Meta EIP lists the EIPs formally Proposed, Considered, Declined for & Scheduled for Inclusion in the Glamsterdam network upgrade.

SPECIFICATION:
Definitions for `Scheduled for Inclusion`, `Considered for Inclusion`, `Declined for Inclusion` and `Proposed for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion * [EIP-7732](./eip-7732.md): Enshrined Proposer-Builder Separation * [EIP-7928](./eip-7928.md): Block-Level Access Lists ### Considered for Inclusion * [EIP-2780](./eip-2780.md): Reduce intrinsic transaction gas * [EIP-7688](./eip-7688.md): Forward compatible

RATIONALE:
This Meta EIP provides a global view of all changes included in the Glamsterdam network upgrade, as well as links to full specification.


=== EIP-4750 ===
TITLE: EOF - Functions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-01-10
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 5, 4, 5, 0

SUMMARY:
Introduce the ability to have several code sections in EOF-formatted ([EIP-3540](./eip-3540.md)) bytecode, each one representing a separate subroutine/function. Two new opcodes,`CALLF` and `RETF`, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.

SPECIFICATION:
### Type Section The type section of EOF containers must adhere to following requirements: 1. The section is a list of metadata where the metadata index in the type section corresponds to a code section index. Therefore, the type section size MUST be `n * 4` bytes, where `n`

MOTIVATION:
Currently, in the EVM everything is a dynamic jump. Languages like Solidity generate most jumps in a static manner (i.e. the destination is pushed to the stack right before, `PUSHn .. JUMP`). Unfortunately however this cannot be used by most EVM interpreters, because of added requirement of validation/analysis. This

RATIONALE:
### `RETF` in the top frame ends execution vs exceptionally halts vs is not allowed during validation Alternative logic for `RETF` in the top frame could be to allow it during code validation and make it either: - end execution if the return stack is emptied by the `RETF`


=== EIP-4938 ===
TITLE: eth/67 - Removal of GetNodeData
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-03-23
REQUIRES: 2, 4, 6, 4, ,,  , 2, 4, 8, 1

SUMMARY:
The [Ethereum Wire Protocol](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md) defines request and response messages for exchanging data between clients. The `GetNodeData` request retrieves a set of trie nodes or contract code from the state trie by hash. We propose to remove the `GetNodeData` and `NodeData` messages from the wire protocol.

SPECIFICATION:
Remove the following message types from the `eth` protocol: * `GetNodeData (0x0d)` * **(eth/66)**: `[request_id: P, [hash_0: B_32, hash_1: B_32, ...]]` * `NodeData (0x0e)` * **(eth/66)**: `[request_id: P, [value_0: B, value_1: B, ...]]`

MOTIVATION:
`GetNodeData` and `NodeData` were introduced in protocol version `eth/63` to allow for a sync mode called "fast sync", which downloads the Ethereum state without executing all blocks. The sync algorithm works by requesting all state trie nodes and contract codes by their hash. Serving `GetNodeData` requests requires clients to

RATIONALE:
A replacement for `GetNodeData` is available in the [snap protocol](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md). Specifically, clients can use the [GetByteCodes](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md#getbytecodes-0x04) and [GetTrieNodes](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md#gettrienodes-0x06) messages instead of `GetNodeData`. The snap protocol can be used to implement the "fast sync" algorithm, though it is recommended to use it for "snap sync".


=== EIP-7919 ===
TITLE: Pureth Meta
TYPE: Meta 
STATUS: Draft
CREATED: 2025-03-26
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 4, 9, 5, ,,  , 7, 6, 6, 8, ,,  , 7, 7, 0, 8, ,,  , 7, 7, 4, 5, ,,  , 7, 7, 9, 9, ,,  , 7, 8, 0, 7, ,,  , 7, 9, 1, 6

SUMMARY:
This Meta EIP bundles a set of improvements to make Ethereum data easier to access and verify without relying on trusted RPC providers or third-party indexers. The improvements achieve this by changing data structures for blocks, transactions, and receipts, so that efficient correctness (i.e., validity) and completion (i.e., nothing

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Improve UX: ETH transfer logs ETH transfers currently don't emit logs, and in many

MOTIVATION:
- **Security**: Today, most wallets and dApps consume data from very few large RPC providers, which exposes users to the risk of incorrect and incomplete data in case the RPC provider gets hacked, becomes malicious, or uses a faulty software version. - **Privacy**: Centralized infrastructure is subject to external

RATIONALE:
See individual EIPs.


=== EIP-3670 ===
TITLE: EOF - Code Validation
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-06-23
REQUIRES: 3540

SUMMARY:
Introduce code validation at contract creation time for EOF formatted ([EIP-3540](./eip-3540.md)) contracts. Reject contracts which contain truncated `PUSH`-data or undefined instructions. Legacy bytecode (code which is not EOF formatted) is unaffected by this change.

SPECIFICATION:
This feature is introduced on the same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST be validated according to these rules. 1. Previously deprecated instructions `CALLCODE` (0xf2) and `SELFDESTRUCT` (0xff), as well as instructions deprecated in EIP-3540, are invalid and their opcodes are undefined. (**NOTE** there are more

MOTIVATION:
Currently existing contracts require no validation of correctness and EVM implementations can decide how they handle truncated bytecode or undefined instructions. This change aims to bring code validity into consensus, so that it becomes easier to reason about bytecode. Moreover, EVM implementations may require fewer paths to decide which

RATIONALE:
### Immediate data Allowing implicit zero immediate data for `PUSH` instructions introduces inefficiencies to EVM implementations without any practical use-case (the value of a `PUSH` instruction at the code end cannot be observed by EVM). This EIP requires all immediate bytes to be explicitly present in the code. ###


=== EIP-7639 ===
TITLE: eth/70 - Cease serving history before PoS
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2024-02-13
REQUIRES: 

SUMMARY:
Execution layer clients will no longer request or respond to p2p queries about block data before the Paris upgrade.

SPECIFICATION:
Add a new `eth` protocol capability with version `70`. Clients connected on this version must not make or respond to p2p queries about block bodies or receipts before block 15537393. The affected protocol messages are: - `GetBlockBodies (0x05)` - `BlockBodies (0x06)` - `GetReceipts (0x0f)` - `Receipts (0x10)`

MOTIVATION:
As of 2024, historical data in clients has grown to around 500 GB. Nearly 400 GB of that is from block data before PoS was activated in the Paris upgrade. Long term, Ethereum plans to bound the amount of data nodes must store. This EIP proposes the first steps

RATIONALE:
### Only Pre-PoS data One might ask why the distinction between pre and post PoS data is made in this EIP. The simple answer is that the at the moment of the merge, the block structure changed substantially. Although execution layer client software today continues on with block data


=== EIP-7808 ===
TITLE: Reserve Tx-Type Range for RIPs
TYPE: Meta 
STATUS: Stagnant
CREATED: 2024-11-04
REQUIRES: 2718

SUMMARY:
This EIP reserves a [transaction-type](./eip-2718.md) range for use by the Rollup Improvement Proposal (RIP) process to ensure there are no conflicts.

SPECIFICATION:
The transaction-type (as specified in [EIP-2718](./eip-2718)) range from `0x40` to `0x7f` (inclusive of both) is reserved for use by the RIP process.

MOTIVATION:
For L2s to use new transactrion types, it is necessary to reserve a transaction-type range for use by the RIP process so as to ensure there are no conflicts between transaction types used by RIPs and EIPs.

RATIONALE:
By reserving a transaction-type range for RIPs, it allows the RIP process to maintain its own registry of transaction types that are not (necessarily) in use on L1 mainnet, the EIP process is then freed from having to maintain a registry of RIP tx-types while still having 64 tx-types


=== EIP-1344 ===
TITLE: ChainID opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-08-22
REQUIRES: 155

SUMMARY:
This EIP adds an opcode that returns the current chain's EIP-155 unique identifier.

SPECIFICATION:
Adds a new opcode `CHAINID` at 0x46, which uses 0 stack arguments. It pushes the current chain ID onto the stack. Chain ID is a 256-bit value. The operation costs `G_base` to execute. The value of the current chain ID is obtained from the chain ID configuration, which should

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md).

RATIONALE:
The current approach proposed by EIP-712 is to specify the chain ID at compile time. Using this approach will result in problems after a hardfork, as well as human error that may lead to loss of funds or replay attacks on signed messages. By adding the proposed opcode it


=== EIP-8080 ===
TITLE: Let exits use the consolidation queue
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-11-13
REQUIRES: 

SUMMARY:
This EIP allows exits to be routed through the consolidation queue when it is shorter than the exit queue, consuming churn that is allocated to consolidations. This democratizes access to a feature that is currently only available to validators with at least 2048 ETH through a loophole in the

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). Starting from the beginning of the epoch when this EIP is activated, Consensus Layer clients

MOTIVATION:
The existing design of consolidation mechanism allows validators with at least 2048 ETH to use the consolidation queue for exits through a loophole in the consolidation logic. When there is an imbalance between exit and consolidation queues favoring the latter, as has been the case since the introduction of

RATIONALE:
The decision to democratize access to this unintended feature, rather than removing it or keeping it as is, is driven by: 1. **Fairness**: All validators gain equal access to this efficiency improvement, rather than it being restricted to those with at least 2048 ETH who can exploit the loophole.


=== EIP-7557 ===
TITLE: Block-level Warming with fair cost savings
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-01
REQUIRES: 

SUMMARY:
A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots among multiple transactions with shared items in their `accessList`.

SPECIFICATION:
The [EIP-2930: Optional access lists](./eip-2930) already introduced the first part of the solution. Each transaction can specify an array of `accessed_addresses` and `accessed_storage_keys` to announce its intention to read those values during the execution of the transaction. The sender of the transaction is then pre-charged with the cost of

MOTIVATION:
[EIP-2929: Gas cost increases for state access opcodes](./eip-2929) introduced a new gas cost model that differentiates between "cold" and "warm" access to accounts and storage slots. However, the cost of every cold access is borne by each transaction separately, even though the validator only needs to fetch the state

RATIONALE:
### Current cold storage gas cost is unfair As described in the [Motivation](#motivation) section, the amount of gas that users spend on accessing the contract code does not reflect the actual cost of this access for the block builder or a validator. The more popular the contract code or


=== EIP-3709 ===
TITLE: Remove Support for Type 1 Transactions
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2021-08-07
REQUIRES: 1559

SUMMARY:
Since both `TransactionType` 1 and 2 contain `access_list`, we propose the removal of offering `TransactionType` 1 from wallets and providers, instead the transaction will be converted to `TransactionType` 2 to make use of the new gas properties introduced by [EIP-1559](./eip-1559.md).

SPECIFICATION:
For wallets and providers, if a user submits a transaction for signing with where `TransactionType == 0x1`, the developer should upgrade the transaction to meet the criteria of transaction of type 2. The following fields need to be changed, or amended: - `access_list`: Nothing changes and it should remain

MOTIVATION:
[EIP-2930](./eip-2930.md) was introduced as the first `TransactionType`, type 1, with the intention of adding `access_list` to the `TransactionPayload`. [EIP-1559](./eip-1559.md) introduced the second `TransactionType` 2, which is represented as `rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`. The intention behind EIP-1559 was to enhance the user

RATIONALE:
Improve the user experience for submitting transactions, and move away from legacy style transactions.


=== EIP-3651 ===
TITLE: Warm COINBASE
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-12
REQUIRES: 2929

SUMMARY:
The `COINBASE` address shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.

SPECIFICATION:
At the start of transaction execution, `accessed_addresses` shall be initialized to also include the address returned by `COINBASE` (`0x41`).

MOTIVATION:
Direct `COINBASE` payments are becoming increasingly popular because they allow conditional payments, which provide benefits such as implicit cancellation of transactions that would revert. But accessing `COINBASE` is overpriced; the address is initially cold under the access list framework introduced in [EIP-2929](./eip-2929.md). This gas cost mismatch can incentivize alternative

RATIONALE:
The addresses currently initialized warm are the addresses that should already be loaded at the start of transaction validation. The `ORIGIN` address is always loaded to check its balance against the gas limit and the gas price. The `tx.to` address is always loaded to begin execution. The `COINBASE` address


=== EIP-7999 ===
TITLE: Unified multidimensional fee market
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-04
REQUIRES: 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 4, 8, 4, 4, ,,  , 7, 5, 1, 6, ,,  , 7, 6, 9, 1, ,,  , 7, 8, 4, 0, ,,  , 7, 9, 1, 8

SUMMARY:
A unified multidimensional fee market is introduced, where each transaction specifies the maximum amount of ETH it is willing to pay for inclusion using a single `max_fee`. Upon inclusion, the protocol ensures that the transaction is able to pay the gas for all dimensions, treating the `max_fee` as fungible

SPECIFICATION:
The specification inherits its logic from [EIP-7706](./eip-7706.md), incorporating the changes necessary for facilitating one aggregate fee, a multidimensional [EIP-7918](./eip-7918.md) logic, a systematic approach to [EIP-7805](./eip-7805.md), and a stable gas normalization function, etc. ### Parameters | Constant | Value | Description | | :--- | :--- | :--- | |

MOTIVATION:
A multidimensional fee market enables precise control over resource consumption. It allows *the market* to fairly price resources according to targets and limits deemed safe by developers, and it allows resources to be consumed at maximum capacity within these limits. Directly expanding the current fee market design to the

RATIONALE:
### Why go multidimensional? Many Ethereum resources such as blobs, calldata, access, and compute are in limited supply each block, constrained by the need to, e.g., timely propagate data or run computations. Upholding the constraints on all these resources via a single meta-resource—"gas"—limits developers' ability to control both supply


=== EIP-2937 ===
TITLE: SET_INDESTRUCTIBLE opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-04
REQUIRES: 

SPECIFICATION:
Add a transaction-wide global variable `globals.indestructible: Set[Address]` (i.e. a variable that operates the same way as the selfdestructs set), initialized to the empty set. Add a `SET_INDESTRUCTIBLE` opcode at `0xA8`, with gas cost `G_base`, that adds the current `callee` to the `globals.indestructible` set. If in the current execution context

MOTIVATION:
The intended use case would be for contracts to make their first byte of code be the `SET_INDESTRUCTIBLE` opcode if they wish to serve as libraries that guarantee to users that their code will exist unmodified forever. This is useful in account abstraction as well as other contexts. Unlike

RATIONALE:
Alternative proposals to this include: * Simply banning `SELFDESTRUCT` outright. This would be ideal, but has larger backwards compatibility issues. * Using a local variable instead of a global variable. This is problematic because it would be broken by `DELEGATECALL`.


=== EIP-2315 ===
TITLE: Simple Subroutines for the EVM
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-10-17
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0

SUMMARY:
This proposal provides a _complete_, _efficient_, _safe_ and _static_ control-flow facility. It introduces two new opcodes to support calling and returning from subroutines: * `RJUMPSUB relative_offset` -- relative jump to subroutine * `RETURNSUB` -- return to `PC` after most recent `RJUMPSUB`. It depends on the two new opcodes proposed

SPECIFICATION:
### Opcodes #### `RJUMPSUB (0x5f) relative_offset` Transfers control to a subroutine. 1. Decode the `relative_offset` from the immediate data at `PC`. 2. Push the current `PC + 3` to the `return stack`. 3. Set `PC` to `PC + relative_offset`. The `relative_offset` is relative to the current `PC`. The offset

MOTIVATION:
### A complete control-flow facility. Jumps, conditional jumps and subroutines were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine: > We wish to be able to arrange that sequences

RATIONALE:
This is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data – a subroutine is not a contiguous sequence of bytecode, it is a subgraph of the bytecode's control-flow graph. The EVM is a simple state


=== EIP-3436 ===
TITLE: Expanded Clique Block Choice Rule
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-25
REQUIRES: 225

SUMMARY:
The current specification of Clique allows for multiple competing blocks from producers but does not provide any strategies to pick blocks aside from the current "highest total difficulty" rule. This EIP proposes a four step choice rule of highest total difficulty, shortest chain, most recently in-turn, and lowest hash.

SPECIFICATION:
When a Clique validator is arbitrating the canonical status between two different chain head blocks, they should choose the canonical block with the following ordered priorities. 1. Choose the block with the most total difficulty. 2. Then choose the block with the lowest block number. 3. Then choose the

MOTIVATION:
There has been more than one deadlock in the Goerli multi-client Clique network. The number of active validators was greater than 1/2 of the available validators so a chain halt should not have occurred. The halt was resolved by an inactive validator coming back on line. The state of

RATIONALE:
Two scenarios of a halted chain are known based on the current total difficulty then first observed rule. One of the scenarios is also resistant to the shortest chain rule. For the first scenario where chains of different lengths can halt consider a block with 8 validators, whose addresses


=== EIP-5345 ===
TITLE: Silent Signing Extension for JSON-RPC
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-07-26
REQUIRES: 

SUMMARY:
Mobile applications supporting lots of transactions might become a source of bad user experience due to uncontrolled switching between the wallet's and application's UI. By this proposal, we would like to introduce the means to sign and send wallet transactions without the need for user participation. This feature can

SPECIFICATION:
To remedy the situation, we'd like to introduce new RPC methods for the ethereum JSON-RPC. Those methods help enable wallets to implement the Silent Signing feature. ### Silent Signing User Flow The Silent Signing process has the following structure: 1. First, the application requests the wallet to use Silent

MOTIVATION:
Some blockchain applications interact with a blockchain much more frequently than others. It is especially true for gaming applications having their own sidechains. Interrupting the gaming process and switching to the wallet to perform a transaction drastically affect the user experience.

RATIONALE:
Games and Metaverse applications imply lots of cases when the user interacts with the wallet, switching to it and approving transactions. This switching aspect might interfere with gaming per se and create a bad user experience. That is why such applications can benefit if the wallets can support the


=== EIP-6690 ===
TITLE: EVM Modular Arithmetic Extensions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-03-15
REQUIRES: 

SUMMARY:
This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1

SPECIFICATION:
### Constants | Name | Value | Description | | ---- | ---- | ---- | | `COST_SETMODX_BASE` | 1 | static cost component for the `SETMODX` opcode | | `COST_STOREX_BASE` | 1 | static cost for the `STOREX` opcode | | `COST_LOADX_BASE` | 1 | static cost for

MOTIVATION:
Current opcodes for modular arithmetic only support values up to 256 bits wide. In addition, they are permissive and accept any representable value for the inputs. Many cryptographic operations are heavily-bottlenecked by modular arithmetic. To expand the range of cryptographic primitives that can be implemented efficiently as EVM contracts,

RATIONALE:
### Separation of EVM Memory and EVMMAX Virtual Register Space It is assumed that optimized implementations will not store values in EVM-compatible big-endian serialization format, but instead convert them to an internal working representation. The costs in the spec explicitly reflect the choice of Montgomery form as an optimal


=== EIP-3554 ===
TITLE: Difficulty Bomb Delay to December 2021
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-05-06
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9,700,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 9_700_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
Targeting for the Shanghai upgrade and/or the Merge to occur before December 2021. Either the bomb can be readjusted at that time, or removed all together.

RATIONALE:
The following script predicts a .1 second delay to blocktime the first week of december and a 1 second delay by the end of the month. This gives reason to address because the effect will be seen, but not so much urgency we don't have space to work around


=== EIP-7862 ===
TITLE: Delayed State Root
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-23
REQUIRES: 

SUMMARY:
This proposal introduces a mechanism to decouple state root computation from block validation by deferring the execution layer's state root reference by one block. Each block's `ExecutionPayload` contains the post-state root of the previous block rather than its own, enabling validators to attest to a block's validity without waiting

SPECIFICATION:
### Header Changes The block header structure is modified to support delayed state root computation: ```python @dataclass class Header: # Existing fields parent_hash: Hash32 ommers_hash: Hash32 coinbase: Address # Delayed state root - references the post-state of block (n-1) state_root: Root # Now points to parent block's post-state #

MOTIVATION:
The primary advantage of this proposal is **asynchronous state root computation**. In the current Ethereum protocol, blocks must compute and include their own post-state root before validators can attest to them. This requirement creates a bottleneck for block production, as the expensive state root computation must complete within critical

RATIONALE:
### Latency Reduction The separation of state root computation from block validation removes the primary latency bottleneck in block production and validation. Proposers and builders no longer need to compute the state root within the same slot, enabling faster block building and validation. This latency reduction is particularly important


=== EIP-155 ===
TITLE: Simple replay attack protection
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-14
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM` and `CHAIN_ID` is available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements `(nonce, gasprice, startgas, to, value, data)`, you **SHOULD** hash nine rlp encoded elements `(nonce, gasprice, startgas, to, value, data, chainid,

RATIONALE:
This would provide a way to send transactions that work on Ethereum without working on ETC or the Morden testnet. ETC is encouraged to adopt this EIP but replacing `CHAIN_ID` with a different value, and all future testnets, consortium chains and alt-etherea are encouraged to adopt this EIP replacing


=== EIP-3074 ===
TITLE: AUTH and AUTHCALL opcodes
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-10-15
REQUIRES: 155

SUMMARY:
This EIP introduces two EVM instructions `AUTH` and `AUTHCALL`. The first sets a context variable `authorized` based on an ECDSA signature. The second sends a call as the `authorized` account. This essentially delegates control of the externally owned account (EOA) to a smart contract.

SPECIFICATION:
### Conventions - **`top - N`** - the `N`th most recently pushed value on the EVM stack, where `top - 0` is the most recent. - **`||`** - byte concatenation operator. - **invalid execution** - execution that is invalid and must exit the current execution frame immediately, consuming all

MOTIVATION:
Adding more functionality to EOAs has been a long-standing feature request. The requests have spanned from implementing batching capabilities, allowing for gas sponsoring, expirations, scripting, and beyond. These changes often mean increased complexity and rigidity of the protocol. In some cases, it also means increased attack surfaces. This EIP

RATIONALE:
### Signature in Memory The signature format (`yParity`, `r`, and `s`) is fixed, so it might seem curious that `auth` accepts a dynamic memory range. The signature is placed in memory so that `auth` can be upgraded in the future to work with contract accounts (which might use non-ECDSA


=== EIP-2200 ===
TITLE: Structured Definitions for Net Gas Metering
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-07-18
REQUIRES: 

SUMMARY:
This EIP provides a structured definition of net gas metering changes for `SSTORE` opcode, enabling new usages for contract storage, and reducing excessive gas costs where it doesn’t match how most implementation works. This is a combination of [EIP-1283] and [EIP-1706].

SPECIFICATION:
Define variables `SLOAD_GAS`, `SSTORE_SET_GAS`, `SSTORE_RESET_GAS` and `SSTORE_CLEARS_SCHEDULE`. The old and new values for those variables are: * `SLOAD_GAS`: changed from `200` to `800`. * `SSTORE_SET_GAS`: `20000`, not changed. * `SSTORE_RESET_GAS`: `5000`, not changed. * `SSTORE_CLEARS_SCHEDULE`: `15000`, not changed. Change the definition of EIP-1283 using those variables. The new specification,

MOTIVATION:
This EIP proposes a way for gas metering on `SSTORE`, using information that is more universally available to most implementations, and require as little change in implementation structures as possible. * Storage slot’s original value. * Storage slot’s current value. * Refund counter. Usages that benefits from this EIP’s

RATIONALE:
This EIP mostly achieves what a transient storage tries to do ([EIP-1087] and [EIP-1153]), but without the complexity of introducing the concept of "dirty maps", or an extra storage struct. * We don't suffer from the optimization limitation of EIP-1087. EIP-1087 requires keeping a dirty map for storage changes,


=== EIP-4399 ===
TITLE: Supplant DIFFICULTY opcode with PREVRANDAO
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-10-30
REQUIRES: 3675

SUMMARY:
This EIP supplants the semantics of the return value of existing `DIFFICULTY (0x44)` opcode and renames the opcode to `PREVRANDAO (0x44)`. The return value of the `DIFFICULTY (0x44)` instruction after this change is the output of the randomness beacon provided by the beacon chain.

SPECIFICATION:
### Definitions * **`TRANSITION_BLOCK`** The definition of this block can be found in the Definitions section of [EIP-3675](./eip-3675.md#definitions). ### Block structure Beginning with `TRANSITION_BLOCK`, client software **MUST** set the value of the `mixHash`, i.e. the field with the number `13` (0-indexed) in a block header, to the latest RANDAO

MOTIVATION:
Applications may benefit from using the randomness accumulated by the beacon chain. Thus, randomness outputs produced by the beacon chain should be accessible in the EVM. At the point of `TRANSITION_BLOCK` of the Proof-of-Stake (PoS) upgrade described in [EIP-3675](./eip-3675.md), the `difficulty` block field **MUST** be `0` thereafter because there

RATIONALE:
### Including RANDAO output in the block header Including a RANDAO output in the block header provides a straightforward method of accessing it from inside of the EVM as block header data is already available in the EVM context. Additionally, this ensures that the execution layer can be fully


=== EIP-1011 ===
TITLE: Hybrid Casper FFG
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-20
REQUIRES: 

SUMMARY:
This EIP specifies a hybrid PoW/PoS consensus model for Ethereum main net. Existing PoW mechanics are used for new block creation, and a novel PoS mechanism called Casper the Friendly Finality Gadget (FFG) is layered on top using a smart contract. Through the use of Ether deposits, slashing conditions,

SPECIFICATION:
#### Deploying Casper Contract If `block.number == HYBRID_CASPER_FORK_BLKNUM`, then when processing the block before processing any transactions: * set the code of `MSG_HASHER_ADDR` to `MSG_HASHER_CODE` * set the code of `PURITY_CHECKER_ADDR` to `PURITY_CHECKER_CODE` * set the code of `CASPER_ADDR` to `CASPER_CODE` * set balance of `CASPER_ADDR` to `CASPER_BALANCE` Then

MOTIVATION:
Transitioning the Ethereum network from PoW to PoS has been on the roadmap and in the [Yellow Paper](https://github.com/ethereum/yellowpaper) since the launch of the protocol. Although effective in coming to a decentralized consensus, PoW consumes an incredible amount of energy, has no economic finality, and has no effective strategy in

RATIONALE:
Naive PoS specifications and implementations have existed since early blockchain days, but most are vulnerable to serious attacks and do not hold up under crypto-economic analysis. Casper FFG solves problems such as "Nothing at Stake" and "Long Range Attacks" through requiring validators to post slashable deposits and through defining


=== EIP-2028 ===
TITLE: Transaction data gas cost reduction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-05-03
REQUIRES: 

SPECIFICATION:
The gas per non-zero byte is reduced from 68 to 16. Gas cost of zero bytes is unchanged.

MOTIVATION:
There are a couple of main benefits to accepting this proposal and lowering gas cost of Calldata On-Chain Scalability: Generally speaking, higher bandwidth of Calldata improves scalability, as more data can fit within a single block. * Layer two scalability: Layer two scaling solutions can improve scalability by moving

RATIONALE:
Roughly speaking, reducing the gas cost of Calldata leads to potentially larger blocks, which increases the network delay associated with data transmission over the network. This is only part of the full network delay, other factors are block processing time (and storage access, as part of it). Increasing network


=== EIP-7825 ===
TITLE: Transaction Gas Limit Cap
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-11-23
REQUIRES: 

SUMMARY:
This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 16,777,216 (2^24) gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the gas

SPECIFICATION:
### Gas Cap - Enforce a protocol-level maximum of **16,777,216 gas (2^24)** for any single transaction. - This cap applies regardless of the block gas limit set by miners or validators. - Transactions specifying gas limits higher than 16,777,216 gas will be rejected with an appropriate error code (e.g.,

MOTIVATION:
Currently, transactions can theoretically consume up to the entire block gas limit, which poses several risks: 1. **DoS Attacks**: A single transaction consuming most or all of the block gas can result in uneven load distribution and impact network stability. 2. **State Bloat Risks**: High-gas transactions often result in

RATIONALE:
### Why 16,777,216 (2^24)? The proposed cap of 16,777,216 gas (2^24) provides a clean power-of-two boundary that simplifies implementation while still being large enough to accommodate most complex transactions, including contract deployments and advanced DeFi interactions. This value represents approximately half of typical block sizes (30-40 million gas), ensuring


=== EIP-6988 ===
TITLE: Elected block proposer has not been slashed
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-05-04
REQUIRES: 

SUMMARY:
Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.

SPECIFICATION:
Specification of the proposed change can be found in [`/_features/eip6988/beacon-chain.md`](https://github.com/ethereum/consensus-specs/blob/0ad3972725e7c22e8edf3bab2dd7730acbe3c272/specs/_features/eip6988/beacon-chain.md).

MOTIVATION:
A block proposed by a slashed validator is rejected by the corresponding validity check in the [`phase0/process_block_header`](https://github.com/ethereum/consensus-specs/blob/3115d1140b23dd4c9c23fbd9e2428186cf816bde/specs/phase0/beacon-chain.md#block-header) function as defined in the consensus layer specification. At the same time the definition of the [`phase0/compute_proposer_index`](https://github.com/ethereum/consensus-specs/blob/3115d1140b23dd4c9c23fbd9e2428186cf816bde/specs/phase0/beacon-chain.md#compute_proposer_index) allows for a slashed validator to be elected as a proposer. This contradiction effectively leads

RATIONALE:
### Modifying `get_beacon_proposer_index` This function is modified to read a proposer index from a beacon state if a slot of a latest block header is the same as the `state.slot`. This modification is done to make the function return correct proposer index in the case when the proposer of


=== EIP-7951 ===
TITLE: Precompile for secp256r1 Curve Support
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-05-27
REQUIRES: 

SUMMARY:
Add functionality to efficiently perform ECDSA signature verification over the secp256r1 elliptic curve (also known as P-256 or prime256v1). This precompile enables native support for signatures generated by modern secure hardware including Apple Secure Enclave, Android Keystore, and FIDO2/WebAuthn devices. This specification addresses critical security issues discovered in RIP-7212

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Precompile We introduce `P256VERIFY` a precompile at the address `0x100` which performs ECDSA signature

MOTIVATION:
The secp256r1 elliptic curve is a NIST-standardized curve widely supported in modern secure hardware and authentication systems. Adding native support for secp256r1 signature verification to Ethereum enables several important use cases that are currently impossible or prohibitively expensive. Modern secure hardware devices, including Apple Secure Enclave, Android Keystore, HSMs,

RATIONALE:
### Security Fixes This specification addresses two critical vulnerabilities in RIP-7212: 1. **Point-at-infinity check**: The original RIP-7212 failed to check if the recovered point R' is the point at infinity. This could lead to non-deterministic behavior where the verification result depends on the underlying implementation's handling of infinity points,


=== EIP-1234 ===
TITLE: Constantinople Difficulty Bomb Delay and Block Reward Adjustment
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-07-19
REQUIRES: 

SUMMARY:
Starting with `CNSTNTNPL_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 5 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 5_000_000) if block.number >= CNSTNTNPL_FORK_BLKNUM else block.number #### Adjust Block, Uncle, and Nephew rewards To

MOTIVATION:
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another 12 months. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards.

RATIONALE:
This will delay the ice age by 29 million seconds (approximately 12 months), so the chain would be back at 30 second block times in winter 2019. An alternate proposal was to add special rules to the difficulty calculation to effectively _pause_ the difficulty between different blocks. This would


=== EIP-1901 ===
TITLE: Add OpenRPC Service Discovery To JSON-RPC Services
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-02-25
REQUIRES: 

SUMMARY:
### What is this? This is a proposal to add [OpenRPC](https://github.com/open-rpc/spec) support to existing and future JSON-RPC services by adding the method [`rpc.discover`](https://github.com/open-rpc/spec#service-discovery-method) to the projects [JSON-RPC](https://www.jsonrpc.org/specification) APIs, enabling automation and tooling. The OpenRPC Document and generated Documentation that specifies all the methods an EVM-based blockchain should implement can

SPECIFICATION:
### What is OpenRPC? The [OpenRPC](https://github.com/open-rpc/spec) Specification defines a standard, programming language-agnostic interface description for [JSON-RPC 2.0](https://www.jsonrpc.org/specification) APIs, which allows both humans and computers to discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic. When properly defined

MOTIVATION:
Although [EIP-1474](./eip-1474.md) outlines a JSON-RPC specification. Ethereum still lacks a machine-readable JSON-RPC Specification that can be used as the industry standard for tooling. This proposal attempts to standardize such a specification in a way that is versionable, and both human and machine readable. Ethereum clients can expose RPC endpoints

RATIONALE:
### Why would we do this? Services need to figure out how to talk to each other. If we really want to build the next generation of automation, then having up to date libraries, documented APIs, and modern tools are going to provide easy discovery, on-boarding, and enable end


=== EIP-7657 ===
TITLE: Sync committee slashings
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-21
REQUIRES: 

SUMMARY:
This EIP defines a slashing condition for malicious [sync committee messages](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/altair/validator.md#containers).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### State transition checks Note: This still allows having contradictions between attestations/proposals and sync committee

MOTIVATION:
A dishonest supermajority of sync committee members is able to convince applications relying on Ethereum's [light client sync protocol](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/specs/altair/light-client/sync-protocol.md) to assume a non-canonical finalized header, and to potentially take over the sync authority for future `SyncCommitteePeriod`. By signing a malicious beacon block root, a malicious (but valid!) `LightClientUpdate` message

RATIONALE:
### What's the use case? Without a slashing, the light client sync protocol is somewhat limited. While wallet applications may benefit from it (the risk being, that incorrect data is displayed) and new beacon nodes may use it for accelerating chain synchronization, other interesting use cases such as bridges,


=== EIP-6110 ===
TITLE: Supply validator deposits on chain
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-12-09
REQUIRES: 7685

SUMMARY:
Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (or `eth1data`) voting from the Consensus Layer. Validator deposits list supplied in a block is obtained by parsing deposit contract log events

SPECIFICATION:
### Execution Layer #### Constants | Name | Value | Comment | | - | - | - | |`DEPOSIT_REQUEST_TYPE` | `b'0'` | The [EIP-7685](./eip-7685.md) request type byte for deposit operation | #### Configuration | Name | Value | Comment | | - | - | - | |`DEPOSIT_CONTRACT_ADDRESS`

MOTIVATION:
Validator deposits are a core component of the proof-of-stake consensus mechanism. This EIP allows for an in-protocol mechanism of deposit processing on the Consensus Layer and eliminates the proposer voting mechanism utilized currently. This proposed mechanism relaxes safety assumptions and reduces complexity of client software design, contributing to the

RATIONALE:
### `index` field Deposit `index` is used to deterministically initialize `deposit_requests_start_index` in the `BeaconState`, this prevents same deposit from being applied twice during `Eth1Data` poll deprecation. ### Not limiting the size of deposit operations list The list is unbounded because of negligible data complexity and absence of potential DoS


=== EIP-7997 ===
TITLE: Deterministic Factory Predeploy
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-03
REQUIRES: 2, 1, 1, ,,  , 1, 0, 1, 4

SUMMARY:
A minimal `CREATE2` factory is inserted as a system contract in the precompile range, to enable deterministic deployments at identical addresses across EVM chains. This benefits developer experience, user experience, and security, in particular for multi-chain and cross-chain applications, including account abstraction.

SPECIFICATION:
### Parameters * `FACTORY_ADDRESS` = `0x12` ### Factory Contract Upon activation of this EIP, the account at `FACTORY_ADDRESS` becomes a contract that, when called, invokes the `CREATE2` instruction ([EIP-1014](./eip-1014.md)) with a salt equal to the first 32 bytes of the call's input data, init code equal to the remaining

MOTIVATION:
There are now a large number of EVM chains where users want to transact and developers want to deploy applications, and we can expect this number to continue to grow in line with Ethereum's rollup-centric roadmap and the general adoption of programmable blockchains. Most applications support multiple chains and

RATIONALE:
### Precompile-range system contract Unlike previous system contracts, this factory cannot be deployed using a normal transaction because, as explained in the Motivation section, that transaction could not be guaranteed to be valid on other chains. Since the purpose of this factory is to be available in all EVM


=== EIP-4881 ===
TITLE: Deposit Contract Snapshot Interface
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2021-01-29
REQUIRES: 

SUMMARY:
This EIP defines a standard format for transmitting the deposit contract Merkle tree in a compressed form during weak subjectivity sync. This allows newly syncing consensus clients to reconstruct the deposit tree much faster than downloading all historical deposits. The format proposed also allows clients to prune deposits that

SPECIFICATION:
Consensus clients MAY continue to implement the deposit Merkle tree however they choose. However, when transmitting the tree to newly syncing nodes, clients MUST use the following format: ```python class DepositTreeSnapshot: finalized: List[Hash32, DEPOSIT_CONTRACT_DEPTH] deposit_root: Hash32 deposit_count: uint64 execution_block_hash: Hash32 execution_block_height: uint64 ``` Where `finalized` is a variable-length list

MOTIVATION:
To reconstruct the deposit Merkle tree, most client implementations require beacon nodes to download and store every deposit log since the launch of the deposit contract. However, this approach requires beacon nodes to store far more deposits than necessary to participate in consensus. Additionally, this leads to increased sync

RATIONALE:
The format in this specification was chosen to achieve several goals simultaneously: 1. Enable reconstruction of the deposit contract Merkle tree without requiring full nodes to store all historical contract logs 2. Avoid requiring consensus nodes to retain more deposits than necessary to fully participate in consensus 3. Simplicity


=== EIP-7643 ===
TITLE: History accumulator for pre-PoS data
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-02-29
REQUIRES: 

SUMMARY:
Defines an SSZ object for accumulating all pre-PoS data and commit to the historical hashes accumulator's root `0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701`.

SPECIFICATION:
### Historical Hashes Accumulator The historical hashes accumulator commits to the set of pre-merge headers and their associated total difficulty. The format for this data is defined as: ```python EPOCH_SIZE = 8192 # blocks MAX_HISTORICAL_EPOCHS = 2048 # An individual record for a historical header. HeaderRecord = Container[block_hash: bytes32,

MOTIVATION:
There are two main uses we consider for the historical hashes accumulator: * for users who wish to download the pre-PoS data for the execution chain and verify it without executing each block, they may simply compute each block hash, accumulate the epoch records, and then compare the local

RATIONALE:
### Inclusion of total difficulty The total difficulty allowed so that clients may return the value for specific JSON-RPC methods which support it. It is also useful for verifying the TTD of the final proof-of-work block.


=== EIP-608 ===
TITLE: Hardfork Meta: Tangerine Whistle
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 5, 0, ,,  , 7, 7, 9

SUMMARY:
This specifies the changes included in the hard fork named Tangerine Whistle (EIP 150).

SPECIFICATION:
- Codename: Tangerine Whistle - Aliases: EIP 150, Anti-DoS - Activation: - Block >= 2,463,000 on Mainnet - Included EIPs: - [EIP-150](./eip-150.md) (Gas cost changes for IO-heavy operations)


=== EIP-1352 ===
TITLE: Specify restricted address range for precompiles/system contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-27
REQUIRES: 

SUMMARY:
The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts.

SPECIFICATION:
The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts. Due to the extremely low probability (and lack of adequate testing possibilities) no explicit checks should be added to ensure that external transaction signing or the invoking of the `CREATE` instruction can result in a

MOTIVATION:
This will simplify certain future features where unless this is implemented, several exceptions must be specified.

RATIONALE:
N/A


=== EIP-7917 ===
TITLE: Deterministic proposer lookahead
TYPE: Standards Track Core
STATUS: Final
CREATED: 2025-03-24
REQUIRES: 

SUMMARY:
At the start of each epoch, pre-calculate and store in the `beacon_state` a deterministic `proposer_lookahead` for the next `MIN_SEED_LOOKAHEAD + 1` epochs.

SPECIFICATION:
The `BeaconState` container is extended with a `proposer_lookahead` field, which is a vector of validator indices covering the full visible lookahead period, starting from the beginning of the current epoch to the next `MIN_SEED_LOOKAHEAD` epochs. ```python class BeaconState: ... proposer_lookahead: Vector[ValidatorIndex, (MIN_SEED_LOOKAHEAD + 1) * SLOTS_PER_EPOCH] ``` For example,

MOTIVATION:
Unlike RANDAO seeds, which have a deterministic lookahead of at least `MIN_SEED_LOOKAHEAD == 1` epochs, the beacon proposer schedule of epoch `N + 1` is not fully predictable from the beacon state during epoch `N`. The reason is that, under certain edge cases, the effective balances (EBs) of active

RATIONALE:
### Considered Alternatives An alternative approach would be to cache the effective balances at the start of epoch `N` so it can be used to calculate the proposer lookahead at the start of epoch `N+MIN_SEED_LOOKAHEAD`. However, this approach would require additional footprint in the beacon state, and would not


=== EIP-7898 ===
TITLE: Uncouple execution payload from beacon block
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-01
REQUIRES: 

SUMMARY:
Currently, the beacon block in Ethereum Consensus embeds transactions within the `ExecutionPayload` field of `BeaconBlockBody`. This EIP proposes to replace `ExecutionPayload` with `ExecutionPayloadHeader` in `BeaconBlockBody` and to independently transmit `ExecutionPayloadWithInclusionProof`. However, this EIP makes no change to the block import mechanism, with the exception that block availability now includes

SPECIFICATION:
- `ExecutionPayload` in the `BeaconBlockBody` is replaced by `ExecutionPayloadHeader` - `ExecutionPayloadWithInclusionProof` is computed by the block proposer/builder and gossiped independently on a separate new topic. Also builder `submitBlindedBlock` api is modified to respond with `ExecutionPayloadWithInclusionProof` instead. - Data availability checks for block import into forkchoice now must wait for

MOTIVATION:
The Ethereum protocol has an ambitious goal to grow the `gasLimit` of the execution payloads (possibly by 10X). This leads to larger messages, negatively affecting the networking and block processing pipelines of the consensus layer (CL) clients leading to following issues: 1. Higher latencies for the arrival of beacon

RATIONALE:
There is another choice we could have made to go for `SignedExecutionPayload` instead of `ExecutionPayloadWithInclusionProof` and having a `SignedExecutionPayloadHeader` with builder signing these messages (validator is the builder in local block building). But without builder enshrinement tight gossip validation of `SignedExecutionPayload` would be an issue and could become a


=== EIP-7880 ===
TITLE: EOF - EXTCODEADDRESS instruction
TYPE: Standards Track Core
STATUS: Review
CREATED: 2025-02-08
REQUIRES: 7, 6, 9, 2, ,,  , 7, 7, 0, 2, ,,  , 7, 7, 6, 1

SUMMARY:
Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.

SPECIFICATION:
### Parameters | Constant | Value | |---------------------------|--------------------------------------------------------------------| | `GAS_COLD_ACCOUNT_ACCESS` | Defined as `2600` in the [Ethereum Execution Layer Spec Constants] | | `GAS_WARM_ACCESS` | Defined as `100` in the [Ethereum Execution Layer Spec Constants] | We introduce a new EOFv1 instruction `EXTCODEADDRESS` (`0xea`). EOF code which contains this

MOTIVATION:
EOFv1 as scoped in [EIP-7692] removes code introspection capabilities from the EVM, preventing EOF from reading raw code values such as code delegation designations set by [EIP-7702]. There are a number of use cases where reading the delegation designation of [EIP-7702] would allow contracts to be more proactive about

RATIONALE:
This EIP is very similar to [EIP-7761], which introduces account type introspection. Its rationale is included by reference as they all apply to this situation. ### Alternative: Return the whole designation, have contract parse One alternative is to have a specially limited `EXTCODECOPY` that would return just delegation designations.


=== EIP-7848 ===
TITLE: On-chain upgrade signaling
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-22
REQUIRES: 

SUMMARY:
This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a “reference implementation hash” field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.

SPECIFICATION:
Ethereum consensus clients shall identify with a reference implementation having its equivalent behaviors. Ethereum consensus clients shall include a `referenceImplementationHash` (specified below) field immediately following the `extraData` field in the block header. Proposed new Ethereum consensus clients shall initially behave as the then-current network does. If, and only if,

MOTIVATION:
Currently, upgrades to Ethereum Mainnet are announced on the ethereum.org blog. This proposal changes that process by activating upgrades based on the consent of network participants.

RATIONALE:
### Forking is no Longer Possible Since the merge, forking Ethereum Mainnet has become practically impossible. Validators stake valuable assets to participate in the network, so any rational validator will choose to upgrade only if they expect widespread adoption. If a validator expects 95% or more participants to upgrade,


=== EIP-4444 ===
TITLE: Bound Historical Data in Execution Clients
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2021-11-02
REQUIRES: 

SUMMARY:
Clients must stop serving historical headers, bodies, and receipts older than one year on the p2p layer. Clients may locally prune this historical data.

SPECIFICATION:
| Parameter | Value | Description | | - | - | - | | `HISTORY_PRUNE_EPOCHS` | 82125 | A year in beacon chain epochs | Clients SHOULD NOT serve headers, block bodies, and receipts that are older than `HISTORY_PRUNE_EPOCHS` epochs on the p2p network. Clients MAY locally prune

MOTIVATION:
Historical blocks and receipts currently occupy more than 400GB of disk space (and growing!). Therefore, to validate the chain, users must typically have a 1TB disk. Historical data is not necessary for validating new blocks, so once a client has synced the tip of the chain, historical data is

RATIONALE:
This proposal forces clients to stop serving old historical data over p2p. We make this explicit to force clients to seek historical data from other sources, instead of relying on the optional behavior of some clients which would result in quality degradation. ### Why a year? This proposal sets


=== EIP-8081 ===
TITLE: Hardfork Meta - Hegotá
TYPE: Meta 
STATUS: Draft
CREATED: 2025-11-11
REQUIRES: 7, 7, 2, 3, ,,  , 7, 7, 7, 3

SUMMARY:
This Meta EIP lists the EIPs formally Proposed, Considered, Declined for & Scheduled for Inclusion in the Hegotá network upgrade.

SPECIFICATION:
Definitions for `Scheduled for Inclusion`, `Considered for Inclusion`, `Declined for Inclusion` and `Proposed for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion ### Considered for Inclusion * [EIP-7805](./eip-7805.md): Fork-choice enforced Inclusion Lists (FOCIL) ### Declined for Inclusion ### Proposed for Inclusion ### Activation | Network Name

RATIONALE:
This Meta EIP provides a global view of all changes included in the network upgrade, as well as links to full specification.


=== EIP-7736 ===
TITLE: Leaf-level state expiry in verkle trees
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-07-05
REQUIRES: 6800

SUMMARY:
Adds an "update epoch" to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted. A new transaction type with a simple verkle proof pays for the costs of reactivating the extension and suffix nodes,

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants |Name|Description|Value| |----|-----------|-----| |`FORK_TIME`|Fork activation time|TBD| |`EPOCH_LENGTH`|Duration of an epoch, in s|15778800 (6 months)|

MOTIVATION:
Previous attempts at implementing state expiry have been stalled by the quickly-increasing complexity, require heavy change in the structure of ethereum (address space extension, oil, multiple trees, ...). This proposal is offering a simpler albeit non-exhaustive approach to state expiry: only removing the leaf nodes and leaving the rest

RATIONALE:
This approach has the benefit of simplicity, over previous proposals for state expiry: * no Address Space Extension (ASE) required * it only uses a single tree instead of multiple, per-epoch trees * smaller resurrection proofs, as only providing the data is necessary to resurrect. * clear gas costs


=== EIP-7692 ===
TITLE: EVM Object Format (EOFv1) Meta
TYPE: Meta 
STATUS: Stagnant
CREATED: 2024-04-17
REQUIRES: 6, 6, 3, ,,  , 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 4, 7, 5, 0, ,,  , 5, 4, 5, 0, ,,  , 6, 2, 0, 6, ,,  , 7, 0, 6, 9, ,,  , 7, 4, 8, 0, ,,  , 7, 6, 2, 0, ,,  , 7, 6, 9, 8

SUMMARY:
This Meta EIP lists the EIPs which belong to the EVM Object Format (EOF) proposal, in its first version (EOFv1), also known as the "Mega EOF".

SPECIFICATION:
### EIPs Included Introduced in eof-devnet-0 - [EIP-3540](./eip-3540.md): EOF - EVM Object Format v1 - [EIP-3670](./eip-3670.md): EOF - Code Validation - [EIP-4200](./eip-4200.md): EOF - Static relative jumps - [EIP-4750](./eip-4750.md): EOF - Functions - [EIP-5450](./eip-5450.md): EOF - Stack Validation - [EIP-6206](./eip-6206.md): EOF - JUMPF and non-returning functions - [EIP-7480](./eip-7480.md): EOF

RATIONALE:
Refer to the individual EIPs.


=== EIP-8030 ===
TITLE: P256 algorithm support
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-09-20
REQUIRES: 7932

SUMMARY:
This EIP adds a new [EIP-7932](./eip-7932.md) algorithm of type `0x0` for supporting P256 signatures.

SPECIFICATION:
This EIP defines a new [EIP-7932](./eip-7932.md) algorithmic type with the following parameters: | Constant | Value | | - | - | | `ALG_TYPE` | `Bytes1(0x0)` | | `SIZE`| `129` | ```python N = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 def gas_cost(signing_data: Bytes) -> Uint64: # This is the precompile cost from [EIP-7951](./eip-7951.md) with

MOTIVATION:
P256 (a.k.a secp256r1) is a widely-used NIST standardized algorithm that already has a presence within the Ethereum codebase. This makes it a great algorithm to write test cases against implementations of [EIP-7932](./eip-7932.md).

RATIONALE:
### Why P256? P256 or secp256r1, is used globally but (more importantly) has an existing implementation in all execution clients. This allows easy implementation of a known-safe algorithm, which is perfect for a test algorithm.


=== EIP-7594 ===
TITLE: PeerDAS - Peer Data Availability Sampling
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-01-12
REQUIRES: 4844

SUMMARY:
PeerDAS (Peer Data Availability Sampling) is a networking protocol that allows nodes to perform data availability sampling (DAS) to ensure that blob data has been made available while downloading only a subset of the data. PeerDAS utilizes gossip for distribution, discovery for finding peers of particular data custody, and

SPECIFICATION:
We extend the blobs introduced in EIP-4844 using a one-dimensional erasure coding extension. Each row consists of the blob data combined with its erasure code. It is subdivided into cells, which are the smallest units that can be authenticated with their respective blob's KZG commitments. Each column, associated with

MOTIVATION:
DAS is a method of scaling data availability beyond the levels of [EIP-4844](./eip-4844.md) by not requiring all nodes to download all data while still ensuring that all of the data has been made available. Providing additional data availability helps bring scale to Ethereum users in the context of layer

RATIONALE:
### Why use DAS to scale the DA layer? PeerDAS is a DAS scheme that requires nodes to only download a small constant fraction of the data to satisfy a local availability check. With the current parameters, this is 1/8 of the total data (i.e. blobs in a block),


=== EIP-7523 ===
TITLE: Empty accounts deprecation
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2023-09-19
REQUIRES: 161

SUMMARY:
This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. An empty account is an account with has **no code** and **zero nonce** and **zero

MOTIVATION:
The possibility of empty accounts is a historical artifact of the early history of Ethereum. The only networks that have ever been capable of containing them are Ethereum Mainnet, the deprecated testnet Ropsten, Etheruem Classic Mainnet and various Ethereum Classic testnets. All remaining empty accounts on Mainnet were cleared

RATIONALE:
This EIP was drafted to be the simplest possible way of eliminating the long term technical debt imposed by empty accounts. The Merge was chosen as a natural easily identifiable cutoff point. Alternative approaches include: - Using an earlier cutoff point, such as block `14049881`. - Identifying a wider


=== EIP-1380 ===
TITLE: Reduced gas cost for call to self
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-31
REQUIRES: 150

SUMMARY:
Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then decrease the cost of `CALL`, `DELEGATECALL`, `CALLCODE` and `STATICCALL` from 700 to 40, if and only if, the destination address of the call equals to the address of the caller.

MOTIVATION:
The current gas cost of 700 for all call types (`CALL`, `DELEGATECALL`, `CALLCODE` and `STATICCALL`) does not take into account that a call to a contract itself does not need to perform additional I/O operations, because the current contract code has already been loaded into memory. Reducing the call-to-self

RATIONALE:
EIP150 has increased the cost of these instructions from 40 to 700 to more fairly charge for loading new contracts from disk, e.g. to reflect the I/O charge more closely. By assuming that 660 is the cost of loading a contract from disk, one can assume that the original


=== EIP-4844 ===
TITLE: Shard Blob Transactions
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-02-25
REQUIRES: 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 9, 5

SUMMARY:
Introduce a new transaction format for "blob-carrying transactions" which contain a large amount of data that cannot be accessed by EVM execution, but whose commitment can be accessed. The format is intended to be fully compatible with the format that will be used in full sharding.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `BLOB_TX_TYPE` | `Bytes1(0x03)` | | `BYTES_PER_FIELD_ELEMENT` | `32` | | `FIELD_ELEMENTS_PER_BLOB` | `4096` | | `BLS_MODULUS` | `52435875175126190479447740508185965837690552500527637822603658699938581184513` | | `VERSIONED_HASH_VERSION_KZG` | `Bytes1(0x01)` | | `POINT_EVALUATION_PRECOMPILE_ADDRESS` | `Bytes20(0x0A)` | | `POINT_EVALUATION_PRECOMPILE_GAS` | `50000` | | `MAX_BLOB_GAS_PER_BLOCK`

MOTIVATION:
Rollups are in the short and medium term, and possibly in the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups

RATIONALE:
### On the path to sharding This EIP introduces blob transactions in the same format in which they are expected to exist in the final sharding specification. This provides a temporary but significant scaling relief for rollups by allowing them to initially scale to 0.375 MB per slot, with


=== EIP-1474 ===
TITLE: Remote procedure call specification
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-10-02
REQUIRES: 

SUMMARY:
Nodes created by the current generation of Ethereum clients expose inconsistent and incompatible remote procedure call (RPC) methods because no formal Ethereum RPC specification exists. This proposal standardizes such a specification to provide developers with a predictable Ethereum RPC interface regardless of underlying node implementation.

SPECIFICATION:
### Concepts #### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). #### JSON-RPC Communication with Ethereum nodes is accomplished using [JSON-RPC](https://www.jsonrpc.org/specification), a stateless, lightweight [remote procedure call](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol

RATIONALE:
Much of Ethereum's effectiveness as an enterprise-grade application platform depends on its ability to provide a reliable and predictable developer experience. Nodes created by the current generation of Ethereum clients expose RPC endpoints with differing method signatures; this forces applications to work around method inconsistencies to maintain compatibility with


=== EIP-7667 ===
TITLE: Raise gas costs of hash functions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Raise the gas costs of opcodes and precompiles that involve hash functions.

SPECIFICATION:
| Parameter | Previous value | New value | | - | - | - | | `KECCAK_BASE_COST` | 30 | 300 | | `KECCAK_WORD_COST` | 6 | 60 | | `SHA256_BASE_COST` | 60 | 300 | | `SHA256_WORD_COST` | 12 | 60 | | `RIPEMD_BASE_COST` | 600 |

MOTIVATION:
Gas costs for hash function opcodes and precompiles were originally set based on the time that it takes to execute them on a regular CPU. Since then, however, there has emerged another equally important execution substrate that the EVM is executed on: zero knowledge proof (ZK-SNARK) systems. By that

RATIONALE:
The above increases the gas costs of all opcodes and precompiles that can be used to require large amounts of hashing in the EVM. All hashing costs are increased to 300 per hash plus 60 per word (or kept the same if they are already higher than this). '"


=== EIP-7782 ===
TITLE: Reduce Block Latency
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-05
REQUIRES: 7, 6, 2, 3, ,,  , 7, 7, 7, 8

SUMMARY:
Reduce Ethereum's slot time from 12 s to 6 s, halving on‑chain latency and epoch duration. This doubles slot throughput while keeping block and blob sizes unchanged, smoothing bandwidth usage. The change delivers better user experience, faster Layer 2 interaction, tighter DEX pricing, reduced MEV, and quicker finality.

SPECIFICATION:
On the consensus layer, a new parameter is added to the configuration: ``` SLOT_SCHEDULE: - EPOCH: 348618 SECONDS_PER_SLOT: 12 - EPOCH: 355368 SECONDS_PER_SLOT: 6 ``` The parameters and schedules above are purely illustrative. Actual values and schedules are beyond the scope of this specification. ### Adjustment to gas and

MOTIVATION:
- **Protocol Carrying Capacity** It is impractical to increase block sizes beyond 10MiB without substantial networking changes. However it is practical to decrease slot time to achieve similar effect while also improving the UX at same time. - **Enhanced UX**: Confirmations now arrive in ~6 s instead of 12

RATIONALE:
This proposal balances user experience, economic efficiency, and network stability: - UX & Finality: Halving slot time directly reduces confirmation latency and halves epoch duration, delivering faster feedback to users and speeding up Casper-FFG finality. - Economic Efficiency: Increased block frequency tightens DEX price spreads, lowers slippage, and diminishes


=== EIP-7045 ===
TITLE: Increase max attestation inclusion slot
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-18
REQUIRES: 

SUMMARY:
Increases max attestation inclusion slot from `attestation.slot + SLOTS_PER_EPOCH` to the last slot of epoch `N+1` where `N` is the epoch containing the attestation slot. This increase is critical to the current LMD-GHOST security analysis as well as the confirmation rule.

SPECIFICATION:
### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | `1710338135` | Mainnet | ### Execution layer This requires no changes to the Execution Layer. ### Consensus layer Specification changes are built into the Consensus Specs Deneb upgrade. The specification makes

MOTIVATION:
Attestations can currently be included after some minimum delay (`1` slot on mainnet) up until `SLOTS_PER_EPOCH` slots after the slot the attestation was created in. This rolling window of one epoch was decided upon during Phase 0 because the equal inclusion window for any attestation was assessed as "fair".

RATIONALE:
### Extended max inclusion slot As discussed in the Motivation, extending this max inclusion slot to the end of the next epoch is critical for LMD-GHOST security proofs and confirmation rule. ### Removal of `inclusion_delay` consideration for target reward Previously, `get_attestation_participation_flag_indices` would only set the `TIMELY_TARGET_FLAG` (and thus reward


=== EIP-2070 ===
TITLE: Hardfork Meta: Berlin
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2019-05-20
REQUIRES: 1679

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Berlin.

SPECIFICATION:
- Codename: Berlin In the current stage of coordination, the changes are tracked and discussed in the [eth1.0-specs](https://github.com/ethereum/eth1.0-specs) repository. For an accurate status please refer to the [`berlin.md`](https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/berlin.md) file.


=== EIP-7607 ===
TITLE: Hardfork Meta - Fusaka
TYPE: Meta 
STATUS: Last Call
CREATED: 2024-02-01
REQUIRES: 7, 6, 0, 0, ,,  , 7, 7, 2, 3

SUMMARY:
This Meta EIP lists the EIPs formally Scheduled for Inclusion in the Fulu/Osaka network upgrade. It follows the Pectra upgrade, documented in [EIP-7600](./eip-7600.md)

SPECIFICATION:
Definitions for `Scheduled for Inclusion`, `Considered for Inclusion`, `Proposed for Inclusion` and `Declined for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion #### Core EIPs * [EIP-7594](./eip-7594.md): PeerDAS - Peer Data Availability Sampling * [EIP-7823](./eip-7823.md): Set upper bounds for MODEXP * [EIP-7825](./eip-7825.md): Transaction Gas Limit Cap

RATIONALE:
This Meta EIP provides a global view of all changes included in the Fusaka network upgrade, as well as links to full specification.


=== EIP-2786 ===
TITLE: Ethereum Provider Connect/Disconnect Events
TYPE: Standards Track Interface
STATUS: Withdrawn
CREATED: 2020-07-15
REQUIRES: 2700

SUMMARY:
The Provider is said to be “connected” when it can service RPC requests to at least one chain. The Provider is said to be “disconnected” when it cannot service RPC requests to any chain at all. When the Provider switches from a "connected" state to a "disconnected" state, it

SPECIFICATION:
### Definitions #### Connected The Provider is considered `connected` when it is able to service RPC requests to at least one chain. #### Disconnected The Provider is considered `disconnected` when it is unable to service RPC requests to any chain. ### Events #### `connect` The Provider **MUST** emit a

MOTIVATION:
When an application is hooked up to an Ethereum provider, there is value in having the application be alerted of connect/disconnect events that may occur so the application can appropriately inform the user of the situation. It is left up to the application to decide whether to listen in

RATIONALE:
This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn’t a lot of room for improving things such as by having a connect/disconnect event per chain.


=== EIP-4736 ===
TITLE: Consensus Layer Withdrawal Protection
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-01-30
REQUIRES: 

SUMMARY:
If a consensus layer mnemonic phrase is compromised, it is impossible for the consensus layer network to differentiate the legitimate holder of the key from an illegitimate holder. However, there are signals that can be considered in a wider sense without changing core Ethereum consensus. This proposal outlines ways

SPECIFICATION:
The Consensus Layer `BLSToExecutionChange` operation has the following fields: * Validator index * Current withdrawal BLS public key * Proposed execution layer withdrawal address * Signature by withdrawal private key over the prior fields This proposal describes OPTIONAL and RECOMMENDED mechanisms which a client beacon node MAY implement, and

MOTIVATION:
The consensus layer `BLSToExecutionChange` message is secure for a single user who has certainty their keys and mnemonic have not been compromised. However, as validator withdrawals on the consensus layer are not possible until the Capella hard fork, no user can have absolute certainty that their keys are not

RATIONALE:
This proposal is intended to protect legitimate validator mnemonic holders where it was knowingly or unknowingly compromised. As there is no safe way to transfer ownership of a validator without exiting, it can safely be assumed that all validator holders intend to set to a withdrawal address they specify.


=== EIP-758 ===
TITLE: Subscriptions and filters for completed transactions
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2017-11-09
REQUIRES: 1474

SUMMARY:
When a new transaction is submitted successfully to an Ethereum node, the node responds with the transaction's hash. If the transaction involved the execution of a contract function that returns data, the data is discarded. If the return data is state-dependent, which is common, there is no straightforward way

SPECIFICATION:
### Subscription A caller who wants to be notified when transactions of theirs complete sends an `eth_subscribe` RPC request with the first parameter `"completedTransaction"`: ```json {"jsonrpc": "2.0", "id": 1, "method": "eth_subscribe", "params": ["completedTransaction", filter]} ``` The `filter` parameter is a dictionary containing 3 optional named arguments: `from`, `to`, and

MOTIVATION:
External callers presently have no way of accessing return data from Ethereum, if the function was executed via `eth_sendTransaction` or `eth_sendRawTransaction` RPC request. Access to function return data is in many cases a desirable feature. Making return data available to external callers also addresses the inconsistency between internal callers,

RATIONALE:
[EIP-658](./eip-658.md) originally proposed adding return data to transaction receipts. However, return data is not charged for (as it is not stored on the blockchain), so adding it to transaction receipts could result in DoS and spam opportunities. Instead, a simple Boolean `status` field was added to transaction receipts. This


=== EIP-8125 ===
TITLE: Temporary Contract Storage
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2026-01-14
REQUIRES: 2, 2, 0, 0, ,,  , 2, 9, 2, 9

SUMMARY:
This EIP introduces *temporary storage*: a new contract-accessible key-value store that persists across transactions and blocks, but is automatically cleared at a protocol-defined schedule. Two new opcodes are added: - `TMPSTORE(key, value)` to write temporary storage for the executing contract. - `TMPLOAD(key)` to read temporary storage for the executing

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### Constants and parameters |Name|Value|Description| |-|:-:|-| | `FORK_BLOCK` | TBD | Activation block of this

MOTIVATION:
![](../assets/eip-8125/1.png) *Figure 1: Over 60% of the storage slots are written once and never accessed again onchain.* Permanent contract storage is costly because it increases long-term node resource requirements (disk, I/O, state maintenance). However, many applications write data that is only valuable for a bounded time window. This EIP

RATIONALE:
### Why not just use transient storage (EIP-1153)? [EIP-1153](./eip-1153.md) (transient storage) is discarded after every transaction, which is ideal for intra-tx operations. This EIP targets a different class of use cases where data must persist across multiple transactions/blocks, but does not need indefinite retention. ### Why two-period rollover? Two-period


=== EIP-7609 ===
TITLE: Decrease base cost of TLOAD/TSTORE
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-02-01
REQUIRES: 1153

SUMMARY:
Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The gas cost for `TLOAD` is proposed to be 5 gas. The gas cost for

MOTIVATION:
[EIP-1153](./eip-1153.md) introduces a new storage region, termed "transient storage". It behaves like storage (word-addressed and persists between call frames), but unlike storage it is wiped at the end of each transaction. During development of EIP-1153, the pricing was set to be the same as warm storage loads and stores.

RATIONALE:
### Gas In benchmarking, `TLOAD` was found to cost a similar amount of CPU time as `MUL`, while `TSTORE` was found to cost about 1.5x that. The values `G_low` and `G_mid` were therefore chosen for `TLOAD` and `TSTORE`, respectively.


=== EIP-197 ===
TITLE: Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-06
REQUIRES: 

SUMMARY:
This EIP suggests to add precompiled contracts for a pairing function on a specific pairing-friendly elliptic curve. This can in turn be combined with [EIP-196](./eip-196.md) to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because

SPECIFICATION:
For blocks where `block.number >= BYZANTIUM_FORK_BLKNUM`, add a precompiled contracts for a bilinear function on groups on the elliptic curve "alt_bn128". We will define the precompiled contract in terms of a discrete logarithm. The discrete logarithm is of course assumed to be hard to compute, but we will give

MOTIVATION:
Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of

RATIONALE:
The specific curve `alt_bn128` was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts. The feature of adding curve and


=== EIP-8007 ===
TITLE: Glamsterdam Gas Repricings
TYPE: Meta 
STATUS: Draft
CREATED: 2025-08-21
REQUIRES: 2, 7, 8, 0, ,,  , 2, 9, 2, 6, ,,  , 7, 7, 7, 8, ,,  , 7, 9, 0, 4, ,,  , 7, 9, 2, 3, ,,  , 7, 9, 7, 1, ,,  , 7, 9, 7, 6, ,,  , 7, 9, 8, 1, ,,  , 8, 0, 1, 1, ,,  , 8, 0, 3, 2, ,,  , 8, 0, 3, 7, ,,  , 8, 0, 3, 8, ,,  , 8, 0, 5, 3, ,,  , 8, 0, 5, 7, ,,  , 8, 0, 5, 8, ,,  , 8, 0, 5, 9

SUMMARY:
This Meta EIP documents all the proposals for Glamsterdam related to the gas repricing effort. The goal of this effort is to harmonize gas costs across the EVM, thereby reducing the impact of specific bottlenecks on scaling. Proposals include changes to the cost of single EVM operations, as well

SPECIFICATION:
The following table lists all EIPs related to repricings that are being discussed in the scope of the Glamsterdam fork. There are three types of EIPs in this list: 1. **Broad harmonization**. These EIPs reprice a class of operations with the goal of harmonizing them and removing single bottlenecks.

MOTIVATION:
The main objective of the Glamsterdam fork is to improve L1 scalability. A crucial aspect of this initiative is to create a better alignment between gas costs and actual resource usage. Currently, the gas model often misprices operations, resulting in inefficiencies and unintended incentives. For instance, within the pure

RATIONALE:
Discussed in the individual EIPs.


=== EIP-649 ===
TITLE: Metropolis Difficulty Bomb Delay and Block Reward Reduction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-06-21
REQUIRES: 

SUMMARY:
Starting with `BYZANTIUM_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 3 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 3 ETH, uncle

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 3_000_000) if block.number >= BYZANTIUM_FORK_BLKNUM else block.number #### Adjust Block, Uncle, and Nephew rewards To

MOTIVATION:
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another one and a half years. With the delay of the ice age, there is a desire to not suddenly also

RATIONALE:
This will delay the ice age by 42 million seconds (approximately 1.4 years), so the chain would be back at 30 second block times at the end of 2018. An alternate proposal was to add special rules to the difficulty calculation to effectively _pause_ the difficulty between different blocks.


=== EIP-2458 ===
TITLE: Updates and Updated-by Header
TYPE: Informational 
STATUS: Withdrawn
CREATED: 2020-01-06
REQUIRES: 

SUMMARY:
EIP headers `updates` and `updated-by` are used for updating `active` EIPs. This is to make the improvement process of EIPs more modular, and have updates to existing `active` EIPs receive similar exposures to EIPs which replace existing `final` EIPs.

SPECIFICATION:
### `updated-by` `updated-by` is reserved for EIPs in `active` status. For an EIP in status `active`, updates to that EIP, which update the header `updated`, should be started by opening a new EIP to start vetting for that update. When an `active` EIP receives a new entry to header

MOTIVATION:
Currently, EIP1 specifies EIP headers: `updated`, `replaces`, and `superseded-by`. Headers `replaces` and `superseded-by` indicates when an entire EIP is being replaced by another EIP, indicating when an EIP is now historical, and is updated by a new standard. The header `updated` indicates the date an EIP has received an

RATIONALE:
`updates` and `updated-by` apply only to EIPs in `active` status as updates to EIPs in `final` status are already handled by EIP headers `superseded-by` and `replaces`. The syntax should align with previous EIP header syntax, as this EIP is not updating syntax, simply adding header options.


=== EIP-5069 ===
TITLE: EIP Editor Handbook
TYPE: Meta 
STATUS: Living
CREATED: 2022-05-02
REQUIRES: 1


=== EIP-1965 ===
TITLE: Method to check if a chainID is valid at a specific block Number
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-20
REQUIRES: 155

SUMMARY:
This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.

SPECIFICATION:
Adds a new precompile which uses 2 argument : a 32 bytes value that represent the chainID to test and a 32 bytes value representing the blockNumber at which the chainID is tested. It return 0x1 if the chainID is valid at the specific blockNumber, 0x0 otherwise. Note that

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent the replay of transactions between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling off-chain message signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md). [EIP-1344](./eip-1344.md) is attempting to solve this

RATIONALE:
The rationale at EIP-1959 applies here as well too : - An opcode is better than a caching system for past chainID, It is cheaper, safer and do not include gaps. - Direct access to the latest chainID is dangerous since it make it easy for contract to use


=== EIP-7666 ===
TITLE: EVM-ify the identity precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.

SPECIFICATION:
| Parameter | Value | | - | - | | `IDENTITY_PRECOMPILE_ADDRESS` | `0x0000....0004` | | `EVM_CODE` | `0x365f5f37365ff3` | At the start of the block in which this fork activates, set the code of `IDENTITY_PRECOMPILE_ADDRESS` to `EVM_CODE`. Starting from and including that block, `IDENTITY_PRECOMPILE_ADDRESS` should no longer be

MOTIVATION:
Ethereum today has a large number of precompiles. Nearly half of these precompiles are not seeing significant use, and are contributing to ongoing maintenance cost and risk of consensus bugs, as well as increased development effort for new Ethereum client implementations, including ZK-EVMs and implementations in formal-verification-friendly languages. This

RATIONALE:
The given `EVM_CODE` corresponds to ``` CALLDATASIZE PUSH0 PUSH0 CALLDATACOPY CALLDATASIZE PUSH0 RETURN ``` Which copies calldata into memory, and then returns the same memory slice. This is thus a minimally disruptive change to Ethereum that preserves functionality, and accomplishes the goal of reducing the number of precompiles by


=== EIP-8012 ===
TITLE: Generalized consolidation requests
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-22
REQUIRES: 

SUMMARY:
This EIP redefines the field `target_pubkey` from consolidations requests into a general array of 48 bytes that can be interpreted separately by the consensus layer.

SPECIFICATION:
### Constants #### Consensus Layer | NAME | Value | Comment | | - | - | - | | `MAGIC_PREFIX` | `0xEF0A11` | 3 byte prefix to all generalized consolidation requests | ### Execution Layer No changes are expected ### Consensus Layer This EIP does not establish any

MOTIVATION:
The current contract to send consolidation requests is not optimized in that the exact same contract, with the exact same calldata and engine API, can be used to transmit more general messages from the EL to the CL without changes on the EL side. In particular, avoiding any cross

RATIONALE:
The proposed reinterpretation of the existing contract enables new implementations in the consensus layer without requireing a hard fork in the execution layer.


=== EIP-2584 ===
TITLE: Trie format transition with overlay trees
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-04-03
REQUIRES: 

SUMMARY:
This EIP describes a four phase process to complete the conversion. * In the first phase, all new state writes are made to an overlay binary trie, while the hexary trie is being converted to binary. The block format is changed to have two storage roots: the root of

SPECIFICATION:
This specification follows the notation introduced by the [Yellow Paper](https://ethereum.github.io/yellowpaper). Prior to reading it is advisable to be familiar with the Yellow Paper. ### Binary tries This EIP assumes that a binary trie is defined like the MPT, except that: * The series of bytes in I₀ is seen

MOTIVATION:
There is a long running interest in switching the state trie from a hexary format to a binary format, for reasons pertaining to proof and storage sizes. The conversion process poses a catch-up issue, caused by the sheer size of the full state: it can not be translated in

RATIONALE:
Methods that have been discussed until now include a "stop the world" approach, in which the chain is stopped for the significant amount of time that is required by the conversion, and a "copy on write" approach, in which branches are converted upon being accessed. The approach suggested here


=== EIP-1890 ===
TITLE: Commitment to Sustainable Ecosystem Funding
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-03-31
REQUIRES: 

SUMMARY:
A mechanism that allows specification of two parameters, a beneficiary address and a per-block reward denominated in wei, that allows a portion of block rewards to be captured for the purpose of ecosystem funding. Both values are set to zero.

SPECIFICATION:
Two new constants are introduced: BENEFICIARY_ADDRESS, an Address, and DEVFUND_BLOCK_REWARD, an amount denominated in wei. Both are set to zero. Beginning with block ISTANBUL_BLOCK_HEIGHT, DEVFUND_BLOCK_REWARD wei is added to the balance of BENEFICIARY_ADDRESS at each block. We may optionally add another constant, DECAY_FACTOR, which specifies a linear or exponenential

MOTIVATION:
In order for Ethereum to succeed, it needs talented, motivated researchers and developers to continue to develop and maintain the platform. Those talented researchers and developers deserve to be paid fairly for their work. At present there is no mechanism in the Ethereum ecosystem that rewards R&D teams fairly

RATIONALE:
We believe that the technical design of this EIP is straightforward. The social rationale is explained in [this article](https://medium.com/gitcoin/funding-open-source-in-the-blockchain-era-8ded753bf05f).


=== EIP-198 ===
TITLE: Big integer modular exponentiation
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-01-30
REQUIRES: 


=== EIP-1193 ===
TITLE: Ethereum Provider JavaScript API
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2018-06-30
REQUIRES: 1, 5, 5, ,,  , 6, 9, 5

SUMMARY:
A common convention in the Ethereum web application ("dapp") ecosystem is for key management software ("wallets") to expose their API via a JavaScript object in the web page. This object is called "the Provider". Historically, Provider implementations have exhibited conflicting interfaces and behaviors between wallets. This EIP formalizes an

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). > Comments like this are non-normative. ### Definitions _This section is non-normative._ - Provider - A JavaScript object made available to

RATIONALE:
The purpose of a Provider is to _provide_ a consumer with access to Ethereum. In general, a Provider must enable an Ethereum web application to do two things: - Make Ethereum RPC requests - Respond to state changes in the Provider's Ethereum chain, Client, and Wallet The Provider API


=== EIP-3382 ===
TITLE: Hardcoded Block Gas Limit
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
Updates the block validation rules such that a block is invalid if the `gas_limit` header field is not equal to `12,500,000`.

SPECIFICATION:
Refer to `gasLimit` as `gasTarget` post EIP-1559. ### Added Consensus Constraint As of `FORK_BLOCK_NUMBER`, the `header.gasLimit` **MUST** be equal to `BLOCK_GAS_LIMIT`, where `BLOCK_GAS_LIMIT` is a hardcoded constant set to `12,500,000`.

MOTIVATION:
Both Ethereum's Proof of Work and Proof of Stake designs assume that block producers are financially rational, but does not assume block producers to be benevolent. There is one exception however, and it is when block producers choose the gas limit of a block where it is assumed that

RATIONALE:
### Keeping gasLimit in Block Headers While it would be possible to remove the `gasLimit` field from block headers, it would change the data structure to be hashed, which could lead to unintended consequences. It is therefore easier to leave the gasLimit as part of block headers. ### Chosen


=== EIP-7981 ===
TITLE: Increase Access List Cost
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-27
REQUIRES: 2, 9, 3, 0, ,,  , 7, 9, 7, 6

SUMMARY:
This EIP charges access lists for their data footprint, preventing the circumvention of the [EIP-7623](./eip-7623.md) floor pricing. This effectively reduces the worst-case block size by ~21% with minimal impact on users.

SPECIFICATION:
| Parameter | Value | Source | | -------------------------------------- | ----- | ------ | | `ACCESS_LIST_ADDRESS_COST` | `2400` | [EIP-2930](./eip-2930.md) | | `ACCESS_LIST_STORAGE_KEY_COST` | `1900` | [EIP-2930](./eip-2930.md) | | `TOTAL_COST_FLOOR_PER_TOKEN` | `15` | [EIP-7976](./eip-7976.md) | Let `access_list_nonzero_bytes` and `access_list_zero_bytes` be the count of non-zero and zero bytes respectively in

MOTIVATION:
Access lists are only priced for storage but not for their data. Furthermore, access lists can circumvent the [EIP-7976](./eip-7976.md) floor pricing by contributing to EVM gas while still leaving a non-negligible data footprint. This enables to achieve the maximal possible block size by combining access lists with calldata at

RATIONALE:
Adding 60 gas per non-zero byte and 15 gas per zero byte ensures consistent pricing across all transaction data: - Address (20 bytes, typically mostly non-zero): ~3600 gas (2400 + 1200 assuming all non-zero) - Storage key (32 bytes, typically mostly non-zero): ~3820 gas (1900 + 1920 assuming all


=== EIP-6789 ===
TITLE: Rename gas to mana
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2023-03-27
REQUIRES: 

SUMMARY:
This EIP suggests renaming `gas` to `mana`, as proposed by Vitalik Buterin in 2015.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The core term `gas` MUST be renamed to `mana`. The following opcodes MUST be renamed:

MOTIVATION:
The underlying motivation for reviving Vitalik's original proposal from 2015 is that we have finally arrived at the age of Proof-of-Stake, and given the roadmap ahead (i.e. "The Surge", "The Scourge", "The Verge", "The Purge", and "The Splurge"), I consider this moment as the last opportunity to make such

RATIONALE:
- `mana` reflects the increased environmental friendliness of Proof-of-Stake; - `mana` is generally understood to be ephemeral and non-transferable, which better represents the concept of `gas`; and - `mana` is generally portrayed as renewable, while (natural) `gas` is non-renewable.


=== EIP-1959 ===
TITLE: New Opcode to check if a chainID is part of the history of chainIDs
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-20
REQUIRES: 155

SUMMARY:
This EIP adds an opcode that returns whether the specific number passed in has been a valid chainID (EIP-155 unique identifier) in the history of the chain (including the current chainID).

SPECIFICATION:
Adds a new opcode ```VALID_CHAINID``` at 0x46, which uses 1 stack argument : a 32 bytes value that represent the chainID to test. It will push ```0x1``` onto the stack if the uint256 value is part of the history (since genesis) of chainIDs of that chain, ```0x0``` otherwise. The

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md). [EIP-1344](./eip-1344.md) is attempting to solve this by giving smart contract

RATIONALE:
The only approach available today is to specify the chain ID at compile time. Using this approach will result in problems after a contentious hardfork as the contract can't accept message signed with a new chainID. The approach proposed by EIP-1344 is to give access to the latest chainID.


=== EIP-3584 ===
TITLE: Block Access List
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-05-22
REQUIRES: 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
[EIP-2929](./eip-2929.md)/[EIP-2930](./eip-2930.md) centers around normalizing the (low) gas costs of data/storage accesses made by a transaction as well as providing for (and encouraging) a new transaction type format: ``` 0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS]) ``` that makes upfront `access_list` declarations, where `access_list`

SPECIFICATION:
A block `access_list` represents: ``` Set [ AccessedAddress, List [AccessedStorageKeys] , Set [ AccessedInBlockTransactionNumber, List [ AccessedStorageKeys ]] ] ``` A **canonical** construction of such an `access_list` is specified as below. ### Canonical Block Access List An `access_list` is defined to be comprised of many `access_list_entry` elements: ``` access_list

MOTIVATION:
Motivation for collating the *transaction* `access_list`s for all the transactions in a **block**’s `access_list` is to have an *access index* of the block with following benefits: 1. Block execution/validation optimizations/parallelization/cache warm-up by enabling construction of *a partial order* for access and hence execution (hint: *chains* in this *poset* can

RATIONALE:
### Sorting of canonical `access_list` It is specified to be sorted in lexicographic ordering or integer sorting wherever applicable and specified. Sorting with respect to access time was considered but didn't seem to provide any additional benefit at the cost of adding implementation complexity and bookkeeping. ### `AccessListRoot` `AccessListRoot`


=== EIP-2330 ===
TITLE: EXTSLOAD opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-10-29
REQUIRES: 2929

SUMMARY:
This proposal adds a new opcode `EXTSLOAD` at `0x5c` which pops two items from the stack: `<account address> <storage key>` and pushes one item: `<storage value>`. The gas cost is sum of account access cost and storage read based on [EIP-2929](./eip-2929.md) Access Lists.

SPECIFICATION:
A new EVM instruction `EXTSLOAD (0x5c)` that works like `SLOAD (0x54)` but an additional parameter representing the contract that is to be read from. ```shell EXTSLOAD (0x5c) ``` The `EXTSLOAD` instruction pops 2 values from the stack, first `contract` a contract address and then second `slot` a storage address

MOTIVATION:
While any off-chain application can read all contract storage data of all contracts, this is not possible for deployed smart contracts themselves. These are bound to use contract calls for any interaction including reading data from other contracts. This EIP adds an EVM opcode to directly read external contract

RATIONALE:
- Without this EIP, a contract can still opt-in to make their entire state public, by having a method that simply SLOADs and returns the values ([example](../assets/eip-2330/Extsload.sol)). The complexity of the gas cost can be seen as `1`x CALL cost + `N`x SLOAD cost. Hence, the gas cost specified


=== EIP-2972 ===
TITLE: Wrapped Legacy Transactions
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-09-12
REQUIRES: 1, 5, 5, ,,  , 2, 7, 1, 8

SUMMARY:
Introduces two new [EIP-2718](./eip-2718.md) transactions that are signature compatible with legacy transactions and can be automatically upgraded by any client. * `0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))` * `0x01 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))`

SPECIFICATION:
### Definitions * `||` is the byte/byte-array concatenation operator. * `yParity` is the parity (0 for even, 1 for odd) of the `y` value of the curve point for which `r` is the `x` value in the secp256k1 signing process. ### Transactions As of `FORK_BLOCK_NUMBER`, `0x00 || ssz.serialize(yParity, r,

MOTIVATION:
We would like to eventually deprecate legacy transactions so we no longer have to retain code in the networking and signer layer that deals with them. However, we also want to ensure that signatures for transactions that were generated prior to that deprecation are still valid and funds don't

RATIONALE:
### Signature doesn't include transaction type as first signature byte These transaction types are explicitly designed to be signature compatible with legacy transactions, which means we cannot change the data being signed. See Security Considerations section for more details. ### Two transaction types instead of one With the introduction


=== EIP-86 ===
TITLE: Abstraction of transaction origin and signature
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-02-10
REQUIRES: 


=== EIP-6916 ===
TITLE: Automatically Reset Testnet
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-04-10
REQUIRES: 

SUMMARY:
This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.

SPECIFICATION:
The testnet is set to always reset after a predefined time period. The reset means the generation of the next genesis, discarding the old one and starting a new network. This is possible by introducing functions for the genesis generation and the client reset. ### Genesis To connect to

MOTIVATION:
A testnet which automatically resets can provide an alternative environment for short-term testing of applications, validators and also breaking changes in client implementations. It avoids issues of long running testnets which suffer from state bloat, lack of testnet funds or consensus issues. Periodically resetting the network back to genesis

RATIONALE:
Ephemeral testnets with deterministic parameters provide a sustainable alternative to traditional testnets, with the same infrastructure. At each reset, the validator set is cleared, faucets are filled again and the database is kept small. Upon reset the whole state is purged, which, on the one hand keeps the network


=== EIP-7636 ===
TITLE: Extension of EIP-778 for "client" ENR Entry
TYPE: Standards Track Networking
STATUS: Withdrawn
CREATED: 2024-02-25
REQUIRES: 778

SUMMARY:
The Ethereum network consists of nodes running various client implementations. Each client has its own set of features, optimizations, and unique behaviors. Introducing a standardized way to identify client software and its version in the ENR allows for more effective network analysis, compatibility checks, and troubleshooting. This EIP proposes

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The "client" entry is proposed to be added to the ENR following the specifications in

MOTIVATION:
Understanding the landscape of client software in the Ethereum network is crucial for developers, nodes, and network health assessment. Currently, there is no standardized method for nodes to announce their software identity and version, which can lead to compatibility issues or difficulty in diagnosing network-wide problems. Adding this to

RATIONALE:
One key was chosen over using many keys to make efficient use of space. The use of one string, however, does not align with other EIPs of similar purpose and as such the RLP list was decided as the best encoding.


=== EIP-7684 ===
TITLE: Return deposits for distinct credentials
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-12
REQUIRES: 

SUMMARY:
Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.

SPECIFICATION:
### Consensus Layer The configuration values and mechanics of the specification can be found in the [Consensus Layer specs](https://github.com/ethereum/consensus-specs/blob/2360756c8c19c0f7b0e91135f5bbcddecdf0a835/specs/_features/eip9999/beacon_chain.md). A sketch of the resulting changes to the consensus layer is included below. - Modify `apply_deposit` to queue for withdrawal deposits with distinct execution withdrawal credentials - Modify `get_expected_withdrawals` to

MOTIVATION:
Some staking operations feature two distinct entities, one operating the validating key, and one funding the deposit. The funding entity delegates control of the stake operation but must retain ultimate control of funds. If the funding entity naively submits a single deposit with the full stake amount and the

RATIONALE:
### Persist pending withdrawals Rejected deposits from block at slot N can not be withdrawn in block N due to a cyclic dependency. An execution client must know the full list of withdrawals before constructing a payload for slot N. After [EIP-6110](./eip-6110.md), a consensus client must know the full


=== EIP-7973 ===
TITLE: Warm Account Write Metering
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-06-14
REQUIRES: 2200

SUMMARY:
This EIP introduces warm metering for account writes. Namely, if one of the account fields (`nonce`, `value`, `codehash`) is changed more than once in a transaction, the later writes are cheaper, since the state root update only happens once.

SPECIFICATION:
The parameters `GAS_CALL_VALUE` and `GAS_STORAGE_UPDATE` are removed, and the following parameters are introduced: | **Parameter** | **Value** | **Description** | |:---:|:---:|:---:| | `GAS_COLD_STORAGE_WRITE` | TBD | Cost of a single update to the storage trie | | `GAS_COLD_ACCOUNT_WRITE` | TBD | Cost of a single update to the account

MOTIVATION:
Updating the state root is one of the most expensive parts of block construction. Currently, multiple writes to storage are subject to a net gas metering, which reduces the cost of a storage write after the first write. However, updates to the account are subject to the same cost

RATIONALE:
An account is represented within Ethereum as a tuple `(nonce, balance, storage_root, codehash)`. The account is a leaf of a Merkle Patricia Tree (MPT), while the `storage_root` is itself the root of the account's MPT key-value store. An update to the account's storage requires updating two MPTs (the account's


=== EIP-2069 ===
TITLE: Recommendation for using YAML ABI in ERCs/EIPs
TYPE: Informational 
STATUS: Stagnant
CREATED: 2017-02-11
REQUIRES: 

SPECIFICATION:
The [Standard Contract ABI] is usually represented as a JSON object. This works well and several tools – including compilers and clients – support it to handle data encoding. One shortcoming of the JSON description is its inability to contain comments. To counter this, we suggest the use of

MOTIVATION:
In the past, most ERCs/EIPs included an ABI description purely as a Solidity contract and/or interface. This has several drawbacks: - Prefers a single language over others and could hinder the development of new languages. - Locks the specification to a certain version of the Solidity language. - Allows

RATIONALE:
The aim was to choose a representation which is well supported by tools and supports comments. While inventing a more concise description language seems like a good idea, it felt as an unnecessary layer of complexity.


=== EIP-7877 ===
TITLE: Enhanced RETURN opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-01-31
REQUIRES: 6, ,,  , 1, 1, 5, 3, ,,  , 3, 8, 5, 5

SUMMARY:
This EIP specifies a series of new `RETURN` opcodes which allow the user to specify which data location to return from instead of defaulting to returning from memory.

SPECIFICATION:
This EIP introduces 3 new opcodes as well as renaming/aliasing an existing one. ``` SRETURN (0xf6) TRETURN (0xf7) RRETURN (0xf8) RETURN -> MRETURN (0xf3) ``` The `MRETURN` opcode is a rename of `RETURN`, whereby sequential bytes in memory are returned. It will operate exactly as it currenty does as

MOTIVATION:
With the introduction of transient storage, many smart contracts have begun to store data using the new transient opcodes to optimize for gas usage, whereby a callback involves returning the data previously stored transiently. However, the current `RETURN` opcode only allows for returning sequential bytes in memory. This requires

RATIONALE:
Allowing for more targeted return opcodes allows for saving gas at all levels of smart contract optimization by eliminating the intermediate steps of first writing any data to memory before returning. In events where this data may be large, this can result in significant gas savings. These opcodes can


=== EIP-3860 ===
TITLE: Limit and meter initcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-16
REQUIRES: 170

SUMMARY:
We extend [EIP-170](./eip-170.md) by introducing a maximum size limit for `initcode` (`MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152`). Furthermore, we introduce a charge of `2` gas for every 32-byte chunk of `initcode` to represent the cost of jumpdest-analysis. Lastly, the size limit results in the nice-to-have property that EVM

SPECIFICATION:
### Parameters | Constant | Value | | -------------------- | ------------------- | | `INITCODE_WORD_COST` | `2` | | `MAX_INITCODE_SIZE` | `2 * MAX_CODE_SIZE` | Where `MAX_CODE_SIZE` is defined by [EIP-170](./eip-170.md) as `24576`. We define `initcode_cost(initcode)` to equal `INITCODE_WORD_COST * ceil(len(initcode) / 32)`. ### Rules 1. If length of transaction

MOTIVATION:
During contract creation the client has to perform jumpdest-analysis on the `initcode` prior to execution. The work performed scales linearly with the size of the `initcode`. This work currently is not metered, nor is there a protocol enforced upper bound for the size. There are three costs charged today:

RATIONALE:
### Gas cost constant The value of `INITCODE_WORD_COST` is selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance of `KECCAK256` hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU. | EVM


=== EIP-7745 ===
TITLE: Trustless log and transaction index
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-07-17
REQUIRES: 7916

SUMMARY:
Replace the fixed 2048 bit log event bloom filters with a new lookup index data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio, allowing efficient trustless proofs of log event queries, canonical block hash and transaction

SPECIFICATION:
### Terms and definitions - _index entry_: a single entry in the `index_entries` tree associated with an indexed event. It is either a _log entry_, a _transaction entry_ or a _block entry_. An _index entry_ generates one or more _map values_. Each _log entry_ adds one _address value_ and

MOTIVATION:
Adding logs has a significantly lower gas cost and should accordingly be less resource consuming than writing to the state. The original design of bloom filters in each block achieves this goal as there is no complex data structure like the state to update, the set of logs emitted

RATIONALE:
### Design goals The proposed data structure is intended to realize a balance between the cost of adding items and accessing old ones. In a search structure of a constantly growing dataset there is typically a tradeoff between the cost of adding new data and the cost of searcing


=== EIP-7863 ===
TITLE: Block-level Warming
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-01-15
REQUIRES: 

SUMMARY:
This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their "warm" status throughout an entire block's execution. Accessed slots can be effectively cached at the block level, allowing for this optimization.

SPECIFICATION:
### Mechanics When a storage slot is accessed within a block: 1. The first access to a slot in a block incurs the cold access cost as of [EIP-2929](./eip-2929.md). 2. All subsequent accesses to the same slot within the same block incur only the warm access cost as of

MOTIVATION:
Currently, the EVM's storage slot warming mechanism operates at the transaction level, requiring each transaction to "warm up" slots independently, even when accessing the same storage locations within the same block. This design does not take advantage of the fact that modern node implementations can effectively cache storage access

RATIONALE:
The proposal builds on several key observations: 1. **Caching Efficiency**: Modern Ethereum clients already implement sophisticated caching mechanisms at the block level. Extending address and storage key warming to match this caching behavior better aligns gas costs with actual computational costs. 2. **Backward Compatibility**: The worst-case scenario for any


=== EIP-7703 ===
TITLE: Increase calldata cost
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-07
REQUIRES: 

SUMMARY:
An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.

SPECIFICATION:
* Increase `G_CALLDATAZERO` from 4 to 12. * Increase `G_CALLDATANONZERO` from 16 to 48.

MOTIVATION:
Larger blocks take longer to propagate through the network. In this way, the maximum potential block size is constraining the block gas limit. Therefore, in order to safely increase the block gas limit, the calldata gas must be increased.

RATIONALE:
Tripling the gas cost of calldata reduces the maximum possible block size by a factor of three.


=== EIP-6188 ===
TITLE: Nonce Cap
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2929

SUMMARY:
This EIP caps the nonce at `2^64-2`, reserving it for contracts with unusual behavior, as defined in other EIPs.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### EOA Transactions The nonce of a transaction originating from an EOA MUST be less than `2^64-2`.

MOTIVATION:
This EIP is not terribly useful on its own, as it adds additional computation without any useful side effects. However, it can be used by other EIPs.

RATIONALE:
Capping a nonce allows for contracts with special properties to be created, with their functionality based on their contract code. As such, only one nonce needs to be reserved.


=== EIP-7542 ===
TITLE: eth/70 - available-blocks-extended protocol
TYPE: Standards Track Networking
STATUS: Withdrawn
CREATED: 2023-10-21
REQUIRES: 7642

SUMMARY:
The purpose of this EIP is to introduce a method that allows an Ethereum node to communicate the range of blocks it has available. By knowing the block range a node can serve, peers can make more informed decisions when choosing whom to request blocks from or whom to

SPECIFICATION:
- Advertise a new `eth` protocol capability (version) at `eth/70`. - The old `eth/69` protocol should still be kept alive side-by-side, until `eth/70` is sufficiently adopted by implementors. - Modify the `Status (0x00)` message for `eth/70` to add an additional `blockRange` field right after the `forkid`: - Current packet

MOTIVATION:
In a first stage of [EIP-4444](./eip-4444.md), some nodes will still need to serve the historical data of the chain and others might be interested in starting to prune it. Currently, nodes need to connect to peers and request specific blocks to determine if a peer has the requested data.

RATIONALE:
Including the available block range in the `eth` handshake allows for immediate understanding of peer capabilities. This can lead to more efficient networking as nodes can prioritize connections based on the data they need. The new message types are introduced to allow nodes to request updated available block range


=== EIP-1014 ===
TITLE: Skinny CREATE2
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-04-20
REQUIRES: 

SPECIFICATION:
Adds a new opcode (`CREATE2`) at `0xf5`, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically to `CREATE` (`0xf0`), except using `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]` instead of the usual sender-and-nonce-hash as the address where the contract is initialized at. The `CREATE2` has the

MOTIVATION:
Allows interactions to (actually or counterfactually in channels) be made with addresses that do not exist yet on-chain but can be relied on to only possibly eventually contain code that has been created by a particular piece of init code. Important for state-channel use cases that involve counterfactual interactions

RATIONALE:
#### Address formula * Ensures that addresses created with this scheme cannot collide with addresses created using the traditional `keccak256(rlp([sender, nonce]))` formula, as `0xff` can only be a starting byte for RLP for data many petabytes long. * Ensures that the hash preimage has a fixed size, #### Gas


=== EIP-7790 ===
TITLE: Controlled Gas Limit Increase Guidelines
TYPE: Informational 
STATUS: Stagnant
CREATED: 2024-10-18
REQUIRES: 7783


=== EIP-1485 ===
TITLE: TEthashV1
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-11-01
REQUIRES: 

SUMMARY:
This EIP pursue "obsolete current ASIC miners" by modifying PoW algorithm in a very low risk manner and update to latest hash algorithm from deprecated FNV Hash algorithms. Following TEthashV1 algorithm suggests safe transition of PoW algorithms and secure the FNV Algorithm in MIX Parts.

SPECIFICATION:
#### 1. Reference materials on ETHASH FNV0 #### Where FNV Applied on ETHASH - In [ETHASH](https://web.archive.org/web/20200505215203/https://github.com/ethereum/wiki/wiki/Ethash), FNV Hash is used on * 1) On data aggregation function, MIX parts. * Ethash Algorithm ``` Header + Nonce | Keccak | **[MIX 0]** --> **[DAG Page]** | | Mixing <--| ...

MOTIVATION:
Provide original Ethash proof of work verification with minimal set of changes by updating FNV0 algorithm

RATIONALE:
In case of ethash algorithm, it can't prevent ASIC forever. And, current ethash algorithm's FNV function is deprecated. So, It needs to be upgraded and it will make current ethash based ASICs obsolete. And current TETHASHV1 FNV1A implementation is based on most of ethash , which is verified for


=== EIP-5593 ===
TITLE: Restrict Ethereum Provider API Injection
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-09-05
REQUIRES: 1193

SUMMARY:
Historically the web platform has had a notion of “powerful” APIs like those defined in W3C's Geolocation specification and W3C's Mediastreams specification, which are subject to additional security restrictions such as those defined by W3C's secure contexts specification. Since the Ethereum Provider APIs allow dApp websites to request access

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Restrictions for providers The provider objects, e.g. `window.ethereum`, are expected to only inject the Ethereum Provider APIs in secure

MOTIVATION:
Wallets are oftentimes maintaining security and safety of users' funds that can be equivalent to large portions of money. For this reason, it's a good idea to restrict access to the Ethereum Provider APIs to align it with other powerful APIs on the web platform. This will assist in

RATIONALE:
By limiting the capabilities of where the Ethereum Provider APIs are being injected we can reduce the surface area of where attacks can be executed. Given the sensitivity of data that's passed to the Ethereum Provider APIs some basic levels of authentication and confidentiality should be met in order


=== EIP-3155 ===
TITLE: EVM trace specification
TYPE: Standards Track Interface
STATUS: Last Call
CREATED: 2020-12-07
REQUIRES: 

SUMMARY:
Introduce a new JSON standard for EVM traces during execution of state tests.

SPECIFICATION:
Clients should be able to execute simple transactions as well as code and return traces. In the following, we will call this client CUT (client under test) and use go-ethereum's `evm` binary for code examples. ### Datatypes | Type | Explanation | Example | |------------|----------------------------------------------------------------|---------------------| | Number | Plain

MOTIVATION:
The Ethereum Virtual Machine executes all smart contract code on ethereum. In order to debug smart contracts and state tests better, a common format was introduced to log every execution step of the EVM. This format was implemented by Go-Ethereum, Parity-Ethereum, Nethermind and Besu. Since the common format was

RATIONALE:
This EIP is largely based on the previous non-official documentation for EVM tracing. It tries to cover as many corner cases as possible to enable true client compatibility. The datatypes and if a field is optional is chosen to be as compatible with current implementations as possible.


=== EIP-3756 ===
TITLE: Gas Limit Cap
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-08-21
REQUIRES: 

SUMMARY:
Set an in-protocol cap for the gas limit of 30,000,000.

SPECIFICATION:
As of the fork block `N`, consider blocks with a `gas_limit` greater than `30,000,000` invalid.

MOTIVATION:
A high gas limit increases pressure on the network. In the benign case, it increases the size of the state and history faster than we can sustain. In the malicious case, it amplifies the devastation of certain denial-of-service attacks.

RATIONALE:
### Why Cap the Gas Limit The gas limit is currently under the control of block proposers. They have the ability to increase the gas limit to whatever value they desire. This allows them to bypass the EIP and All Core Devs processes in protocol decisions that may negatively


=== EIP-7940 ===
TITLE: Ethereum Shah
TYPE: Informational 
STATUS: Draft
CREATED: 2025-04-28
REQUIRES: 

SUMMARY:
Ethereum needs a Shah. The role of the Shah is to be the "protector". A Shah, empowered by the community and with a mandate to represent their interests, could solve the communication gaps between the Ethereum community and core devs, represent the interests of the Ethereum community (holders, stakers,

SPECIFICATION:
The Shah SHOULD be elected by the Ethereum community, using a combination of ETH voting, social signalling, and core dev ratification. The Shah SHOULD be singularly responsible for deciding on the EIP inclusion roadmap, as well as having veto power over which EIPs to include. The Shah SHOULD maintain

MOTIVATION:
It is clear from recent events that Ethereum is suffering from a coordination breakdown between the user ecosystem and the core devs. A case in point is the EOF debacle, with years wasted in EOF development that ~~seems ultimately likely to be~~ was just rejected as a result of

RATIONALE:
During times of war, the Roman Senate would elect an "Imperator" that would be responsible for dealing with an imminent threat, and once the threat was dealt with, would abdicate their power. The Shah is a similar concept, but rooted in the culture of the Persian Empire, which pioneered


=== EIP-6465 ===
TITLE: SSZ withdrawals root
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-08
REQUIRES: 2, 7, 1, 8, ,,  , 4, 8, 9, 5, ,,  , 6, 4, 0, 4, ,,  , 7, 4, 9, 5, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP defines a migration process of the existing Merkle Patricia Trie (MPT) commitment for withdrawals to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated

MOTIVATION:
While the consensus `ExecutionPayloadHeader` and the execution block header map to each other conceptually, they are encoded differently. This EIP aims to align the encoding of the `withdrawals_root`, taking advantage of the more modern SSZ format. This brings several advantages: 1. **Reducing complexity:** The proposed design reduces the number

RATIONALE:
This change was originally a candidate for inclusion in Shanghai, but was postponed to accelerate the rollout of withdrawals.


=== EIP-8062 ===
TITLE: Add sweep withdrawal fee for 0x01 validators
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-28
REQUIRES: 4, 8, 9, 5, ,,  , 7, 2, 5, 1

SUMMARY:
A fee is proposed on the partial "sweep" withdrawal of validators using `0x01` credentials, to improve stake consolidation and fairness. Ethereum's fast finality roadmap hinges on staking service providers migrating from `0x01` validators to `0x02` compounding validators. One roadblock is that `0x01` validators receive free-of-charge partial skimming withdrawals for

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `WITHDRAWAL_FEE_FRACTION` | `2000` | ### Functions In `process_withdrawals()`, take out a fee for skimmed `0x01` validators that did not perform a full exit, burning it on the CL: ```python def process_withdrawals(state: BeaconState, payload: ExecutionPayload) -> None:

MOTIVATION:
The roadmap for fast finality hinges on stake consolidation, where staking service providers (SSPs) transition from running 32-ETH validators with `0x01` credentials to compounding validators with `0x02` credentials. A roadblock to this transition is that `0x01` validators have been designed with close-to-ideal capital efficiency and free-of-charge partial withdrawals for

RATIONALE:
### Fast finality Fast finality is best realized through a reduction to the active validator set voting each round. Two paths have been envisioned. In one path referred to as Orbit SSF, the active set rotates in a weighted fashion, such that large consolidated validators always are active, and


=== EIP-3322 ===
TITLE: Account gas storage opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-03-04
REQUIRES: 

SUMMARY:
Contracts can persist gas for later transfer to the refund counter. Three opcodes are introduced to read, add to, and use this gas counter.

SPECIFICATION:
Contract accounts gain an unsigned gas refund counter, initially zero. Three new opcodes are introduced to manage this state. * `SELFGAS` (`0x49`): Pushes the current account's gas refund counter onto the stack. Shares gas pricing with `SELFBALANCE`. * `USEGAS` (`0x4a`): Pops `amount` from the stack. The minimum of `amount`

MOTIVATION:
The refund mechanism is currently being used by gas tokens to arbitrage gas price. This brings gas supply elasticity and price stability by moving gas from blocks with less demand to blocks with more demand. Unfortunately this rewards unnecessary state growth. By introducing a superior gas storage mechanism, the

RATIONALE:
By reusing the execution context's refund counter we can reuse its 50% DoS protection, which limits its block elasticity contribution to 2x. The gas costs are based on similar opcodes `SELFBALANCE` and `SSTORE`. Most accounts will store no gas, so the per-account storage overhead should be minimal or even


=== EIP-5450 ===
TITLE: EOF - Stack Validation
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-08-12
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 4, 7, 5, 0

SUMMARY:
Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.

SPECIFICATION:
### Code validation *Remark:* We rely on the notions of *operand stack* and *type section* as defined by [EIP-4750](./eip-4750.md). Each code section is validated independently. #### Instructions validation In the first validation phase defined in [EIP-3670](./eip-3670.md) (and extended by [EIP-4200](./eip-4200.md) and [EIP-4750](./eip-4750.md)) instructions are inspected independently to check if

MOTIVATION:
The current EVM performs a number of validity checks for each executed instruction, such as checking for instruction being defined, stack overflow and underflow, and enough amount of gas remaining. This EIP minimizes the number of such checks required at run-time by verifying that no exceptional conditions can happen

RATIONALE:
### Properties of validated code Any code section validated according to operand stack validation has the following properties: 1. There are no unreachable instructions 2. There are no instructions reachable only via backwards jump 3. Operand stack underflow cannot happen. 4. Operand stack overflow can only happen at `CALLF`


=== EIP-7927 ===
TITLE: History Expiry Meta
TYPE: Meta 
STATUS: Stagnant
CREATED: 2025-03-28
REQUIRES: 4444

SUMMARY:
This Meta-EIP documents the activation process and plan for history expiry as well as providing links to other EIPs that are related.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Execution layer client MUST implement [EIP-7642](./eip-7642.md) to support the `eth/69` over DevP2P. Execution layer clients

MOTIVATION:
[EIP-4444](./eip-4444.md) documents the motivation for history expiry itself. This EIP exists to document the process through which history expiry will be activated on mainnet, the testnet activation on Sepolia, devnet testing and other information surrounding history expiry that doesn't fit cleanly in any of the supporting EIPs.

RATIONALE:
### Why wait for Pectra Consensus Layer clients have a dependency on pre-merge deposit logs. [EIP-6110](./eip-6110.md) will remove this dependency when the Pectra fork is activated. ### Why drop Sepolia history The Sepolia history drop is intended as a testing ground for the mainnet activation. ### Why drop Devnet


=== EIP-140 ===
TITLE: REVERT instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-06
REQUIRES: 

SUMMARY:
The `REVERT` instruction will stop execution, roll back all state changes done so far and provide a pointer to a memory section, which can be interpreted as an error code or message. While doing so, it will not consume all the remaining gas.

SPECIFICATION:
On blocks with `block.number >= BYZANTIUM_FORK_BLKNUM`, the `REVERT` instruction is introduced at `0xfd`. It expects two stack items, the top item is the `memory_offset` followed by `memory_length`. It does not produce any stack elements because it stops execution. The semantics of `REVERT` with respect to memory and memory cost

MOTIVATION:
Currently this is not possible. There are two practical ways to revert a transaction from within a contract: running out of gas or executing an invalid instruction. Both of these options will consume all remaining gas. Additionally, reverting an EVM execution means that all changes, including LOGs, are lost


=== EIP-8061 ===
TITLE: Increase exit and consolidation churn
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-17
REQUIRES: 7521

SUMMARY:
This EIP roughly doubles the consolidation churn, as well as quadrupling the exit churn and restoring its proportionality to total stake (though maintaining the existing cap on activations). The choice of parameters balances maintaining a sufficiently long weak subjectivity period (~7 days, roughly halving the current period) with achieving

SPECIFICATION:
The `CHURN_LIMIT_QUOTIENT` is halved, from `2**16` to `2**15`, and fully dedicated to activations and exits. However, the cap on activations introduced in [EIP-7514](./eip-7514.md) is maintained via `MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT`, while exits are freed from this cap. Consolidations now have their own dedicated churn, determined by `CONSOLIDATION_CHURN_LIMIT_QUOTIENT`. This is set here to

MOTIVATION:
[EIP-7514](./eip-7514.md) introduced an activation cap of 8 validators per epoch (now 256 ETH per epoch) to prevent overly rapid validator set growth. [EIP-7251](./eip-7251.md) extended this cap to exits, to make room for the newly introduced consolidation operations, without increasing the weak subjectivity period. However, the fixed cap prevents the

RATIONALE:
- **Independent parameters:** a separate churn consolidation is easy to independently tune, in particular adjusted upward if we want to speed up the consolidation process further, and later downward, when the primary wave of validator set consolidation has already happened and the consolidation operation becomes less crucial. - **Scaling


=== EIP-1 ===
TITLE: EIP Purpose and Guidelines
TYPE: Meta 
STATUS: Living
CREATED: 2015-10-27
REQUIRES: 


=== EIP-7768 ===
TITLE: No-Ether transactions with free-for-all tips
TYPE: Meta 
STATUS: Draft
CREATED: 2024-09-14
REQUIRES: 

SUMMARY:
A technique is introduced where an externally-owned account having no Ether can send transactions and pay tips using a new "free-for-all" bucket and using their own `origin.tx`. This requires no client changes and is compatible with existing ecosystem parts.

SPECIFICATION:
### End user process 1. An end user who controls an externally-owned account, say Alice, will prepare transaction(s) she would like to execute and she signs this (series of) transactions. 2. If Alice will like to provide consideration for executing these transactions, she will ensure that a well-known address

MOTIVATION:
There is much interest in third-party-pay transactions on Ethereum and competing networks. Other proposals require changes to the Ethereum client, that transactions be sent to the network (i.e. `tx.origin`) using a separate account and/or other additional things. In contrast, this proposal introduces and standardizes a solution to this problem

RATIONALE:
This approach can be useful for end users who do not want to or are not able to add Ether to their account. This approach allows to use the correct `origin.tx` which may be required for important transactions like ERC-721 `setApprovalForAll`. This approach may use more gas than other


=== EIP-689 ===
TITLE: Address Collision of Contract Address Causes Exceptional Halt
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-08-15
REQUIRES: 

SUMMARY:
Some test cases in the consensus test suite try to deploy a contract at an address already with nonempty code. Although such cases can virtually never happen on the main network before the Constantinople fork block, the test cases detected discrepancies in clients' behavior. Currently, the Yellow Paper says

SPECIFICATION:
If `block.number >= 0`, when a contract creation is on an account with non-zero nonce or non-empty code, the creation fails as if init code execution resulted in an exceptional halt. This applies to contract creation triggered by a contract creation transaction and by CREATE instruction.

MOTIVATION:
This EIP has no practical relevance to the main net history, but simplifies testing and reasoning. This EIP has no effects after Constantinople fork because [EIP-86](./eip-86.md) contains the changes proposed in this EIP. Even before the Constantinople fork, this EIP has no practical relevance because the change is visible

RATIONALE:
It seems impractical to implement never-used features just for passing tests. Client implementations will be simpler with this EIP.


=== EIP-2387 ===
TITLE: Hardfork Meta: Muir Glacier
TYPE: Meta 
STATUS: Final
CREATED: 2019-11-22
REQUIRES: 1, 6, 7, 9, ,,  , 2, 3, 8, 4

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hard fork named Muir Glacier. This hard fork addresses the impending Ice Age on Ethereum Mainnet and includes a commitment to solving the problems with the ice age more permanently.

SPECIFICATION:
- Codename: Muir Glacier ### Activation - `Block >= 9,200,000` on the Ethereum mainnet - `Block >= 7,117,117` on the Ropsten testnet - `Block >= N/A` on the Kovan testnet - `Block >= N/A` on the Rinkeby testnet - `Block >= N/A` on the Görli testnet ### Included EIPs

MOTIVATION:
Ethereum achieves a consistent block time due to its' difficulty retargeting algorithm. If a block-time is higher than 20 seconds, it reduces the difficulty, and if a block time is lower than 10 seconds, it increases the difficulty. This mechanism reaches typically an equilibrium of around 13-14 seconds. Included

RATIONALE:
I want to address the rationale for the intention of the Iceage and the implementation of the Iceage separately. **The original intentions of the ice age include:** - At the time of upgrades, inhibit unintentional growth of the resulting branching forks leading up to Eth 2.0. * - Encourage


=== EIP-233 ===
TITLE: Formal process of hard forks
TYPE: Meta 
STATUS: Stagnant
CREATED: 2017-03-23
REQUIRES: 

SUMMARY:
To describe the formal process of preparing and activating hard forks.

SPECIFICATION:
A Meta EIP should be created and merged as a *Draft* as soon as a new hard fork is planned. This EIP should contain: - the desired codename of the hard fork, - activation block number once decided - a timeline section - an EIPs to include section -

MOTIVATION:
Today discussions about hard forks happen at various forums and sometimes in ad-hoc ways.

RATIONALE:
A meta EIP for coordinating the hard fork should help in visibility and traceability of the scope of changes as well as provide a simple name and/or number for referring to the proposed fork.


=== EIP-1930 ===
TITLE: CALLs with strict gas semantic. Revert if not enough gas available.
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-10
REQUIRES: 

SUMMARY:
The current CALL, DELEGATE_CALL, STATIC_CALL opcode do not enforce the gas being sent, they simply consider the gas value as a maximum. This pose serious problem for applications that require the call to be executed with a precise amount of gas. This is for example the case for meta-transaction

SPECIFICATION:
There are 2 possibilities a) one is to add opcode variant that have a stricter gas semantic b) The other is to consider a specific gas value range (one that have never been used before) to have strict gas semantic, while leaving other values as before Here are the

RATIONALE:
Currently the gas specified as part of these opcodes is simply a maximum value. And due to the behavior of [EIP-150](./eip-150.md) it is possible for an external call to be given less gas than intended (less than the gas specified as part of the CALL) while the rest of


=== EIP-6051 ===
TITLE: Private Key Encapsulation
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-11-21
REQUIRES: 

SUMMARY:
This EIP proposes a mechanism to encapsulate a private key so that it could be securely relocated to another application without providing the seed. This EIP combines `ECIES` (Elliptic Curve Integrated Encryption Scheme) and optional signature verification under various choices to ensure that the private key is encapsulated for

SPECIFICATION:
### Sender and Recipient We hereby define: - *Sender* as the party who holds in custody the private key to be encapsulated; *Sender Application* as the client-side application that said *Sender* uses to send the encapsulated private key. - *Recipient* as the party who accepts the encapsulated private key,

MOTIVATION:
There are various cases in which we might want to export one of many private keys from a much more secure but less convenient wallet, which is controlled with a seed or passphrase. 1. We might dedicate one of many private keys for messaging purposes, and that private key

RATIONALE:
A critical difference between this [EIP-6051](./eip-6051.md) with [EIP-5630](./eip-5630.md) is that, as the purpose of key encapsulation is to transport a private key securely, the public key from the key recipient should be ephemeral, and mostly used only one-time. While in EIP-5630 settings, the public key of the message recipient


=== EIP-6 ===
TITLE: Renaming SUICIDE opcode
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2015-11-22
REQUIRES: 

SUMMARY:
The solution proposed in this EIP is to change the name of the `SUICIDE` opcode in Ethereum programming languages with `SELFDESTRUCT`. ### Motivation Mental health is a very real issue for many people and small notions can make a difference. Those dealing with loss or depression would benefit from

MOTIVATION:
Mental health is a very real issue for many people and small notions can make a difference. Those dealing with loss or depression would benefit from not seeing the word suicide in our programming languages. By some estimates, 350 million people worldwide suffer from depression. The semantics of Ethereum's


=== EIP-7792 ===
TITLE: Verifiable logs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-21
REQUIRES: 6466

SUMMARY:
This EIP defines a method to make the `eth_getLogs` JSON-RPC response verifiable.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Configuration | Name | Value | | - | - | | `LOG_CONTRACT_ADDRESS` |

MOTIVATION:
The `eth_getLogs` endpoint is used by wallets to obtain the transaction history pertaining to an account or a topic. To verify correctness and completeness of the logs, a wallet would also have to obtain all block headers and check against their logs bloom. However, that mechanism is inefficient due

RATIONALE:
Making the `eth_getLogs` response verifiable adds the necessary security attributes to enable wallets to transition away from relying on trusted data providers, ultimately improving the wallet's privacy guarantees as it is no longer subject to the privacy policy of any given provider. ### Gas cost The gas cost produced


=== EIP-3336 ===
TITLE: Paged memory allocation for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-06
REQUIRES: 

SUMMARY:
Presently, the EVM charges for memory as a linear array starting at address 0 and extending to the highest address that has been read from or written to. This suffices for simple uses, but means that compilers have to generate programs that use memory compactly, which leads to wasted

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `PAGE_BITS` | 10 | | `PAGE_BASE_COST` | 96 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. ### Changes to memory allocation in EVM implementations Memory is now allocated

MOTIVATION:
Most modern computers implement "virtual memory" for userspace programs, where programs have access to a large address space, with pages of RAM that are allocated as needed by the OS. This allows them to distribute data throughout memory in ways that minimises the amount of reallocation and copying that

RATIONALE:
### Memory expansion gas cost The new gas cost follows the same curve as the previous one, while ensuring that the new gas cost is always less than or equal to the previous cost. This prevents existing programs that make assumptions about memory allocation gas costs from resulting in


=== EIP-7958 ===
TITLE: EVM64 - Little endian opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-05-26
REQUIRES: 7937

SUMMARY:
This EIP defines additional little endian opcodes that can be deployed alongside [EIP-7937](./eip-7937.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. We define the following gas cost constant: * `G_VERYLOW64`: 2 ### `BYTE64` `BYTE64` (0xc01a) is

MOTIVATION:
The core EIP that defines EVM64 (EIP-7937) is endianness-independent. This EIP defines those additional opcodes that must expose endianness. They are the bitwise opcode `BYTE64`, memory opcodes `MLOAD64` and `MSTORE64`, and stack opcodes `PUSH*64`.

RATIONALE:
For detailed rationale discussion, please see the core EVM64 definition [EIP-7937](./eip-7937.md).


=== EIP-5 ===
TITLE: Gas Usage for `RETURN` and `CALL*`
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-22
REQUIRES: 

SUMMARY:
This EIP makes it possible to call functions that return strings and other dynamically-sized arrays. Currently, when another contract / function is called from inside the Ethereum Virtual Machine, the size of the output has to be specified in advance. It is of course possible to give a larger

SPECIFICATION:
The gas and memory semantics for `CALL`, `CALLCODE` and `DELEGATECALL` (called later as `CALL*`) are changed in the following way (`CREATE` does not write to memory and is thus unaffected): Suppose the arguments to `CALL*` are `gas, address, value, input_start, input_size, output_start, output_size`, then, at the beginning of the

MOTIVATION:
In general, it is good practice to reserve a certain memory area for the output of a call, because letting a subroutine write to arbitrary areas in memory might be dangerous. On the other hand, it is often hard to know the output size of a call prior to

RATIONALE:
This way of dealing with the problem requires a minimal change to the Ethereum Virtual Machine. Other means of achieving a similar goal would have changed the opcodes themselves or the number of their arguments. Another possibility would have been to only change the gas mechanics if `output_size` is


=== EIP-2 ===
TITLE: Homestead Hard-fork Changes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-15
REQUIRES: 


=== EIP-1015 ===
TITLE: Configurable On Chain Issuance
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-20
REQUIRES: 


=== EIP-4520 ===
TITLE: Multi-byte opcodes prefixed by EB and EC.
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-12-01
REQUIRES: 

SUMMARY:
Reserve `0xEB` and `0xEC` for usage as extended opcode space.

SPECIFICATION:
For example, a new arithmetic opcode may be allocated to `0xEC 01`(`ADD`), and a novel opcode may be introduced at `0xEB F4`(`DELEGATECALL`). Triple byte opcodes may be doubly-prefixed by `0xEB EB`, `0xEC EC`, `0xEB EC` and `0xEC EB`. It is possible to allocate experimental opcodes to this triple-byte space

MOTIVATION:
It would be convenient to introduce new opcodes that are likely to be infrequently used, whilst also being able to have greater than 256 opcodes in total. As a single byte opcode is half the size of a double byte opcode, the greatest efficiency in code sizes will be

RATIONALE:
It was considered that two prefix bytes rather than one would be adequate for reservation as extension addresses. Both `0xEB` and `0xEC` were chosen to be part of the E-series of opcodes. For example, the `0xEF` byte is reserved for contracts conforming to the Ethereum Object Format. By having


=== EIP-2256 ===
TITLE: wallet_getOwnedAssets JSON-RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-08-29
REQUIRES: 5, 5, ,,  , 1, 5, 5, ,,  , 1, 4, 7, 4

SUMMARY:
There is no standardized way for a dApp to request a list of owned assets from a user. Now, each dApp needs to keep a list of all the popular or existing assets and check the user's balance against the blockchain, for each of these assets. This leads to

SPECIFICATION:
New JSON-RPC method to be added to web3 browsers: `wallet_getOwnedAssets`. This method is for dApp-wallet communication and only targets the assets that have already been whitelisted by the wallet, for the user account. **Arguments:** - type `address`, Ethereum address that owns the assets - options object, optional: - `chainId`

MOTIVATION:
There are financial dApps that require a list of owned assets from a user, for various purposes - calculating taxes, selecting customized payment options, etc. Each of these dApps are now forced to keep a list of popular assets (smart contract addresses, ABIs) and retrieve the user's data from

RATIONALE:
In order to avoid duplication of effort for dApps that require keeping a list of all or popular assets and to provide optimal UX, the `wallet_getOwnedAssets` JSON-RPC method is proposed. The `chainId` and `types` optional parameters enable dApps to provide options in order to restrict the selection list that


=== EIP-5027 ===
TITLE: Remove the limit on contract code size
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-21
REQUIRES: 1, 7, 0, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.

SPECIFICATION:
### Parameters | Constant | Value | | ------------------------- | ---------------- | | `FORK_BLKNUM` | TBD | | `CODE_SIZE_UNIT` | 24576 | | `COLD_ACCOUNT_CODE_ACCESS_COST_PER_UNIT` | 2600 | | `CREATE_DATA_GAS` | 200 | If `block.number >= FORK_BLKNUM`, the contract creation initialization can return data with any length, but the contract-related

MOTIVATION:
The motivation is to remove the limit on the code size so that users can deploy a large-code contract without worrying about splitting the contract into several sub-contracts. With the dramatic growth of dApplications, the functionalities of smart contracts are becoming more and more complicated, and thus, the sizes

RATIONALE:
### Gas Metering The goal is to measure the CPU/IO cost of the contract read/write operations reusing existing gas metering so that the resources will not be abused. - For code-size-related opcodes (`CODESIZE`/`EXTCODESIZE`), we would expect the client to implement a mapping from the hash of code to the


=== EIP-2481 ===
TITLE: eth/66 request identifier
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-01-17
REQUIRES: 2464

SUMMARY:
The `eth` protocol defines various request and response commands that are used to exchange data between Ethereum nodes. For example, to ask a peer node for a specific set of headers, a node sends it the [`GetBlockHeaders`](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md#getblockheaders-0x03) command. *Citing from the [`GetBlockHeaders` spec definition](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md#getblockheaders-0x03):* >`[block: {P, B_32}, maxHeaders: P,

SPECIFICATION:
Change the following message types in the `eth` protocol: * `GetBlockHeaders (0x03)` * **Current (eth/65):** `[block: {P, B_32}, maxHeaders: P, skip: P, reverse: P in {0, 1}]` * **Then (eth/66)**: `[request_id: P, [block: {P, B_32}, maxHeaders: P, skip: P, reverse: P in {0, 1}]]` * `BlockHeaders (0x04)` * **Current

MOTIVATION:
The lack of request identifiers in the request / response paris of the `eth` protocol puts unnecessary burden of code complexity into every Ethereum client. It also makes the communication slightly less efficient. Another argument can be made that the addition of request identifiers makes the protocol more aligned

RATIONALE:
**Q: The efficiency gains might encourage clients to flood their peers with too many simultaneous requests** Peers can always throttle or disconnect if they don't feel treated well. This is the same as today. **Q: If `les` already defines the commands like this, why not just use the `les`


=== EIP-7867 ===
TITLE: Flow Control Wallet Call Capability
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2025-01-17
REQUIRES: 5792

SUMMARY:
This proposal extends [EIP-5792](./eip-5792.md) to allow dapps to downgrade their required atomicity guarantees and control the behaviour after a failed/reverted call. It introduces the batch-scope concept of `strict` vs. `loose` atomicity, where a `strict` batch remains atomic in the face of chain reorgs and a `loose` batch does not;

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### RPC Interface The following subsections are modifications to the API endpoints from EIP-5792. If

MOTIVATION:
While the base EIP-5792 specification works extremely well for smart contract wallets, it does not allow the expression of the full range of flow control options that wallets can implement. For example, a dapp may only be submitting a batch for gas savings and not care about whether all

RATIONALE:
<!-- The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The current placeholder is acceptable for a draft. TODO:


=== EIP-1985 ===
TITLE: Sane limits for certain EVM parameters
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
Introduce an explicit value range for certain EVM parameters (such as gas limit, block number, block timestamp, size field when returning/copying data within EVM). Some of these already have an implicit value range due to various (practical) reasons.

SPECIFICATION:
If `block.number >= {FORK_BLOCK}`, the following value ranges are introduced. They restrict the results (i.e. values pushed to the stack) of the instructions listed below. 1. *gas*, *gas limit*, *block gas limit* is a range between `0` and `0x7fffffffffffffff` (`2**63 - 1`, `9223372036854775807`). It affects the following instructions: -

MOTIVATION:
Having such an explicit value range can help in creating compatible client implementations, in certain cases it can also offer minor speed improvements, and can reduce the effort needed to create consensus critical test cases by eliminating unrealistic edge cases.

RATIONALE:
These limits have been: - proposed by [EVMC] - implemented partially by certain clients, such as [Aleth], [geth], [Parity] and [ethereumjs] - allowed by certain test cases in the [Ethereum testing suite] - and implicitly also allowed by certain assumptions, such as due to gas limits some of these


=== EIP-7727 ===
TITLE: EVM Transaction Bundles
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-06-24
REQUIRES: 2718

SUMMARY:
This EIP introduces two new [EIP-2718](./eip-2718.md) transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native 'bundles', which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles

SPECIFICATION:
### Constants | Name | Value | | --- | --- | | DELEGATED_TX_TYPE | 0x05 | | BUNDLE_TX_TYPE | 0x06 | | BUNDLE_BASE_GAS_COST | TBD <!-- TODO --> | | BUNDLE_SIGNER_OPCODE_NUMBER | TBD <!-- TODO --> | ### New Transaction Payload Types Two new [EIP-2718](./eip-2718.md) transactions with types

MOTIVATION:
Currently, a single block builder has unrestricted control over the final sequencing of a block’s transactions. This poses a problem, as sequencing—the choice of who gets to interact with specific pieces of state and in what order—significantly influences value flow. The objective of this EIP is to allow more

RATIONALE:
### Allowing invalid transactions to be included in a `BUNDLE_TX_TYPE`'s `transactionList` Knowing how a transaction will execute is challenging without knowing the state root to which the transaction is applied. Creators of `BUNDLE_TX_TYPE` transactions can only access the previous block’s state root and cannot predict which transactions will precede


=== EIP-7938 ===
TITLE: Exponential Gas Limit Increase
TYPE: Informational 
STATUS: Stagnant
CREATED: 2025-04-27
REQUIRES: 

SUMMARY:
This proposal introduces a deterministic gas limit growth schedule via client-side defaults. Ethereum clients will vote to increase the gas limit according to an exponential schedule unless explicitly configured otherwise by the user. The gas limit increase occurs every beacon chain epoch, aligned to a factor-of-10 increase every approximately

SPECIFICATION:
### Schedule Let `G0 = 50,000,000` be the gas limit at the activation epoch. Let the activation epoch be Ethereum beacon chain **epoch 369017**, which corresponds to approximately June 1, 2025. Let `t` be the current beacon chain epoch and `t0 = 369017` be the activation epoch. Let `T

MOTIVATION:
The current gas limit mechanism relies on miner/operator voting, which lacks coordination and predictability. While flexible, this approach can lead to stagnation or overly cautious increases. By introducing a predictable exponential growth pattern as a client default, this EIP encourages a sustainable and transparent gas limit trajectory, aligned with

RATIONALE:
This EIP maintains Ethereum's current gas voting mechanism but enhances it with a predictable and community-coordinated trajectory. By distributing responsibility across clients rather than enforcing protocol changes via consensus rules, this proposal offers flexibility while encouraging scalability. The exponential growth model ensures gradual but significant increases, allowing the network


=== EIP-150 ===
TITLE: Gas cost changes for IO-heavy operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-09-24
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then: - Increase the gas cost of EXTCODESIZE to 700 (from 20). - Increase the base gas cost of EXTCODECOPY to 700 (from 20). - Increase the gas cost of BALANCE to 400 (from 20). - Increase the gas cost of SLOAD to 200 (from

RATIONALE:
Recent denial-of-service attacks have shown that opcodes that read the state tree are under-priced relative to other opcodes. There are software changes that have been made, are being made and can be made in order to mitigate the situation; however, the fact will remain that such opcodes will be


=== EIP-8115 ===
TITLE: Batch priority fees at end of block
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-12-30
REQUIRES: 1, 5, 5, 9, ,,  , 4, 8, 9, 5

SUMMARY:
This EIP defines how to optimize processing of priority fees from [EIP-1559](./eip-1559.md) fee market transactions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### Priority fee processing [EIP-1559](./eip-1559.md) priority fees SHALL no longer be credited after each individual

MOTIVATION:
Priority fees are credited at the end of each transaction, leading to these complications: 1. **Limited parallelization:** Each transaction writes to the fee recipient account balance. 2. **Mempool complexities:** A transaction sender may become solvent only after prior transactions in a block have been processed. 3. **Accounting complexities:** The

RATIONALE:
This EIP is one step towards fully accurate ETH balance logs. Batched crediting of priority fees improves parallel execution of transactions, as a transaction can no longer start with insufficient fees and only become eligible for execution after incremental priority fees have been credited.


=== EIP-616 ===
TITLE: SIMD Operations for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-04-25
REQUIRES: 


=== EIP-7889 ===
TITLE: Emit log on revert
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-02-20
REQUIRES: 

SUMMARY:
All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.

SPECIFICATION:
### Parameters <!-- TODO --> * `REVERTTOPIC`: `TBD` * `DATA_LIMIT`: `TBD` ### Functionality Whenever `REVERT` is called with non-zero size, emit a log identical to a LOG1 with the topic `REVERTTOPIC`. The log data is the raw bytes of the revert message. The data is truncated to `DATA_LIMIT`.

MOTIVATION:
Revert messages are currently inaccessible to users as they are not available via standard RPC. Instead, users have to request a node to trace the transaction and check the stack and memory at the moment when the REVERT opcode was executed. This introduces overhead for users and nodes -

RATIONALE:
This is the simplest possible implementation that allows revert messages to be accessible via RPC methods. It does not require any changes to client libraries, or other RPC consumers as it is backward compatible. It does not introduce new RPC methods or new opcodes.


=== EIP-7668 ===
TITLE: Remove bloom filters
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.

SPECIFICATION:
The logs bloom of an execution block is now required to be empty (ie. 0 bytes long). The logs bloom of a transaction receipt is now required to be empty (ie. 0 bytes long).

MOTIVATION:
Logs were originally introduced to give applications a way to record information about onchain events, which decentralized applications (dapps) would be able to easily query. Using bloom filters, dapps would be able to quickly go through the history, identify the few blocks that contained logs relative to their application,

RATIONALE:
This is a minimally disruptive way to remove the need to handle blooms from clients. A future EIP can later clean up by removing this field entirely, along with other fields that have been deprecated. Gas costs of LOG are not reduced, because while the externality of polluting the


=== EIP-7896 ===
TITLE: ABI attachment in `wallet_sendCalls`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2025-02-27
REQUIRES: 5792

SUMMARY:
This EIP extends [EIP-5792](./eip-5792.md) with a new `interfaces` capability, whereby an application can attach the contract interface specifications (aka. ABIs) that the wallet needs to reliably decode the calldata in the request.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A new capability called `interfaces` is added to EIP-5792 requests. ### `wallet_sendCalls` When this capability

MOTIVATION:
The security model of Ethereum accounts relies on a separation of concerns between applications and wallets, the latter being responsible for securing private key material and providing restricted access to it. When an application requests a transaction or a signature, the wallet prompts the user to accept it or

RATIONALE:
<!-- TODO -->


=== EIP-7713 ===
TITLE: Box type for EIP-712 messages
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2024-05-23
REQUIRES: 712

SUMMARY:
This EIP defines a new type `box` for use in [EIP-712](./eip-712.md) messages. A `box` value is a value of an arbitrary struct type whose underlying type is encapsulated and hidden from the outer struct but transparent and type-checkable by the wallet, and thus able to be fully inspected by

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. EIP-712 is extended as follows: ### Typed structured data A struct type may contain a

MOTIVATION:
EIP-712 signatures have become a widely used primitive for users to express and authorize intents off-chain. Wide-ranging applications are able to define parameterized messages for users to sign in their wallet through a general-purpose interface that clearly surfaces the type, parameters, and domain of authorization. This crucially applies to

RATIONALE:
TBD <!-- TODO -->


=== EIP-2488 ===
TITLE: Deprecate the CALLCODE opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-12-20
REQUIRES: 7

SUMMARY:
Deprecate `CALLCODE` in a *somewhat* backwards compatible way, by making it always return failure.

SPECIFICATION:
If `block.number >= FORK_BLOCK`, the `CALLCODE` (`0xf2`) instruction always returns `0`, which signals failure.

MOTIVATION:
`CALLCODE` was part of the Frontier release of Ethereum. In the first few weeks/months it became clear that it cannot accomplish its intended design goal. This was rectified with introducing `DELEGATECALL` ([EIP-7](./eip-7.md)) in the Homestead update (early 2016). `CALLCODE` became never utilized, but it still puts a burden on

RATIONALE:
It would be possible just to remove the opcode and exceptionally abort if it is encountered. However, by returning failure, the contract has a chance to act on it and potentially recover.


=== EIP-4345 ===
TITLE: Difficulty Bomb Delay to June 2022
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-10-05
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 10_700_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
Targeting for The Merge to occur before June 2022. If it is not ready by then, the bomb can be delayed further.

RATIONALE:
The following script predicts a ~0.1 second delay to block time by June 2022 and a ~0.5 second delay by July 2022. This gives reason to address because the effect will be seen, but not so much urgency we don't have space to work around if needed. ```python def


=== EIP-7903 ===
TITLE: Remove Initcode Size Limit
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-03-05
REQUIRES: 1, 7, 0, ,,  , 3, 8, 6, 0

SUMMARY:
This EIP proposes the removal of the `initcode` size limit of 49152 bytes introduced in [EIP-3860](./eip-3860). The restriction complicates deploying multiple contracts addressing the [EIP-170](./eip-170) limit (24576 bytes) within a single transaction, while the existing gas metering for `initcode`, already ensures fair `initcode` costing, including for `JUMPDEST` analysis.

SPECIFICATION:
Revert the `initcode` size limit introduced in EIP-3860. Specifically: - Remove the 49152-byte cap on `initcode` size during contract creation. - Retain existing gas costs for `initcode` execution, including the 2 gas per byte for `JUMPDEST` analysis, as defined in EIP-3860. No changes to deployed contract size limits (EIP-170)

MOTIVATION:
The EIP-3860 `initcode` size limit imposes an unnecessary constraint on deployment patterns, particularly for creation transactions creating large _logical_ contracts composed of multiple _physical sub-contracts_ in a single transaction. A key argument for retaining EIP-170's 24KB runtime code limit is that high-level languages (HLLs) should abstract it away. However,

RATIONALE:
This proposal is driven by the need to restore flexibility in contract deployment patterns, such as factory contracts creating multiple sub-contracts in one transaction. The design decision to remove the 49152-byte cap leverages the pre-existing gas metering system, which scales linearly with `initcode` size (i.e., 2 gas per byte),


=== EIP-2228 ===
TITLE: Canonicalize the name of network ID 1 and chain ID 1
TYPE: Informational 
STATUS: Final
CREATED: 2019-08-04
REQUIRES: 

SUMMARY:
The name for the Ethereum network with network ID 1 and chain ID 1 shall be Ethereum Mainnet or just Mainnet. This is a proper noun. This standard specifies the name for this network and provides reference examples in an effort to standardize the word choice and provide a

SPECIFICATION:
The network name for network ID 1 and chain ID 1 shall be Ethereum Mainnet, or just Mainnet if the context is known to be discussing Ethereum networks. This IS a proper noun. Several examples are given below which differentiate between usage of the name of the network versus

MOTIVATION:
The Ethereum network with network ID 1 and chain ID 1 is referenced using several conflicting names across EIPs, client implementations, and information published on the internet at large. In several locations, even documents written by the same author use inconsistent names to refer to the Ethereum network with

RATIONALE:
Choosing common word use promotes interoperability of implementations and increases customer awareness. Also, it adds a sense of professionalism when customers see the same word and word styling (i.e. capitalization of letters) across different implementations. Anybody that has travelled to certain countries and seen an "IPhone [sic]" repair store


=== EIP-8094 ===
TITLE: eth/vhash - Blob-Aware Mempool
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2025-11-29
REQUIRES: 7642

SUMMARY:
This EIP eliminates the need to redistribute blob content in the mempool if only the metadata (fees) of a transaction are updated, making RBF (replace-by-fee) more efficient and cheaper for the network. It achieves this modifying the devp2p ‘eth’ protocol to address blobs in type 3 transaction sidecars by

SPECIFICATION:
### Transactions (0x02) changes Type 3 transaction should be sent without sidecar ### PooledTransactions (0x0a) changes Type 3 transaction should be sent without sidecar ### GetPooledBlobs (msg code to be assigned <-- TODO -->) [request-id: P, [vhash₁: B_32, vhash₂: B_32, ...]] This message requests blobs from the recipient's transaction

MOTIVATION:
In the current version of devp2p eth/69, when a transaction is replaced, it must be redistributed in the mempool like any new transaction. Even if the actual content is largely the same, protocol participants have no means to figure this out before getting the full content, making a replacement

RATIONALE:
A typical blob transaction RBF changes the fees only, while the sidecar (blob content) remains the same. If a node that has the previous version would know this, it could avoid pulling the sidecar, largely reducing bandwidth consumption. However, this is not possible with the current messaging. To make


=== EIP-3300 ===
TITLE: Phase out refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-26
REQUIRES: 

SUMMARY:
This EIP would define a block when the `SSTORE` and `SELFDESTRUCT` refunds would begin to diminish. The refund would step linearly downward, eroding the implicit value of such refunds at an accelerating pace.

SPECIFICATION:
Parameters: * `FORK_BLOCK_NUM`: EIP-3300 activation block * `REFUND_DECAY_STEP`: 1 gas * `REFUND_DECAY_FREQUENCY`: 100 blocks Computed: * `REFUND_DECAY`: `REFUND_DECAY_STEP * ceil((block.number + 1 - FORK_BLOCK_NUM) / REFUND_DECAY_FREQUENCY)` On the block this EIP activates, and again every `REFUND_DECAY_FREQUENCY` blocks, all gas refunds, including `SELFDESTRUCT` and `SSTORE` would diminish by `REFUND_DECAY_STEP`, until

MOTIVATION:
Refunds increase block elasticity, so the block gas target can exceed the number established by miners by up to 2x. This can cause hesitancy for miners to increase the block gas target. Refunds, tokenized or not, are valuable to their holders, especially during congestion. If refunds must be removed,

RATIONALE:
Persisted refunds would become worthless before they fall below their activation cost. Once the refunds are worthless, they can be removed by another hard fork without waiting for 0. The rate of diminishing specified would currently require (24000-5000) * 100 = 1,900,000 blocks for `SELFDESTRUCT` and (15000-5000) * 100


=== EIP-7519 ===
TITLE: Atomic Storage Operations SCREDIT and SDEBIT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-09-16
REQUIRES: 2, 2, 0, 0, ,,  , 2, 9, 2, 9

SUMMARY:
Two new opcodes that atomically mutate smart contract storage are proposed: SCREDIT, which increments a storage slot by a specified value, and SDEBIT, which decrements a storage slot by a specified value. Overflow and underflow errors are enforced, reverting when an unsigned 256-bit integer would overflow or underflow.

SPECIFICATION:
Two operations to atomically increment and decrement a storage will be introduced at `0xTBD`. Each operation takes two stack arguments and has no immediate arguments. Gas schedule will be the same as SSTORE. | Mnemonic | Op | Input | Output | |-----------|-----------|-------|--------| | `SCREDIT` | `0xTBD` | `2`

MOTIVATION:
There has been a large amount of energy around parallel EVMs across multiple chains, however there is a lack of parallel primitives within the EVM to support any model other than optimistic concurrency control (OCC). By adding concurrent increment and decrement operations more advanced parallel environments can be introduced

RATIONALE:
The primary consideration when choosing between alternatives is that the primary intended audiences is token contracts and other asset-tracking contracts combined with a desire to ship the minimum necessary changes to enable that use case. General concurrency controls is not a goal of this EIP. ### Enforcing Overflow Semantics


=== EIP-8059 ===
TITLE: Gas Units Rebase for High-precision Metering
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-22
REQUIRES: 

SUMMARY:
This proposal rebases Ethereum’s gas unit to a factor of `REBASE_FACTOR` to enable high-precision metering without introducing fractional gas. All gas-related parameters and variables are increased to a factor of `REBASE_FACTOR`. This reduces rounding errors that arise when repricing EVM operations and future-proofs gas costs as hardware improves and

SPECIFICATION:
| **Parameter** | **Value** | |:---:|:---:| | `REBASE_FACTOR` | 1000 | This proposal introduces a gas rebase such that all gas-related parameters and variables are increased by a factor of `REBASE_FACTOR`. At fork boundary, `calculate_base_fee_per_gas` is updated so that both `parent_gas_used` and `parent_base_fee_per_gas` are also scaled by a factor

MOTIVATION:
Currently, most EVM compute operations (`ADD`, `SUB`, `MUL`, etc.) are significantly underpriced when compared with state operations (`SSTORE`, `SLOAD`, `CREATE`, etc.). There are two factors contributing to this mismatch. On one hand, client optimizations and hardware improvements have made pure compute operations more efficient. On the other hand, with

RATIONALE:
A rebase factor of 1000 has two advantages: 1. It is large enough to completely remove rounding errors for compute operations now and to be future-proof. As we can see from the motivation, an anchor of 400Mgas/s would be enough to reduce these errors. Assuming a 2-second block execution


=== EIP-615 ===
TITLE: Subroutines and Static Jumps for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2016-12-10
REQUIRES: 

SUMMARY:
EVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine—including the compilers—are sufficiently performant to reduce the need for precompiles and otherwise meet the network's long-term demands.

SPECIFICATION:
### Dependencies > **[EIP-1702](./eip-1702.md). Generalized Account Versioning Scheme.** This proposal needs a versioning scheme to allow for its bytecode (and eventually eWasm bytecode) to be deployed with existing bytecode on the same blockchain. ### Proposal We propose to deprecate two existing instructions—`JUMP` and `JUMPI`—and propose new instructions to support

MOTIVATION:
Currently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack. Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs. So dynamic jumps cannot be avoided, yet they obscure

RATIONALE:
This design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment. It was also informed by the lead author's previous work implementing Java and Scheme interpreters. As such there was very little room for alternative designs. As


=== EIP-5000 ===
TITLE: MULDIV instruction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-03-14
REQUIRES: 

SUMMARY:
Introduce a new instruction, `MULDIV(x, y, z)`, to perform `((x * y) / z) % 2**256` in 512-bit precision. `z = 0` is a special case for `(x * y) / 2**256`.

SPECIFICATION:
A new instruction is introduced: `MULDIV` (`0x1e`). - Pops 3 values from the stack, first `x`, then `y` and `z`. - If `z == 0`, `r = (uint512(x) * y) / 2**256`. - Otherwise `r = (uint512(x) * y / z) % 2**256`, where the intermediate calculation is performed

MOTIVATION:
Fixed point operations in high level languages are very commonly used on Ethereum, especially in the domain of financial applications. While fixed point addition and subtraction can be done with merely `add` and `sub` respectively, being able to efficiently do fixedpoint multiplication and division is a very sought after

RATIONALE:
### The special 0 case All the arithmetic instructions in EVM handle division or modulo 0 specially: the instructions return 0. We have decided to break consistency in order to provide a flexible opcode, which can be used to detect wrapping behaviour. Alternate options include: - Returning a flag


=== EIP-7688 ===
TITLE: Forward compatible consensus data structures
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-04-15
REQUIRES: 6, 1, 1, 0, ,,  , 7, 0, 0, 2, ,,  , 7, 2, 5, 1, ,,  , 7, 4, 9, 5, ,,  , 7, 5, 4, 9, ,,  , 7, 5, 6, 9, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP defines the changes needed to adopt `ProgressiveContainer` from [EIP-7495](./eip-7495.md) and `ProgressiveList` from [EIP-7916](./eip-7916.md) in consensus data structures.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `Container` conversion `Container` types that are expected to evolve over forks SHALL be redefined

MOTIVATION:
Ethereum's consensus data structures make heavy use of [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md) `Container`, which defines how they are serialized and merkleized. The merkleization scheme allows application implementations to verify that individual fields (and partial fields) have not been tampered with. This is useful, for example, in smart contracts of decentralized

RATIONALE:
### Best timing? Applying this EIP breaks `hash_tree_root` and Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by a `Container` reaching a new power of


=== EIP-1872 ===
TITLE: Ethereum Network Upgrade Windows
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-03-25
REQUIRES: 

SUMMARY:
Four different weeks, spaced roughly evenly throughout the year, are targeted for network upgrades to be launched. Regular network upgrades should announce their intention to launch in a particular window early in their process and choose a block number four to six weeks prior to that window. If a

SPECIFICATION:
Scheduling is defined for three categories of network upgrades. First are `Roadmap` network upgrades that include deliberate protocol improvements. Next are `Priority` network updates, where there are technical reasons that necessitate a prompt protocol change but these reasons do not present a systemic risk to the protocol or the

MOTIVATION:
The aim of this EIP is to provide some level of regularity and predictability to the Ethereum network upgrade/hard fork process. This will allow service providers such as exchanges and node operators a predictable framework to schedule activities around. This also provides a framework to regularize the delivery of

RATIONALE:
The rationale for defining launch windows is to give business running Ethereum infrastructure a predictable schedule for when upgrades may or may not occur. Knowing when a upgrade is not going to occur gives the businesses a clear time frame within which to perform internal upgrades free from external


=== EIP-7778 ===
TITLE: Block Gas Accounting without Refunds
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-01
REQUIRES: 

SUMMARY:
This EIP modifies the block gas accounting mechanism to prevent the circumvention of block gas limits. It proposes that gas refunds, particularly those from SSTORE operations setting storage slots to zero, should not reduce the gas counted toward the block gas limit, while still being applied to transaction gas

SPECIFICATION:
### Gas Accounting Changes 1. **Block Gas Accounting (Modified):** - When calculating gas for block gas limit enforcement, refunds are not subtracted - Block gas accounting becomes: `block.gas_used += max(tx_gas_used, calldata_floor_gas_cost)` (incorporating the calldata floor from [EIP-7623](./eip-7623.md)) - Storage discounts that reflect actual reduced computational work (e.g., warm storage

MOTIVATION:
Currently, gas refunds from operations like clearing storage slots (setting to zero) reduce both the transaction gas cost for users and the gas counted toward the block gas limit. This creates a discrepancy between the computational work performed and the gas accounted for in the block. Example: Block `20878522`

RATIONALE:
### Aligning Gas Limits with Computational Work The block gas limit is designed to constrain the computational load per block. Gas refunds were introduced to incentivize "cleaning up" the state, not to allow exceeding computational limits. By excluding refunds from block gas accounting, we ensure the block gas limit


=== EIP-7732 ===
TITLE: Enshrined Proposer-Builder Separation
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-06-28
REQUIRES: 

SUMMARY:
This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being a *builder*) and a new duty (submitting *payload timeliness attestations*) to Ethereum validators.

SPECIFICATION:
### Execution Layer No changes are required. ### Consensus Layer The full consensus changes can be found in the consensus-specs Github repository. They are split between: - [Beacon Chain](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/beacon-chain.md) changes. - [Fork choice](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/fork-choice.md) changes. - [P2P](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/p2p-interface.md) changes. - [Honest validator guide](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/validator.md) changes. - A new [honest builder](https://github.com/ethereum/consensus-specs/blob/9e2dc0bcf9aa17b549e1df4712b16a5709d74119/specs/_features/eip7732/builder.md) guide. -

MOTIVATION:
This EIP solves a different set of unrelated important problems. - An overwhelming majority of beacon block proposers outsource the construction of the execution payload within their blocks to a third party (henceforth called a *builder*). In order to do so, they request the hash tree root (HTR) of

RATIONALE:
### Staked builders Being a builder is a new attribution of validators. As such builders are staked in the beacon chain and they have their own withdrawal credential prefix. This allows for in-protocol trustless enforcement of the builder's payment to the proposer. Alternatively, payment could be enforced in the


=== EIP-3298 ===
TITLE: Removal of refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-02-26
REQUIRES: 

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. Do not apply the `refund`. The description above is sufficient to describe the change, but for the sake of clarity we enumerate

MOTIVATION:
Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It

RATIONALE:
A full removal of refunds is the simplest way to solve the issues with refunds; any gains from partial retention of the refund mechanism are not worth the complexity that that would leave remaining in the Ethereum protocol.


=== EIP-3076 ===
TITLE: Slashing Protection Interchange Format
TYPE: Standards Track Interface
STATUS: Last Call
CREATED: 2020-10-27
REQUIRES: 

SUMMARY:
A standard format for transferring a key's signing history allows validators to easily switch between clients without the risk of signing conflicting messages. While a common keystore format provides part of the solution, it does not contain any information about a key's signing history. For a validator moving their

SPECIFICATION:
### JSON Schema A valid interchange file is one that adheres to the following JSON schema, and is interpreted according to the [Conditions](#conditions). ```json { "title": "Signing history", "description": "This schema provides a record of the blocks and attestations signed by a set of validators", "type": "object", "properties": {

MOTIVATION:
The proof of stake (PoS) protocol penalises validators for voting in ways that could result in two different versions of the chain being finalised. These types of penalties are called slashings. For a validator following the protocol correctly, there is, in principle, no risk of being slashed. However, changing

RATIONALE:
### Supporting Different Strategies The interchange format is designed to be flexible enough to support the full variety of slashing protection strategies that clients may implement, which may be categorised into two main types: 1. **Complete**: a database containing every message signed by each validator. 2. **Minimal**: a database


=== EIP-2026 ===
TITLE: State Rent H - Fixed Prepayment for accounts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-14
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces a fixed charge for state expansion that comes from adding new accounts to the state. Theoretically, it puts a bound on the number of accounts that can be ever created, because that fixed charge cannot be recycled

SPECIFICATION:
On and after block `H`, every newly created account gets a new field `rentbalance` of type unsigned 256-bit integer. On and after block `H`, any operation that leads to the creation of a new account, deducts the amount `ACCOUNT_PREPAYMENT` from `tx.origin`. This amount is added to the `rentbalance` field

MOTIVATION:
The penalty is levied to the transaction sender. Rather than raising the gas cost of account creation (that would direct levy towards the miner), this change directs prepayment into the account's special field, `rentbalance`. It addresses several shortcomings of the simple raising of the gas cost: 1. Prepayments cannot

RATIONALE:
Prior to rent prepayments, other alternatives were considered: 1. Simple raising of the gas cost - discussed in the Motivation section. 1. In [first version of State Rent proposal](https://github.com/ledgerwatch/eth_state/blob/master/State_rent.pdf), there was no notion of extra levy upon account creation. It created a slight usability issue, where newly created contracts


=== EIP-2542 ===
TITLE: New opcodes TXGASLIMIT and CALLGASLIMIT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-29
REQUIRES: 

SUMMARY:
Currently, there is an existing opcode `0x45 GASLIMIT` that provides access to the block gas limit. While this information may be useful in some cases, it is probably not a value that smart contract developers may be concerned about. The opcode `0x5a GAS` provides the remaining gas, not the

SPECIFICATION:
If block.number >= TBD, add three new opcodes: TXGASLIMIT: 0x5c Pushes the gas limit of the entire transaction onto the stack. This is a value of the 'startgas' parameter signed by the externally owned account. Gas costs: 2 (same as `GASLIMIT`) CALLGASLIMIT: 0x5d Pushes the gas limit of the

MOTIVATION:
As concepts of relaying, meta-transactions, gas fees, and account abstraction gain popularity, it becomes critical for some contracts to be able to track gas expenditure with absolute precision. Without access to this data on an EVM level, such contracts resort to approximation, mimicking EVM logic on-chain, and some use-cases

RATIONALE:
Consider a solidity smart contract that wants to know how much gas the entire transaction or a part of it had consumed. It is not entirely possible with the current EVM. With proposed changes, using a pseudo-Solidity syntax, this information would be easily available: ``` function keepTrackOfGas(string memory message,


=== EIP-5133 ===
TITLE: Delaying Difficulty Bomb to mid-September 2022
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-06-01
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 11_400_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
To avoid network degradation due to a premature activation of the difficulty bomb.

RATIONALE:
The following script predicts the bomb will go off at block 15530314, which is expected to be mined around mid-September. ```python import math def predict_bomb_block(current_difficulty, diff_adjust_coeff, block_adjustment): ''' Predicts the block number at which the difficulty bomb will become noticeable. current_difficulty: the current difficulty diff_adjust_coeff: intuitively, the percent increase


=== EIP-695 ===
TITLE: Create `eth_chainId` method for JSON-RPC
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-08-21
REQUIRES: 155

SUMMARY:
The `eth_chainId` method should return a single STRING result for an integer value in hexadecimal format, describing the currently configured `CHAIN_ID` value used for signing replay-protected transactions, introduced by [EIP-155](./eip-155.md).

SPECIFICATION:
### `eth_chainId` Returns the currently configured chain ID, a value used in replay-protected transaction signing as introduced by [EIP-155](./eip-155.md). The chain ID returned should always correspond to the information in the current known head block. This ensures that caller of this RPC method can always use the retrieved information

MOTIVATION:
Currently although we can use `net_version` RPC call to get the current network ID, there's no RPC for querying the chain ID. This makes it impossible to determine the current actual blockchain using the RPC.

RATIONALE:
An ETH/ETC client can accidentally connect to an ETC/ETH RPC endpoint without knowing it unless it tries to sign a transaction or it fetches a transaction that is known to have signed with a chain ID. This has since caused trouble for application developers, such as MetaMask, to add


=== EIP-6963 ===
TITLE: Multi Injected Provider Discovery
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2023-05-01
REQUIRES: 1193

SUMMARY:
An alternative discovery mechanism to `window.ethereum` for [EIP-1193](./eip-1193.md) providers which supports discovering multiple injected Wallet Providers in a web page using Javascript's `window` events.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [RFC-2119]. ### Definitions Wallet Provider: A user agent that manages keys and facilitates transactions with Ethereum. Decentralized Application (DApp): A web page

MOTIVATION:
Currently, Wallet Provider that offer browser extensions must inject their Ethereum providers ([EIP-1193](./eip-1193.md)) into the same window object `window.ethereum`; however, this creates conflicts for users that may install more than one browser extension. Browser extensions are loaded in the web page in an unpredictable and unstable order, resulting in

RATIONALE:
The previous proposal introduced mechanisms that relied on a single, mutable window object that could be overwritten by multiple parties. We opted for an event-based approach to avoid the race conditions, the namespace collisions, and the potential for "pollution" attacks on a shared mutable object; the event-based orchestration creates


=== EIP-2935 ===
TITLE: Serve historical block hashes from state
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-09-03
REQUIRES: 

SUMMARY:
Store last `HISTORY_SERVE_WINDOW` historical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact on `BLOCKHASH` resolution mechanism (and hence its range/costs etc).

SPECIFICATION:
| Parameter | Value | | - | - | | `BLOCKHASH_SERVE_WINDOW` | `256` | | `HISTORY_SERVE_WINDOW` | `8191` | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | | `HISTORY_STORAGE_ADDRESS` | `0x0000F90827F1C53a10cb7A02335B175320002935` | This EIP specifies for storing last `HISTORY_SERVE_WINDOW` block hashes in a ring buffer storage of `HISTORY_SERVE_WINDOW` length. Note that

MOTIVATION:
EVM implicitly assumes the client has the recent block (hashes) at hand. This assumption is not future-proof given the prospect of stateless clients. Including the block hashes in the state will allow bundling these hashes in the witness provided to a stateless client. This is already possible in the

RATIONALE:
Very similar ideas were proposed before. This EIP is a simplification, removing two sources of needless complexity: 1. Having a tree-like structure with multiple layers as opposed to a single list 2. Writing the EIP in EVM code 3. Serial unbounded storage of hashes for a deep access to


=== EIP-2926 ===
TITLE: Chunk-Based Code Merkleization
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2020-08-25
REQUIRES: 1, 6, 1, ,,  , 1, 7, 0

SUMMARY:
Code merkleization, along with binarification of the trie and gas cost bump of state-accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing

SPECIFICATION:
What follows is structured to have two sections: 1. How a given contract code is split into chunks and then merkleized 2. How to merkleize all existing contract codes during a hardfork ### Constants and Definitions #### Constants - `CHUNK_SIZE`: 31 (bytes) - `VERSION_KEY`: `max(u256)` - `VERSION`: 0 -

MOTIVATION:
Bytecode is currently the second contributor to block witness size, after the proof hashes. Transitioning the trie from hexary to binary reduces the hash section of the witness by 3x, thereby making code the first contributor. By breaking contract code into chunks and committing to those chunks in a

RATIONALE:
### Hexary vs binary trie The trie format is chosen to be the same as that of the account trie. If a tree conversion happens at a later stage, the chunk tree will have to be converted as well, e.g. the way it is in [EIP-6800](./eip-6800.md) or [EIP-7864](./eip-7864.md). ###


=== EIP-7971 ===
TITLE: Hard Limits for Transient Storage
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-06-12
REQUIRES: 1153

SUMMARY:
This EIP proposes to reduce the gas costs for transient storage operations (`TLOAD` and `TSTORE`) by implementing constant pricing. To prevent denial-of-service attacks through excessive memory allocation, a transaction-global limit on transient storage slots is introduced. This approach provides lower costs for common use cases while maintaining security against

SPECIFICATION:
### Parameters This EIP introduces the following parameters: | Constant | Value | Description | | :--- | :--- | :--- | | `GAS_TLOAD` | 5 | Gas cost of `TLOAD` | | `GAS_TSTORE` | 12 | Gas cost of `TSTORE` | | `MAX_TRANSIENT_SLOTS` | 131072 | The maximum

MOTIVATION:
[EIP-1153](./eip-1153.md) introduced transient storage with gas costs equivalent to warm storage operations (100 gas). The current pricing model presents several limitations: 1. Reentrancy Protection Cost: At 100 gas per operation, implementing reentrancy locks by default remains expensive enough to discourage universal adoption at the language level, leaving contracts vulnerable

RATIONALE:
### Constant Pricing with Hard Limit This EIP implements constant pricing with a hard limit for several reasons: 1. A hard limit provides guarantees on the total resource consumption which are easier to reason about for clients, rather than needing to perform a calculation as a function of current


=== EIP-3788 ===
TITLE: Strict enforcement of chainId
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-09-02
REQUIRES: 155

SUMMARY:
Reject transactions that do not explicitly have the same chainId as the node's configuration.

SPECIFICATION:
As of the fork block `N`, consider transactions with a `chaindId = 0` to be invalid. Such that transactions are verified based on the nodes configuration. Eg: ``` if (node.cfg.chainId != tx.chainId) { // Reject transaction } ```

MOTIVATION:
Per [EIP-155](./eip-155.md) a transaction with a `chainId = 0` is considered to be a valid transaction. This was a feature to offer developers the ability to submit replayable transactions across different chains. With the rise of evm compatible chains, many of which use forks, or packages from popular Ethereum

RATIONALE:
The configuration set by the node is the main source of truth, and thus should be explicitly used when deciding how to filter out a transaction. This check should exist in two places, as a filter on the JSON-RPC (eg: `eth_sendTransaction`), and strictly enforced on the EVM during transaction


=== EIP-2982 ===
TITLE: Serenity Phase 0
TYPE: Informational 
STATUS: Final
CREATED: 2020-09-15
REQUIRES: 

SUMMARY:
This EIP specifies Phase 0 of Serenity (eth2), a multi-phased upgrade to the consensus mechanism for Ethereum mainnet. In Phase 0, the existing PoW chain and mechanics are entirely unaffected, while a PoS chain -- the beacon chain -- is built in parallel to serve as the core of

SPECIFICATION:
Phase 0 is designed to require _no breaking consensus changes_ to existing Ethereum mainnet. Instead, this is the bootstrapping a new PoS consensus that can, once stable, supplant the current PoW consensus. Phase 0 specifications are maintained in a repository independent of this EIP. `SPEC_RELEASE_VERSION` release of the specs

MOTIVATION:
Eth2 aims to fulfill the original vision of Ethereum to support an efficient, global-scale, general-purpose transactional platform while retaining high cryptoeconomic security and decentralization. Today, Ethereum blocks are consistently full due to increasingly high demand for decentralized applications. Ever since the first serious spikes in adoption in 2017 (cryptokitties),

RATIONALE:
### Principles * **Simplicity**: especially since cryptoeconomic proof of stake and quadratic sharding are inherently complex, the protocol should strive for maximum simplicity in its decisions as much as possible. This is important because it (i) minimizes development costs, (ii) reduces risk of unforeseen security issues, and (iii) allows


=== EIP-2537 ===
TITLE: Precompile for BLS12-381 curve operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-02-21
REQUIRES: 

SUMMARY:
Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification. Along with the curve arithmetic, multi-scalar-multiplication operations are included to efficiently aggregate public keys or individual signer's signatures during BLS signature verification.

SPECIFICATION:
### Constants | Name | Value | Comment | |---------------------|-------|--------------------| | BLS12_G1ADD | 0x0b | precompile address | | BLS12_G1MSM | 0x0c | precompile address | | BLS12_G2ADD | 0x0d | precompile address | | BLS12_G2MSM | 0x0e | precompile address | | BLS12_PAIRING_CHECK | 0x0f | precompile address

MOTIVATION:
The motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security.

RATIONALE:
The motivation section covers a total motivation to have operations over the BLS12-381 curves available. We also extend a rationale for more specific fine points. ### MSM as a separate call Explicit separate MSM operation that allows one to save execution time (so gas) by both the algorithm used


=== EIP-1355 ===
TITLE: Ethash 1a
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-08-26
REQUIRES: 

SPECIFICATION:
1. Define hash function `fnv1a()` as ```python def fnv1a(v1, v2): return ((v1 ^ v2) * FNV1A_PRIME) % 2**32 ``` where `FNV1A_PRIME` is 16777499 or 16777639. 2. Change the hash function that determines the DAG item index in Ethash algorithm from `fnv()` to new `fnv1a()`. In [Main Loop](https://github.com/ethereum/eth-wiki/blob/master/concepts/ethash/ethash.md#main-loop) change ```python

MOTIVATION:
Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.

RATIONALE:
The usual argument for decentralization and network security. Unless programmable, an ASIC is hardwired to perform sequential operations in a given order. fnv1a changes the order in which an exclusive-or and a multiply are applied, effectively disabling the current wave of ASICS. A second objective is minimize ethash changes


=== EIP-3403 ===
TITLE: Partial removal of refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-16
REQUIRES: 

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `SSTORE_REFUND_GAS` | 19000 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. 1. Remove the `SELFDESTRUCT` refund. 2. Remove the `SSTORE` refund in all cases except for one specific

MOTIVATION:
Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It

RATIONALE:
Preserving refunds in the `new = original = 0 != current` case ensures that a few key use cases that deserve favorable gas cost treatment continue to receive favorable gas cost treatment, particularly: * Anti-reentrancy locks (typically flipped from 0 to 1 right before a child call begins, and


=== EIP-1679 ===
TITLE: Hardfork Meta: Istanbul
TYPE: Meta 
STATUS: Final
CREATED: 2019-01-04
REQUIRES: 1, 5, 2, ,,  , 1, 1, 0, 8, ,,  , 1, 3, 4, 4, ,,  , 1, 7, 1, 6, ,,  , 1, 8, 8, 4, ,,  , 2, 0, 2, 8, ,,  , 2, 2, 0, 0

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Istanbul.

SPECIFICATION:
- Codename: Istanbul ### Activation - `Block >= 9,069,000` on the Ethereum Mainnet - `Block >= 6,485,846` on the Ropsten testnet - `Block >= 14,111,141` on the Kovan testnet - `Block >= 5,435,345` on the Rinkeby testnet - `Block >= 1,561,651` on the Görli testnet ### Included EIPs -


=== EIP-101 ===
TITLE: Serenity Currency and Crypto Abstraction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2015-11-15
REQUIRES: 

SPECIFICATION:
1. Accounts now have only two fields in their RLP encoding: **code** and **storage**. 2. Ether is no longer stored in account objects directly; instead, at address `0`, we premine a contract which contains all ether holdings. The `eth.getBalance` command in web3 is remapped appropriately. 3. `msg.value` no longer

RATIONALE:
This allows for a large increase in generality, particularly in a few areas: 1. Cryptographic algorithms used to secure accounts (we could reasonably say that Ethereum is quantum-safe, as one is perfectly free to secure one's account with Lamport signatures). The nonce-incrementing approach is now also open to revision


=== EIP-7441 ===
TITLE: Upgrade block proposer election to Whisk
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-09-01
REQUIRES: 

SUMMARY:
Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.

SPECIFICATION:
### Execution layer This requires no changes to the Execution Layer. ### Consensus layer The protocol can be summarized in the following concurrent steps: - Validators register a tracker and unique commitment on their first proposal after the fork - At the start of a shuffling phase a list

MOTIVATION:
The beacon chain currently elects the next 32 block proposers at the beginning of each epoch. The results of this election are public and everyone gets to learn the identity of those future block proposers. This information leak enables attackers to launch DoS attacks against each proposer sequentially in

RATIONALE:
### Fields per validator Whisk requires having one tracker `(rG,krG)` and one unique commitment `kG` per validator. Both are updated only once on a validator's first proposal after the fork. Trackers are registered with a randomized base `(rG,krG)` to make it harder for adversaries to track them through shuffling


=== EIP-6914 ===
TITLE: Reuse Withdrawn Validator Indices
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-19
REQUIRES: 

SUMMARY:
Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.

SPECIFICATION:
### Consensus Layer The configuration values and mechanics of the specification can be found in the [Consensus Layer specs](https://github.com/ethereum/consensus-specs/blob/1a38b83e5db8638ee01c9461cccf11e7d8a3ebce/specs/_features/eip6914). Note that validator indices are reused in the event that the validator has been fully withdrawn *and* that the validator has been withdrawable for a sufficient safe period. ### Execution

MOTIVATION:
The beacon chain maintains a list of validators and a separate list of balances associated with each validator. When a new deposit for a new validator occurs, the current mechanism only appends, rather than reusing previously fully withdrawn validator indices. As validators fully withdraw and new validators enter, this

RATIONALE:
The `validators` and `balances` lists are currently appended to each time a new Deposit for a new pubkey comes into the beacon chain. Due to the natural mechanics of stakers entering and leaving consensus over long time spans, these lists, thus the state size, will grow unbounded. Increased state


=== EIP-7707 ===
TITLE: Incentivize Access List Provisioning
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-12
REQUIRES: 2930

SUMMARY:
This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.

SPECIFICATION:
We shall update [EIP-2930](./eip-2930.md) parameters: | Constant | Value | | - | - | | `ACCESS_LIST_STORAGE_KEY_COST` | 320 | | `ACCESS_LIST_ADDRESS_COST` | 512 |

MOTIVATION:
While [EIP-2930](./eip-2930.md) introduced `accessLists` as a mechanism for `SLOAD` pre-warming to reduce gas costs by informing the EVM upfront about which storage slots a transaction will access, the practical use is limited and uncommon due to the savings versus penalties involved. In order to break even for each address

RATIONALE:
As stated in the introduction the gas cost benefit analysis does not encourage the users of the chain to provide accessList hints, even though the mechanism is already in protocol (and a call to `eth_createAccessList` will give them, or a wallet the correct list to include). So we propose


=== EIP-2378 ===
TITLE: EIPs Eligible for Inclusion
TYPE: Meta 
STATUS: Stagnant
CREATED: 2019-11-13
REQUIRES: 

SUMMARY:
The pipeline for Core EIPs, per the EIP-Centric upgrade model, is as follows. ``` [ DRAFT ] -> [ ELLIGLE FOR INCLUSION ] -> [ IMPLEMENTATION ] -> [ TESTING ] -> [ ACCEPTED ] -> [ DEPLOYED ] ``` This EIP documents all EIPs marked as **Eligible For

SPECIFICATION:
| EIP | Title | Pipeline Status | Date of Initial Decision | REF | | -------- | ----------------------------------------------------- | -------- | ---------- | ---- | | EIP-663 | Unlimited SWAP and DUP instructions | ELIGIBLE | 2019-11-01 | [🔗](https://github.com/ethereum/pm/blob/master/AllCoreDevs-EL-Meetings/Meeting%2074.md) | | EIP-1057 | ProgPoW, a Programmatic Proof-of-Work |

MOTIVATION:
Development of clear specifications and pull requests to existing Ethereum Clients is a large investment of time and resources. The state of *Eligible for Inclusion* is a signal from the Ethereum Core Developers to an EIP Author validiating the idea behind an EIP and confirms investing their time further

RATIONALE:
**EIP Number** **Title** **Pipeline Status** : Show the current status in the context of the EIP centric model. The list is sorted by furthest along in the process. **Date of Initial Decision** : Date of the initial decision for Eligibility for Inclusion **REF** : Link to the decision on


=== EIP-7976 ===
TITLE: Increase Calldata Floor Cost
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-06-18
REQUIRES: 7623

SUMMARY:
This EIP proposes an adjustment to calldata pricing by raising the floor cost from 10/40 to 15/60 gas per zero/non-zero calldata byte. This reduces the worst-case block size by ~33% with minimal impact.

SPECIFICATION:
| Parameter | Value | | ---------------------------- | ----- | | `STANDARD_TOKEN_COST` | `4` | | `TOTAL_COST_FLOOR_PER_TOKEN` | `15` | Let `tokens_in_calldata = zero_bytes_in_calldata + nonzero_bytes_in_calldata * 4`. Let `isContractCreation` be a boolean indicating the respective event. Let `execution_gas_used` be the gas used for EVM execution with the gas

MOTIVATION:
While [EIP-7623](./eip-7623.md) successfully reduced the maximum possible block size by introducing a floor cost of 10/40 gas per byte for data-heavy transactions, continued increases in gas limit demands further optimization. The current floor cost still permits relatively large data-heavy payloads that contribute to block size variance. By increasing the

RATIONALE:
With [EIP-7623](./eip-7623.md)'s implementation, data-heavy transactions cost 10/40 gas per zero/non-zero byte, reducing the maximum possible EL payload size to approximately 1.07 MB (`45s_000_000/40`). This EIP further reduces this to approximately 0.72 MB (`45_000_000/60`) for non zero bytes and maintains proportional costs for non-zero bytes. By increasing calldata costs from


=== EIP-2970 ===
TITLE: IS_STATIC opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-13
REQUIRES: 

SPECIFICATION:
Add a `IS_STATIC (0x4A)` opcode that pushes `1` if the current context is static (ie. the execution is in a `STATICCALL` or a descendant thereof, so state-changing operations are not possible), and `0` if it is not.

MOTIVATION:
The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA's security model) but not state-changing calls.

RATIONALE:
Determining staticness is already possibly using the following hacky technique: make a `CALL` with limited gas, and inside that `CALL` issue one `LOG` and exit. If the context is static, the `CALL` would fail and leave a 0 on the stack; if the context is non-static, the `CALL` would


=== EIP-7378 ===
TITLE: Add time-weighted averaging to the base fee
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-22
REQUIRES: 

SUMMARY:
This EIP proposes a new formula to update the base fee, derived from [EIP-1559](./eip-1559.md). The existing base fee update formula, $$b[i+1]\triangleq b[i] \cdot \left( 1+\frac{1}{8} \cdot \frac{s[i]-s^* }{s^* }\right)$$ only considers the last block size $s[i]$. This mechanism incentivizes proposers to collude with users to manipulate the base fee.

SPECIFICATION:
$s[i]$ is replaced by $s_{\textit{avg}}[i]$, where: $$s_{\textit{avg}}[i] \triangleq \alpha\sum_{k=1}^{\infty} (1-\alpha)^k\cdot s[i-k+1]$$ which simplifies to the recursive form $$s_{\textit{avg}}[i] = \alpha\cdot s[i] + (1-\alpha)\cdot s_{\textit{avg}}[i-1]$$ where $\alpha\in(0, 1)$ is the smoothing factor. A higher smoothing factor means that the average responds more quickly to changes in block size (e.g., if

MOTIVATION:
To reduce bribe motivation when the demand for blockspace is high (see Incentive Considerations section) and to reduce oscillations, thus, having a more stable fee setting mechanism. Proposers use a mechanism described in EIP-1559 to determine which messages to include in a block. This mechanism includes a "base fee":

RATIONALE:
An intuitive option for the Transaction Fee Mechanism (TFM) that adjusts supply and demand economically is *First price auction*, which is well known and studied. Nevertheless, the Ethereum network choice was to use EIP-1559 for the TFM (one stated reason was to try and simplify the fee estimation for


=== EIP-7966 ===
TITLE: eth_sendRawTransactionSync Method
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2025-06-11
REQUIRES: 

SUMMARY:
This EIP proposes a new JSON-RPC method, `eth_sendRawTransactionSync`, which submits a signed raw transaction and waits synchronously for the transaction receipt or a configurable timeout before returning. This method addresses the user experience gap in high-frequency applications by offering stronger delivery guarantees than `eth_sendRawTransaction`.

SPECIFICATION:
### Method Name `eth_sendRawTransactionSync` ### Parameters | Position | Type | Description | Required | |----------|--------|-----------------------------------|----------| | 1 | `DATA` | The signed transaction data | Yes | | 2 | `INT` | Maximum wait time in milliseconds | No | #### Parameter Validation Rules - **Transaction Data**. MUST

MOTIVATION:
Currently, Ethereum clients submit signed transactions asynchronously using `eth_sendRawTransaction`. Clients receive a transaction hash immediately but must poll repeatedly for the transaction receipt, which increases latency and complicates client-side logic. This asynchronous approach is not efficient for high-frequency blockchains or Layer 2 solutions with fast block times and low

RATIONALE:
### Why Not Extend Existing RPC? Modifying `eth_sendRawTransaction` to support this behavior would risk compatibility issues and ambiguity. A separate method makes the semantics explicit and opt-in. ### Node-Configured Timeouts Node implementations SHOULD allow configuration of the timeout period, defaulting to 2 seconds (depending on the implementation). This balances


=== EIP-1682 ===
TITLE: Storage Rent
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-11-10
REQUIRES: 

SUMMARY:
This EIP describes a scheme to charge for data in state, and 'archive' data which is no longer being paid for. It also describes how resurrection of 'archived' data happens.

SPECIFICATION:
The cost of storing an account over time is called `rent`. The amount of `rent` due depends on the size of the account. The `ether` that is paid for `rent` is destroyed. The `rent` is deducted whenever an account is touched. `rent` can be paid from the account's regular

MOTIVATION:
The Ethereum blockchain in its current form is not sustainable because it grows indefinitely. This is true of any blockchain, but Ethereum grows faster than most chains. Many implementation strategies to slow down growth exist. A common strategy is 'state pruning' which discards historical state, keeping only the active

RATIONALE:
### Why do we need a separate rent balance? Accounts need a separate rent balance because some contracts are non-payable, i.e. they reject regular value transfers. Such contracts might not be able to keep themselves alive, but users of those contracts can keep them alive by paying rent for


=== EIP-7975 ===
TITLE: eth/70 - partial block receipt lists
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2025-06-16
REQUIRES: 7, 6, 4, 2, ,,  , 7, 8, 2, 5

SUMMARY:
This EIP modifies the 'eth' p2p protocol to allow requesting partial block receipt lists.

SPECIFICATION:
Modify the encoding for receipts in the `Receipts (0x10)` message as follows: - (eth/69): `[request-id: P, [[receipt₁, receipt₂], ...]]` - (eth/70): `[request-id: P, lastBlockIncomplete: {0,1}, [[receipt₁, receipt₂], ...]]` If the `lastBlockIncomplete` flag is set to true (`1`), the last receipt list does not contain all receipts of the block,

MOTIVATION:
As Ethereum moves toward a higher block gas limit on mainnet, the worst-case total size of a block receipts list also becomes larger, and may eventually exceed the 10MiB message size limit commonly applied in clients. This can lead to sync failures.

RATIONALE:
Since [EIP-7825] caps the gas limit of a single transaction to ~16.7M gas, a single transaction receipt will always be limited in size. Specifically, a transaction can produce at most 16777216/8 = 2MiB of log data. However, a block can contain contain multiple transactions, and thus the entire block


=== EIP-7329 ===
TITLE: ERC/EIP Repository split
TYPE: Meta 
STATUS: Final
CREATED: 2023-07-13
REQUIRES: 1

SUMMARY:
Describes the motivation and rational for splitting the EIP repositories into an EIP repository, targeting core ethereum changes and an ERC repository, targeting application layer specifications.

SPECIFICATION:
This specification only details with the initial mechanism of the split. The particulars of how each repository will govern itself is out of scope for this EIP, as it is the motivating point of this EIP that the divergent needs of the community will require highly divergent methods. 1.

MOTIVATION:
Long ago when the EIPs repository was created, there was a vision of a single home for all standards related to Ethereum. The community was small and most people were interacting at every level of the ecosystem. It made sense to combine application standards with core consensus changes. Since

RATIONALE:
There are two major communities served by the EIP process that are highly divergent and very differentiated in their needs. Let's consider the impact of specification ambiguity, the impacts are different based on the community. The core protocol community has a low tolerance for difference of implementation and a


=== EIP-7568 ===
TITLE: Hardfork Meta Backfill - Berlin to Shapella
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-01
REQUIRES: 2, 0, 7, 0, ,,  , 2, 3, 8, 7, ,,  , 2, 9, 8, 2, ,,  , 6, 1, 2, 2, ,,  , 6, 9, 5, 3

SUMMARY:
Following Muir Glacier hard fork, Meta EIPs were abandoned in favor of other ways to track changes included in Ethereum network upgrades. This EIP aggregates the specifications for these upgrades, which themselves list the specific changes included. Specifically, it covers the Beacon Chain launch (Serenity Phase 0), Berlin, London,

SPECIFICATION:
The network upgrades below are listed in order of activation. Upgrades to Ethereum's execution layer are marked "[EL]", and those to Ethereum's consensus layer are marked "[CL]". ### Beacon Chain Launch - Serenity Phase 0 [CL] The full specifications for the Beacon Chain at launch can be found in

MOTIVATION:
For many years, Ethereum used Meta EIPs to document network upgrades. Recently, consensus has formed around using them again. This EIP aggregates the network upgrades who did not have Meta EIPs and links out to their specifications.

RATIONALE:
The EIP repository is well known within the Ethereum community, and Meta EIPs have historically been useful to clearly list the EIPs included in a specific network upgrade. While the specification process for the execution and consensus layers differ, there is value in having a single, harmonized, list of


=== EIP-8013 ===
TITLE: Static relative jumps and calls for the EVM
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-19
REQUIRES: 7979

SUMMARY:
Five new EVM jump instructions are introduced (`RJUMP`, `RJUMPI`, `RJUMPV`, `RJUMPSUB`, and `RJUMPSUBV`) which encode destinations as signed immediate values. These can be useful in almost all `JUMP` and `JUMPI` use cases and offer improvements in cost, performance, and static analysis.

SPECIFICATION:
We introduce five new instructions, each taking either a two-byte relative offset or else a table of offsets as immediate arguments. 1) relative jump: * `RJUMP (0xe0) relative_offset` * sets the `PC` to `PC_post_instruction + relative_offset`, where * `relative_offset` is encoded as a 16-bit **signed** (two's-complement) big-endian value. 2)

MOTIVATION:
A recurring discussion topic is that the EVM only has a mechanism for dynamic jumps. They provide a very flexible architecture with only 2 (!) instructions. This flexibility comes at a cost however: it makes analysis of code more complicated, often intractable, and it also (partially) resulted in the

RATIONALE:
### Relative addressing We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code like `PUSHn PC ADD JUMPI`. We do not


=== EIP-4788 ===
TITLE: Beacon block root in the EVM
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-02-10
REQUIRES: 1559

SUMMARY:
Commit to the hash tree root of each beacon chain block in the corresponding execution payload header. Store each of these roots in a smart contract.

SPECIFICATION:
| constants | value | |--- |--- | | `FORK_TIMESTAMP` | `1710338135` | | `HISTORY_BUFFER_LENGTH` | `8191` | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | | `BEACON_ROOTS_ADDRESS` | `0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02` | ### Background The high-level idea is that each execution block contains the parent beacon block's root. Even in the event of

MOTIVATION:
Roots of the beacon chain blocks are cryptographic accumulators that allow proofs of arbitrary consensus state. Exposing these roots inside the EVM allows for trust-minimized access to the consensus layer. This functionality supports a wide variety of use cases that improve trust assumptions of staking pools, restaking constructions, smart

RATIONALE:
### Why not repurpose `BLOCKHASH`? The `BLOCKHASH` opcode could be repurposed to provide the beacon root instead of some execution block hash. To minimize code change, avoid breaking changes to smart contracts, and simplify deployment to mainnet, this EIP suggests leaving `BLOCKHASH` alone and adding new functionality with the


=== EIP-8016 ===
TITLE: SSZ CompatibleUnion
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-28
REQUIRES: 7, 4, 9, 5, ,,  , 7, 9, 1, 6

SUMMARY:
This EIP introduces a new [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md) type to represent unions with forward-compatible Merkleization: A given field is always assigned the same stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/merkle-proofs.md#generalized-merkle-tree-index) across all type options.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### `CompatibleUnion({selector: type})` A new [SSZ composite type](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#composite-types) is defined: - **compatible union**: union type

MOTIVATION:
Certain types, e.g., transactions, allow multiple variants carving out slightly different feature sets. Merkleization equivalence is still desirable, as it allows verifiers to check common fields across variants. These types should still efficiently deserialize into one of their possible variants corresponding to its known tree shape. In programming languages,

RATIONALE:
### Why are `CompatibleUnion` selectors limited to `1 ... 127`? Reserving `0` prevents issues with incomplete initialization, and can possibly be used in a future EIP to denote optionality. Reserving selectors above `127` (i.e., highest bit is set) enables future backwards compatible extensions. The range `1 ... 127` is


=== EIP-1108 ===
TITLE: Reduce alt_bn128 precompile gas costs
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-05-21
REQUIRES: 1, 9, 6, ,,  , 1, 9, 7

SUMMARY:
Changes in 2018 to the underlying library used by the official Go reference implementation led to significant performance gains for the `ECADD`, `ECMUL`, and pairing check precompiled contracts on the `alt_bn128` elliptic curve. In the Parity client, field operations used by the precompile algorithms were optimized in 2018, and

SPECIFICATION:
Following is a table with the current gas cost and new gas cost: | Contract | Address | Current Gas Cost | Updated Gas Cost | | ------------- | --------- | ----------------------------- | ------------------- | | `ECADD` | `0x06` | 500<sup>[1]</sup> | 150 | | `ECMUL` | `0x07` |

MOTIVATION:
Recently, the underlying library used by the [official Go reference implementation](https://github.com/ethereum/go-ethereum) to implement the `ECADD` (at address `0x06`), `ECMUL` (at address `0x07`), and pairing check (at address `0x08`) precompiled contracts was shifted to [Cloudflare's bn256 library](https://github.com/cloudflare/bn256). Based on the [initial PR that introduced this change](https://github.com/ethereum/go-ethereum/pull/16203), and corroborated in [a


=== EIP-3102 ===
TITLE: Binary trie structure
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-01
REQUIRES: 

SUMMARY:
This proposal presents a binary structure and merkelization rule for the account and storage tries, which are merged into a single “state” trie. RLP and most of the MPT’s optimizations are dropped to simplify the design. Keccak256 is replaced with blake2b.

SPECIFICATION:
### Conventions | Code | Description | | :-: | - | | `u256(x)` | Big endian, 32-byte representation of number _x_ | |`||` | Byte-wise concatenation operator| | `++` | Bit-wise concatenation operator | | `0b0101` | The binary string `0101` | | `hash()` | The usual hashing

MOTIVATION:
The current design of the Merkle Patricia Trie (MPT) uses an hexary trie. Hexary Merkle trees are more shallow than their binary counterparts, which means less hashing. Over the course of the 5 years of Ethereum’s existence, it has become apparent that disk accesses are a greater bottleneck than

RATIONALE:
### blake2b BLAKE2 offers better performance, which is key to compensate for the loss of performance associated to a ~4x increase in the number of nodes. BLAKE3 offers even better performance. No official golang release exists at the time of the writing of this document. This presents a security


=== EIP-7939 ===
TITLE: Count leading zeros (CLZ) opcode
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-04-28
REQUIRES: 

SUMMARY:
Introduce a new opcode, `CLZ(x)`, which pops `x` from the stack and pushes the number of leading zero bits in `x` to the stack. If `x` is zero, pushes 256.

SPECIFICATION:
A new opcode is introduced: `CLZ` (`0x1e`). - Pops 1 value from the stack. - Pushes a value to the stack, according to the following code: ```solidity /// @dev Count leading zeros. /// Returns the number of zeros preceding the most significant one bit. /// If `x` is zero,

MOTIVATION:
Count leading zeros (CLZ) is a native opcode in many processor architectures (even in RISC architectures like ARM). It is a basic building block used in math operations, byte operations, compression algorithms, data structures: - lnWad - powWad - lambertW0Wad - sqrt - cbrt - byte string comparisons -

RATIONALE:
### The special 0 case 256 is the smallest number after 255. Returning a small number allows the result to be compared with minimal additional bytecode. For byte scanning operations, one can get the number of bytes to be skipped for a zero word by simply computing `256 >>


=== EIP-7934 ===
TITLE: RLP Execution Block Size Limit
TYPE: Standards Track Core
STATUS: Final
CREATED: 2025-04-16
REQUIRES: 

SUMMARY:
This proposal introduces a protocol-level cap on the maximum RLP-encoded execution block size to 10 megabytes (MiB), which includes a margin of 2 MiB to account for beacon block sizes.

SPECIFICATION:
### Block Size Cap - Introduce constants: - `MAX_BLOCK_SIZE` set to **10 MiB (10,485,760 bytes)** - `SAFETY_MARGIN` set to **2MiB (2,097,152 bytes)** - `MAX_RLP_BLOCK_SIZE` calculated as `MAX_BLOCK_SIZE - MARGIN` - Any RLP-encoded block exceeding `MAX_RLP_BLOCK_SIZE` must be considered invalid. Thus add the following check to the Ethereum protocol: ```python

MOTIVATION:
Currently, Ethereum does not enforce a strict upper limit on the encoded size of blocks. This lack of constraint can result in: 1. **Network Instability**: Extremely large blocks slow down propagation and increase the risk of temporary forks and reorgs. 2. **DoS Risks**: Malicious actors could generate exceptionally large

RATIONALE:
### Why 10 MiB? A cap of 10 MiB aligns with the gossip protocol constraint in Ethereum's consensus layer (CL). An additional 2MiB margin explicitly accounts for beacon block sizes, ensuring compatibility and consistent block propagation across the network. Blocks significantly larger than 10 MiB will not be broadcast


=== EIP-7600 ===
TITLE: Hardfork Meta - Pectra
TYPE: Meta 
STATUS: Final
CREATED: 2024-01-18
REQUIRES: 2, 5, 3, 7, ,,  , 2, 9, 3, 5, ,,  , 6, 1, 1, 0, ,,  , 7, 0, 0, 2, ,,  , 7, 2, 5, 1, ,,  , 7, 5, 4, 9, ,,  , 7, 5, 6, 9, ,,  , 7, 6, 2, 3, ,,  , 7, 6, 8, 5, ,,  , 7, 6, 9, 1, ,,  , 7, 7, 0, 2

SUMMARY:
This Meta EIP lists the EIPs Included in the Prague/Electra network upgrade. It follows the Dencun upgrade, documented in [EIP-7569](./eip-7569.md).

SPECIFICATION:
### Included EIPs #### Core EIPs * [EIP-2537](./eip-2537.md): Precompile for BLS12-381 curve operations * [EIP-2935](./eip-2935.md): Save historical block hashes in state * [EIP-6110](./eip-6110.md): Supply validator deposits on chain * [EIP-7002](./eip-7002.md): Execution layer triggerable exits * [EIP-7251](./eip-7251.md): Increase the MAX_EFFECTIVE_BALANCE * [EIP-7549](./eip-7549.md): Move committee index outside Attestation * [EIP-7623](./eip-7623.md): Increase

RATIONALE:
This Meta EIP provides a global view of all changes included in the Prague/Electra network upgrade, as well as links to the full specification.


=== EIP-7516 ===
TITLE: BLOBBASEFEE instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-09-11
REQUIRES: 3, 1, 9, 8, ,,  , 4, 8, 4, 4

SUMMARY:
Add a `BLOBBASEFEE (0x4a)` instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical to [EIP-3198](./eip-3198.md) (`BASEFEE` opcode) except that it returns the blob base-fee as per [EIP-4844](./eip-4844.md).

SPECIFICATION:
Add a `BLOBBASEFEE` instruction with opcode `0x4a`, with gas cost `2`. | Op | Input | Output | Cost | |------|-------|--------|------| | 0x4a | 0 | 1 | 2 | `BLOBBASEFEE` returns the result of the `get_blob_gasprice(header) -> int` function as defined in [EIP-4844 §Gas accounting](./eip-4844.md#gas-accounting).

MOTIVATION:
The intended use case would be for contracts to get the value of the blob base-fee. This feature enables blob-data users to programmatically account for the blob gas price, eg: - Allow rollup contracts to trustlessly account for blob data usage costs. - Blob gas futures can be implemented

RATIONALE:
### Gas cost The value of the blob base-fee is needed to process data-blob transactions. That means its value is already available before running the EVM code. The instruction does not add extra complexity and additional read/write operations, hence the choice of `2` gas cost. This is also identical


=== EIP-225 ===
TITLE: Clique proof-of-authority consensus protocol
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-03-06
REQUIRES: 

SUMMARY:
Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.

SPECIFICATION:
We define the following constants: * **`EPOCH_LENGTH`**: Number of blocks after which to checkpoint and reset the pending votes. * Suggested `30000` for the testnet to remain analogous to the mainnet `ethash` epoch. * **`BLOCK_PERIOD`**: Minimum difference between two consecutive block's timestamps. * Suggested `15s` for the testnet to

MOTIVATION:
Ethereum's first official testnet was Morden. It ran from July 2015 to about November 2016, when due to the accumulated junk and some testnet consensus issues between Geth and Parity, it was finally laid to rest in favor of a testnet reboot. Ropsten was thus born, clearing out all


=== EIP-5749 ===
TITLE: The 'window.evmproviders' object
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-10-04
REQUIRES: 1193

SUMMARY:
A Javascript Ethereum Provider interface injection that will allow for the interoperability of multiple browser wallets at the same time. Replacing `window.ethereum` with `window.evmproviders` is a simple solution that will provide multiple benefits including: improving user experience, encouraging innovation in the space, removing race conditions and a 'winner-takes-most' environment

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### `window.evmproviders={}` ```typescript /** * Represents the assets needed to display a wallet */ interface ProviderInfo { /** * A

MOTIVATION:
At present, `window.ethereum` is the prevailing method by which Ethereum-compatible applications interact with injected wallets. This originated with Mist Wallet in 2015 to interact with other applications. With the proliferation of both applications and wallets, `window.ethereum` has unintended negative consequences: - `window.ethereum` only permits one wallet to be injected

RATIONALE:
Standardizing a `ProviderInfo` type allows determining the necessary information to populate a wallet selection popup. This is particularly useful for web3 onboarding libraries such as Web3Modal, Web3React, and Web3Onboard. The name `evmproviders` was chosen to include other EVM-compliant chains. The SVG image format was chosen for its flexibility, lightweight


=== EIP-8024 ===
TITLE: Backward compatible SWAPN, DUPN, EXCHANGE
TYPE: Standards Track Core
STATUS: Review
CREATED: 2025-08-16
REQUIRES: 

SUMMARY:
Currently, `SWAP*` and `DUP*` instructions are limited to a stack depth of 16. Introduce three new instructions, `SWAPN`, `DUPN` and `EXCHANGE` which lift this limitation and allow accessing the stack at higher depths.

SPECIFICATION:
We introduce three new instructions: - `DUPN` (`0xe6`) - `SWAPN` (`0xe7`) - `EXCHANGE` (`0xe8`) Each instruction carries one or two immediate operands. Informally, using 1-based indexing, the semantics are: - `DUPN n`: The `n`'th stack item is duplicated at the top of the stack. - `SWAPN n`: The `n

MOTIVATION:
While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a "stack to memory elevation" in a compiler. This can result in complex and inefficient code. Furthermore, implementing

RATIONALE:
### Use of an immediate operand Allowing dynamic selection of the arguments to swap or dup could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their


=== EIP-1962 ===
TITLE: EC arithmetic and pairings with runtime definitions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-22
REQUIRES: 1109

SUMMARY:
This EIP proposes a new precompile to bring cryptographic functionality desired for privacy and scaling solutions. Functionality of such precompile will require the following: - Implementation the following operations over elliptic curves in the Weierstrass form with curve parameters such as base field, A, B coefficients defined in runtime:

SPECIFICATION:
If `block.number >= XXXXX`, define a set of `10` new precompiles with an addresses `[0x.., 0x.., ...]` and the following functionality. - Addition of points on the curve defined over base field - Multiplication of a point on the curve defined over base field - Multiexponentiation for `N` pairs

MOTIVATION:
- There is a pending proposal to implement base elliptic curve arithmetic is covered by [EIP-1829](./eip-1829.md) and will allow to implement various privacy-preserving protocols with a reasonable gas costs per operation. - Pairings are an important extension for basic arithmetic and so this new precompile is proposed with the

RATIONALE:
Only the largest design decisions will be covered: - While there is no arithmetic over the scalar field (which is modulo size of the main group) of the curve, it's required for gas estimation purposes. - Multiexponentiation is a separate operation due to large cost saving - There are


=== EIP-778 ===
TITLE: Ethereum Node Records (ENR)
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-11-23
REQUIRES: 


=== EIP-7961 ===
TITLE: EVM64 - EOF code section
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-28
REQUIRES: 3, 5, 4, 0, ,,  , 4, 7, 5, 0, ,,  , 7, 9, 6, 0

SUMMARY:
An EOF-only specification for EVM64 instruction set. This defines a separate "EVM64" type for EOF code section in addition to "regular EVM". The interpreter then enters EVM64 mode when entering the code section. This EIP is an alternative to [EIP-7937](./eip-7937.md).

SPECIFICATION:
Define `0x02` as an allowed `type` in `types_section`, as defined in EIP-7960. This denotes an EVM64 code section. ### EOF function execution When entering an EOF code section (either at the beginning of the contract call, or through `CALLF`), it enters "pure EVM64 mode". Unless defined below, no other

MOTIVATION:
EIP-7937 has maximum compatibility with existing EVM. It implements EVM64 simply as a group of additional opcodes (using a prefix opcode). This EIP defines an alternative method, using EOF container's code section. It has its pros and cons. The code size will obviously become shorter, due to not needing

RATIONALE:
### Stack behavior "Pure" in "pure EVM64" refers to the fact that all opcodes in EVM64 mode only operates on the least significant 64 bits. In this specification, we don't specifically define 64-bit stack. As far as this EIP is concerned, stack is still 256-bit. However, because it only


=== EIP-8099 ===
TITLE: MEVless Protocol
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-09-25
REQUIRES: 

SUMMARY:
This proposal introduces the MEVless protocol, a novel approach to prevent Maximum Extractable Value (MEV) attacks by implementing blind transaction sequencing. The core principle of MEVless is to prevent validators from seeing transaction content during the ordering phase, thereby eliminating the fundamental prerequisite for MEV attacks. The protocol separates

SPECIFICATION:
### Protocol Overview The MEVless protocol operates on a two-phase block system: 1. **Sequencing Blocks**: Order transactions based on transaction hashes and prepayment amounts without revealing transaction content. Sequencing blocks interval can be shorter than execution blocks. 2. **Execution Blocks**: Execute transactions in the predetermined order from sequencing blocks

MOTIVATION:
MEV attacks, particularly sandwich attacks and front-running, represent a significant threat to blockchain ecosystems, especially in DeFi applications. The fundamental prerequisite for MEV attacks is that validators can see transaction content before ordering, which allows them to: 1. **Sandwich Attacks**: Insert buy and sell transactions around user transactions to

RATIONALE:
### Why Blind Sequencing? Blind sequencing eliminates the root cause of MEV attacks by preventing miners from seeing transaction content during the critical ordering phase. This approach is more efficient than encryption-based solutions and more decentralized than private mempool approaches. ### Why Two-Phase Blocks? Separating sequencing and execution allows


=== EIP-1052 ===
TITLE: EXTCODEHASH opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-05-02
REQUIRES: 161

SUMMARY:
This EIP specifies a new opcode, which returns the keccak256 hash of a contract's code.

SPECIFICATION:
A new opcode, `EXTCODEHASH`, is introduced, with number `0x3f`. The `EXTCODEHASH` takes one argument from the stack, zeros the first 96 bits and pushes to the stack the keccak256 hash of the code of the account at the address being the remaining 160 bits. In case the account does

MOTIVATION:
Many contracts need to perform checks on a contract's bytecode, but do not necessarily need the bytecode itself. For instance, a contract may want to check if another contract's bytecode is one of a set of permitted implementations, or it may perform analyses on code and whitelist any contract

RATIONALE:
As described in the motivation section, this opcode is widely useful, and saves on wasted gas in many cases. The gas cost is the same as the gas cost for the `BALANCE` opcode because the execution of the `EXTCODEHASH` requires the same account lookup as in `BALANCE`. Only the


=== EIP-7645 ===
TITLE: Alias ORIGIN to SENDER
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-03
REQUIRES: 

SUMMARY:
This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This EIP proposes the alteration of the behavior of the ORIGIN opcode within the Ethereum

MOTIVATION:
The ORIGIN opcode in Ethereum returns the address of the account that started the transaction chain, differing from the SENDER (or CALLER) opcode, which returns the address of the direct caller. The use of ORIGIN has been discouraged and deemed deprecated since mid-2016 due to the security problems it

RATIONALE:
The rationale behind aliasing ORIGIN to SENDER is to: Facilitate Account Abstraction: Elegantly nullify a universal barrier to account abstraction, enabling more flexible and powerful account models in Ethereum. Enhance Security: Eliminate the security vulnerabilities associated with differentiating between the original transaction initiator and the immediate caller. Clean up


=== EIP-7928 ===
TITLE: Block-Level Access Lists
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-31
REQUIRES: 

SUMMARY:
This EIP introduces Block-Level Access Lists (BALs) that record all accounts and storage locations accessed during block execution, along with their post-execution values. BALs enable parallel disk reads, parallel transaction validation, parallel state root computation and executionless state updates.

SPECIFICATION:
### Block Structure Modification We introduce a new field to the block header, `block_access_list_hash`, which contains the Keccak-256 hash of the RLP-encoded block access list. When no state changes are present, this field is the hash of an empty rlp list `0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347`, i.e. `keccak256(rlp.encode([]))`. ```python class Header: # Existing

MOTIVATION:
Transaction execution cannot be parallelized without knowing in advance which addresses and storage slots will be accessed. While [EIP-2930](./eip-2930.md) introduced optional transaction access lists, they are not enforced. This proposal enforces access lists at the block level, enabling: - Parallel disk reads and transaction execution - Parallel post-state root

RATIONALE:
### BAL Design Choice This design variant was chosen for several key reasons: 1. **Size vs parallelization**: BALs include all accessed addresses (even unchanged) for complete parallel IO and execution. 2. **Storage values for writes**: Post-execution values enable state reconstruction during sync without individual proofs against state root. 3.


=== EIP-7834 ===
TITLE: Separate Metadata Section for EOF
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-12-06
REQUIRES: 3540

SUMMARY:
Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Extending the format introduced in [EIP-3540](./eip-3540.md), this EIP proposes to add a new OPTIONAL section

MOTIVATION:
It is desirable to include metadata in contract's bytecode for various reasons. For instance, both the Solidity and Vyper compilers by default include the language and compiler version used to compile. Vyper (with 0.4.1) appends an integrity hash to the initcode in CBOR encoding. Solidity additionally includes the IPFS

RATIONALE:
The `metadata_section` in the `body`, as well as the `kind_metadata` and `metadata_size` fields in the `header`, are OPTIONAL. This way, the compilers can avoid additional bytes in the container if they don't want to write any metadata. The `data_section` can change in its size and content during deployment, therefore


=== EIP-7495 ===
TITLE: SSZ ProgressiveContainer
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-08-18
REQUIRES: 7916

SUMMARY:
This EIP introduces a new [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md) type to represent containers with forward-compatible Merkleization: A given field is always assigned the same stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/merkle-proofs.md#generalized-merkle-tree-index) even when different container versions append new fields or drop existing fields.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `ProgressiveContainer(active_fields)` A new [SSZ composite types](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#composite-types) is defined: - **progressive container**: ordered heterogeneous collection

MOTIVATION:
SSZ containers are frequently versioned, for example across fork boundaries. When the number of fields reaches a new power of two, or a field is removed or replaced with one of a different type, the shape of the underlying Merkle tree changes, breaking verifiers of Merkle proofs for these

RATIONALE:
### Why is `active_fields` limited to 256 bits? 256 bits (1 word) allows the mix-in to be simple, consistent with the length mix-in for lists, and is practically sufficient. An alternate design with a `ProgressiveBitlist` mix-in was explored, however deemed too over-engineered as it would effectively require introducing caches


=== EIP-3091 ===
TITLE: Block Explorer API Routes
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-11-02
REQUIRES: 

SUMMARY:
This proposal brings standardization between block explorers API routes when linking transactions, blocks, accounts and tokens.

SPECIFICATION:
Block explorers will route their webpages accordingly for the following data: ### Blocks `<BLOCK_EXPLORER_URL>/block/<BLOCK_HASH_OR_HEIGHT>` ### Transactions `<BLOCK_EXPLORER_URL>/tx/<TX_HASH>` ### Accounts `<BLOCK_EXPLORER_URL>/address/<ACCOUNT_ADDRESS>` ### Tokens `<BLOCK_EXPLORER_URL>/token/<TOKEN_ADDRESS>`

MOTIVATION:
Currently wallets and dapps link transactions and accounts to block explorer web pages but as chain diversity and layer two solutions grow it becomes harder to maintain a consistent user experience. Adding new chains or layer two solutions becomes harder given these endpoints are inconsistent. Standardizing the API routes

RATIONALE:
The particular paths used in this proposal are chosen to be compatible with the majority of existing block explorers.


=== EIP-7039 ===
TITLE: Scheme-Handler Discovery Option for Wallets
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2023-05-15
REQUIRES: 1193

SUMMARY:
This proposal (affectionately known as SHADOW) is an alternative to [EIP-1193](./eip-1193.md) for wallet discovery in web browsers that requires no special permissions. Web pages intending to open a connection to a wallet inject an `iframe` tag pointing at a well-known scheme. Communication between the page and the wallet uses

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Initiating a Connection To initiate a connection to a provider, a web page SHOULD:

MOTIVATION:
Current wallet discovery methods (eg. `window.ethereum`) only support one active wallet at a time, and require browser extensions to request broad permissions to modify web pages. Ideally users should be able to have multiple wallets active, and choose between them at runtime. This not only results in an improved

RATIONALE:
Instead of directly using the `iframe.contentWindow`'s message port, SHADOW transfers a message port in the first message. This allows the `iframe`, in some specific scenarios, to completely hand off communication, so the web page and the provider communicate directly, without any proxying in the `iframe`.


=== EIP-7664 ===
TITLE: Access-Key opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2024-03-27
REQUIRES: 1, 1, 5, 3, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4

SUMMARY:
This EIP introduces a new opcode to inspect the access-list keys of the executing address.

SPECIFICATION:
### Parameters | Constant | Value | |----------------------------|--------| | `ACCESS_KEY_OPCODE_GAS` | `3` | | `ACCESS_KEY_OPCODE_BYTE` | `0x4B` | ### Opcode We add an instruction `ACCESS_KEY` (with opcode `ACCESS_KEY_OPCODE_BYTE`) which pops `index` from the top of the stack as big-endian `uint256`, and pushes `tx.access_list[address][index]` back on the stack, if `address`

MOTIVATION:
This EIP serves as a substitute of top-level-call detection to enable a smart-contract to enforce static declaration of attributes. Previously, application-layer contracts, against common advice from account-abstraction proponents, used to rely on the `tx.origin` to enforce a top-level call, such that the contract inputs are encoded as transaction input.

RATIONALE:
### Static analysis of transactions Static declaration of contract-inputs enables advanced layer-two constructions and block-building techniques: data is available without EVM introspection, and contracts can reliably tell if the executing transaction declared critical properties to the block builder and verifying nodes. Static-declaration of contract inputs is now independent of


=== EIP-2255 ===
TITLE: Wallet Permissions System
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-08-22
REQUIRES: 1193

SUMMARY:
This EIP adds two new wallet-namespaced RPC endpoints, `wallet_getPermissions` and `wallet_requestPermissions`, providing a standard interface for requesting and checking permissions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal adds two new methods to a wallet's web3 provider API: `wallet_getPermissions` and `wallet_requestPermissions`. ### `wallet_getPermissions` The `wallet_getPermissions` method

MOTIVATION:
Wallets are responsible for mediating interactions between untrusted applications and users' keys through appropriate user consent. Today, wallets always prompt the user for every action. This provides security at the cost of substantial user friction. We believe that a single permissions request can achieve the same level of security

RATIONALE:
While the current model of getting user consent on a per-action basis has high security, there are huge usability gains to be had bo getting more general user consent which can cover broad categories of usage, which can be expressed in a more human-readable way. This pattern has a


=== EIP-107 ===
TITLE: safe "eth_sendTransaction" authorization via html popup
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2016-06-05
REQUIRES: 

SUMMARY:
This draft EIP describes the details of an authorization method that if provided by rpc enabled ethereum nodes would allow regular websites to send transactions (via ```eth_sendTransaction```) without the need to enable CORS. Instead, user would be asked to confirm the transaction via an html popup. Every read only

SPECIFICATION:
In order for the mechanism to work, the node needs to serve an html file via http at the url \<node url\>/authorization.html This file will then be used by the dapp in 2 different modes (invisible iframe and popup window). The invisible iframe will be embedded in the dapp

MOTIVATION:
Currently, if a user navigates to a dapp running on a website using her/his everyday browser, the dapp will by default have no access to the rpc api for security reasons. The user will have to enable CORS for the website's domain in order for the dapp to work.

RATIONALE:
The design for that proposal was chosen for its simplicity and security. A previous idea was to use an oauth-like protocol in order for the user to accept or deny a transaction request. It would have required deeper code change in the node and some geth contributors argues that


=== EIP-7675 ===
TITLE: Retroactively Included EIPs
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2024-04-04
REQUIRES: 2, 6, 8, 1, ,,  , 3, 6, 0, 7, ,,  , 4, 8, 0, 3, ,,  , 7, 5, 2, 3, ,,  , 7, 6, 1, 0

SUMMARY:
This Meta EIP lists Core EIPs introducing changes to Ethereum's consensus which were activated independently of an Ethereum hard fork due to their backward compatible nature. These EIPs generally introduce constraints to underspecified protocol rules or clarify how certain edge cases should be handled.

SPECIFICATION:
### Retroactively Activated EIPs * [EIP-2681](./eip-2681.md): Limit account nonce to 2^64-1 * [EIP-3607](./eip-3607.md): Reject transactions from senders with deployed code * [EIP-4803](./eip-4803.md): Limit transaction gas to a maximum of 2^63-1 * [EIP-7523](./eip-7523.md): Empty accounts deprecation * [EIP-7610](./eip-7610.md): Revert creation in case of non-empty storage ### Activation All EIPs listed

MOTIVATION:
To maintain consensus across all nodes, backward incompatible changes to Ethereum must be activated synchronously. Given the coordination required for this, changes are usually bundled together in network upgrades. A Meta EIP is typically used to list the changes included in a network upgrade, as well as its activation

RATIONALE:
This Meta EIP provides a global view of all changes included in the Ethereum protocol without an explicit network upgrade, as well as links to full specification.


=== EIP-3332 ===
TITLE: MEDGASPRICE Opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-05
REQUIRES: 

SUMMARY:
Adds `MEDGASPRICE (0x46)` opcode that returns the median gas price for the parent block.

SPECIFICATION:
If `block.number >= TBD`, add a new opcode `MEDGASPRICE (0x46)`: Pushes the median gas price of the parent block onto the stack. | Op | Input | Output | Cost | |:----: |:-----: |:------: |:----: | | 0x46 | 0 | 1 | 8 |

MOTIVATION:
With the emergence of rollups as core mechanisms in scaling Ethereum there are a number of common transactions that can be front-run. Optimistic rollups rely on the submission of fraud proofs to maintain the integrity of their systems. As a result actors submitting fraud proofs typically receive a financial

RATIONALE:
Having access to the current gas price economy allows contracts to implement more robust and automated logic surrounding acceptable transaction gas prices. ### Naming note The name `MEDGASPRICE` was chosen because the median gas price of the network can only be calculated from the latest complete block. Thus transactions


=== EIP-6780 ===
TITLE: SELFDESTRUCT only in same transaction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-03-25
REQUIRES: 2, 6, 8, 1, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 2, 9

SUMMARY:
This EIP changes the functionality of the `SELFDESTRUCT` opcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved when `SELFDESTRUCT` is called in the same transaction a contract was created.

SPECIFICATION:
The behaviour of `SELFDESTRUCT` is changed in the following way: 1. When `SELFDESTRUCT` is executed in a transaction that is not the same as the contract calling `SELFDESTRUCT` was created: - The current execution frame halts. - `SELFDESTRUCT` does not delete any data (including storage keys, code, or the

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root

RATIONALE:
Getting rid of the `SELFDESTRUCT` opcode has been considered in the past, and there are currently no strong reasons to use it. This EIP implements a behavior that will attempt to leave some common uses of `SELFDESTRUCT` working, while reducing the complexity of the change on EVM implementations that


=== EIP-7620 ===
TITLE: EOF Contract Creation
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-02-12
REQUIRES: 1, 7, 0, ,,  , 6, 8, 4, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 4, 0, ,,  , 3, 5, 4, 1, ,,  , 3, 6, 7, 0

SUMMARY:
EVM Object Format (EOF) removes the possibility to create contracts using `CREATE` or `CREATE2` instructions. We introduce a new/replacement method in form of pair of instructions : `EOFCREATE` and `RETURNCODE` to provide a way to create contracts using EOF containers.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Wherever not explicitly listed, the rules of EOF contract creation, as well as the `EOFCREATE`

MOTIVATION:
This EIP uses terminology from the [EIP-3540](./eip-3540.md) which introduces the EOF format. EOF aims to remove code observability, which is a prerequisite to legacy EVM contract creation logic using legacy-style create transactions, `CREATE` or `CREATE2`, because both the initcode and code are available to the EVM and can be

RATIONALE:
### Data section appending The data section is appended to during contract creation and also its size needs to be updated in the header. Alternative designs were considered, where: - additional section kinds for the data were introduced - additional fields describing a subcontainer were introduced - data section


=== EIP-1681 ===
TITLE: Temporal Replay Protection
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-01-08
REQUIRES: 

SPECIFICATION:
The roll-out would be performed in two phases, `X` (hardfork), and `Y` (softfork). At block `X`, - Add an optional field `valid-until` to the RLP-encoded transaction, defined as a `uint64` (same as `nonce`). - If the field is present in transaction `t`, then - `t` is only eligible for

MOTIVATION:
There are a couple of different motivators for introducing a timebased transaction validity. - If any form of dust-account clearing is introduced, e.g. (https://github.com/ethereum/EIPs/issues/168), it will be necessary to introduce a replay protection, such as https://github.com/ethereum/EIPs/issues/169 . Having temporal replay protection removes the need to change nonce-behaviour in the

RATIONALE:
### Rationale for this EIP For the dust-account clearing usecase, - This change is much less invasive in the consensus engine. - No need to maintain a consensus-field of 'highest-known-nonce' or cap the number of transactions from a sender in a block. - Only touches the transaction validation part


=== EIP-627 ===
TITLE: Whisper Specification
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-05-05
REQUIRES: 

SUMMARY:
This EIP describes the format of Whisper messages within the ÐΞVp2p Wire Protocol. This EIP should substitute the [existing specification](https://github.com/ethereum/wiki/wiki/Whisper-Wire-Protocol). More detailed documentation on Whisper could be found [here](https://github.com/ethereum/go-ethereum/wiki/Whisper).

SPECIFICATION:
All Whisper messages sent as ÐΞVp2p Wire Protocol packets should be RLP-encoded arrays of data containing two objects: integer packet code followed by another object (whose type depends on the packet code). If Whisper node does not support a particular packet code, it should just ignore the packet without

MOTIVATION:
It is necessary to specify the standard for Whisper messages in order to ensure forward compatibility of different Whisper clients.

RATIONALE:
Packet codes 0x00 and 0x01 are already used in all Whisper versions. Packet code 0x02 will be necessary for the future development of Whisper. It will provide possibility to adjust the PoW requirement in real time. It is better to allow the network to govern itself, rather than hardcode


=== EIP-7843 ===
TITLE: SLOTNUM opcode
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-06
REQUIRES: 

SUMMARY:
This EIP proposes to add a new opcode `SLOTNUM` (`0x4b`), that returns the corresponding slot number for the current block.

SPECIFICATION:
A new opcode `SLOTNUM` is introduced at `0x4b`. It shall return one stack element. ### Output One element `slotNumber` is added to the stack; it is equal to the corresponding slot number for this block. `slotNumber` is a `uint64` in big endian encoding. ### Gas Cost The gas cost

MOTIVATION:
There are currently two ways to get the current slot number onchain: 1) Calculate from the block timestamp. This requires hardcoding the chain slot length into a smart contract. 2) Provide the slot number as calldata and prove it against the beacon block root (using [EIP-4788](./eip-4788.md)). Both of these

RATIONALE:
### Gas Price The opcode is priced to match similar opcodes in the `W_base` set. ### Calculation in consensus layer The slot number could alternatively be calculated in the execution layer using the timestamp, but it is more appropriate to calculate values pertaining to the beacon chain in the


=== EIP-145 ===
TITLE: Bitwise shifting instructions in EVM
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.

SPECIFICATION:
The following instructions are introduced: ### `0x1b`: `SHL` (shift left) The `SHL` instruction (shift left) pops 2 values from the stack, first `arg1` and then `arg2`, and pushes on the stack `arg2` shifted to the left by `arg1` number of bits. The result is equal to ``` (arg2 *

MOTIVATION:
EVM is lacking bitwise shifting operators, but supports other logical and arithmetic operators. Shift operations can be implemented via arithmetic operators, but that has a higher cost and requires more processing time from the host. Implementing `SHL` and `SHR` using arithmetic cost each 35 gas, while the proposed instructions

RATIONALE:
Instruction operands were chosen to fit the more natural use case of shifting a value already on the stack. This means the operand order is swapped compared to most arithmetic instructions.


=== EIP-2031 ===
TITLE: State Rent B - Net transaction counter
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-15
REQUIRES: 2029

SUMMARY:
It is part of the State Rent roadmap. This particular change makes any Ethereum transaction increment the transaction counter, which is a special storage slot in the *State counter contract*. This counter will be used to populate the nonces of newly created non-contract accounts. This way of populating nonce

SPECIFICATION:
A new field, with the location 0 (that means it resides in the storage slot 0 in the state counter contract, and can be read by calling that contract with argument being 32 zero bytes), is added to the state counter contract. It will eventually contain `txCount`, the total

MOTIVATION:
Ethereum currently does not have a special place in the state for tracking number of transactions.

RATIONALE:
Two main alternatives were proposed for the replay protection of the accounts that were evicted by subsequently brought back by sending ether to them: 1. Temporal replay protection. The nonce of the new accounts (and those brought back) is still zero, but a new `valid-until` field is introduced, making


=== EIP-6888 ===
TITLE: Arithmetic verification at EVM level
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-16
REQUIRES: 

SUMMARY:
This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Starting from `BLOCK_TIMESTAMP >= HARDFORK_TIMESTAMP` ### Constants | Constant | Type | Value | |

MOTIVATION:
The importance of math checks in smart contract projects is very clear. It was an OpenZeppelin library and then incorporated in Solidity's default behavior. Bringing this to EVM level can combine both gas efficiency and safety.

RATIONALE:
EVM uses two's complement for negative numbers. The opcodes listed above triggers one or two flags depending if they are used for signed and unsigned numbers. The conditions described for each opcode is made with implementation friendliness in mind. The only exception is EXP as it is hard to


=== EIP-1102 ===
TITLE: Opt-in account exposure
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-05-04
REQUIRES: 1474

SUMMARY:
The previous generation of Ethereum-enabled DOM environments follows a pattern of injecting a provider populated with accounts without user consent. This puts users of such environments at risk because malicious websites can use these accounts to view detailed account information and to arbitrarily initiate unwanted transactions on a user's

SPECIFICATION:
### Concepts #### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). #### `eth_requestAccounts` Providers exposed by Ethereum-enabled DOM environments define a new RPC method: `eth_requestAccounts`. Calling this method

RATIONALE:
The pattern of automatic account exposure followed by the previous generation of Ethereum-enabled DOM environments fails to protect user privacy and fails to maintain safe user experience: untrusted websites can both view detailed account information and arbitrarily initiate transactions on a user's behalf. Even though most users may reject


=== EIP-3855 ===
TITLE: PUSH0 instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-02-19
REQUIRES: 

SUMMARY:
Introduce the `PUSH0` (`0x5f`) instruction, which pushes the constant value 0 onto the stack.

SPECIFICATION:
The instruction `PUSH0` is introduced at `0x5f`. It has no immediate data, pops no items from the stack, and places a single item with the value 0 onto the stack. The cost of this instruction is 2 gas (aka `base`).

MOTIVATION:
Many instructions expect offsets as inputs, which in a number of cases are zero. A good example is the return data parameters of `CALLs`, which are set to zeroes in case the contract prefers using `RETURNDATA*`. This is only one example, but there are many other reasons why a

RATIONALE:
### Gas cost The `base` gas cost is used for instructions which place constant values onto the stack, such as `ADDRESS`, `ORIGIN`, and so forth. ### Opcode `0x5f` means it is in a "contiguous" space with the rest of the `PUSH` implementations and potentially could share the implementation.


=== EIP-1283 ===
TITLE: Net gas metering for SSTORE without dirty maps
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
This EIP proposes net gas metering changes for `SSTORE` opcode, enabling new usages for contract storage, and reducing excessive gas costs where it doesn't match how most implementations work. This acts as an alternative for EIP-1087, where it tries to be friendlier to implementations that use different optimization strategies

SPECIFICATION:
Definitions of terms are as below: * *Storage slot's original value*: This is the value of the storage if a reversion happens on the *current transaction*. * *Storage slot's current value*: This is the value of the storage before SSTORE operation happens. * *Storage slot's new value*: This is

MOTIVATION:
This EIP proposes a way for gas metering on SSTORE (as an alternative for EIP-1087 and EIP-1153), using information that is more universally available to most implementations, and requires as little change in implementation structures as possible. * *Storage slot's original value*. * *Storage slot's current value*. * Refund

RATIONALE:
This EIP mostly achieves what a transient storage tries to do (EIP-1087 and EIP-1153), but without the complexity of introducing the concept of "dirty maps", or an extra storage struct. * We don't suffer from the optimization limitation of EIP-1087. EIP-1087 requires keeping a dirty map for storage changes,


=== EIP-1227 ===
TITLE: Defuse Difficulty Bomb and Reset Block Reward
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-18
REQUIRES: 649

SUMMARY:
Starting with `FORK_BLKNUM` the client will calculate the difficulty without the additional exponential component. Furthermore, block rewards will be adjusted to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Remove Exponential Component of Difficulty Adjustment For the purposes of `calc_difficulty`, simply remove the exponential difficulty adjustment component, `epsilon`, i.e. the `int(2**((block.number // 100000) - 2))`. #### Reset Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward =

MOTIVATION:
Due to the "difficulty bomb" (also known as the "ice age"), introduced in EIP [#2](./eip-2.md), an artificial exponential increase in difficulty until chain freeze, users may find it much more challenging to remain on the unforked chain after a hard-fork. This is a desirable effect of the ice age

RATIONALE:
This will permanently, without further changes, disable the "ice age." It will also reset the block reward to pre-Byzantium levels. Both of these changes are specified similarly to EIP [#649](./eip-649.md), so they should require only minimal changes from client developers.


=== EIP-8096 ===
TITLE: Increase Gas Cost of Point Evaluation
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-12-02
REQUIRES: 4844

SUMMARY:
This EIP modifies the gas cost of `point evaluation` precompile introduced in [EIP-4844](./eip-4844.md).

SPECIFICATION:
Upon activation of this EIP, the gas cost of calling the precompile at address `0x000000000000000000000000000000000000000A` will be doubled from `50_000` gas to `100_000` gas.

MOTIVATION:
Currently the `point evaluation` precompile is underpriced relative to its resource consumption. This EIP aims to address these discrepancies by adjusting the gas cost and making `point evaluation` precompile sufficiently efficient to enable potential further increases in the block gas limit.

RATIONALE:
Benchmarking the `point evaluation` precompile revealed that its gas cost is significantly underestimated. This modification aim to ensure that the `point evaluation` precompile's performance no longer impedes potential increases to the block gas limit.


=== EIP-7545 ===
TITLE: Verkle proof verification precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-13
REQUIRES: 

SUMMARY:
This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A precompiled contract is added at address `0x21`, wrapping the stateless ethereum proof verification function.

MOTIVATION:
The proposed proof systems for stateless Ethereum require an upgrade to many tools and applications, that need a simple path to keep their proving systems up-to-date, without having to develop and deploy new proving libraries each time another proof format must be supported.

RATIONALE:
Stateless Ethereum relies on proofs using advanced mathematical concepts and tools from a fast-moving area of cryptography. As a result, a soft-fork approach is currently favored in the choice of the proof format: proofs are going to be distributed outside of consensus, and in the future, stateless clients will


=== EIP-7775 ===
TITLE: BURN opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-09-30
REQUIRES: 

SUMMARY:
This proposal introduces a `BURN` opcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Behaviour The `BURN` opcode `(0xFC)` is introduced with the following behavior: 1. Pops one

MOTIVATION:
The motivation for this proposal is to provide a standardized and efficient way to burn native ether directly within the EVM. Historically, contracts such as the BeaconDepositContract have "burned" ether by making it irrecoverable from the given address. This approach can lead to confusion and potential misuse. By introducing

RATIONALE:
The introduction of the `BURN` opcode helps clean up a piece of weird semantics in the Ethereum. Historically, burning native ether involved sending them to an address from which they could not be recovered, such as the zero address or a contract with no withdrawal functionality. This method is


=== EIP-8066 ===
TITLE: Upgrade Mascots
TYPE: Informational 
STATUS: Draft
CREATED: 2024-10-29
REQUIRES: 

SUMMARY:
This EIP establishes a mascot for each Ethereum network upgrade. Mascots serve to humanize and celebrate upgrades, fostering community engagement while adhering to principles of cuteness, relevance, and inclusivity. The mascot is selected through community-driven processes, with safeguards for appropriateness, by a designated facilitator (the "Mascot Wrestler").

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### 1. Mascot Requirements - **Relevance**: The mascot **SHOULD** relate thematically to the network upgrade's

MOTIVATION:
Ethereum network upgrades often introduce complex technical changes that can feel abstract to the broader community. Mascots provide a fun, memorable, and relatable symbol for each upgrade, drawing inspiration from its headliner(s). By mandating emoji-representable mascots that are cute and non-offensive, this process: - Enhances community participation and excitement

RATIONALE:
This specification balances creativity with guardrails to prevent mascot drift (e.g., unrelated or edgy choices). Emoji-based representation ensures accessibility across digital platforms, while the animal/cute mandate aligns with Ethereum's community ethos of approachability. The self-selected Mascot Wrestler role decentralizes coordination, leveraging vetoes for accountability. Selection flexibility accommodates Ethereum's decentralized


=== EIP-7804 ===
TITLE: Withdrawal Credential Update Request
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-31
REQUIRES: 

SUMMARY:
This proposal defines a mechanism to allow validators to update their withdrawal credentials using a new execution request type (0x03). The request allows for changing the execution address and the withdrawal credential prefix (0x01 or 0x02).

SPECIFICATION:
### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | *TBD* | Mainnet | ### Configuration | Name | Value | Comment | | - | - | - | | `WITHDRAWAL_CREDENTIALS_UPDATE_REQUEST_PREDEPLOY_ADDRESS` | `0x09Fc772D0857550724b07B850a4323f39112aAaA` | Where to call and store relevant

MOTIVATION:
When the ability to update a validator BLS withdrawal credentials to execution address was introduced in Capella, one of the most common questions was about allowing the withdrawal credential to be changed in the future. Either for security (e.g. credential rotation) or to allow for alternative ways of handling

RATIONALE:
<!-- TODO -->


=== EIP-5806 ===
TITLE: Delegate transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-10-20
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters - `FORK_BLKNUM` = `TBD` - `TX_TYPE` = TBD, > 0x03 ([EIP-4844](./eip-4844.md)) As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is

MOTIVATION:
EOA are the most widely used type of account, yet their ability to perform operations is limited to deploying contracts and sending "call" transactions. It is currently not possible for an EOA to execute arbitrary code, which greatly limits the interactions users can have with the blockchain. Account abstraction

RATIONALE:
EOAs are the most widely used type of wallet. This EIP would drastically expand the ability of EOAs to interact with smart contracts by using the pre-existing and well-understood delegation mechanism introduced in [EIP-7](./eip-7.md) and without adding new complexity to the EVM.


=== EIP-6206 ===
TITLE: EOF - JUMPF and non-returning functions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-21
REQUIRES: 4, 7, 5, 0, ,,  , 5, 4, 5, 0

SUMMARY:
This EIP allows for tail call optimizations in EOF functions ([EIP-4750](./eip-4750.md)) by introducing a new instruction `JUMPF`, which jumps to a code section without adding a new return stack frame. Additionally the format of the type sections is extended to allow declaring sections as non-returning, with simplified stack validation

SPECIFICATION:
### Type section changes We define a non-returning section as one that cannot return control to its caller section. Type section `outputs` field contains a special value `0x80` when corresponding code section is non-returning. See [Non-returning status validation](#non-returning-status-validation) below for validation details. The first code section MUST have 0

MOTIVATION:
It is common for functions to make a call at the end of the routine only to then return. `JUMPF` optimizes this behavior by changing code sections without needing to update the return stack. Knowing at validation time that a function will never return control allows for `JUMPF` to

RATIONALE:
### Allowing `JUMPF` to section with less outputs An alternative rule for `JUMPF` stack validation could require the target section's outputs to be exactly equal to the current section's outputs. Under such rule, a particular target section (a shared "helper" piece of code) would only "match" sections (requiring some


=== EIP-6122 ===
TITLE: Forkid checks based on timestamps
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-12-13
REQUIRES: 2124

SUMMARY:
[EIP-2124](./eip-2124.md) proposed a way of identifying nodes on the p2p network based on their chain configuration via the forkid parameter. It allows nodes to cut incompatible nodes off quickly which makes the P2P network more reliable. After the merge, forks are scheduled by block time instead of block number.

SPECIFICATION:
Each node maintains the following values: - **`FORK_HASH`**: IEEE CRC32 checksum (`[4]byte`) of the genesis hash and fork blocks numbers or timestamps that already passed. - The fork block numbers or timestamps are fed into the CRC32 checksum in ascending order. - If multiple forks are applied at the

MOTIVATION:
While in proof-of-work forks were scheduled by block number, the proof-of-stake consensus layer schedules forks by slot number. The slot number is a time based measurement. In order to schedule forks at the same time on the consensus and execution layer, the execution layer is forced to also schedule

RATIONALE:
Shanghai will be scheduled by timestamp thus the forkid calculations need to be updated to work with timestamps and blocks. Since all block number based forks are before time based forks, nodes need to check the block based forks before the time based forks.


=== EIP-3046 ===
TITLE: Adds `baseFee` to `eth_getUncleByBlockNumberAndIndex`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getUncleByBlockNumberAndIndex` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getUncleByBlockNumberAndIndex` #### Description Returns information about an uncle specified by block number and uncle index position Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-7702 ===
TITLE: Set Code for EOAs
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-05-07
REQUIRES: 2, ,,  , 1, 6, 1, ,,  , 1, 0, 5, 2, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0, ,,  , 3, 5, 4, 1, ,,  , 3, 6, 0, 7, ,,  , 4, 8, 4, 4

SUMMARY:
Add a new [EIP-2718](./eip-2718.md) transaction type that allows Externally Owned Accounts (EOAs) to set the code in their account. This is done by attaching a list of authorization tuples -- individually formatted as `[chain_id, address, nonce, y_parity, r, s]` -- to the transaction. For each tuple, a delegation indicator

SPECIFICATION:
### Parameters | Parameter | Value | | ------------------------ | ------- | | `SET_CODE_TX_TYPE` | `0x04` | | `MAGIC` | `0x05` | | `PER_AUTH_BASE_COST` | `12500` | | `PER_EMPTY_ACCOUNT_COST` | `25000` | ### Set code transaction A new [EIP-2718](./eip-2718.md) transaction known as the "set code transaction" is introduced, where

MOTIVATION:
Despite great advances in the smart contract wallet ecosystem, EOAs have held back broad adoption of UX improvements across applications. This EIP therefore focuses on adding short-term functionality improvements to EOAs which will allow UX improvements to permeate through the entire application stack. Three particular features this EIP is

RATIONALE:
Below is the rationale for both general design directions of the EIP, as well as specific technical choices. ### General design philosophy #### Persistence of code delegation The first draft of this proposal had a clever idea to avoid disagreement on whether in-protocol revocation was needed or not. The


=== EIP-6475 ===
TITLE: SSZ Optional
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-02-09
REQUIRES: 

SUMMARY:
This EIP introduces a new [Simple Serialize (SSZ) type](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/ssz/simple-serialize.md) to represent `Optional[T]` values.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Type definition `Optional[T]` is defined as a type that can represent: - A value

MOTIVATION:
Optional values are currently only representable in SSZ using workarounds. Adding proper support provides these benefits: 1. **Better readability:** SSZ structures with optional values can be represented with idiomatic types of the underlying programming language, e.g., `Optional[T]` in Python, making them easier to interact with. 2. **Compact serialization:** SSZ

RATIONALE:
### Why not `Union[None, T]`? `Union[None, T]` leaves ambiguity about the intention whether the type may be extended in the future, i.e., `Union[None, T, U]`. Furthermore, SSZ Union types are currently not used in any final Ethereum specification and do not have a finalized design themselves. If the only


=== EIP-7870 ===
TITLE: Hardware and Bandwidth Recommendations
TYPE: Informational 
STATUS: Living
CREATED: 2025-01-26
REQUIRES: 

SUMMARY:
This proposal specifies hardware and bandwidth recommendations for different types of Ethereum nodes: - **Full nodes**: Nodes that follow the tip of the chain without necessarily proposing blocks. - **Validators**: Split into: - **Attesters**: Validators that validate and attest to blocks created by proposers. - **Local block builders** (Proposers):

SPECIFICATION:
### Roles and Their Recommended Specifications Node operators typically run both an **Execution Layer (EL)** client and a **Consensus Layer (CL)** client on the same machine. The specifications below assume the combined resource usage of both. | Node Type | Storage | Memory | CPU Cores / Threads |

MOTIVATION:
Clear system specifications are crucial for: - Ensuring meaningful benchmark comparisons across different client implementations. - Enabling informed decision-making about protocol upgrades and their resource usage implications. - Providing clear guidance for node operators to ensure alignment with future network requirements. Without a shared understanding of target hardware specifications:

RATIONALE:
### Storage - **Recommended**: 4 TB NVMe M.2 drive with: - **Sequential R/W**: 7,000 MB/s - **Random 4K R/W**: Up to 1,000,000 IOPS - **Why NVMe over SATA?** - NVMe drives have significantly higher throughput and lower latency than SATA SSDs. - Drives without DRAM (DRAMless) or with QLC


=== EIP-2938 ===
TITLE: Account Abstraction
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-09-04
REQUIRES: 2718

SUMMARY:
**See also: [https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020](https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020) and the links therein for historical work and motivation.** Transaction validity, as of Muir Glacier, is defined rigidly by the protocol: ECDSA signature, a simple nonce, and account balance. Account abstraction extends the validity conditions of transactions with the execution of arbitrary EVM bytecode (with some

SPECIFICATION:
### Single Tenant After `FORK_BLOCK`, the following changes will be recognized by the protocol. #### Constants | Constant | Value | | - | - | | **`AA_ENTRY_POINT`** | `0xffffffffffffffffffffffffffffffffffffffff` | | **`AA_TX_TYPE`** | `2` | | **`FORK_BLOCK`** | TBD | | **`AA_BASE_GAS_COST`** | 15000 | #### New Transaction

MOTIVATION:
The existing limitations preclude innovation in a number of important areas, particularly: 1. Smart contract wallets that use signature verification other than ECDSA (eg. Schnorr, BLS, post-quantum...) 2. Smart contract wallets that include features such as multisig verification or social recovery, reducing the highly prevalent risk of funds being

RATIONALE:
The core problem in an account abstraction setup is always that miners and network nodes need to be able to verify that a transaction that they attempt to include, or rebroadcast, will actually pay a fee. Currently, this is fairly simple, because a transaction is guaranteed to be includable


=== EIP-5656 ===
TITLE: MCOPY - Memory copying instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-02-01
REQUIRES: 

SUMMARY:
Provide an efficient EVM instruction for copying memory areas.

SPECIFICATION:
The instruction `MCOPY` is introduced at `0x5E`. ### Input stack | Stack | Value | |-------|-------| | top - 0 | `dst` | | top - 1 | `src` | | top - 2 | `length` | This ordering matches the other copying instructions, i.e. `CALLDATACOPY`, `RETURNDATACOPY`. ### Gas

MOTIVATION:
Memory copying is a basic operation, yet implementing it on the EVM comes with overhead. This was recognised and alleviated early on with the introduction of the "identity" precompile, which accomplishes memory copying by the use of `CALL`'s input and output memory offsets. Its cost is `15 + 3

RATIONALE:
Production implementation of exact-word memory copying and partial-word memory copying can be found in the Solidity, Vyper and Fe compilers. With [EIP-2929](./eip-2929.md) the call overhead using the identity precompile was reduced from 700 to 100 gas. This is still prohibitive for making the precompile a reasonable alternative again.


=== EIP-1459 ===
TITLE: Node Discovery via DNS
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2018-09-26
REQUIRES: 778

SUMMARY:
This document describes a scheme for authenticated, updateable Ethereum node lists retrievable via DNS.

SPECIFICATION:
A 'node list' is a list of 'node records' [as defined by EIP-778](./eip-778.md) of arbitrary length. Lists may refer to other lists using links. The entire list is signed using a secp256k1 private key. The corresponding public key must be known to the client in order to verify the

MOTIVATION:
Many Ethereum clients contain hard-coded bootstrap node lists. Updating those lists requires a software update. The current lists are small, giving the client little choice of initial entry point into the Ethereum network. We would like to maintain larger node lists containing hundreds of nodes, and update them regularly.

RATIONALE:
### Why DNS? We have chosen DNS as the distribution medium because it is always available, even under restrictive network conditions. The protocol provides low latency and answers to DNS queries can be cached by intermediate resolvers. No custom server software is needed. Node lists can be deployed to


=== EIP-1285 ===
TITLE: Increase Gcallstipend gas in the CALL opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
Currently, the ``CALL`` opcode forwards a stipend of ``2,300`` gas units for a non zero value ``CALL`` operations where a contract is called. This stipend is given to the contract to allow execution of its ``fallback`` function. The stipend given is intentionally small in order to prevent the called

SPECIFICATION:
Increase the ``Gcallstipend`` fee parameter in the ``CALL`` opcode from ``2,300`` to ``3,500`` gas unit. The actual change to the Ethereum clients would be to change the ``CallStipend`` they store as a constant. For an implementation example you can find a Geth client implementation linked [here](https://github.com/ben-kaufman/go-ethereum/tree/eip-1285). The actual change

MOTIVATION:
The main motivation behind this EIP is to allow simple fallback functions to be implemented for contracts following the ``"Proxy"`` pattern. Simply explained, a ``"Proxy Contract"`` is a contract which use ``DELEGATECALL`` in its ``fallback`` function to behave according to the logic of another contract and serve as an

RATIONALE:
The rational for increasing the ``Gcallstipend`` gas parameter by ``1,200`` gas units comes from the cost of performing ``DELEGATECALL`` and ``SLOAD`` with a small margin for some small additional operations. All while still keeping the stipend relatively small and insufficient for accessing the storage or changing the state.


=== EIP-2696 ===
TITLE: JavaScript `request` method RPC transport
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2020-06-04
REQUIRES: 

SUMMARY:
This standard provides the description of an object that is made available to JavaScript applications which they can use to communicate with the Ethereum blockchain through. This standard only describes the transport mechanism, it does not specify the payloads that are valid nor does it specify how the client

SPECIFICATION:
### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Interface TypeScript interface definition: ```ts interface RequestArguments { readonly method: string; readonly params?: readonly unknown[] | object; }

MOTIVATION:
When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime. Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or

RATIONALE:
While this standard is perhaps not the greatest mechanism for communicating between an application and a blockchain, it is closely aligned with established practices within the community so migration from existing systems to this one should be relatively easy. Most communication is currently done via JSON-RPC, so aligning with


=== EIP-7793 ===
TITLE: Conditional Transactions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-17
REQUIRES: 7843

SUMMARY:
This EIP proposes to add a new transaction format for "conditional transactions", that are only valid at a specified slot and index within the block. A new opcode `TXINDEX` is introduced to expose the conditional transaction index onchain.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `COND_TX_TYPE` | `Bytes1(0x05)` | | `TXINDEX_OPCODE_BYTE` | `Bytes1(0x4c)` | | `TXINDEX_OPCODE_GAS` | `2` | ### Conditional Transaction Type We introduce a new type of [EIP-2718](./eip-2718.md) transaction, "conditional transactions", where the `TransactionType` is `COND_TX_TYPE` and the `TransactionPayload`

MOTIVATION:
The proposal aims to improve support for encrypted mempools. Transactions in an encrypted mempool are ordered while the transactions are encrypted, before being decrypted and included onchain at the top of the block. If the builder does not respect the order when including the decrypted transactions then they could

RATIONALE:
### Transaction Type An alternative design could simply return the current transaction index without adding a new transaction type. Adding a new transaction type is favoured as it means that the expected transaction index must be declared statically upfront, rather than allowing dynamic behaviour based on the returned transaction


=== EIP-7956 ===
TITLE: Tx Ordering via Block-level Randomness
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-05-24
REQUIRES: 7998

SUMMARY:
Proposers and builders can currently permute pending transactions arbitrarily, enabling reorder‑driven MEV. This EIP introduces a consensus rule that sorts all transactions inside a block by XOR‑ing each transaction hash with fresh slot randomness. The randomness is unknown until the slot starts, so the order is deterministic once known

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Slot Randomness `R` We define our randomness `R` as the `randao_reveal` of the each

MOTIVATION:
Unrestricted ordering is the key enabler of sandwich and classic front‑running attacks. Deterministic ordering collapses these vectors to latency racing and information asymmetry. Clear candidate‑set and bundle semantics preserve fee markets while removing the need for trusted sequencers. Academic works shows deterministic ordering drives sandwich profits toward zero. ###

RATIONALE:
### Why randomness‑driven ordering? * Objective & Verifiable – Using a function of on‑chain randomness (R) and a transaction’s own hash gives every validator an identical, cheap check on order validity. * Unpredictable Until Slot Start – The XOR of slot‑level RANDAO and the proposer’s VRF output ensures that


=== EIP-1087 ===
TITLE: Net gas metering for SSTORE operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-17
REQUIRES: 

SUMMARY:
This EIP proposes a change to how gas is charged for EVM `SSTORE` operations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.

SPECIFICATION:
The following changes are made to the EVM: - A 'dirty map' for each transaction is maintained, tracking all storage slots in all contracts that have been modified in the current transaction. The dirty map is scoped in the same manner as updates to storage, meaning that changes to

MOTIVATION:
Presently, `SSTORE` (`0x55`) operations are charged as follows: - 20,000 gas to set a slot from 0 to non-0 - 5,000 gas for any other change - A 10,000 gas refund when a slot is set from non-0 to 0. Refunds are applied at the end of the transaction.

RATIONALE:
We believe the proposed mechanism represents the simplest way to reduce storage gas costs in situations where they do not reflect the actual costs borne by nodes. Several alternative designs were considered and dismissed: - Charging a flat 200 gas for `SSTORE` operations, and an additional 19800 / 4800


=== EIP-7979 ===
TITLE: Call and Return Opcodes for the EVM
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-12-17
REQUIRES: 3541

SUMMARY:
This is the smallest possible change to the EVM to support calls and returns. This proposal introduces three new control-flow instructions to the EVM: * `CALLSUB` transfers control to the `destination` on the `stack`. * `ENTERSUB` marks a `CALLSUB` destination. * `RETURNSUB` returns to the `PC` after the most

SPECIFICATION:
> _The key words MUST and MUST NOT in this Specification are to be interpreted as described in RFC 2119 and RFC 8174._ ### `CALLSUB (0x..)` Transfers control to a subsidiary operation. 1. Pop the `destination` on top on the `stack`. 2. Push the current `PC + 1` to

MOTIVATION:
In 2016 the lead author set out to write a compiler from the EVM to code for virtual or real register machines. The design was simple -- traverse the EVM stack code in one pass, emitting register code for the target machine. I was immediately stymied by the presence

RATIONALE:
### How can dynamic jumps cause quadratic control flow? Static analysis amounts to most anything you can do with a program without actually running it. And traversing the flow of control — in a way that follows every possible path only once — is a fundamental first step for


=== EIP-663 ===
TITLE: SWAPN, DUPN and EXCHANGE instructions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-07-03
REQUIRES: 3, 5, 4, 0, ,,  , 5, 4, 5, 0

SUMMARY:
Currently, `SWAP*` and `DUP*` instructions are limited to a stack depth of 16. Introduce three new instructions, `SWAPN`, `DUPN` and `EXCHANGE` which lift this limitation and allow accessing the stack at higher depths.

SPECIFICATION:
We introduce three new instructions: 1. `DUPN` (`0xe6`) 2. `SWAPN` (`0xe7`) 3. `EXCHANGE` (`0xe8`) If the code is legacy bytecode, any of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*) If the code is valid EOF1, the following rules apply: 1. The instructions

MOTIVATION:
While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a "stack to memory elevation" in a compiler. This can result in complex and inefficient code. Furthermore, implementing

RATIONALE:
### Use of an immediate argument Allowing dynamic selection of the arguments to swap, dup, or exchange could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make


=== EIP-7918 ===
TITLE: Blob base fee bounded by execution cost
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2025-03-25
REQUIRES: 4, 8, 4, 4, ,,  , 7, 8, 4, 0

SUMMARY:
This EIP assigns a reserve price `BLOB_BASE_COST * base_fee_per_gas` to blobs by introducing an `if`-clause in `calc_excess_blob_gas()`. Specifically, when the reserve price is higher than `GAS_PER_BLOB * base_fee_per_blob_gas`, the function will not subtract `target_blob_gas` from `excess_blob_gas`, causing `excess_blob_gas` to increase according to `blob_gas_used`, while keeping the per-block maximum increase

SPECIFICATION:
### Parameters | Constant | Value | - | - | | `BLOB_BASE_COST` | `2**13` | ### Functions An `if`-clause is added to `calc_excess_blob_gas()` from [EIP-4844](./eip-4844.md). The function no longer subtracts `target_blob_gas` when updating `excess_blob_gas` if the price of a `blob` is below the price of `BLOB_BASE_COST` execution gas.

MOTIVATION:
Ethereum uses a dynamic pricing auction to set the blob base fee, lowering the fee if less gas is consumed than `target_blob_gas = GAS_PER_BLOB * blobSchedule.target` and raising the fee if more gas is consumed. Such an auction can function well when the blob base fee represents the price

RATIONALE:
### Fee-inelasticity and reserve price This proposal alleviates idiosyncrasies in the blob base fee auction. When a rollup's costs are dominated by execution costs for the blob-carrying transactions, ZK proof verification, or priority fees, the protocol can no longer rely on the blob base fee to control the equilibrium


=== EIP-2831 ===
TITLE: Transaction Replacement Message Type
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-07-26
REQUIRES: 1193

SUMMARY:
The current communication between providers and consumers of providers are fundamentally broken in the event that a transaction in the mempool has been superseded by a newer transactions. Providers currently have no way of communicating a transaction replacement, and consumers are required to poll block by block for the

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Definitions _This section is non-normative._ - Provider - A JavaScript object made available to a consumer, that provides access to

MOTIVATION:
Exert from EIP-1193 > A common convention in the Ethereum web application ("dapp") ecosystem is for key management software ("wallets") to expose their API via a JavaScript object in the web page. This object is called "the Provider". Many ingenious developments have been made by wallet developers to improve

RATIONALE:
The implementation was chosen to help the ease of implementation for both providers and dapp developers. Since `ProviderMessage` is widely used by dapp developers already it means that the implementation path would be as trivial as adding and additional `if` clause to their existing message listener. This also provides


=== EIP-7922 ===
TITLE: Dynamic exit queue rate limit
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-03-24
REQUIRES: 

SUMMARY:
This EIP proposes updating Ethereum's validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period ("generation") based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This

SPECIFICATION:
Since the validator exit process is complex, we start with the stack trace and a verbal description of the end-to-end process in Electra. 1. `initiate_validator_exit` – a validator signals their intent to exit, which is actuated by setting `validator.exit_epoch` and `validator.withdrawable_epoch` based on the output of `compute_exit_epoch_and_update_churn`. 2. `compute_exit_epoch_and_update_churn`

MOTIVATION:
Ethereum currently implements a fixed, rate-limited queue for validator exits to ensure the security and stability of the network. The exit queue ensures the economic security of transactions finalized by the validator set. Suppose a malicious validator could immediately exit the set without any delay. In that case, they

RATIONALE:
As we described earlier, by computing unused churn from the previous 14 generations, the churn limit dynamically responds to actual validator behavior. This mechanism: - Reduces validator waiting times during periods of congestion. - Ensures security by restricting maximum churn limit increases. - Simplifies implementation compared to more complex


=== EIP-7942 ===
TITLE: Available Attestation
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-04-30
REQUIRES: 

SUMMARY:
This EIP proposes Available Attestation (AA), a protocol enhancement to make Ethereum PoS resilient against reorganization attacks. The proposal introduces a stability criterion for blocks based on attestation quorums, requiring that a block must include at least one-third of validators' attestations from the previous slot to be considered stable.

SPECIFICATION:
### Overview We provide a lightweight yet efficient solution for Ethereum PoS which is: 1) reorg resilient in a synchronous network; 2) safe and live in a partially synchronous network; 3) easy to implement and deploy. We introduce AA, an approach inspired by conventional BFT protocols from *weak quorum*

MOTIVATION:
We find that all known effective attacks on Ethereum PoS belong to reorganization attacks, although they emphasize different types of adversarial strategies. According to how the canonical chain is manipulated by the adversary, we classify known attacks into two categories: attacks from *changing block weight* and attacks from *filtering

RATIONALE:
The reason why our approach is reorg resilient is that the AA mechanism *prevents* Byzantine validators from creating conflicting branches. As summarized in the table, there are two strategies for Byzantine validators: (1) Byzantine validators directly propose a block conflicting with the canonical chain and (2) Byzantine validators propose


=== EIP-2718 ===
TITLE: Typed Transaction Envelope
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-06-13
REQUIRES: 

SUMMARY:
`TransactionType || TransactionPayload` is a valid transaction and `TransactionType || ReceiptPayload` is a valid transaction receipt where `TransactionType` identifies the format of the transaction and `*Payload` is the transaction/receipt contents, which are defined in future EIPs.

SPECIFICATION:
### Definitions * `||` is the byte/byte-array concatenation operator. ### Transactions As of `FORK_BLOCK_NUMBER`, the transaction root in the block header **MUST** be the root hash of `patriciaTrie(rlp(Index) => Transaction)` where: * `Index` is the index in the block of this transaction * `Transaction` is either `TransactionType || TransactionPayload`

MOTIVATION:
In the past, when we have wanted to add new transaction types we have had to ensure they were backward compatible with all other transactions, meaning that you could differentiate them based only on the encoded payload, and it was not possible to have a transaction that matched both

RATIONALE:
### TransactionType only goes up to 0x7f For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit. This also prevents us from colliding with legacy transaction types, which always start


=== EIP-7637 ===
TITLE: Optimize EOA EXTCODEHASH
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-02-26
REQUIRES: 1052

SUMMARY:
This proposal is an optimization for [EIP-1052](./eip-1052.md), For addresses with a balance, but without code, the codehash should still be `0x`. When an address `add.code == 0x` and `add.balance != 0`, `add.codehash==0` is required instead of `add.codehash==keccak256("")`

SPECIFICATION:
The behaviour of `EXTCODEHASH` is changed in the following way: 1. When calling `EXTCODEHASH`, the codehash of the address with balance but no code is still `0x`

MOTIVATION:
EIP-1052 was proposed to save gas fees. However, due to some flaws in the set specifications, in actual applications, due to safety concerns, they will not actually be used. In order for EIP-1052 to be truly useful, it should be optimized. If someone uses it based on the proposal

RATIONALE:
EIP-1052 In order to include the function of `BALANCE`, let the `EXTCODEHASH` of the address without balance be `0x`, and the `EXTCODEHASH` of the address with balance be `keccak256("")`. The contract address can be calculated in advance. Whether it is `CREATE` or `CREATE2`, it is possible that the contract


=== EIP-7935 ===
TITLE: Set default gas limit to 60M
TYPE: Informational 
STATUS: Last Call
CREATED: 2025-04-22
REQUIRES: 

SUMMARY:
The gas limit on mainnet is currently 36M. This should be significantly increased to 60M by the time Fusaka is released by execution layer clients updating their default configurations.

SPECIFICATION:
Execution layer clients have different configuration formats. They should all update the gas limit value generated in their default configurations to 60M.

MOTIVATION:
There is currently great interest in scaling L1 execution. This can likely be done to some extent without implementing any new features. However, it requires guidance from EL devs as we expect to find bugs in clients at higher gas limits than currently used on mainnet. This will require

RATIONALE:
In the past there has been some difficulty coordinating EL clients to update gas limit values in their default configurations. Therefore we suggest tying a new value to a hard fork release.


=== EIP-1898 ===
TITLE: Add `blockHash` to defaultBlock methods
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-04-01
REQUIRES: 234

SUMMARY:
For JSON-RPC methods which currently accept a default block parameter, additionally allow the parameter to be a block hash. This EIP can be considered a generalization of [EIP-234](./eip-234.md). It would enable clients to unambiguously specify the block they want to query for certain JSON-RPC methods, even if the block

SPECIFICATION:
The following JSON-RPC methods are affected: - `eth_getBalance` - `eth_getStorageAt` - `eth_getTransactionCount` - `eth_getCode` - `eth_call` - `eth_getProof` The following options, quoted from the Ethereum JSON-RPC spec, are currently possible for the defaultBlock parameter: > - HEX String - an integer block number > - String "earliest" for the

RATIONALE:
Currently, the state-querying JSON-RPC methods specified above have no option to unambiguously specify which block to query the state for. This can cause issues for applications which need to make multiple calls to the RPC. For instance, a wallet which just executed a transfer may want to display the


=== EIP-2929 ===
TITLE: Gas cost increases for state access opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-09-01
REQUIRES: 

SUMMARY:
Increase the gas cost of `SLOAD` (`0x54`) to 2100, and the `*CALL` opcode family (`0xf1`, `f2`, `f4`, `fA`), `BALANCE` `0x31` and the `EXT*` opcode family (`0x3b`, `0x3c`, `0x3f`) to 2600. Exempts (i) precompiles, and (ii) addresses and storage slots that have already been accessed in the same transaction, which

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | 12244000 | | `COLD_SLOAD_COST` | 2100 | | `COLD_ACCOUNT_ACCESS_COST` | 2600 | | `WARM_STORAGE_READ_COST` | 100 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. When executing a transaction, maintain a set

MOTIVATION:
Generally, the main function of gas costs of opcodes is to be an estimate of the time needed to process that opcode, the goal being for the gas limit to correspond to a limit on the time needed to process a block. However, storage-accessing opcodes (`SLOAD`, as well as

RATIONALE:
### Opcode costs vs charging per byte of witness data The natural alternative path to changing gas costs to reflect witness sizes is to charge per byte of witness data. However, that would take a longer time to implement, hampering the goal of providing short-term security relief. Furthermore, following


=== EIP-7691 ===
TITLE: Blob throughput increase
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-04-17
REQUIRES: 

SUMMARY:
Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.

SPECIFICATION:
### Parameters | Constant | Value | |------------------------------------------|---------------------| | `MAX_BLOBS_PER_BLOCK_ELECTRA` | `9` | | `TARGET_BLOBS_PER_BLOCK_ELECTRA` | `6` | | `MAX_BLOB_GAS_PER_BLOCK` | `1179648` | | `TARGET_BLOB_GAS_PER_BLOCK` | `786432` | | `BLOB_BASE_FEE_UPDATE_FRACTION_PRAGUE` | `5007716` | `MAX_BLOBS_PER_BLOCK_ELECTRA` and `TARGET_BLOBS_PER_BLOCK_ELECTRA` are consumed by the consensus layer clients, and starting at `PECTRA_FORK_EPOCH` replace the

MOTIVATION:
Ethereum, with its rollup centric roadmap, scales by relying on L2. Since the Dencun fork, the blob gas target and maximum was set to 3/6 respectively. The blob gas limit was arrived at based on a series of big block tests performed on the Ethereum mainnet network as well

RATIONALE:
### Simplicity The EIP aims to minimize the amount of testing and implementation effort from the perspective of the client teams, to allow for more resources to be allocated to peerDAS and other scaling research. While this EIP may not achieve the new optimal blob limit, it offers a


=== EIP-1829 ===
TITLE: Precompile for Elliptic Curve Linear Combinations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-03-06
REQUIRES: 

SUMMARY:
A precompile that takes a curve and computes a linear combination of curve points.

SPECIFICATION:
Given integers `m, α` and `β`, scalars `s_i`, and curve points `A_i` construct the elliptic curve ``` y² = x³ + α ⋅ x + β mod m ``` and compute the following ``` C = s₀ ⋅ A₀ + s₁ ⋅ A₁ + ⋯ + s_n ⋅ A_n

RATIONALE:
**Generic Field and Curve.** Many important optimizations are independent of the field and curve used. Some missed specific optimizations are: * Reductions specific to the binary structure of the field prime. * Precomputation of Montgomery factors. * Precomputation of multiples of certain popular points like the generator. * Special


=== EIP-8025 ===
TITLE: Optional Execution Proofs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-09-17
REQUIRES: 

SUMMARY:
Optional execution proofs allow beacon nodes to verify the validity of the execution payload within a beacon block without running an execution layer client. The execution proofs are sent over the consensus layer's peer-to-peer network.

SPECIFICATION:
This is a consensus layer change only. Validators will now be able to enable two new modes: - zkEVM Proof generating - Stateless validation When a proof generating node receives a beacon block, they will create the necessary proofs for the execution payload in the block and re-propagate them

MOTIVATION:
Optional execution proofs reduce the hardware and bandwidth requirements that are needed for an attester to verify a beacon block. Moreover, the cost to verify to a block no longer grows with the gas limit. Since these are optional, protocol upgrades cannot be based on the improvements in this

RATIONALE:
<-- TODO -->


=== EIP-1482 ===
TITLE: Define a maximum block timestamp drift
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-10-09
REQUIRES: 

SUMMARY:
On the basis that both Geth and Parity implement the same timestamp validation requirements, this should be written into the reference specification.

SPECIFICATION:
The yellow paper should define a timestamp as: > A scalar value equal to the output of Unix’s time() at this block’s inception. For the purpose of block validation, it must be greater than the previous block's timestamp, and no more than 15 seconds greater than system time.

MOTIVATION:
There is a lack of clarity about how accurate timestamps in the block header must be. The yellow paper describes the timestamp as > A scalar value equal to the reasonable output of Unix’s time() at this block’s inception This causes [confusion](https://ethereum.stackexchange.com/questions/5924/how-do-ethereum-mining-nodes-maintain-a-time-consistent-with-the-network/5926#5926) about the safe use of the `TIMESTAMP`

RATIONALE:
Both [Geth](https://github.com/ethereum/go-ethereum/blob/4e474c74dc2ac1d26b339c32064d0bac98775e77/consensus/ethash/consensus.go#L45) and [Parity](https://github.com/paritytech/parity-ethereum/blob/73db5dda8c0109bb6bc1392624875078f973be14/ethcore/src/verification/verification.rs#L296-L307) reject blocks with timestamp more than 15 seconds in the future. This establishes a defacto standard, which should be made explicit in the reference specification.


=== EIP-665 ===
TITLE: Add precompiled contract for Ed25519 signature verification
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-03-25
REQUIRES: 

SUMMARY:
Verification of Ed25519 cryptographic signatures is obviously possible in EVM bytecode. However, the gas cost will be very high, and computationally expensive, as such tight, wide word operations intensive code as required for Ed25519 is not a good fit for the EVM bytecode model. The addition of a native

SPECIFICATION:
If `block.number >= CONSTANTINOPLE_FORK_BLKNUM`, add a precompiled contract for Ed25519 signature verification (`ED25519VFY`). The proposal adds a new precompiled function `ED25519VFY` with the following input and output. `ED25519VFY` takes as **input 128 octets**: 1. **message**: the 32-octet message that was signed 2. **public key**: the 32-octet Ed25519 public key

MOTIVATION:
Ed25519 and Ed448 (that is, EdDSA using Curve25519 or Curve448) are IETF recommendations ([RFC7748](https://tools.ietf.org/html/rfc7748)) with some attractive properties: * Ed25519 is intended to operate at around the 128-bit security level and Ed448 at around the 224-bit security level * EdDSA uses small public keys (32 or 57 octets) and

RATIONALE:
The proposed `ED25519VFY` function takes the signer public key as a call parameter, as with Ed25519, I don't believe it is possible to derive the signers public key from the signature and message alone. The proposed `ED25519VFY` function uses a zero return value to indicate success, since this allows


=== EIP-170 ===
TITLE: Contract code size limit
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-11-04
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then if contract creation initialization returns data with length of **more than** `MAX_CODE_SIZE` bytes, contract creation fails with an out of gas error. ### Rationale Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a

RATIONALE:
Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a constant amount of gas, the call can trigger O(n) cost in terms of reading the code from disk, preprocessing the code for VM execution, and also adding O(n) data


=== EIP-1706 ===
TITLE: Disable SSTORE with gasleft lower than call stipend
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-01-15
REQUIRES: 1283

SUMMARY:
[EIP-1283](./eip-1283.md) significantly lowers the gas costs of writing to contract's storage. This created a danger of a new kind of reentrancy attacks on existing contracts as Solidity by default grants a 'stipend' of 2300 gas to simple transfer calls. This danger is easily mitigated if SSTORE is not allowed

SPECIFICATION:
Add the following condition to the SSTORE opcode gas cost calculation: * If *gasleft* is less than or equal to 2300, fail the current call frame with 'out of gas' exception.

MOTIVATION:
An attack that is described in [this article](https://medium.com/chainsecurity/constantinople-enables-new-reentrancy-attack-ace4088297d9). Explicitly specifying the call stipend as an invariant will have a positive effect on Ethereum protocol security: https://www.reddit.com/r/ethereum/comments/agdqsm/security_alert_ethereum_constantinople/ee5uvjt

RATIONALE:
In order to keep in place the implicit reentrancy protection of existing contracts, transactions should not be allowed to modify state if the remaining gas is lower then the 2300 stipend given to 'transfer'/'send' in Solidity. These are other proposed remediations and objections to implementing them: * Drop EIP-1283


=== EIP-8051 ===
TITLE: Precompile for ML-DSA signature verification
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-15
REQUIRES: 7932

SUMMARY:
This proposal adds precompiled contracts that perform signature verifications using the NIST module-lattice signature scheme. Two instantiations are supported: * **ML-DSA** — NIST-compliant version using SHAKE256 (FIPS-204), * **ML-DSA-ETH** — EVM-optimized version for cheaper on-chain verification: * Uses Keccak-based PRNG instead of SHAKE256 (leverages native KECCAK256 precompile) * Stores

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The following specification provides two precompiled contracts: |**Precompiled contract**|**1**|**2**| |-|-|-| |**Name**|`MLDSA_VERIFY`|`MLDSA_VERIFY_ETH`| |**Address**| 0x12| 0x13| |**Gas

MOTIVATION:
Quantum computers pose a long-term risk to classical cryptographic algorithms. In particular, signature algorithms based on the hardness of the Elliptic Curve Discrete Logarithm Problem (ECDLP) such as secp256k1, are widely used in Ethereum and threatened by quantum algorithms. This exposes potentially on-chain assets and critical infrastructure to quantum

RATIONALE:
The ML-DSA scheme was selected as a NIST-standardized post-quantum cryptographic algorithm due to its strong security guarantees and efficiency. ML-DSA is a signature algorithm build from lattice-based cryptography. Specifically, its hardness relies on the Short Integer Solution (SIS) problem and the Learning With Errors (LWE) problem, which is believed


=== EIP-3534 ===
TITLE: Restricted Chain Context Type Transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-20
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new EIP-2718 transaction type with the format `0x4 || rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`. This proposed `chainContext` element adds a constraint on the validity of a transaction to a chain segment meeting the referenced value(s). Four contexts are defined

SPECIFICATION:
### Parameters - `FORK_BLOCK_NUMBER` `TBD` - `TRANSACTION_TYPE_NUMBER` `0x4`. See EIP-2718. As of `FORK_BLOCK_NUMBER`, a new EIP-2718 transaction is introduced with `TransactionType` `TRANSACTION_TYPE_NUMBER`. The EIP-2718 `TransactionPayload` for this transaction is `rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`. The EIP-2718 `ReceiptPayload` for this transaction is `rlp([status,

MOTIVATION:
Establish a protocol-based mechanism with which transactions are able to articulate constraints on eligible chain contexts. Generally, these constraints give the consumer (the transactor) an ability to express requirements about the transaction's relationship to blockchain data and its provenance. - Restrict transaction applicability to a chain context that is

RATIONALE:
### Subclasses Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP. Their specification definitions allow arbitrary mutual (`AND`) combinations. This design is intended to form a proposal which offers a concrete set of specifics while doing so with


=== EIP-7892 ===
TITLE: Blob Parameter Only Hardforks
TYPE: Informational 
STATUS: Last Call
CREATED: 2025-02-28
REQUIRES: 7840

SUMMARY:
This EIP introduces **Blob Parameter Only (BPO) Hardforks**, a lightweight mechanism for incrementally scaling Ethereum’s blob capacity through targeted hard forks that modify only blob-related parameters: `target`, `max`, and `baseFeeUpdateFraction`. Unlike traditional hard forks, which require extensive coordination and introduce broader protocol changes, BPO forks enable rapid, low-overhead scaling

SPECIFICATION:
### Definition BPO hardforks are defined as protocol upgrades that modify only blob-related parameters through configuration, without requiring any client-side code changes. The new parameters take effect immediately at the specified activation time. ### Blob schedule configuration The following protocol parameters are now managed by the blob schedule configuration:

MOTIVATION:
Ethereum's scaling strategy relies on Layer 2 (L2) solutions for transaction execution while using Ethereum as a **data availability (DA) layer**. However, the demand for DA has increased rapidly, and the current approach of only modifying blob parameters in large, infrequent hard forks is **not agile enough** to keep

RATIONALE:
### Why not just use regular hardforks? Full hard forks require extensive coordination, testing, and implementation changes beyond parameter adjustments. For example, in Lighthouse, a typical hard fork implementation requires thousands of lines of boilerplate before any protocol changes occur. BPO forks streamline this process by avoiding the need


=== EIP-3540 ===
TITLE: EOF - EVM Object Format v1
TYPE: Standards Track Core
STATUS: Review
CREATED: 2021-03-16
REQUIRES: 3, 5, 4, 1, ,,  , 3, 8, 6, 0

SUMMARY:
We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. In order to guarantee that every EOF-formatted contract in the state is valid, we need

MOTIVATION:
On-chain deployed EVM bytecode contains no pre-defined structure today. Code is typically validated in clients to the extent of `JUMPDEST` analysis at runtime, every single time prior to execution. This poses not only an overhead, but also a challenge for introducing new or deprecating existing features. Validating code during

RATIONALE:
EVM and/or account versioning has been discussed numerous times over the past years. This proposal aims to learn from them. See "Ethereum account versioning" on the Fellowship of Ethereum Magicians Forum for a good starting point. ### Execution vs. creation time validation This specification introduces creation time validation, which


=== EIP-7998 ===
TITLE: Turn `randao_reveal` into a VRF
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-08-03
REQUIRES: 

SUMMARY:
This EIP proposes a modification to the data signed by a block proposer for the `randao_reveal`. The current `randao_reveal` is a BLS signature over the current epoch number, which is predictable. This proposal incorporates the RANDAO mix of the previous epoch and the current slot number into the signed

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). The gist of the change is in `process_randao`, which now uses the RANDAO mix of

MOTIVATION:
This change creates a secure, per-slot VRF output from the proposer, with several benefits: 1. it **paves the way for secret proposer election**, which would in turn reduce MEV and completely eliminate the well-known RANDAO bias attack vector; 2. it supports other proposals like [EIP-7956](./eip-7956.md) that rely on a

RATIONALE:
### Choice of VRF Input The `randao_reveal` is effectively transformed into `VRF(sk, message)` where the `message` is the SSZ serialization of the `RandaoRevealSeed` container. - `previous_mix`: Including the RANDAO mix from the previous epoch (`previous_mix`) is the core of this proposal. Since the previous epoch's final mix is not


=== EIP-2327 ===
TITLE: BEGINDATA opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-10-28
REQUIRES: 

SUMMARY:
It is common for smart contracts to efficiently store data directly in the contract bytecode. Examples include constructor arguments, constant variables, compiler metadata and the contract runtime during the init phase. Currently, such data is not distinguished from normal bytecode and is still being analysed for `JUMPDEST`s by EVM

SPECIFICATION:
While computing the valid `JUMPDEST`s of a contract, halt analysis once the first `BEGINDATA` is encountered. In other words: A jump to any codelocation equal to or greater than the location of the first `BEGINDATA` causes a `BAD_JUMP_DESTINATION` error. If `BEGINDATA` is encountered during contract execution, it has the

MOTIVATION:
The `BEGINDATA` opcode has been suggested before as part of the EIP `Subroutines and Static Jumps for the EVM` [EIP-615](./eip-615.md) as a way to determine the position of jumptables in contract bytecode. It is here introduced in its own right in order to exclude data from the `JUMPDEST` analysis

RATIONALE:
The byte `0xb6` was chosen to align with [EIP-615](./eip-615.md). The choice to `STOP` if `BEGINDATA` is encountered is somewhat arbitrary. An alternative would be to be to abort the execution with an out-of-gas error.


=== EIP-141 ===
TITLE: Designated invalid EVM instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-09
REQUIRES: 

SUMMARY:
An instruction is designated to remain as an invalid instruction.

SPECIFICATION:
The opcode `0xfe` is the `INVALID` instruction. It can be used to abort the execution (i.e. duplicates as an `ABORT` instruction).

MOTIVATION:
The invalid instruction can be used as a distinct reason to abort execution.


=== EIP-7698 ===
TITLE: EOF - Creation transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-24
REQUIRES: 3540

SUMMARY:
Creation transactions (i.e. the ones with empty `to`) can be used to deploy EOF contracts by providing EOF initcontainer concatenated with `calldata` for initcontainer execution in transaction's `data`. Initcontainer execution is similar to its execution during `EOFCREATE` instruction, ending with `RETURNCODE` instruction. New account address calculation is based on

SPECIFICATION:
Wherever not explicitly listed, the rules of EOF contract creation should be identical or analogous to those of legacy creation transaction. This includes but is not limited to: - behavior on `accessed_addresses` and address collision ([EIP-684](./eip-684.md) and [EIP-2929](./eip-2929.md)) - EVM execution frame created for the initcode - memory, account

MOTIVATION:
Creation transaction is one of the three ways alongside creation instructions provided by legacy EVM to deploy new code. Given that legacy creation instructions (`CREATE` and `CREATE2`) are not allowed to deploy EOF code, supporting EOF in creation transactions is the only way to get the first EOF on-chain.

RATIONALE:
### Irregular state change to deploy Creator Contract Originally it was proposed to deploy the first EOF contract via irregular state change. This contract would execute `TXCREATE` instruction and could be used then as an entry point to deploy any other EOF code. This would also require an introduction


=== EIP-7069 ===
TITLE: Revamped CALL instructions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-05-05
REQUIRES: 1, 5, 0, ,,  , 2, 1, 1, ,,  , 2, 1, 4, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 4, 0

SUMMARY:
Introduce three new call instructions, `EXTCALL`, `EXTDELEGATECALL` and `EXTSTATICCALL`, with simplified semantics. Introduce another instruction, `RETURNDATALOAD` for loading a word from return data into stack. Modify the behavior of `RETURNDATACOPY` instruction executed within EOF formatted code (as defined by [EIP-3540](./eip-3540.md)). The existing `*CALL` instructions are rejected by EOF validation.

SPECIFICATION:
| Name | Value | Comment | |------|-------|---------| | WARM_STORAGE_READ_COST | 100 | From [EIP-2929](./eip-2929.md) | | COLD_ACCOUNT_ACCESS | 2600 | From [EIP-2929](./eip-2929.md) | | CALL_VALUE_COST | 9000 | | | ACCOUNT_CREATION_COST | 25000 | | | MIN_RETAINED_GAS | 5000 | | | MIN_CALLEE_GAS | 2300 | | We

MOTIVATION:
Observability of gas has been a problem for very long. The system of gas has been (and likely must be) flexible in adapting to changes to both how Ethereum is used as well as changes in underlying hardware. Unfortunately, in many cases compromises or workarounds had to be made

RATIONALE:
### Removing gas selectability One major change from the original `CALL` series of instructions is that the caller has no control over the amount of gas passed in as part of the call. The number of cases where such a feature is essential are probably better served by direct


=== EIP-8070 ===
TITLE: Sparse Blobpool
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2025-10-29
REQUIRES: 4, 8, 4, 4, ,,  , 7, 5, 9, 4, ,,  , 7, 8, 7, 0

SUMMARY:
This proposal introduces the sparse blobpool, a construction that brings cell-level, custody-aligned sampling in the Execution Layer (EL). For every new type 3 (blob-carrying) transaction, an EL node fetches full blob payloads only with probability p = 0.15, and otherwise it merely samples the blobs, using the same custody

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### Execution clients :: devp2p changes We introduce a new devp2p protocol version, `eth/71` extending

MOTIVATION:
As Blob Parameter Only (BPO) forks progressively increase throughput, the full-replication nature of today's EL blobpool will begin dominating bandwidth utilization, causing us to hit [EIP-7870](./eip-7870.md) limits. Furthermore, this traffic will compete, and potentially starve, block and attestation propagation, risking instability and liveness issues. This behavior has already been

RATIONALE:
### Parameter selection The choice of p = 0.15 balances bandwidth reduction with availability guarantees. Mathematical analysis for a mesh degree D = 50 shows: - **Primary reliability**: Probability of having at least 3 peers with complete blob payload is 98.6% - **Secondary reliability**: Via reconstruction from partial availability,


=== EIP-684 ===
TITLE: Revert creation in case of collision
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-03-20
REQUIRES: 

SUMMARY:
This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by "creating" an account at that existing address.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. If a contract creation is attempted due to a creation transaction, the `CREATE` opcode, the

RATIONALE:
One of the core tenets of smart contracts is that their code will not change. However with sufficient computing power an attacker can change the code stored in an address to any other code, steal funds or execute other malicious activity.


=== EIP-7949 ===
TITLE: Genesis File Format
TYPE: Informational 
STATUS: Draft
CREATED: 2025-05-19
REQUIRES: 

SUMMARY:
This EIP defines a canonical structure for Ethereum genesis files (`genesis.json`) used to bootstrap Ethereum networks. The standard aligns with the de facto structure implemented by Geth (Go-Ethereum), and already adopted by other clients. It introduces a JSON Schema to ensure consistency and tool compatibility across clients.

SPECIFICATION:
The canonical genesis file MUST be a JSON object with the following top-level fields: ### Top-Level Fields | Field | Type | Description | Example | |-----------------|---------|------------------------------------------------------------------|---------| | `config` | Object | Chain configuration object. | (see below) | | `alloc` | Object | Map of addresses to pre-allocated

MOTIVATION:
The lack of an official standard for the `genesis.json` file has led to incompatibilities, bugs and confusion, as well as added workload for those running multiple clients together in test networks. This EIP aims to reduce ambiguity by defining a consistent structure and enabling tooling through schema-based validation.

RATIONALE:
There are a growing number of EIPs that propose improvements to how a network is configured at genesis: [Add Blob Schedule to EL Config File](eip-7840) [Blob Parameter Only Hardforks](eip-7892) [eth_config JSON-RPC method](eip-7910) However, the root configuration element amended by these remains unspecified. Adopting a minimal schema to define that


=== EIP-1010 ===
TITLE: Uniformity Between 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B and 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-18
REQUIRES: 

SUMMARY:
As of the date of this EIP, the difference in balance between address `0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B` and address `0x15E55EF43efA8348dDaeAa455F16C43B64917e3c` is far from equitable or uniform, with the former having more than 365,000 ether more than the latter. The distribution of ether between these two addresses must be improved in order to

SPECIFICATION:
The balance of `0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B` will be decreased by 100,000 ether. The balance of `0x15E55EF43efA8348dDaeAa455F16C43B64917e3c` will be increased by 100,000 ether. No net change in the amount of extant ether will occur unless at the time of implementation the former address does not contain sufficient ether for such a deduction.

MOTIVATION:
This proposal is necessary because the Ethereum protocol does not allow the owner of an address which does not own an equitable amount of ether to claim their share of ether from an address which owns a dangerously centralized quantity. Rather than proposing an overly complicated generic mechanism for

RATIONALE:
The value 100,000 was chosen after careful technically sound analysis of various economic theories developed over the past century. In spite of the fact that it is a convenient round number, it is actually the exact output of a complex statistical process iterated to determine the optimal distribution of


=== EIP-7916 ===
TITLE: SSZ ProgressiveList
TYPE: Standards Track Core
STATUS: Review
CREATED: 2025-03-24
REQUIRES: 

SUMMARY:
This EIP introduces a new Merkle tree shape for [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md) types that results in fewer hashes when only a small number of leaves is used. The new tree shape grows progressively with increased leaf count and no longer has a bounded capacity. It also offers forward compatibility:

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Progressive Merkle tree The [SSZ Merkleization specification](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/simple-serialize.md#merkleization) is extended with a helper function: -

MOTIVATION:
Current SSZ `List[type, N]` types require a predefined capacity `N`, which leads to several issues: - Inefficient hashing: Lists often contain far fewer elements than their maximum capacity (e.g., [`Transaction`](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/specs/bellatrix/beacon-chain.md#custom-types)), resulting in unnecessary zero-padding and dozens of extra hash computations. This is exacerbated when nesting `List[type, N]`, e.g., in

RATIONALE:
### Why a recursive structure? - Efficiency: Small lists use fewer hashes (e.g., a 3-item list in a 16-element subtree wastes fewer hashes than a 1024-element `List[type, N]`). - Stability: Fixed subtree sizes ensure stable gindices, avoiding the need for dynamic depth adjustments or multiple queries. - Scalability: Recursive


=== EIP-2976 ===
TITLE: Typed Transactions over Gossip
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-09-13
REQUIRES: 2718

SUMMARY:
[Typed Transactions](./eip-2718.md) can be sent over devp2p as `TransactionType || TransactionPayload`. The exact contents of the `TransactionPayload` are defined by the `TransactionType` in future EIPs, and clients may start supporting their gossip without incrementing the devp2p version. If a client receives a `TransactionType` that it doesn't recognize, it **SHOULD**

SPECIFICATION:
All changes specified below apply to all protocol/versions retroactively. ### Definitions * `||` is the byte/byte-array concatenation operator. * `|` is the type union operator. * `DEVP2P_VERSION = TBD` * `Transaction` is either `TypedTransaction` or `LegacyTransaction` * `TypedTransaction` is a byte array containing `TransactionType || TransactionPayload` * `TypedTransactionHash` is

MOTIVATION:
[EIP-2718](./eip-2718.md) introduced new transaction types for blocks (which presents itself in the makeup of a block header's transaction root and receipts root). However, without a mechanism for gossiping these transactions, no one can actually include them in a block. By updating devp2p to support the gossip of Typed Transactions,

RATIONALE:
### Why not specify each transaction type at the protocol layer? We could have chosen to make the protocol aware of the shape of the transaction payloads. The authors felt that it would be too much maintenance burden long term to have every new transaction type require an update


=== EIP-3 ===
TITLE: Addition of CALLDEPTH opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2015-11-19
REQUIRES: 


=== EIP-3541 ===
TITLE: Reject new contract code starting with the 0xEF byte
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-03-16
REQUIRES: 

SUMMARY:
Disallow new code starting with the `0xEF` byte to be deployed. Code already existing in the account trie starting with `0xEF` byte is not affected semantically by this change.

SPECIFICATION:
After `block.number == HF_BLOCK` new contract creation (via create transaction, `CREATE` or `CREATE2` instructions) results in an exceptional abort if the _code_'s first byte is `0xEF`. ### Remarks The *initcode* is the code executed in the context of the *create* transaction, `CREATE`, or `CREATE2` instructions. The *initcode* returns *code*

MOTIVATION:
Contracts conforming to the EVM Object Format (EOF) are going to be validated at deploy time. In order to guarantee that every EOF-formatted contract in the state is valid, we need to prevent already deployed (and not validated) contracts from being recognized as such format. This will be achieved

RATIONALE:
The `0xEF` byte was chosen because it resembles **E**xecutable **F**ormat. Contracts using unassigned opcodes are generally understood to be at risk of changing semantics. Hence using the unassigned `0xEF` should have lesser effects, than choosing an assigned opcode, such as `0xFD` (`REVERT`), `0xFE` (`INVALID)`, or `0xFF` (`SELFDESTRUCT`). Arguably while


=== EIP-8032 ===
TITLE: Size-Based Storage Gas Pricing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-09-29
REQUIRES: 

SUMMARY:
This EIP introduces a mechanism to dynamically price SSTORE operations based on the storage size of a contract. A new optional `storage_count` field is added to the account RLP, which tracks the number of storage slots it owns. The gas cost for SSTORE will be augmented by a factor

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174). ### Constants and parameters |Name|Value|Description| |-|:-:|-| |`FORK_TIMESTAMP`| TBD | Fork activation timestamp | |`LIN_FACTOR` |

MOTIVATION:
Ethereum's state size is a growing concern, as it directly impacts node synchronization times, hardware requirements, and overall network health. The current gas model for storage operations does not fully account for the long-term cost of maintaining state indefinitely. As a result, it remains economically viable to deploy contracts

RATIONALE:
The intent is to create friction when growing the state size of a contract, thus limiting the number of such contracts. Going over the limit, some contract developers might want to use another contract to start fresh, which comes at the cost of paying for contract creation, and for


=== EIP-6800 ===
TITLE: Ethereum state using a unified verkle tree
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-03-17
REQUIRES: 6780

SUMMARY:
Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Verkle tree definition We define a Verkle tree here by providing the function to

MOTIVATION:
Verkle trees solve a key problem standing in the way of Ethereum being stateless-client-friendly: witness sizes. A witness accessing an account in today’s hexary Patricia tree is, in the average case, close to 3 kB, and in the worst case it may be three times larger. Assuming a worst

RATIONALE:
This implements all of the logic in transitioning to a Verkle tree, and at the same time reforms gas costs, but does so in a minimally disruptive way that does not require simultaneously changing the whole tree structure. Instead, we add a new Verkle tree that starts out empty,


=== EIP-7685 ===
TITLE: General purpose execution layer requests
TYPE: Standards Track Core
STATUS: Final
CREATED: 2024-04-14
REQUIRES: 

SUMMARY:
This proposal defines a general purpose framework for storing contract-triggered requests. It extends the execution header with a single field to store the request information. Requests are later on exposed to the consensus layer, which then processes each one.

SPECIFICATION:
### Execution Layer #### Requests A `requests` object consists of a `request_type` byte prepended to an opaque byte array `request_data`. The `request_data` contains zero or more encoded request objects. ``` requests = request_type ++ request_data ``` Each request type will define its own `requests` object with its own `request_data`

MOTIVATION:
The proliferation of smart contract controlled validators has caused there to be a demand for additional EL triggered behaviors. By allowing these systems to delegate administrative operations to their governing smart contracts, they can avoid intermediaries needing to step in and ensure certain operations occur. This creates a safer

RATIONALE:
### Opaque byte array rather than an RLP array By having the bytes of `request_data` array from second byte on be opaque bytes, rather than an RLP (or other encoding) list, we can support different encoding formats for the request payload in the future such as SSZ, LEB128, or


=== EIP-7748 ===
TITLE: State conversion to Verkle Tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-07-23
REQUIRES: 7612

SUMMARY:
This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants | Parameter | value | Description | | ---------------------------- | ----- | --------------------------------------------------------------

MOTIVATION:
The accounts state is too large to wait for transactions to organically move all of them to the VKT through the Overlay Tree. Thus, we need a strategy to convert all the state within a reasonable time. The state conversion completion allows removing the Overlay Tree abstraction introduced in

RATIONALE:
### State conversion step position in block execution Performing the conversion step before the block txs execution has some benefits: - If the state conversion step is done after txs execution, there's a possibility that txs execution writes overlap with converted key-values, having to care about them becoming stale


=== EIP-7915 ===
TITLE: Adaptive mean reversion blob pricing
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2025-03-23
REQUIRES: 4844

SUMMARY:
Reworks the excess blob gas update in `calc_excess_blob_gas()` so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The

SPECIFICATION:
### Parameters | Constant | Value | Short description | | - | - | - | | `EMA_DECAY` | `2**18` | Reciprocal of the EMA decay rate (per slot) | | `MEAN_REVERSION_DEADBAND` | `64` | Fee ratio at which mean reversion effect accelerates | | `MEAN_REVERSION_FULLBAND` | `10**6`

MOTIVATION:
Demand for blobspace is fee-inelastic, leading to a blob base fee that may fluctuate excessively with minor shifts in aggregate demand. The lower end of the fee range of 1 wei is under current circumstances economically inconsequential, but can be reached after a period of blocks consuming fewer blobs

RATIONALE:
### Supply and demand Since the introduction of blobs, the reservation fee of the marginal consumer of blobs has periodically been very low. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a


=== EIP-2566 ===
TITLE: Human Readable Parameters for Contract Function Execution
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-03-23
REQUIRES: 

SUMMARY:
When a dapp prompts a user to execute a smart contract function via a ProviderWallet, confirmation screens displayed in the ProviderWallet layer cannot display the human readable details of the function to be called and the arguments to be passed. This is because the Ethereum RPC method used for

SPECIFICATION:
This EIP proposes increasing the set of Ethereum RPC methods to include a new method - `eth_sendTransactionToContractFunction`. This method parallels `eth_sendTransaction` with the only difference being the inclusion of the contract function's `abi` field. Parameters 1. `Object` - The transaction object * `from`: `DATA`, 20 Bytes - The address

MOTIVATION:
### ProviderWallet Definition ProviderWallets like Metamask and Geth are hybrid software that combine an Ethereum API provider with an Ethereum wallet. This allows them to sign transactions on behalf of their users and also broadcast those signed transactions to the Ethereum network. ProviderWallets are used for both convenience and

RATIONALE:
This EIP's proposed `eth_sendTransactionToContractFunction` method is intended to parallel `eth_sendTransaction` as much as possible since both methods result in the same behaviour when executing a contract function. The newly introduced `abi` field is an element of the contract's ABI that corresponds to the intended function. The `data` field is


=== EIP-1702 ===
TITLE: Generalized Account Versioning Scheme
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-12-30
REQUIRES: 

SUMMARY:
This defines a method of hard forking while maintaining the exact functionality of existing account by allowing multiple versions of the virtual machines to execute in the same block. This is also useful to define future account state structures when we introduce the on-chain WebAssembly virtual machine.

SPECIFICATION:
### Account State Re-define account state stored in the world state trie to have 5 items: `nonce`, `balance`, `storageRoot`, `codeHash`, and `version`. The newly added field `version` is a 256-bit **scalar**. We use the definition of "scalar" from Yellow Paper. Note that this is the same type as `nonce`

MOTIVATION:
By allowing account versioning, we can execute different virtual machine for contracts created at different times. This allows breaking features to be implemented while making sure existing contracts work as expected. Note that this specification might not apply to all hard forks. We have emergency hard forks in the

RATIONALE:
This introduces account versioning via a new RLP item in account state. The design above gets account versioning by making the contract *family* always have the same version. In this way, versions are only needed to be provided by contract creation transaction, and there is no restrictions on formats


=== EIP-7251 ===
TITLE: Increase the MAX_EFFECTIVE_BALANCE
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-06-28
REQUIRES: 7, 0, 0, 2, ,,  , 7, 6, 8, 5

SUMMARY:
Increases the constant `MAX_EFFECTIVE_BALANCE`, while keeping the minimum staking balance `32 ETH`. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.

SPECIFICATION:
### Constants #### Execution layer | Name | Value | Comment | | - | - | - | | `CONSOLIDATION_REQUEST_TYPE` | `0x02` | The [EIP-7685](./eip-7685.md) type prefix for consolidation request | | `CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS` | `0x0000BBdDc7CE488642fb579F8B00f3a590007251` | Where to call and store relevant details about consolidation request mechanism |

MOTIVATION:
As of October 3, 2023, there are currently over 830,000 validators participating in the consensus layer. The size of this set continues to grow due, in part, to the `MAX_EFFECTIVE_BALANCE`, which limits the stake of a single validator to `32 ETH`. This leads to large amounts of "redundant validators",

RATIONALE:
This EIP aims to reduce the total number of validators without changing anything about the economic security of the protocol. It provides a mechanism by which large node operators who control significant amounts of stake can consolidate into fewer validators. We analyze the reasoning behind each of the core


=== EIP-7549 ===
TITLE: Move committee index outside Attestation
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-11-01
REQUIRES: 

SUMMARY:
Move the committee's `index` field outside of the signed Attestation message to allow aggregation of equal consensus votes.

SPECIFICATION:
### Execution layer This requires no changes to the Execution Layer. ### Consensus layer - Set `index` field from `AttestationData` to a fixed value of zero - Move committee indexing data to the outer `Attestation` container with `committee_bits` - Increase the capacity of `aggregation_bits` to all committees in a

MOTIVATION:
This proposal aims to make Casper FFG clients more efficient by reducing the average number of pairings needed to verify consensus rules. While all types of clients can benefit from this EIP, ZK circuits proving Casper FFG consensus will likely have the most impact. On a beacon chain network

RATIONALE:
### Deprecation strategy The `index` field in `AttestationData` can be deprecated by: 1. Removing the field 2. Preserving the field and setting it to zero 3. Changing the field type to Optional (from EIP-7495 StableContainer) This EIP chooses the second option to not complicate the inclusion of `AttesterSlashing` objects.


=== EIP-2159 ===
TITLE: Common Prometheus Metrics Names for Clients
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-07-01
REQUIRES: 

SUMMARY:
Many Ethereum clients expose a range of metrics in a format compatible with Prometheus to allow operators to monitor the client's behaviour and performance and raise alerts if the chain isn't progressing or there are other indications of errors. While the majority of these metrics are highly client-specific, reporting

SPECIFICATION:
The table below defines metrics which may be captured by Ethereum clients which expose metrics to Prometheus. Clients may expose additional metrics however these should not use the `ethereum_` prefix. | Name | Metric type | Definition | JSON-RPC Equivalent | |----------------------------------|-------------|-------------------------------------------------------------------|---------------------------------------------------------------------| | ethereum_blockchain_height | Gauge | The current

MOTIVATION:
Using common names and meanings for metrics which apply to all clients allows node operators to monitor clusters of nodes using heterogeneous clients using a single dashboard and alerting configuration. Currently there are no agreed names or meanings, leaving client developers to invent their own making it difficult to

RATIONALE:
The defined metrics are independent of Ethereum client implementation but provide sufficient information to create an overview dashboard to support monitoring a group of Ethereum nodes. There is a similar, though more prescriptive, specification for beacon chain client metrics. The specific details of how to expose the metrics has


=== EIP-2539 ===
TITLE: BLS12-377 curve operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-26
REQUIRES: 1, 1, 0, 9, ,,  , 2, 0, 4, 6

SUMMARY:
This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary to *efficiently* perform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and

SPECIFICATION:
Curve parameters: BLS12-377 curve is fully defined by the following set of parameters (coefficient `A=0` for all BLS12 curves): ``` Base field modulus = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001 B coefficient = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 Main subgroup order = 0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001 Extension tower: Fp2 construction: Fp quadratic non-residue = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508bffffffffffc Fp6/Fp12 construction: Fp2 cubic non-residue c0

MOTIVATION:
Motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security. In addition it allows efficient one-time recursive proof aggregations, e.g. proofs about

RATIONALE:
Motivation section covers a total motivation to have operations over BLS12-377 curve available. We also extend a rationale for move specific fine points. ### Multiexponentiation as a separate call Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger


=== EIP-196 ===
TITLE: Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-02
REQUIRES: 

SUMMARY:
This EIP suggests to add precompiled contracts for addition and scalar multiplication on a specific pairing-friendly elliptic curve. This can in turn be combined with [EIP-197](./eip-197.md) to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users

SPECIFICATION:
If `block.number >= BYZANTIUM_FORK_BLKNUM`, add precompiled contracts for point addition (ADD) and scalar multiplication (MUL) on the elliptic curve "alt_bn128". Address of ADD: 0x6 Address for MUL: 0x7 The curve is defined by: ``` Y^2 = X^3 + 3 over the field F_p with p = 21888242871839275222246405745257275088696311157297823662689037894645226208583 ``` ###

MOTIVATION:
Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of

RATIONALE:
The specific curve `alt_bn128` was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts. The feature of adding curve and


=== EIP-2681 ===
TITLE: Limit account nonce to 2^64-1
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-04-25
REQUIRES: 

SUMMARY:
Limit account nonce to be between `0` and `2^64-1`.

SPECIFICATION:
Introduce two new restrictions retroactively from genesis: 1. Consider any transaction invalid, where the nonce exceeds or equals to `2^64-1`. 2. The `CREATE` and `CREATE2` instructions' execution ends with the result `0` pushed on stack, where the account nonce is `2^64-1`. Gas for initcode execution is not deducted in

MOTIVATION:
Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way. Additionally it could prove beneficial to transaction formats, where some improvements

RATIONALE:
1. It is unlikely for any nonce to reach or exceed the proposed limit. If one would want to reach that limit via external transactions, it would cost at least `21000 * (2^64-1) = 387_381_625_547_900_583_915_000` gas. 2. It must be noted that in the past, in the Morden testnet,


=== EIP-7799 ===
TITLE: System logs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-29
REQUIRES: 4, 8, 9, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 7, 0, 8, ,,  , 7, 9, 1, 6, ,,  , 8, 1, 1, 5

SUMMARY:
This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Fee payment logs A log, identical to a LOG2, is issued for every transaction

MOTIVATION:
With [EIP-7708](./eip-7708.md) wallets gain the ability to use eth_getLogs to track changes to their ETH balance. However, the ETH balance may change without an explicit transaction, through block production and withdrawals. By having such operations emit block-level system logs, eth_getLogs provides a complete picture of ETH balance changes.

RATIONALE:
Together with [EIP-7708](./eip-7708.md) this EIP provides the ability for wallets to compute the exact ETH balance from logs without requiring download of every single block header and all withdrawals. The block reward from priority fees no longer has to be summed up by processing all receipts and can be


=== EIP-7708 ===
TITLE: ETH transfers emit a log
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-17
REQUIRES: 

SUMMARY:
All ETH-transfers, including transactions, `CALL` and `SELFDESTRUCT` emit a log.

SPECIFICATION:
### ETH transfer logs A log, identical to a LOG3, is issued for: - Any nonzero-value-transferring transaction, before any other logs created by EVM execution - Any nonzero-value-transferring `CALL`, at the time that the value transfer executes - Any nonzero-value-transferring `SELFDESTRUCT` to a different account, at the time that

MOTIVATION:
Logs are often used to track when balance changes of assets on Ethereum. Logs work for [ERC-20](./eip-20.md) tokens, but they do not work for ETH. ETH transfers from EOAs can be read from the transaction list in the block, but ETH transfers from smart contract wallets are not automatically

RATIONALE:
This is the simplest possible implementation that ensures that all ETH transfers are implemented in some kind of record that can be easily accessed through making RPC calls into a node, or through asking for a Merkle branch that is hashed into the block root. The log type is


=== EIP-7805 ===
TITLE: Fork-choice enforced Inclusion Lists (FOCIL)
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-01
REQUIRES: 

SUMMARY:
FOCIL implements a robust mechanism to preserve Ethereum’s censorship resistance properties by guaranteeing timely transaction inclusion. FOCIL (**Fo**rk-**c**hoice enforced **I**nclusion **L**ists) is built in a few simple steps: - In each slot, a set of validators is selected as inclusion list (IL) committee members. Each member builds and gossips

SPECIFICATION:
### Execution Layer On the execution layer, an additional check is introduced for new payloads. After all of the transactions in the payload have been executed, we check whether any transaction from ILs, that is not already present in the payload, could be validly included (i.e. nonce and balance

MOTIVATION:
In an effort to shield the Ethereum validator set from centralizing forces, the right to build blocks has been auctioned off to specialized entities known as *builders*. This has led to a few sophisticated builders dominating block production, leading to a deterioration of the network’s censorship resistance properties. To

RATIONALE:
### Core Properties - Committee-based: FOCIL relies on a committee of multiple validators, rather than a single proposer, to construct and broadcast ILs. This approach significantly reduces the surface for bribery and extortion attacks and strengthens censorship resistance. - Fork-choice enforced: FOCIL incorporates the force-inclusion mechanism into the fork-choice


=== EIP-1276 ===
TITLE: Eliminate Difficulty Bomb and Adjust Block Reward on Constantinople Shift
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-31
REQUIRES: 

SUMMARY:
Starting with `CNSTNTNPL_FORK_BLKNUM` the client will calculate the difficulty without considering the current block number. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Remove Exponential Component of Difficulty Adjustment For the purposes of `calc_difficulty`, simply remove the exponential difficulty adjustment component, `epsilon`, i.e. the `int(2**((block.number // 100000) - 2))`. #### Adjust Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward =

MOTIVATION:
Block time has been played a most important role on blockchain ecosystem, and it is being adjusted by the logic of mining difficulty calculation that is already implemented on the node client as a part of proof-of-work consensus. Last year, average block time rapidly increased due to the wrong

RATIONALE:
This will completely remove the difficulty bomb on difficulty adjustment algorithm without delaying the difficulty bomb again, therefore it is possible to prevent network delay on the beginning of 2019. This EIP-1276 opposes directly the intent of [EIP-1234](./eip-1234.md) which should be also considered in discussions.


=== EIP-5478 ===
TITLE: CREATE2COPY Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-08-17
REQUIRES: 1, 0, 1, 4, ,,  , 2, 9, 2, 9

SUMMARY:
Adding a new opcode, `CREATE2COPY`, that is identical to `CREATE2` but with potentially much lower gas cost by accepting an additional argument `existing_contract_address` that already stored the code of the new contract.

SPECIFICATION:
### Parameters | Constant | Value | | ---------------------------- | ---------------- | | `FORK_BLKNUM` | TBD | | `CREATE_DATA_GAS_PER_BYTE` | 200 | | `COLD_ACCOUNT_ACCESS_COST` | 2600 | | `WARM_ACCOUNT_ACCESS_COST` | 100 | If `block.number >= FORK_BLKNUM`, a new opcode is added (`CREATE2COPY`) at `0xf6`, which takes 5 stack arguments:

MOTIVATION:
This EIP aims to reduce the smart contract creation cost of account abstraction (AA) contracts that have identical code. The major cost of creating an AA contract is the contract creation cost, especially data gas. For example, creating an AA contract with 10,000 bytes will consume 2,000,000 data gas.

RATIONALE:
TBD


=== EIP-6493 ===
TITLE: SSZ transaction signature scheme
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-24
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 6

SUMMARY:
This EIP defines a signature scheme for native [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md) encoded transactions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Transaction signature scheme Native SSZ transactions are based on the `TransactionPayload` defined in [EIP-6404](./eip-6404.md)

MOTIVATION:
[EIP-6404](./eip-6404.md) introduces SSZ transactions by converting from RLP transactions. Defining a signature scheme for native SSZ transactions further reduces required conversions and unlocks the forward compatibility benefits of SSZ [`ProgressiveContainer`](./eip-7495.md).

RATIONALE:
The SSZ signature scheme reduces hashing overhead and ensures that `tx_hash` commitments are available on-chain. It also provides a flexible basis for future transaction functionality.


=== EIP-210 ===
TITLE: Blockhash refactoring
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-02-10
REQUIRES: 

SPECIFICATION:
If `block.number == CONSTANTINOPLE_FORK_BLKNUM`, then when processing the block, before processing any transactions set the code of BLOCKHASH_CONTRACT_ADDR to BLOCKHASH_CONTRACT_CODE. If `block.number >= CONSTANTINOPLE_FORK_BLKNUM`, then when processing a block, before processing any transactions execute a call with the parameters: * `SENDER`: SUPER_USER * `GAS`: 1000000 * `TO`: BLOCKHASH_CONTRACT_ADDR *

RATIONALE:
This removes the need for implementations to have an explicit way to look into historical block hashes, simplifying the protocol definition and removing a large component of the "implied state" (information that is technically state but is not part of the state tree) and thereby making the protocol more


=== EIP-3030 ===
TITLE: BLS Remote Signer HTTP API
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-09-30
REQUIRES: 

SUMMARY:
A [validator](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/validator.md) client contributes to the consensus of the Eth2 blockchain by signing proposals and attestations of blocks, using a BLS private key which must be available to this client at all times. The BLS remote signer API is designed to be consumed by validator clients, looking for a

SPECIFICATION:
### `GET /upcheck` _**Responses**_ Success | <br> --- | --- Code | `200` Content | `{"status": "OK"}` --- ### `GET /keys` Returns the identifiers of the keys available to the signer. _**Responses**_ Success | <br> --- | --- Code | `200` Content | `{"keys": "[identifier]"}` --- ### `POST /sign/:identifier`

MOTIVATION:
Eth2 utilizes [BLS12-381](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/) signatures. Consensus on the eth2 Blockchain is achieved via the proposal and attestation of blocks from validator clients, using a BLS private key (_signing_ key) which must be available each time a message is signed: that is, at least once every epoch (6.4 minutes), during a

RATIONALE:
### UNIX philosophy: Simple API This API specification contains only three methods: one for **status**, one for **listing the available keys**, and one to **produce a signature**. There are no methods for authentication, key management, nor transport encryption. The following subsections discuss aspects to be considered by the client


=== EIP-4863 ===
TITLE: Beacon chain push withdrawals
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-28
REQUIRES: 

SUMMARY:
Introduce a new [EIP-2718 transaction type](./eip-2718.md) to support validator withdrawals that are "pushed" from the beacon chain to the EVM. Add block validations to ensure the withdrawal transactions are sound with respect to withdrawal processing on the beacon chain.

SPECIFICATION:
| constants | value | units |--- |--- |--- | `FORK_TIMESTAMP` | TBD | | `WITHDRAWAL_TX_TYPE` | `0x3` | byte Beginning with the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** introduce the following extensions to transaction processing and block validation: ### New transaction type Define a new [EIP-2718](./eip-2718.md) transaction type

MOTIVATION:
This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM. The architecture is "push"-based, rather than "pull"-based, where withdrawals are required to be processed in the execution block as soon as they are dequeued from the beacon chain. This approach is

RATIONALE:
### Push vs pull approach This push approach gives validators a small subsidy with respect to processing, in lieu of needing to buy gas via normal EVM processing that would be required for a pull-based approach. This style also happens automatically when the requisite conditions are met on the


=== EIP-8123 ===
TITLE: RPC Method for Transaction Gas Limit Cap
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2026-01-11
REQUIRES: 1, 4, 7, 4, ,,  , 7, 8, 2, 5

SUMMARY:
This EIP specifies a new Ethereum JSON-RPC method, `eth_txGasLimitCap`, which returns the maximum transaction gas limit (`tx.gas`) that the node will accept under the current fork rules (and any stricter local policy). This enables wallets, SDKs, bundlers, and tooling to discover the effective per-transaction gas limit cap without simulation

SPECIFICATION:
The key words “MUST", “MUST NOT", “SHOULD", and “MAY" are to be interpreted as described in RFC 2119. ### New method: `eth_txGasLimitCap` #### Request - **Method**: `eth_txGasLimitCap` - **Params**: `[]` (no parameters) #### Response - **Result**: `QUANTITY` or `null` - If the node enforces a finite transaction gas limit

MOTIVATION:
[EIP-7825](./eip-7825.md) introduces a protocol-level per-transaction gas limit cap (e.g. `2^24 = 16,777,216` on Ethereum) to bound worst-case single-transaction work. However, it does not specify any way to query this cap. As a consequence, users and tools must: - infer it from failed transaction submissions, - hardcode network assumptions, -

RATIONALE:
A dedicated method is needed because there is currently no way to query the maximum allowed `tx.gas` without simulation or out-of-band knowledge. Returning the _effective_ cap (`min(protocolCap, policyCap)`) matches what users need when constructing transactions to submit.


=== EIP-2803 ===
TITLE: Rich Transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-07-18
REQUIRES: 

SUMMARY:
If a transaction has a `to` of address `x`, then the `data` of the transaction will be treated as EVM bytecode and it will be executed from the context of the `CALLER` of the transaction (aka: the transaction signer).

SPECIFICATION:
A new reserved address is specified at `x`, in the range used for precompiles. When a transaction is sent to this address from an externally owned account, the payload of the transaction is treated as EVM bytecode, and executed with the signer of the transaction as the current account.

MOTIVATION:
Many Ethereum DApps presently require users to approve multiple transactions in order to produce one effect - for example, the common pattern of first approving a contract to spend a token, then calling that contract. This results in a poor user-experience, and complicates the experience of interacting with DApps.

RATIONALE:
The intent of this EIP is for the new precompile to act in all ways possible like a `DELEGATECALL` from an externally owned account. Some changes are required to reflect the fact that the code being executed is not stored on chain, and for special cases such as `SELFDESTRUCT`,


=== EIP-5793 ===
TITLE: eth/68 - Add tx type to tx announcement
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-10-18
REQUIRES: 2, 4, 6, 4, ,,  , 2, 4, 8, 1, ,,  , 4, 9, 3, 8

SUMMARY:
The Ethereum Wire Protocol defines request and response messages for exchanging data between clients. The `NewPooledTransactionHashes` message announces transactions available in the node. This EIP extends this announcement message such that beside the transaction hashes, the node sends the transaction types and their sizes (as defined in [EIP-2718](./eip-2718.md)) as

SPECIFICATION:
Modify the `NewPooledTransactionHashes (0x08)` message: * **(eth/67)**: `[hash_0: B_32, hash_1: B_32, ...]` * **(eth/68)**: `[types: B, [size_0: P, size_1: P, ...], [hash_0: B_32, hash_1: B_32, ...]]` The new `types` element refers to the transaction types of the announced hashes. Note the transaction types are packed as a 'byte array'

MOTIVATION:
The `NewPooledTransactionHashes` message announces transaction hashes, allowing the peer to selectively fetch transactions it does not yet have. [EIP-4844](./eip-4844.md) introduces a new transaction type for blob transactions. Since these blob transactions are large, naively broadcasting them to `sqrt(peers)` could significantly increase bandwidth requirements. Adding the transaction type and the

RATIONALE:
This change will make the `eth` protocol future-proof for new transaction types that might not be relevant for all nodes. It gives the receiving node better control over the data it fetches from the peer as well as allow throttling the download of specific types. The `types` message element


=== EIP-8057 ===
TITLE: Inter-Block Temporal Locality Gas Discounts
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-20
REQUIRES: 2, 9, 2, 9, ,,  , 7, 9, 2, 8

SUMMARY:
This proposal introduces a deterministic, multi-block discount for the first access to accounts and storage keys in a transaction. The discount depends on how many blocks have passed since the item was last accessed, decaying smoothly to zero over a fixed recent window. Intra-block warming semantics are unchanged -

SPECIFICATION:
### Terminology and constants | Name | Description | Default | |-----------------------------|-----------------------|-----------------| | `WINDOW_SIZE_BLOCKS`| Number of recent blocks over which a discount may apply. | `32` | | `CURRENT_BLOCK_NUMBER` | The block number of the transaction being executed. | - | | `LAST_ACCESS_BLOCK_NUMBER(item)` | The most recent block number

MOTIVATION:
Current warm and cold access pricing correctly models client state costs in the *worst case* but leaves a predictable efficiency gap in the *common case*. Clients maintain short-lived in-memory caches of recently accessed accounts and storage slots to handle short reorgs and pipeline execution across blocks. These caches make

RATIONALE:
- Determinism: discounts depend only on prior blocks, so users can predict costs at submission time. The block-level access lists in headers remove bootstrap ambiguity for new nodes. Intra-block dependent savings are inherently unknowable and non-actionable at submission, so they do not change behaviour; prior-block based savings do. -


=== EIP-4200 ===
TITLE: EOF - Static relative jumps
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-07-16
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Three new EVM jump instructions are introduced (`RJUMP`, `RJUMPI` and `RJUMPV`) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.

SPECIFICATION:
We introduce three new instructions on the same block number [EIP-3540](./eip-3540.md) is activated on: 1. `RJUMP` (0xe0) - relative jump 2. `RJUMPI` (0xe1) - conditional relative jump 3. `RJUMPV` (0xe2) - relative jump via jump table If the code is legacy bytecode, all of these instructions result in an

MOTIVATION:
A recurring discussion topic is that EVM only has a mechanism for dynamic jumps. They provide a very flexible architecture with only 2 (!) instructions. This flexibility comes at a cost however: it makes analysis of code more complicated and it also (partially) resulted in the need to have

RATIONALE:
### Relative addressing We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code like `PUSHn PC ADD JUMPI`. We do not


=== EIP-7723 ===
TITLE: Network Upgrade Inclusion Stages
TYPE: Meta 
STATUS: Last Call
CREATED: 2024-06-12
REQUIRES: 

SUMMARY:
Define the stages that EIPs go through in the process of planning network upgrades: `Proposed for Inclusion`, `Considered for Inclusion`, `Scheduled for Inclusion`, `Declined for Inclusion` and `Included`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All EIP statuses apply to a single network upgrade. EIPs must be `Proposed`, `Considered`, `Declined`

MOTIVATION:
This EIP proposes definitions for the various stages EIPs go through when planning network upgrades. It also provides context and guidelines around when and how EIPs should be moved from one stage to the next.

RATIONALE:
Formalizing the `Proposed for Inclusion`, `Considered for Inclusion`, `Scheduled for Inclusion`, `Declined for Inclusion` and `Included` stages provides better legibility to both protocol maintainers and the broader Ethereum community. The specification tries to minimize steps which **MUST** be followed to align with Ethereum's "rough consensus" governance model. Assuming it


=== EIP-2364 ===
TITLE: eth/64: forkid-extended protocol handshake
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2019-11-08
REQUIRES: 2124

SUMMARY:
This EIP specifies the inclusion of the `forkid`, originally defined in [(EIP-2124)](./eip-2124.md), as a new field in the Ethereum wire protocol (`eth`) handshake. This change is implemented as a new version of the wire protocol, `eth/64`.

SPECIFICATION:
- Implement `forkid` generation and validation per [EIP-2124](./eip-2124.md). - Advertise a new `eth` protocol capability (version) at `eth/64`. - The old `eth/63` protocol should still be kept alive side-by-side, until `eth/64` is sufficiently adopted by implementors. - Redefine `Status (0x00)` for `eth/64` to add a trailing `forkid` field: -

MOTIVATION:
The [`forkid` (EIP-2124)](./eip-2124.md) was designed to permit two Ethereum nodes to quickly and cheaply decide if they are compatible or not, not only at a genesis/networking level, but also from the perspective of the currently passed network updates (i.e. forks). [EIP-2124](./eip-2124.md) only defines how the `forkid` is calculated and

RATIONALE:
The specification is tiny since most parts are already specified in EIP-2124. `eth/63` is not specified as an EIP, but is maintained in the [ethereum/devp2p](https://github.com/ethereum/devp2p) Github repository. ### EIP-2124 mentions advertising the `forkid` in the discovery protocol too. How does that compare to advertising in the `eth` protocol? Why


=== EIP-1013 ===
TITLE: Hardfork Meta: Constantinople
TYPE: Meta 
STATUS: Final
CREATED: 2018-04-20
REQUIRES: 1, 4, 5, ,,  , 6, 0, 9, ,,  , 1, 0, 1, 4, ,,  , 1, 0, 5, 2, ,,  , 1, 2, 3, 4, ,,  , 1, 2, 8, 3

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Constantinople.

SPECIFICATION:
- Codename: Constantinople - Aliases: Metropolis/Constantinople, Metropolis part 2 - Activation: - `Block >= 7_280_000` on the Ethereum Mainnet - `Block >= 4,230,000` on the Ropsten testnet - `Block >= 9_200_000` on the Kovan testnet - `Block >= 3_660_663` on the Rinkeby testnet - Included EIPs: - [EIP-145](./eip-145.md): Bitwise


=== EIP-1767 ===
TITLE: GraphQL interface to Ethereum node data
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-02-14
REQUIRES: 

SUMMARY:
This EIP specifies a GraphQL schema for accessing data stored on an Ethereum node. It aims to provide a complete replacement to the read-only information exposed via the present JSON-RPC interface, while improving on usability, consistency, efficiency, and future-proofing.

SPECIFICATION:
### Node API Compatible nodes MUST provide a GraphQL endpoint available over HTTP. This SHOULD be offered on port 8547 by default. The path to the GraphQL endpoint SHOULD be '/graphql'. Compatible nodes MAY offer a GraphiQL interactive query explorer on the root path ('/'). ### Schema The GraphQL

MOTIVATION:
The current JSON-RPC interface for Ethereum nodes has a number of shortcomings. It's informally and incompletely specified in areas, which has led to incompatibilities around issues such as representation of empty byte strings ("" vs "0x" vs "0x0"), and it has to make educated guesses about the data a

RATIONALE:
Ethereum nodes have been moving away from providing read-write functionality such as transaction and message signing, and from other services such as code compilation, in favor of a more 'unix-like' approach where each task is performed by a dedicated process. We have thus specified a core set of types


=== EIP-867 ===
TITLE: Standardized Ethereum Recovery Proposals
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-02-02
REQUIRES: 

SUMMARY:
This proposal identifies a common solution method that can be used to address certain classes of lost funds on the Ethereum blockchain. In particular, it is intended to address cases where there is no disagreement about the right outcome between directly affected parties, enabling timely and low-risk solutions to

SPECIFICATION:
This EIP describes a common format to be used for a subclass of EIPs, referred to as ethereum recovery proposals (ERPs), that propose an irregular state change required to address a fund recovery scenario that cannot be addressed using the standard protocol. Each ERP will reference this EIP will

MOTIVATION:
The issue of fund recovery on the Ethereum blockchain is often controversial. Frozen fund recovery proposals are almost never successful due to the relatively ad-hoc nature of such requests and the subjectivity that is often required to evaluate the merits. This EIP attempts to remove these barriers by providing

RATIONALE:
The primary consideration for the approach described above was to minimize the amount of risk associated with recovery actions that would otherwise not have a viable solution. A secondary consideration was to standardize the format used in the proposals for recovery actions. First, including a verification script guarantees that


=== EIP-2844 ===
TITLE: Add DID related methods to the JSON-RPC
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-08-01
REQUIRES: 

SUMMARY:
This EIP describes three new methods to add to the JSON-RPC that enables wallets to support *Decentralized Identifiers* (DIDs) as well as *JSON Object Signing and Encryption* (JOSE). These standards enables wallets to support data decryption as well as authenticated data, both in standard formats using JOSE. With these

SPECIFICATION:
Three new JSON-RPC methods are specified under the new `did_*` prefix. ### Auth Authenticate the current rpc connection to the DID methods. Prompt the user to give permission to the current connection to access the user DID and the given `paths`. ##### Method: `did_authenticate` ##### Params: * `nonce` -

MOTIVATION:
There has been one main previous effort ([#130](https://github.com/ethereum/EIPs/issues/130), [#1098](https://github.com/ethereum/EIPs/pull/1098)) to add decryption to Ethereum wallets in a standard way. This previous approach used a non standard way to encode and represent data encrypted using `x25519-xsalsa20-poly1305`. While this approach does provide a functional way to add encryption support to wallets,

RATIONALE:
This EIP chooses to rely on DIDs and JOSE since there is already support for these standards in many places, by current systems and new systems. By using DIDs and JOSE wallet implementers can also choose which signing and encryption algorithms that they want to support, since these formats


=== EIP-5757 ===
TITLE: Process for Approving External Resources
TYPE: Meta 
STATUS: Final
CREATED: 2022-09-30
REQUIRES: 1

SUMMARY:
Ethereum improvement proposals (EIPs) occasionally link to resources external to this repository. This document sets out the requirements for origins that may be linked to, and the process for approving a new origin.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Definitions - **Link**: Any method of referring to a resource, including: markdown links, anchor tags (`<a>`), images, citations of

RATIONALE:
### Unique Identifiers If it is impossible to uniquely identify a version of a resource, it becomes impractical to track changes, which makes it difficult to ensure immutability. ### Availability If it is possible to implement a standard without a linked resource, then the linked resource is unnecessary. If


=== EIP-7701 ===
TITLE: Native Account Abstraction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-05-01
REQUIRES: 

SUMMARY:
We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction. We further separate transaction validation for the purposes of authorization and the gas fee payment, allowing one contract to pay

SPECIFICATION:
### Constants | Name | Value | |-----------------------------|-------------------| | `AA_TX_TYPE` | TBD | | `AA_ENTRY_POINT` | `address(0x7701)` | | `AA_BASE_GAS_COST` | 15000 | | `ROLE_SENDER_DEPLOYMENT` | `0xA0` | | `ROLE_SENDER_VALIDATION` | `0xA1` | | `ROLE_PAYMASTER_VALIDATION` | `0xA2` | | `ROLE_SENDER_EXECUTION` | `0xA3` | | `ROLE_PAYMASTER_POST_OP` | `0xA4` | ###

MOTIVATION:
Native Account Abstraction allows custom validation logic of a transaction and custom gas payment logic, opening new use-cases and features for wallets and dApps. A more detailed motivation for this proposal can be found in the [README document](../assets/eip-7701/README.md).

RATIONALE:
A full list of rationales for the decisions made in this proposal can be found in the [README document](../assets/eip-7701/README.md).


=== EIP-7911 ===
TITLE: Scaling Ethereum with a Perceptron Tree ZKP
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-03-19
REQUIRES: 

SUMMARY:
This project proposes a method to enhance scalability and privacy protection in the Ethereum network using a Perceptron Tree-based Zero-Knowledge Proof (ZKP) model. The Perceptron Tree, a hybrid model combining the strengths of decision trees and perceptron neural networks, provides a compressed representation for transaction relationships, facilitating efficient verification.

SPECIFICATION:
### 1. Tree Construction The system inputs a transaction dataset T = {x₁, x₂, ..., xₙ} to construct a recursive tree. - Each node classifies transaction data using a perceptron with a linear function: ``` f(x) = step(Wₐ·a + Wᵦ·b + θ) ``` where the step function is defined

MOTIVATION:
The significant increase in blockchain transactions has resulted in scalability limitations and privacy issues. Existing ZKP methods effectively validate individual transactions but fall short in analyzing inter-transaction relationships while maintaining privacy. ZK-Rollups bundle multiple transactions off-chain into a single proof submitted to the Ethereum mainnet, improving throughput and reducing

RATIONALE:
The Perceptron Tree-based ZKP model extends the capabilities of existing zero-knowledge proof techniques by incorporating transaction relationships into the proof structure. Traditional zk-SNARK and zk-STARK methods validate individual transactions but do not leverage inter-transaction similarity, which can lead to inefficiencies. By structuring transactions using a Perceptron Tree, this model


=== EIP-868 ===
TITLE: Node Discovery v4 ENR Extension
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2018-02-02
REQUIRES: 8, ,,  , 7, 7, 8


=== EIP-1716 ===
TITLE: Hardfork Meta: Petersburg
TYPE: Meta 
STATUS: Final
CREATED: 2019-01-21
REQUIRES: 1, 0, 1, 3, ,,  , 1, 2, 8, 3

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork that removes [EIP-1283](./eip-1283.md) from [Constantinople](./eip-1013.md).

SPECIFICATION:
- Codename: Petersburg - Aliases: St. Petersfork, Peter's Fork, Constantinople Fix - Activation: - `Block >= 7_280_000` on the Ethereum Mainnet - `Block >= 4_939_394` on the Ropsten testnet - `Block >= 10_255_201` on the Kovan testnet - `Block >= 4_321_234` on the Rinkeby testnet - `Block >= 0`


=== EIP-8037 ===
TITLE: State Creation Gas Cost Increase
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-10-01
REQUIRES: 2780

SUMMARY:
This proposal increases the cost of state creation operations, thus avoiding excessive state growth under increased block gas limits. It dynamically sets the unit cost per new state byte at a given block gas limit, by targeting an average state growth of 100 GiB per year based on current

SPECIFICATION:
### New parameters | **Parameter** | **Value** | |:---:|:---:| | `TARGET_STATE_GROWTH_PER_YEAR` | 100 x 1024^3 bytes | Besides these fixed parameters, this EIP introduces a dynamic variable that controls the cost per byte of state created for a given block gas limit. The variable is `cost_per_state_byte` and is calculated

MOTIVATION:
State creation does not have a harmonized cost, with different methods incurring varied costs for creating the same size of new state. For instance, while contract deployment only costs 202 gas units per new byte created, new storage slots cost 625 gas units per new byte created. Also, deploying

RATIONALE:
### Deriving the cost per byte The variable `cost_per_state_byte` is a dynamic parameter that depends on the block gas limit. The idea is to have a cost that scales as the block gas limit increases, thus avoiding excessive state growth. To compute this variable, we target a specific state


=== EIP-1418 ===
TITLE: Blockchain Storage Rent Payment
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-09-16
REQUIRES: 1559

SUMMARY:
At each block, deduct an amount of value ("rent") from every account based on the quantity of storage used by that account.

SPECIFICATION:
**Updated transaction type** A new transaction type is introduced. Whereas [EIP-1559](./eip-1559.md) introduced warm access for contract state, this new type introduces warm access for contract code. **New state variables (per account)** * **σ[a]_rent** -- an amount of value, in Wei, this is a signed value * **σ[a]_storageWords** -- number

MOTIVATION:
Ethereum is a public utility and we are underpricing the long-term costs of storage. Storage cost can be approximately modeled as bytes × time.


=== EIP-5065 ===
TITLE: Instruction for transferring ether
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-30
REQUIRES: 2929

SUMMARY:
Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to how `SELFDESTRUCT (0xFF)` transfers ether to the destination without making a call to it.

SPECIFICATION:
Introduce a new instruction, `AIRDROP` (`0xFG`) that transfers ether to the destination without making a call to it. ### Stack input address: the account to send ether to. value: value in wei to send to the account. ### Gas The total gas cost should be the sum of a

MOTIVATION:
From an architectural point of view, execution flow should never be handed over to an untrusted contract. Ethereum currently does not have any ideal way to transfer ether without transferring the flow of execution. People have come up with reentrancy guards and similar solutions to prevent some types of

RATIONALE:
This behavior is already possible by deploying a new contract that does `SELFDESTRUCT (0xFF)` but it is prohibitively expensive. In most scenarios, the contract author only wants to transfer ether rather than transferring control of the execution. ERC20 can be used as a case study for this where most


=== EIP-7002 ===
TITLE: Execution layer triggerable withdrawals
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-09
REQUIRES: 7685

SUMMARY:
Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials. These new execution layer exit messages are appended to the execution layer block and then processed by the consensus layer.

SPECIFICATION:
### Configuration | Name | Value | Comment | | - | - | - | | `WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS` | `0x00000961Ef480Eb55e80D19ad83579A64c007002` | Where to call and store relevant details about exit / partial withdrawal mechanism | | `WITHDRAWAL_REQUEST_TYPE` | `0x01` | The [EIP-7685](./eip-7685.md) type prefix for withdrawal request | |

MOTIVATION:
Validators have two keys -- an active key and a withdrawal credential. The active key takes the form of a BLS key, whereas the withdrawal credential can either be a BLS key (0x00) or an execution layer address (0x01). The active key is "hot", actively signing and performing validator

RATIONALE:
### `validator_pubkey` field Multiple validators can utilize the same execution layer withdrawal credential, thus the `validator_pubkey` field is utilized to disambiguate which validator is being exited. Note, `validator_index` also disambiguates validators. The problem is that smart contracts of some staking pools are not aware of the indices, because the


=== EIP-2677 ===
TITLE: Limit size of `initcode`
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-05-18
REQUIRES: 

SUMMARY:
Enforce a maximum size limit (`max_initcode_size`) for `initcode`. If the size of `initcode` exceeds `max_initcode_size`, then contract creation fails with an out of gas error. Since [EIP-170](./eip-170.md) was implemented, there has been a size limit of `24576` (`0x6000`) on contract code. We propose to also limit the size of

SPECIFICATION:
There are three situations where this is applicable: * `CREATE`, * `CREATE2`, * creation using a transaction with empty receiver. In all these (and future) cases, the EVM should fail with Out Of Gas error if the code has a length more than `max_initcode_size`.

MOTIVATION:
When a client executes `initcode`, the client has to perform a jumpdest analysis. In some cases, the client also performs a `hash` of the code: * To use as a key in a mapping containing the result of a jumpdest analysis * To use for address calculation within `CREATE2`.

RATIONALE:
TBA


=== EIP-7904 ===
TITLE: General Repricing
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2025-02-05
REQUIRES: 7883

SUMMARY:
This proposal revises the gas cost schedule for opcodes and data access, prioritizing computational complexity, while excluding network-related costs such as state persistence. The adjustments aim to enhance gas cost accuracy and rebalance the cost structure.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Parameters | Constant | Value | | ------------------------ | ----- | | `WARM_STORAGE_READ_COST` |

MOTIVATION:
Gas costs compromise of two components: network (social) cost and computation cost. Network cost reflects the blockchain’s effort to maintain state, including adding transactions, storage, logs, calldata, and receipts, while computation cost represents the non-durable processing effort of smart contracts. The importance of adequate gas costs arises from the

RATIONALE:
### Gas Cost Estimator Project The [Gas Cost Estimator](../assets/eip-7904/gas-cost-estimator-report.pdf) project serves as the empirical foundation for this EIP. This project conducted extensive testing across seven widely-used EVM implementations to measure the actual computational effort required by various opcodes and operations. Conducted in a controlled environment to eliminate external variables,


=== EIP-3326 ===
TITLE: Wallet Switch Ethereum Chain RPC Method (`wallet_switchEthereumChain`)
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2021-03-04
REQUIRES: 1, 5, 5, ,,  , 6, 9, 5

SUMMARY:
The `wallet_switchEthereumChain` RPC method allows Ethereum applications ("dapps") to request that the wallet switches its active Ethereum chain, if the wallet has a concept thereof. The caller must specify a chain ID. The wallet application may arbitrarily refuse or accept the request. `null` is returned if the active chain

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### `wallet_switchEthereumChain` The method accepts a single object parameter with a `chainId` field. The method returns `null` if the wallet switched

MOTIVATION:
All dapps require the user to interact with one or more Ethereum chains in order to function. Some wallets only supports interacting with one chain at a time. We call this the wallet's "active chain". `wallet_switchEthereumChain` enables dapps to request that the wallet switches its active chain to whichever

RATIONALE:
The purpose `wallet_switchEthereumChain` is to provide dapps with a way of requesting to switch the wallet's active chain, which they would otherwise have to ask the user to do manually. The method accepts a single object parameter to allow for future extensibility at virtually no cost to implementers and


=== EIP-3520 ===
TITLE: Transaction Destination Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-16
REQUIRES: 3508

SUMMARY:
This EIP introduces the following EVM instruction: `ENTRYPOINT`. This instruction is meant to provide access to the original recipient of the transaction, the `to` address, enabling new ways of introspection to be applied in conjunction with [EIP-3508](./eip-3508.md).

SPECIFICATION:
### ENTRYPOINT (`0x4a`) The `ENTRYPOINT` instruction uses 0 stack arguments and pushes the original `to` member of the transaction onto the stack. The address yielded by the instruction is a 160-bit value padded to 256-bits. The operation costs `G_base` to execute, similarly to `ORIGIN` (`0x32`). The address returned by

MOTIVATION:
It is undeniable that smart contracts are becoming more interconnected than ever. Up until this point, smart contracts have entirely relied on compliant interfaces and introspection to introduce a new step in the call chain of a complex multi-contract interaction. However, this presents a forwards-only approach which limits the

RATIONALE:
### AUTHCALL (`0xf7`) Interaction The [EIP-3074](./eip-3074.md) introduced a new call instruction called `AUTHCALL` (`0xf7`) that will replace a transaction's `ORIGIN` (`0x32`) with the context variable `authorized`. The intention of `AUTHCALL` is to prevent discrimination between smart contracts and EOAs which `ORIGIN` initially facilitated. The `ENTRYPOINT` opcode by itself re-introduces


=== EIP-6466 ===
TITLE: SSZ receipts
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-08
REQUIRES: 6, 5, 8, ,,  , 2, 7, 1, 8, ,,  , 6, 4, 0, 4, ,,  , 7, 4, 9, 5, ,,  , 7, 6, 6, 8, ,,  , 7, 7, 0, 2, ,,  , 7, 9, 1, 6, ,,  , 8, 0, 1, 6, ,,  , 8, 1, 1, 6

SUMMARY:
This EIP defines a migration process of [EIP-2718](./eip-2718.md) Recursive-Length Prefix (RLP) receipts to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/b3e83f6691c61e5b35136000146015653b22ed38/ssz/simple-serialize.md)

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated

MOTIVATION:
RLP receipts have a number of shortcomings: 1. **Limited proving support:** Due to receipt data being linearly hashed as part of the `receipts_root` Merkle-Patricia Trie (MPT), it is not possible to efficiently proof individual parts of receipts, such as logs. Requiring the full receipt data to be present can

RATIONALE:
### Forward compatibility All receipts share the same Merkle tree shape with a stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/b5c3b619887c7850a8c1d3540b471092be73ad84/ssz/merkle-proofs.md#generalized-merkle-tree-index) assigned to each field. Future transaction features can introduce additional receipt fields or drop existing fields without breaking verifiers. ### Verifier improvements Committing to `from`, `contract_address` and `authorities` in the receipt allows


=== EIP-4895 ===
TITLE: Beacon chain push withdrawals as operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-03-10
REQUIRES: 

SUMMARY:
Introduce a system-level "operation" to support validator withdrawals that are "pushed" from the beacon chain to the EVM. These operations create unconditional balance increases to the specified recipients.

SPECIFICATION:
| constants | value | units |--- |--- |--- | `FORK_TIMESTAMP` | 1681338455 | Beginning with the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** introduce the following extensions to payload validation and processing: ### System-level operation: withdrawal Define a new payload-level object called a `withdrawal` that describes withdrawals that have

MOTIVATION:
This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM. The architecture is "push"-based, rather than "pull"-based, where withdrawals are required to be processed in the execution layer as soon as they are dequeued from the consensus layer. Withdrawals are represented

RATIONALE:
### Why not a new transaction type? This EIP suggests a new type of object -- the "withdrawal operation" -- as it has special semantics different from other existing types of EVM transactions. Operations are initiated by the overall system, rather than originating from end users like typical transactions.


=== EIP-3690 ===
TITLE: EOF - JUMPDEST Table
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-06-23
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Introduce a section in the EOF format ([EIP-3540](./eip-3540.md)) for storing the list of `JUMPDEST`s, validate the correctness of this list at the time of contract creation, and remove the need for `JUMPDEST`-analysis at execution time. In EOF contracts, the `JUMPDEST` instruction is not needed anymore and becomes invalid. Legacy

SPECIFICATION:
This feature is introduced on the very same block [EIP-3540](./eip-3540.md) is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps. *Remark:* We rely on the notation of *initcode*, *code* and *creation* as defined by [EIP-3540](./eip-3540.md), and extend validation rules of [EIP-3670](./eip-3670.md). ### EOF container changes

MOTIVATION:
Currently existing contracts require no validation of correctness, but every time they are executed, a list must be built containing all the valid jump-destinations. This is an overhead which can be avoided, albeit the effect of the overhead depends on the client implementation. With the structure provided by EIP-3540

RATIONALE:
### Jumpdests section is bounded The length of the `jumpdests` section is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this is additionally limited by the max bytecode size 0x6000. Then any valid `jumpdests` section may not be larger than 0x3000. ### Delta encoding


=== EIP-7756 ===
TITLE: EOF/EVM Trace Specification
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2024-08-13
REQUIRES: 3, 1, 5, 5, ,,  , 4, 7, 5, 0

SUMMARY:
Updates the [EIP-3155](./eip-3155.md) JSON tracing specification to support EOF features.

SPECIFICATION:
To promote clarity and provide a cohesive specification, the entire tracing specification will be presented with alterations in-line rather than as a set of diffs on top of EIP-3155. Differences will be highlighted in the Backwards Compatibility section. The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",

MOTIVATION:
EIP-3155 defined a tracing standard for Legacy EVM operations. However, the EVM Object Format ([EIP-7692](./eip-7692.md)) adds a number of features that need to be reflected in debugging traces. The use of these traces has also moved out from state testing, including live block tracing and differential fuzzing, increasing the

RATIONALE:
This EIP is an extension of the EIP-3155 tracing features that has been in use for years. Rather than dramatically re-boot the feature, the information was added to the existing traces. A "mini" trace was contemplated to allow for tracing to be included in tools such as `t8n` and


=== EIP-100 ===
TITLE: Change difficulty adjustment to target mean block time including uncles
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-04-28
REQUIRES: 

SPECIFICATION:
Currently, the formula to compute the difficulty of a block includes the following logic: ``` python adj_factor = max(1 - ((timestamp - parent.timestamp) // 10), -99) child_diff = int(max(parent.difficulty + (parent.difficulty // BLOCK_DIFF_FACTOR) * adj_factor, min(parent.difficulty, MIN_DIFF))) ... ``` If `block.number >= BYZANTIUM_FORK_BLKNUM`, we change the first line to

RATIONALE:
This new formula ensures that the difficulty adjustment algorithm targets a constant average rate of blocks produced including uncles, and so ensures a highly predictable issuance rate that cannot be manipulated upward by manipulating the uncle rate. A formula that accounts for the exact number of included uncles: ```


=== EIP-2003 ===
TITLE: EVMC modules for implementations of precompiled contracts
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-05-09
REQUIRES: 1352

SUMMARY:
[EVMC] specifies a generic API for Ethereum execution engines. This EIP specifies a way of providing implementations of Ethereum precompiled contracts using the [EVMC VM API].

SPECIFICATION:
For the complete [EVMC] specification visit the [EVMC documentation] first. This EIP is based on and is compatible with EVMC ABI version 6. The EVMC module with implementations of precompiled contracts SHOULD: 1. Advertise the [`EVMC_CAPABILITY_PRECOMPILES`] capability in the [`get_capabilities()`] method. 2. Implement the [`execute()`] method in the following

RATIONALE:
It is very unlikely that any precompile will need to access or modify a contract state. Not requiring the Client to implement the EVMC Host interface removes the big portion of work needed for full EVMC integration.


=== EIP-7823 ===
TITLE: Set upper bounds for MODEXP
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-11-11
REQUIRES: 198

SUMMARY:
Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.

SPECIFICATION:
Recap from [EIP-198](./eip-198.md): > At address `0x00……05`, add a precompile that expects input in the following format: > > `<length_of_BASE> <length_of_EXPONENT> <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>` We introduce an upper bound to the inputs of the precompile, each of the length inputs (`length_of_BASE`, `length_of_EXPONENT` and `length_of_MODULUS`) MUST be less than

MOTIVATION:
The MODEXP precompile has been a source of numerous consensus bugs. Many of them were due to specifically crafted cases using impractical input lengths. Its pricing function is also quite complex given its nature of unbounded inputs. While we don't suggest to rework the pricing function, it may be

RATIONALE:
### Limit This upper bound allows the existing use cases of MODEXP: 1. RSA verification with up to 8192 bit keys. Commonly used ones are 1024/2048/4096 bits. 2. Elliptic curve related use cases are usually less than 384 bits. ### EVMMAX Replacing the precompile with EVM code using an


=== EIP-3508 ===
TITLE: Transaction Data Opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-16
REQUIRES: 

SUMMARY:
This EIP introduces the following three EVM instructions: `ORIGINDATALOAD`, `ORIGINDATASIZE`, and `ORIGINDATACOPY`. These three instructions are meant to provide access to the original transaction's `data` payload, enabling a gas-efficient way of accessing large data payloads in cross-contract calls.

SPECIFICATION:
### ORIGINDATALOAD (`0x47`), ORIGINDATASIZE (`0x48`) and ORIGINDATACOPY (`0x49`) These instructions are meant to operate similarly to their call-prefixed counterparts with the exception that they instead operate on the original `data` of a transaction instead of the current call's data. In detail: - ORIGINDATALOAD (`0x47`) performs similarly to CALLDATALOAD (`0x35`)

MOTIVATION:
As the Ethereum development scene matures, more ambitious and complex features are introduced into smart contracts more often than not requiring the utilization of complex and at times large data structures. Given the inherent limits of the EVM, however, transporting large data structures in between contracts is a costly

RATIONALE:
### AUTHCALL (`0xf7`) Interaction The [EIP-3074](./eip-3074.md) that will be part of the London fork has introduced a new call instruction called `AUTHCALL` (`0xf7`) that will replace a transaction's `ORIGIN` (`0x32`) with the context variable `authorized`. The intention of `AUTHCALL` is to prevent discrimination between smart contracts and EOAs which
