=== EIP-1153 ===
TITLE: Transient storage opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-06-15
REQUIRES: 2, 2, 0, 0, ,,  , 3, 5, 2, 9

SUMMARY:
This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, and `TSTORE` is not subject to the gas stipend check as defined in [EIP-2200](./eip-2200.md). In other words, the values of transient storage are never deserialized from

SPECIFICATION:
Two new opcodes are added to EVM, `TLOAD` (`0x5c`) and `TSTORE` (`0x5d`). (Note that previous drafts of this EIP specified the values `0xb3` and `0xb4` for `TLOAD` and `TSTORE` respectively to avoid conflict with other EIPs. The conflict has since been removed.) They use the same arguments on stack

MOTIVATION:
Running a transaction in Ethereum can generate multiple nested frames of execution, each created by `CALL` (or similar) instructions. Contracts can be re-entered during the same transaction, in which case there are more than one frame belonging to one contract. Currently, these frames can communicate in two ways: via

RATIONALE:
Another option to solve the problem of inter-frame communication is repricing the `SSTORE` and `SLOAD` opcodes to be cheaper for the transient storage use case. This has already been done as of [EIP-2200](./eip-2200.md). However, [EIP-3529](./eip-3529.md) reduced the maximum refund to only 20% of the transaction gas cost, which means


=== EIP-6190 ===
TITLE: Verkle-compatible SELFDESTRUCT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2, 9, 2, 9, ,,  , 6, 1, 8, 8, ,,  , 6, 1, 8, 9

SUMMARY:
Changes `SELFDESTRUCT` to only cause a finite number of state changes.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Prerequisites [EIP-6188](./eip-6188.md) and [EIP-6189](./eip-6189.md) must be used for this EIP to function correctly. ### `SELFDESTRUCT` Behaviour

MOTIVATION:
The `SELFDESTRUCT` instruction has a fixed price, but is unbounded in storage/account changes (it needs to delete all keys). This has been an outstanding concern for some time. Furthermore, with *Verkle trees* accounts will be organised differently. Account properties, including storage, would have individual keys. It would not be

RATIONALE:
This EIP is designed to be a step towards supporting `SELFDESTRUCT` in Verkle trees while making the minimum amount of changes. The `5000` base gas cost and additional alias contracts represents the cost of setting the account nonce and first storage slot. The [EIP-2929](./eip-2929.md) gas cost increase is preserved


=== EIP-7620 ===
TITLE: EOF Contract Creation
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-02-12
REQUIRES: 1, 7, 0, ,,  , 6, 8, 4, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 4, 0, ,,  , 3, 5, 4, 1, ,,  , 3, 6, 7, 0

SUMMARY:
EVM Object Format (EOF) removes the possibility to create contracts using `CREATE` or `CREATE2` instructions. We introduce a new/replacement method in form of pair of instructions : `EOFCREATE` and `RETURNCONTRACT` to provide a way to create contracts using EOF containers.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Parameters | Constant | Value | | - | - | | `GAS_KECCAK256_WORD` |

MOTIVATION:
This EIP uses terminology from the [EIP-3540](./eip-3540.md) which introduces the EOF format. EOF aims to remove code observability, which is a prerequisite to legacy EVM contract creation logic using legacy-style create transactions, `CREATE` or `CREATE2`, because both the initcode and code are available to the EVM and can be

RATIONALE:
### Data section appending The data section is appended to during contract creation and also its size needs to be updated in the header. Alternative designs were considered, where: - additional section kinds for the data were introduced - additional fields describing a subcontainer were introduced - data section


=== EIP-2330 ===
TITLE: EXTSLOAD opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-10-29
REQUIRES: 2929

SUMMARY:
This proposal adds a new opcode `EXTSLOAD` at `0x5c` which pops two items from the stack: `<account address> <storage key>` and pushes one item: `<storage value>`. The gas cost is sum of account access cost and storage read based on [EIP-2929](./eip-2929.md) Access Lists.

SPECIFICATION:
A new EVM instruction `EXTSLOAD (0x5c)` that works like `SLOAD (0x54)` but an additional parameter representing the contract that is to be read from. ```shell EXTSLOAD (0x5c) ``` The `EXTSLOAD` instruction pops 2 values from the stack, first `contract` a contract address and then second `slot` a storage address

MOTIVATION:
While any off-chain application can read all contract storage data of all contracts, this is not possible for deployed smart contracts themselves. These are bound to use contract calls for any interaction including reading data from other contracts. This EIP adds an EVM opcode to directly read external contract

RATIONALE:
- Without this EIP, a contract can still opt-in to make their entire state public, by having a method that simply SLOADs and returns the values ([example](../assets/eip-2330/Extsload.sol)). The complexity of the gas cost can be seen as `1`x CALL cost + `N`x SLOAD cost. Hence, the gas cost specified


=== EIP-4488 ===
TITLE: Transaction calldata gas cost reduction with total calldata limit
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-11-23
REQUIRES: 

SUMMARY:
Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.

SPECIFICATION:
| Parameter | Value | | - | - | | `NEW_CALLDATA_GAS_COST` | `3` | | `BASE_MAX_CALLDATA_PER_BLOCK` | `1,048,576` | | `CALLDATA_PER_TX_STIPEND` | `300` | Reduce the gas cost of transaction calldata to `NEW_CALLDATA_GAS_COST` per byte, regardless of whether the byte is zero or nonzero. Add a rule that

MOTIVATION:
Rollups are in the short and medium term, and possibly the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups are

RATIONALE:
A natural alternative proposal is to decrease `NEW_CALLDATA_GAS_COST` without adding a limit. However, this presents a security concern: today, the average block size [is 60-90 kB](https://etherscan.io/chart/blocksize), but the _maximum_ block size is `30M / 16 = 1,875,000` bytes (plus about a kilobyte of block and tx overhead). Simply decreasing


=== EIP-6189 ===
TITLE: Alias Contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2, 9, 2, 9, ,,  , 6, 1, 8, 8

SUMMARY:
This EIP allows contracts to be turned into "alias contracts" using a magic nonce. Alias contracts automatically forward calls to other contracts.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Definitions A contract is an alias contract if its nonce is `2^64-1`, and its contract code

MOTIVATION:
This EIP is not terribly useful on its own, as it adds additional computation and gas costs without any useful side effects. However, in conjunction with [EIP-6190](./eip-6190.md), it can be used to make SELFDESTRUCT compatible with Verkle trees.

RATIONALE:
The additional gas cost of `25` represents the cost of fetching the nonce and comparing it to the given value. `eth_getStorageAt` was modified to throw an error because of alias contracts' special behavior. The nonce of `2^64-1` was chosen since it is the nonce protected by [EIP-6188](./eip-6188.md). The contract


=== EIP-684 ===
TITLE: Revert creation in case of collision
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-03-20
REQUIRES: 

SUMMARY:
This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by "creating" an account at that existing address.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. If a contract creation is attempted due to a creation transaction, the `CREATE` opcode, the

RATIONALE:
One of the core tenants of smart contracts is that its code will not change. However with sufficient computing power an attacker can change the code stored in an address to any other code, steal funds or execute other malicious activity.


=== EIP-3074 ===
TITLE: AUTH and AUTHCALL opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-15
REQUIRES: 155

SUMMARY:
This EIP introduces two EVM instructions `AUTH` and `AUTHCALL`. The first sets a context variable `authorized` based on an ECDSA signature. The second sends a call as the `authorized` account. This essentially delegates control of the externally owned account (EOA) to a smart contract.

SPECIFICATION:
### Conventions - **`top - N`** - the `N`th most recently pushed value on the EVM stack, where `top - 0` is the most recent. - **`||`** - byte concatenation operator. - **invalid execution** - execution that is invalid and must exit the current execution frame immediately, consuming all

MOTIVATION:
Adding more functionality to EOAs has been a long-standing feature request. The requests have spanned from implementing batching capabilities, allowing for gas sponsoring, expirations, scripting, and beyond. These changes often mean increased complexity and rigidity of the protocol. In some cases, it also means increased attack surfaces. This EIP

RATIONALE:
### Signature in Memory The signature format (`yParity`, `r`, and `s`) is fixed, so it might seem curious that `auth` accepts a dynamic memory range. The signature is placed in memory so that `auth` can be upgraded in the future to work with contract accounts (which might use non-ECDSA


=== EIP-5656 ===
TITLE: MCOPY - Memory copying instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-02-01
REQUIRES: 

SUMMARY:
Provide an efficient EVM instruction for copying memory areas.

SPECIFICATION:
The instruction `MCOPY` is introduced at `0x5E`. ### Input stack | Stack | Value | |-------|-------| | top - 0 | `dst` | | top - 1 | `src` | | top - 2 | `length` | This ordering matches the other copying instructions, i.e. `CALLDATACOPY`, `RETURNDATACOPY`. ### Gas

MOTIVATION:
Memory copying is a basic operation, yet implementing it on the EVM comes with overhead. This was recognised and alleviated early on with the introduction of the "identity" precompile, which accomplishes memory copying by the use of `CALL`'s input and output memory offsets. Its cost is `15 + 3

RATIONALE:
Production implementation of exact-word memory copying and partial-word memory copying can be found in the Solidity, Vyper and Fe compilers. With [EIP-2929](./eip-2929.md) the call overhead using the identity precompile was reduced from 700 to 100 gas. This is still prohibitive for making the precompile a reasonable alternative again.


=== EIP-1285 ===
TITLE: Increase Gcallstipend gas in the CALL opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
Currently, the ``CALL`` opcode forwards a stipend of ``2,300`` gas units for a non zero value ``CALL`` operations where a contract is called. This stipend is given to the contract to allow execution of its ``fallback`` function. The stipend given is intentionally small in order to prevent the called

SPECIFICATION:
Increase the ``Gcallstipend`` fee parameter in the ``CALL`` opcode from ``2,300`` to ``3,500`` gas unit. The actual change to the Ethereum clients would be to change the ``CallStipend`` they store as a constant. For an implementation example you can find a Geth client implementation linked [here](https://github.com/ben-kaufman/go-ethereum/tree/eip-1285). The actual change

MOTIVATION:
The main motivation behind this EIP is to allow simple fallback functions to be implemented for contracts following the ``"Proxy"`` pattern. Simply explained, a ``"Proxy Contract"`` is a contract which use ``DELEGATECALL`` in its ``fallback`` function to behave according to the logic of another contract and serve as an

RATIONALE:
The rational for increasing the ``Gcallstipend`` gas parameter by ``1,200`` gas units comes from the cost of performing ``DELEGATECALL`` and ``SLOAD`` with a small margin for some small additional operations. All while still keeping the stipend relatively small and insufficient for accessing the storage or changing the state.


=== EIP-7792 ===
TITLE: Verifiable logs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-21
REQUIRES: 6466

SUMMARY:
This EIP defines a method to make the `eth_getLogs` JSON-RPC response verifiable.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Configuration | Name | Value | | - | - | | `LOG_CONTRACT_ADDRESS` |

MOTIVATION:
The `eth_getLogs` endpoint is used by wallets to obtain the transaction history pertaining to an account or a topic. To verify correctness and completeness of the logs, a wallet would also have to obtain all block headers and check against their logs bloom. However, that mechanism is inefficient due

RATIONALE:
Making the `eth_getLogs` response verifiable adds the necessary security attributes to enable wallets to transition away from relying on trusted data providers, ultimately improving the wallet's privacy guarantees as it is no longer subject to the privacy policy of any given provider. ### Gas cost The gas cost produced


=== EIP-7788 ===
TITLE: Dynamic target blob count
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-15
REQUIRES: 7742

SUMMARY:
This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.

SPECIFICATION:
### Parameters | Parameter | Value | | - | - | | `FORK_TIMESTAMP` | TBD | | `TARGET_BLOB_COUNT_CHANGE_RATE` | `1` | | `MIN_TARGET_BLOB_COUNT` | `1` | | `MAX_TARGET_BLOB_COUNT` | `3` | | `BLOB_COST_CHANGE_MARGIN` | `2^48` | | `TARGET_BLOB_COST` | `2^49` | ### Dynamic targeting The target blob count

MOTIVATION:
Ethereum currently uses a target of 50% capacity for blob count, with [EIP-1559](./eip-1559.md) smoothing out short term spikes and pushing average throughput towards the target. A dynamic target is orthogonal to EIP-1559, tweaking the target itself over a longer timescale to aim for some desired blob cost. With static

RATIONALE:
### Constant blob cost target A constant blob cost target can keep L2 transaction costs affordable for end users. Volatility in the price of ETH would affect affordability, but is unlikely to be significant compared to normal fluctuations in blob gas costs due to spikes in activity. In future


=== EIP-7044 ===
TITLE: Perpetually Valid Signed Voluntary Exits
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-18
REQUIRES: 

SUMMARY:
Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.

SPECIFICATION:
### Consensus Layer Specification changes are built into the Consensus Specs Deneb upgrade. The specific makes one change to the state transition function: - Modify [`process_voluntary_exit`](https://github.com/ethereum/consensus-specs/blob/75971a8c218b1d76d605dd8b88a08d39c42de221/specs/deneb/beacon-chain.md#modified-process_voluntary_exit) to compute the signing domain and root fixed on `CAPELLA_FORK_VERSION`. Additionally, the `voluntary_exit` gossip conditions are implicitly modified to support this change. To

MOTIVATION:
Currently, signed voluntary exits are valid up-to only two upgrades for block inclusion due to the Beacon Chain state considering only the current and previous fork version. This limitation increases the complexity of some staking operations, specifically those in which the staking operator (holder of active key) is distinct

RATIONALE:
Perpetually valid signed voluntary exits allow simpler staking operation designs. It also aligns the UX of such objects to `BLSToExecutionChanges` and deposits, such that downstream tooling does not need to be updated with fork version information.


=== EIP-5000 ===
TITLE: MULDIV instruction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-03-14
REQUIRES: 

SUMMARY:
Introduce a new instruction, `MULDIV(x, y, z)`, to perform `((x * y) / z) % 2**256` in 512-bit precision. `z = 0` is a special case for `(x * y) / 2**256`.

SPECIFICATION:
A new instruction is introduced: `MULDIV` (`0x1e`). - Pops 3 values from the stack, first `x`, then `y` and `z`. - If `z == 0`, `r = (uint512(x) * y) / 2**256`. - Otherwise `r = (uint512(x) * y / z) % 2**256`, where the intermediate calculation is performed

MOTIVATION:
Fixed point operations in high level languages are very commonly used on Ethereum, especially in the domain of financial applications. While fixed point addition and subtraction can be done with merely `add` and `sub` respectively, being able to efficiently do fixedpoint multiplication and division is a very sought after

RATIONALE:
### The special 0 case All the arithmetic instructions in EVM handle division or modulo 0 specially: the instructions return 0. We have decided to break consistency in order to provide a flexible opcode, which can be used to detect wrapping behaviour. Alternate options include: - Returning a flag


=== EIP-170 ===
TITLE: Contract code size limit
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-11-04
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then if contract creation initialization returns data with length of **more than** `MAX_CODE_SIZE` bytes, contract creation fails with an out of gas error. ### Rationale Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a

RATIONALE:
Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a constant amount of gas, the call can trigger O(n) cost in terms of reading the code from disk, preprocessing the code for VM execution, and also adding O(n) data


=== EIP-2515 ===
TITLE: Implement Difficulty Freeze
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-10
REQUIRES: 

SUMMARY:
The difficulty Freeze is a mechanism that is easy to predict and model, and the pressures of missing it are more readily felt by the core developers and client maintainers. The client maintainers are also positioned as the group that is most able to respond to an incoming Difficulty

SPECIFICATION:
Add variable `DIFFICULTY_FREEZE_HEIGHT` The logic of the Difficulty Freeze is defined as follows: ``` if (BLOCK_HEIGHT <= DIFFICULTY_FREEZE_HEIGHT): block_diff = parent_diff + parent_diff // 2048 * max( 1 - (block_timestamp - parent_timestamp) // 10, -99) else: block_diff = parent_diff + parent_diff * 0.01 ``` **Optional Implementation** Add the variable

MOTIVATION:
The current difficulty bombs' effect on the Block Time Targeting mechanism is rather complex to model, and it has both appeared when it was not expected (Muir Glacier) and negatively affected miners when they are not the target (in the case of delaying forks due to technical difficulties). Miners

RATIONALE:
Block height is very easy to predict and evaluate within the system. This removes the effect of the Difficulty Bomb on block time, simplifying the block time targeting mechanism. The addition of an increase in the difficulty was added after feedback that the game theory of the mechanism did


=== EIP-7805 ===
TITLE: Fork-choice enforced Inclusion Lists (FOCIL)
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-01
REQUIRES: 

SUMMARY:
FOCIL implements a robust mechanism to preserve Ethereum’s censorship resistance properties by guaranteeing timely transaction inclusion. FOCIL (**Fo**rk-choice enforced **I**nclusion **L**ists) is built in a few simple steps: - In each slot, a set of validators is selected as inclusion list (IL) committee members. Each member builds and gossips

SPECIFICATION:
### Execution Layer On the execution layer, the block validity conditions are extended such that, after all of the transactions in the block have been executed, we attempt to execute each valid transaction from ILs that was not present in the block. If one of those transactions executes successfully,

MOTIVATION:
In an effort to shield the Ethereum validator set from centralizing forces, the right to build blocks has been auctioned off to specialized entities known as *builders*. This has led to a few sophisticated builders dominating block production, leading to a deterioration of the network’s censorship resistance properties. To

RATIONALE:
### Core Properties - Committee-based: FOCIL relies on a committee of multiple validators, rather than a single proposer, to construct and broadcast ILs. This approach significantly reduces the surface for bribery and extortion attacks and strengthens censorship resistance. - Fork-choice enforced: FOCIL incorporates the force-inclusion mechanism into the fork-choice


=== EIP-1884 ===
TITLE: Repricing for trie-size-dependent opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-03-28
REQUIRES: 1, 5, 0, ,,  , 1, 0, 5, 2

SUMMARY:
The growth of the Ethereum state has caused certain opcodes to be more resource-intensive at this point than they were previously. This EIP proposes to raise the `gasCost` for those opcodes.

SPECIFICATION:
At block `N`, - The `SLOAD` (`0x54`) operation changes from `200` to `800` gas, - The `BALANCE` (`0x31`) operation changes from `400` to `700` gas, - The `EXTCODEHASH` (`0x3F`) operation changes from `400` to `700` gas, - A new opcode, `SELFBALANCE` is introduced at `0x47`. - `SELFBALANCE` pops `0`

MOTIVATION:
An imbalance between the price of an operation and the resource consumption (CPU time, memory etc) has several drawbacks: - It could be used for attacks, by filling blocks with underpriced operations which causes excessive block processing time. - Underpriced opcodes cause a skewed block gas limit, where sometimes

RATIONALE:
Here are two charts, taken from a full sync using Geth. The execution time was measured for every opcode, and aggregated for 10K blocks. These bar charts show the top 25 'heavy' opcodes in the ranges 5M to 6M and 6M to 7M: ![bars1](../assets/eip-1884/run3.total-bars-5.png) ![bars2](../assets/eip-1884/run3.total-bars-6.png) Note: It can also


=== EIP-7568 ===
TITLE: Hardfork Meta Backfill - Berlin to Shapella
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-01
REQUIRES: 2, 0, 7, 0, ,,  , 2, 3, 8, 7, ,,  , 2, 9, 8, 2, ,,  , 6, 1, 2, 2, ,,  , 6, 9, 5, 3

SUMMARY:
Following Muir Glacier hard fork, Meta EIPs were abandoned in favor of other ways to track changes included in Ethereum network upgrades. This EIP aggregates the specifications for these upgrades, which themselves list the specific changes included. Specifically, it covers the Beacon Chain launch (Serenity Phase 0), Berlin, London,

SPECIFICATION:
The network upgrades below are listed in order of activation. Upgrades to Ethereum's execution layer are marked "[EL]", and those to Ethereum's consensus layer are marked "[CL]". ### Beacon Chain Launch - Serenity Phase 0 [CL] The full specifications for the Beacon Chain at launch can be found in

MOTIVATION:
For many years, Ethereum used Meta EIPs to document network upgrades. Recently, consensus has formed around using them again. This EIP aggregates the network upgrades who did not have Meta EIPs and links out to their specifications.

RATIONALE:
The EIP repository is well known within the Ethereum community, and Meta EIPs have historically been useful to clearly list the EIPs included in a specific network upgrade. While the specification process for the execution and consensus layers differ, there is value in having a single, harmonized, list of


=== EIP-1706 ===
TITLE: Disable SSTORE with gasleft lower than call stipend
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-01-15
REQUIRES: 1283

SUMMARY:
[EIP-1283](./eip-1283.md) significantly lowers the gas costs of writing to contract's storage. This created a danger of a new kind of reentrancy attacks on existing contracts as Solidity by default grants a 'stipend' of 2300 gas to simple transfer calls. This danger is easily mitigated if SSTORE is not allowed

SPECIFICATION:
Add the following condition to the SSTORE opcode gas cost calculation: * If *gasleft* is less than or equal to 2300, fail the current call frame with 'out of gas' exception.

MOTIVATION:
An attack that is described in [this article](https://medium.com/chainsecurity/constantinople-enables-new-reentrancy-attack-ace4088297d9). Explicitly specifying the call stipend as an invariant will have a positive effect on Ethereum protocol security: https://www.reddit.com/r/ethereum/comments/agdqsm/security_alert_ethereum_constantinople/ee5uvjt

RATIONALE:
In order to keep in place the implicit reentrancy protection of existing contracts, transactions should not be allowed to modify state if the remaining gas is lower then the 2300 stipend given to 'transfer'/'send' in Solidity. These are other proposed remediations and objections to implementing them: * Drop EIP-1283


=== EIP-2026 ===
TITLE: State Rent H - Fixed Prepayment for accounts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-14
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces a fixed charge for state expansion that comes from adding new accounts to the state. Theoretically, it puts a bound on the number of accounts that can be ever created, because that fixed charge cannot be recycled

SPECIFICATION:
On and after block `H`, every newly created account gets a new field `rentbalance` of type unsigned 256-bit integer. On and after block `H`, any operation that leads to the creation of a new account, deducts the amount `ACCOUNT_PREPAYMENT` from `tx.origin`. This amount is added to the `rentbalance` field

MOTIVATION:
The penalty is levied to the transaction sender. Rather than raising the gas cost of account creation (that would direct levy towards the miner), this change directs prepayment into the account's special field, `rentbalance`. It addresses several shortcomings of the simple raising of the gas cost: 1. Prepayments cannot

RATIONALE:
Prior to rent prepayments, other alternatives were considered: 1. Simple raising of the gas cost - discussed in the Motivation section. 1. In [first version of State Rent proposal](https://github.com/ledgerwatch/eth_state/blob/master/State_rent.pdf), there was no notion of extra levy upon account creation. It created a slight usability issue, where newly created contracts


=== EIP-3336 ===
TITLE: Paged memory allocation for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-06
REQUIRES: 

SUMMARY:
Presently, the EVM charges for memory as a linear array starting at address 0 and extending to the highest address that has been read from or written to. This suffices for simple uses, but means that compilers have to generate programs that use memory compactly, which leads to wasted

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `PAGE_BITS` | 10 | | `PAGE_BASE_COST` | 96 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. ### Changes to memory allocation in EVM implementations Memory is now allocated

MOTIVATION:
Most modern computers implement "virtual memory" for userspace programs, where programs have access to a large address space, with pages of RAM that are allocated as needed by the OS. This allows them to distribute data throughout memory in ways that minimises the amount of reallocation and copying that

RATIONALE:
### Memory expansion gas cost The new gas cost follows the same curve as the previous one, while ensuring that the new gas cost is always less than or equal to the previous cost. This prevents existing programs that make assumptions about memory allocation gas costs from resulting in


=== EIP-8 ===
TITLE: devp2p Forward Compatibility Requirements for Homestead
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2015-12-18
REQUIRES: 

SUMMARY:
This EIP introduces new forward-compatibility requirements for implementations of the devp2p Wire Protocol, the RLPx Discovery Protocol and the RLPx TCP Transport Protocol. Clients which implement EIP-8 behave according to Postel's Law: > Be conservative in what you do, be liberal in what you accept from others. ### Specification

SPECIFICATION:
Implementations of **the devp2p Wire Protocol** should ignore the version number of hello packets. When sending the hello packet, the version element should be set to the highest devp2p version supported. Implementations should also ignore any additional list elements at the end of the hello packet. Similarly, implementations of

MOTIVATION:
Changes to the devp2p protocols are hard to deploy because clients running an older version will refuse communication if the version number or structure of the hello (discovery ping, RLPx handshake) packet does not match local expectations. Introducing forward-compatibility requirements as part of the Homestead consensus upgrade will ensure

RATIONALE:
The proposed changes address forward compatibility by applying Postel's Law (also known as the Robustness Principle) throughout the protocol stack. The merit and applicability of this approach has been studied repeatedly since its original application in RFC 761. For a recent perspective, see ["The Robustness Principle Reconsidered" (Eric Allman,


=== EIP-2046 ===
TITLE: Reduced gas cost for static calls made to precompiles
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-17
REQUIRES: 2, 1, 4, ,,  , 1, 3, 5, 2

SUMMARY:
Reduce the base gas cost of calling precompiles using `STATICCALL` from 700 to 40. This should allow more efficient use of precompiles as well as precompiles with a total cost below 700.

SPECIFICATION:
After block `HF` the `STATICCALL` (`0xfa`) instruction charges different basic gas cost (G<sub>call</sub> in [Yellow Paper]'s notation) depending on the destination address provided: - for precompiles (address range as per [EIP-1352]) the cost is `40` - for every other address the cost remains unchanged (`700`)

MOTIVATION:
The Spurious Dragon hard fork increased the cost of calls significantly to account for loading contract code from the state without making an exception for precompiles, whose "code" is always loaded. This made use of certain precompiles impractical. FIXME: extend this with recent reasoning about ECC repricings.

RATIONALE:
Only the `STATICCALL` instruction was changed to reduce the impact of the change. This should not be a limiting factor, given precompiles (currently) do not have a state and cannot change the state. However, contracts created and deployed before Byzantium likely will not use `STATICCALL` and as a result


=== EIP-1898 ===
TITLE: Add `blockHash` to defaultBlock methods
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-04-01
REQUIRES: 234

SUMMARY:
For JSON-RPC methods which currently accept a default block parameter, additionally allow the parameter to be a block hash. This EIP can be considered a generalization of [EIP-234](./eip-234.md). It would enable clients to unambiguously specify the block they want to query for certain JSON-RPC methods, even if the block

SPECIFICATION:
The following JSON-RPC methods are affected: - `eth_getBalance` - `eth_getStorageAt` - `eth_getTransactionCount` - `eth_getCode` - `eth_call` - `eth_getProof` The following options, quoted from the Ethereum JSON-RPC spec, are currently possible for the defaultBlock parameter: > - HEX String - an integer block number > - String "earliest" for the

RATIONALE:
Currently, the state-querying JSON-RPC methods specified above have no option to unambiguously specify which block to query the state for. This can cause issues for applications which need to make multiple calls to the RPC. For instance, a wallet which just executed a transfer may want to display the


=== EIP-1234 ===
TITLE: Constantinople Difficulty Bomb Delay and Block Reward Adjustment
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-07-19
REQUIRES: 

SUMMARY:
Starting with `CNSTNTNPL_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 5 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 5_000_000) if block.number >= CNSTNTNPL_FORK_BLKNUM else block.number #### Adjust Block, Uncle, and Nephew rewards To

MOTIVATION:
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another 12 months. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards.

RATIONALE:
This will delay the ice age by 29 million seconds (approximately 12 months), so the chain would be back at 30 second block times in winter 2019. An alternate proposal was to add special rules to the difficulty calculation to effectively _pause_ the difficulty between different blocks. This would


=== EIP-706 ===
TITLE: DEVp2p snappy compression
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-09-07
REQUIRES: 

SUMMARY:
The base networking protocol (DEVp2p) used by Ethereum currently does not employ any form of compression. This results in a massive amount of bandwidth wasted in the entire network, making both initial sync as well as normal operation slower and laggier. This EIP proposes a tiny extension to the

SPECIFICATION:
Bump the advertised DEVp2p version number from `4` to `5`. If during handshake, the remote side advertises support only for version `4`, run the exact same protocol as until now. If the remote side advertises a DEVp2p version `>= 5`, inject a Snappy compression step right before encrypting the

MOTIVATION:
Synchronizing the Ethereum main network (block 4,248,000) in Geth using fast sync currently consumes 1.01GB upload and 33.59GB download bandwidth. On the Rinkeby test network (block 852,000) it's 55.89MB upload and 2.51GB download. However, most of this data (blocks, transactions) are heavily compressible. By enabling compression at the message


=== EIP-3508 ===
TITLE: Transaction Data Opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-16
REQUIRES: 

SUMMARY:
This EIP introduces the following three EVM instructions: `ORIGINDATALOAD`, `ORIGINDATASIZE`, and `ORIGINDATACOPY`. These three instructions are meant to provide access to the original transaction's `data` payload, enabling a gas-efficient way of accessing large data payloads in cross-contract calls.

SPECIFICATION:
### ORIGINDATALOAD (`0x47`), ORIGINDATASIZE (`0x48`) and ORIGINDATACOPY (`0x49`) These instructions are meant to operate similarly to their call-prefixed counterparts with the exception that they instead operate on the original `data` of a transaction instead of the current call's data. In detail: - ORIGINDATALOAD (`0x47`) performs similarly to CALLDATALOAD (`0x35`)

MOTIVATION:
As the Ethereum development scene matures, more ambitious and complex features are introduced into smart contracts more often than not requiring the utilization of complex and at times large data structures. Given the inherent limits of the EVM, however, transporting large data structures in between contracts is a costly

RATIONALE:
### AUTHCALL (`0xf7`) Interaction The [EIP-3074](./eip-3074.md) that will be part of the London fork has introduced a new call instruction called `AUTHCALL` (`0xf7`) that will replace a transaction's `ORIGIN` (`0x32`) with the context variable `authorized`. The intention of `AUTHCALL` is to prevent discrimination between smart contracts and EOAs which


=== EIP-7808 ===
TITLE: Reserve Tx-Type Range for RIPs
TYPE: Meta 
STATUS: Draft
CREATED: 2024-11-04
REQUIRES: 2718

SUMMARY:
This EIP reserves a [transaction-type](./eip-2718.md) range for use by the Rollup Improvement Proposal (RIP) process to ensure there are no conflicts.

SPECIFICATION:
The transaction-type (as specified in [EIP-2718](./eip-2718)) range from `0x40` to `0x7f` (inclusive of both) is reserved for use by the RIP process.

MOTIVATION:
For L2s to use new transactrion types, it is necessary to reserve an transaction-type range for use by the RIP process so as to ensure there are no conflicts between transaction types used by RIPs and EIPs.

RATIONALE:
By reserving a transaction-type range for RIPs, it allows the RIP process to maintain its own registry of transaction types that are not (necessarily) in use on L1 mainnet, the EIP process is then freed from having to maintain a registry of RIP tx-types while still having 64 tx-types


=== EIP-225 ===
TITLE: Clique proof-of-authority consensus protocol
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-03-06
REQUIRES: 

SUMMARY:
Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.

SPECIFICATION:
We define the following constants: * **`EPOCH_LENGTH`**: Number of blocks after which to checkpoint and reset the pending votes. * Suggested `30000` for the testnet to remain analogous to the mainnet `ethash` epoch. * **`BLOCK_PERIOD`**: Minimum difference between two consecutive block's timestamps. * Suggested `15s` for the testnet to

MOTIVATION:
Ethereum's first official testnet was Morden. It ran from July 2015 to about November 2016, when due to the accumulated junk and some testnet consensus issues between Geth and Parity, it was finally laid to rest in favor of a testnet reboot. Ropsten was thus born, clearing out all


=== EIP-3068 ===
TITLE: Precompile for BN256 HashToCurve Algorithms
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-23
REQUIRES: 1, 9, 8, ,,  , 1, 1, 0, 8

SUMMARY:
There is currently no inexpensive way to perform BLS signature verification for arbitrary messages. This stems from the fact that there is no precompiled contract in the EVM for a hash-to-curve algorithm for the BN256 elliptic curve. The gas cost of calling a deterministic hash-to-curve algorithm written in Solidity

SPECIFICATION:
Here is the pseudocode for the `HashToG1` function: ``` function HashToG1(msg) fieldElement0 = HashToBase(msg, 0x00, 0x01) fieldElement1 = HashToBase(msg, 0x02, 0x03) curveElement0 = BaseToG1(fieldElement0) curveElement1 = BaseToG1(fieldElement1) g1Element = ECAdd(curveElement0, curveElement1) return g1Element end function ``` Here is the pseudocode for `HashToBase`; `msg` is the byte slice to be

MOTIVATION:
The precompiled contracts in [EIP-198](./eip-198.md) and [EIP-1108](./eip-1108.md) increased usage of cryptographic operations in the EVM by reducing the gas costs. In particular, the cost reduction from [EIP-1108](./eip-1108.md) helps increase the use of SNARKs in Ethereum via an elliptic curve pairing check; however, a hash-to-curve algorithm enabling arbitrary BLS signature

RATIONALE:
The BaseToG1 algorithm is based on the original Fouque and Tibouchi [paper](../assets/eip-3068/latincrypt12.pdf) with modifications based on Wahby and Boneh's [paper](../assets/eip-3068/2019-403_BLS12_H2C.pdf). There is freedom in choosing the HashToBase function and this could easily be changed. Within HashToBase, the particular hashing algorithm (Keccak256 in our case) could also be modified. It


=== EIP-3014 ===
TITLE: eth_symbol JSON-RPC method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-09-30
REQUIRES: 

SUMMARY:
The new method `eth_symbol` (`eth_`-namespaced) has no parameters and returns a string of the native coin of the network. For the Ethereum mainnet this will be `ETH`, other networks will have other symbols.

SPECIFICATION:
Method: `eth_symbol`. Params: none. Returns: `result` - the native coin symbol, string Example: ```js curl -X POST --data '{"jsonrpc":"2.0","method":"eth_symbol","params":[],"id":1}' // Result { "id": 1, "jsonrpc": "2.0", "result": "ETH" } ```

MOTIVATION:
Wallets that deal with multiple networks need some basic information for every blockchain that they connect to. One of those things is the symbol of the native coin of the network. Instead of requiring the user to research and manually add the symbol it could be provided to the

RATIONALE:
This endpoint is similar to [EIP-695](./eip-695.md) but it provides the symbol instead of `chainId`. It provides functionality that is already there for [ERC-20](./eip-20.md) tokens, but not yet for the native coin of the network. Alternative naming of `eth_nativeCurrencySymbol` was considered, but the context and the fact that it just


=== EIP-969 ===
TITLE: Modifications to ethash to invalidate existing dedicated hardware implementations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-03
REQUIRES: 

SUMMARY:
There are companies who currently have dedicated hardware based ethereum miners in production, and may be actively mining. This EIP aims to "poison the well" by modifying the block mining algorithm in a low risk manner that may *"break"* these miners if they are in-fact built as traditional ASICs.

SPECIFICATION:
If `block.number >= ASIC_MITIGATION_FORK_BLKNUM`, require that the ethash solution sealing the block has been mined using `ethashV2`.

MOTIVATION:
ASIC-based miners will have lower operational costs than GPU-based miners, which will result in GPU-based mining quickly becoming unprofitable. Given that production of ASIC-based miners has a high barrier to entry and few market players, this will cause a trend towards centralization of mining power. Risks include market dominance

RATIONALE:
This EIP is aimed at breaking existing ASIC-based miners via small changes to the existing ethash algorithm. We hope to accomplish the following: 1. Break existing ASIC-based miners. 2. Demonstrate a willingness to fork in the event of future ASIC miner production. Goal #1 is something that we can


=== EIP-4520 ===
TITLE: Multi-byte opcodes prefixed by EB and EC.
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-12-01
REQUIRES: 

SUMMARY:
Reserve `0xEB` and `0xEC` for usage as extended opcode space.

SPECIFICATION:
For example, a new arithmetic opcode may be allocated to `0xEC 01`(`ADD`), and a novel opcode may be introduced at `0xEB F4`(`DELEGATECALL`). Triple byte opcodes may be doubly-prefixed by `0xEB EB`, `0xEC EC`, `0xEB EC` and `0xEC EB`. It is possible to allocate experimental opcodes to this triple-byte space

MOTIVATION:
It would be convenient to introduce new opcodes that are likely to be infrequently used, whilst also being able to have greater than 256 opcodes in total. As a single byte opcode is half the size of a double byte opcode, the greatest efficiency in code sizes will be

RATIONALE:
It was considered that two prefix bytes rather than one would be adequate for reservation as extension addresses. Both `0xEB` and `0xEC` were chosen to be part of the E-series of opcodes. For example, the `0xEF` byte is reserved for contracts conforming to the Ethereum Object Format. By having


=== EIP-7002 ===
TITLE: Execution layer triggerable withdrawals
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-05-09
REQUIRES: 7685

SUMMARY:
Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials. These new execution layer exit messages are appended to the execution layer block and then processed by the consensus layer.

SPECIFICATION:
### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | *TBD* | Mainnet | ### Configuration | Name | Value | Comment | | - | - | - | | `WITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS` | `0x0c15F14308530b7CDB8460094BbB9cC28b9AaaAA` | Where to call and store relevant

MOTIVATION:
Validators have two keys -- an active key and a withdrawal credential. The active key takes the form of a BLS key, whereas the withdrawal credential can either be a BLS key (0x00) or an execution layer address (0x01). The active key is "hot", actively signing and performing validator

RATIONALE:
### `validator_pubkey` field Multiple validators can utilize the same execution layer withdrawal credential, thus the `validator_pubkey` field is utilized to disambiguate which validator is being exited. Note, `validator_index` also disambiguates validators. ### Message queue The contract maintains and in-state queue of withdrawal request messages to be dequeued each block


=== EIP-7797 ===
TITLE: Double speed for hash_tree_root
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-23
REQUIRES: 

SUMMARY:
This EIP explains how to customize [`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md#merkleization) to double its performance.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### SHA-256 preprocessing Before SHA-256 hash computation begins, the input message is preprocessed. A single

MOTIVATION:
Hashing is a dominant performance bottleneck for Consensus Layer implementations. To support large validator counts, it is critical to optimize hashing performance. Consensus Layer hashes are based on [`hash_tree_root`](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md#merkleization), a mechanism that splits up the data into chunks and then forms a tree by recursively combining two adjacent chunks

RATIONALE:
Doubling the throughput of the underlying hash algorithm allows scaling to more validators on the same hardware, or allows using the freed CPU time for other tasks. Even when caching rarely-changed intermediate hashes across computations such as the `validators` list of a `BeaconState`, and employing hardware-accelerated SHA-256 implementations that


=== EIP-3372 ===
TITLE: 5 FNV primes for ethash
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
This EIP is to kick current ASIC implementations out of the network to keep the Ethereum network secure and healthy by changing the `fnv` constants.

SPECIFICATION:
If `block.number >= ETHASH11_BLKNUM`, activate the `ethash1.1` algorithm version. ### ethash1.1 Prior to this change, `fnv` hash function is used throughout the `hashimoto` function. `fnv` is identical for all steps, `ethash1.1` will introduce additional `fnvA`, `fnvB`, `fnvC`, `fnvD`, and `fnvE` functions. All those functions will have different FNV constants.

MOTIVATION:
ASICs provide a severe centralization risk for the Ethereum network. If we do not get rid of them, small GPU miners will be forced to exit the Ethereum mining because EIP-1559 will make them mining at a loss. Furthermore, ASIC production will be concentrated only at one or two

RATIONALE:
ASIC Miners have become a threat to the future of Ethereum and a hard fork is required to remove them from the network before additional damage is caused. EIP-3372 proposes the minimum necessary to do so and will not affect ETH stakeholders or the network like Ethash 2.0 would.


=== EIP-7727 ===
TITLE: EVM Transaction Bundles
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-06-24
REQUIRES: 2718

SUMMARY:
This EIP introduces two new [EIP-2718](./eip-2718.md) transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native 'bundles', which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles

SPECIFICATION:
### Constants | Name | Value | | --- | --- | | DELEGATED_TX_TYPE | 0x05 | | BUNDLE_TX_TYPE | 0x06 | | BUNDLE_BASE_GAS_COST | TBD <!-- TODO --> | | BUNDLE_SIGNER_OPCODE_NUMBER | TBD <!-- TODO --> | ### New Transaction Payload Types Two new [EIP-2718](./eip-2718.md) transactions with types

MOTIVATION:
Currently, a single block builder has unrestricted control over the final sequencing of a block’s transactions. This poses a problem, as sequencing—the choice of who gets to interact with specific pieces of state and in what order—significantly influences value flow. The objective of this EIP is to allow more

RATIONALE:
### Allowing invalid transactions to be included in a `BUNDLE_TX_TYPE`'s `transactionList` Knowing how a transaction will execute is challenging without knowing the state root to which the transaction is applied. Creators of `BUNDLE_TX_TYPE` transactions can only access the previous block’s state root and cannot predict which transactions will precede


=== EIP-7636 ===
TITLE: Extension of EIP-778 for "client" ENR Entry
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2024-02-25
REQUIRES: 778

SUMMARY:
The Ethereum network consists of nodes running various client implementations. Each client has its own set of features, optimizations, and unique behaviors. Introducing a standardized way to identify client software and its version in the ENR allows for more effective network analysis, compatibility checks, and troubleshooting. This EIP proposes

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The "client" entry is proposed to be added to the ENR following the specifications in

MOTIVATION:
Understanding the landscape of client software in the Ethereum network is crucial for developers, nodes, and network health assessment. Currently, there is no standardized method for nodes to announce their software identity and version, which can lead to compatibility issues or difficulty in diagnosing network-wide problems. Adding this to

RATIONALE:
One key was chosen over using many keys to make efficient use of space. The use of one string, however, does not align with other EIPs of similar purpose and as such the RLP list was decided as the best encoding.


=== EIP-3374 ===
TITLE: Predictable Proof-of-Work (POW) Sunsetting
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
Sets the block reward to 3 ETH and then incrementally decreases it every block for 2,362,000 blocks (approximately 1 year) until it reaches 1 ETH.

SPECIFICATION:
### Constants * `TRANSITION_START_BLOCK_NUMBER: TBD` * `TRANSITION_DURATION: 2_362_000` // (about one year) * `TRANSITION_END_BLOCK_NUMBER: FORK_BLOCK_NUMBER + TRANSITION_DURATION` * `STARTING_REWARD: 3_000_000_000_000_000_000` * `ENDING_REWARD: 1_000_000_000_000_000_000` * `REWARD_DELTA: STARTING_REWARD - ENDING_REWARD` ### Block Reward ```py if block.number >= TRANSITION_END_BLOCK_NUMBER: block_reward = ENDING_REWARD elif block.number == TRANSITION_START_BLOCK_NUMBER: block_reward = STARTING_REWARD elif block.number >

MOTIVATION:
Unnecessarily abrupt changes to the Ethereum ecosystem cause disruption and disharmony resulting in the disenfranchisement of community members while undermining stability and confidence. While moves from Proof-of-Work to Proof-of-Stake will undoubtedly cause friction between those community members vested in either, all benefit from a measured, predictable transition. This proposal:

RATIONALE:
Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame. Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner


=== EIP-3102 ===
TITLE: Binary trie structure
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-01
REQUIRES: 

SUMMARY:
This proposal presents a binary structure and merkelization rule for the account and storage tries, which are merged into a single “state” trie. RLP and most of the MPT’s optimizations are dropped to simplify the design. Keccak256 is replaced with blake2b.

SPECIFICATION:
### Conventions | Code | Description | | :-: | - | | `u256(x)` | Big endian, 32-byte representation of number _x_ | |`||` | Byte-wise concatenation operator| | `++` | Bit-wise concatenation operator | | `0b0101` | The binary string `0101` | | `hash()` | The usual hashing

MOTIVATION:
The current design of the Merkle Patricia Trie (MPT) uses an hexary trie. Hexary Merkle trees are more shallow than their binary counterparts, which means less hashing. Over the course of the 5 years of Ethereum’s existence, it has become apparent that disk accesses are a greater bottleneck than

RATIONALE:
### blake2b BLAKE2 offers better performance, which is key to compensate for the loss of performance associated to a ~4x increase in the number of nodes. BLAKE3 offers even better performance. No official golang release exists at the time of the writing of this document. This presents a security


=== EIP-6188 ===
TITLE: Nonce Cap
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-12-20
REQUIRES: 2929

SUMMARY:
This EIP caps the nonce at `2^64-2`, reserving it for contracts with unusual behavior, as defined in other EIPs.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### EOA Transactions The nonce of a transaction originating from an EOA MUST be less than `2^64-2`.

MOTIVATION:
This EIP is not terribly useful on its own, as it adds additional computation without any useful side effects. However, it can be used by other EIPs.

RATIONALE:
Capping a nonce allows for contracts with special properties to be created, with their functionality based on their contract code. As such, only one nonce needs to be reserved.


=== EIP-7784 ===
TITLE: GETCONTRACT opcode
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-10-07
REQUIRES: 

SUMMARY:
This is a proposal to add a new opcode, `GETCONTRACT`. The `GETCONTRACT` opcode would return the address containing the bytecode by its hash.

SPECIFICATION:
### Opcode Definition * **Mnemonic:** `GETCONTRACT` * **Opcode Value:** `0x4f` * **Input:** * `codehash`: A single 32-byte code hash from the stack. * **Output:** * `address`: If the `codehash` exists in the state, pushes the corresponding contract address onto the stack. Otherwise, pushes 0. * **Gas Cost:** 150 *

MOTIVATION:
Content addressing by hash is a common pattern in database design. It allows to store and retrieve data by its unique footprint in the storage. This pattern is widely used in the industry and it allows abstracting the actual storage location and allows reusing the same bytecode in multiple

RATIONALE:
**Bytecode over Addresses**: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable. **Do not re-index**: There is small, yet non-zero probability of hash collision attack. Disallowing updates to indexed location of bytecode coupes with this. **Gas cost**: This operation is more complex than simple


=== EIP-3540 ===
TITLE: EOF - EVM Object Format v1
TYPE: Standards Track Core
STATUS: Review
CREATED: 2021-03-16
REQUIRES: 3, 5, 4, 1, ,,  , 3, 8, 6, 0

SUMMARY:
We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174. In order to guarantee that every EOF-formatted contract in the state is valid, we need

MOTIVATION:
On-chain deployed EVM bytecode contains no pre-defined structure today. Code is typically validated in clients to the extent of `JUMPDEST` analysis at runtime, every single time prior to execution. This poses not only an overhead, but also a challenge for introducing new or deprecating existing features. Validating code during

RATIONALE:
EVM and/or account versioning has been discussed numerous times over the past years. This proposal aims to learn from them. See "Ethereum account versioning" on the Fellowship of Ethereum Magicians Forum for a good starting point. ### Execution vs. creation time validation This specification introduces creation time validation, which


=== EIP-7577 ===
TITLE: Versioning Scheme for EIPs
TYPE: Meta 
STATUS: Draft
CREATED: 2023-12-13
REQUIRES: 

SUMMARY:
This EIP introduces a versioning scheme for [Standards Track](./eip-1.md#eip-types) EIPs by applying [Semantic Versioning 2.0.0](../assets/eip-7577/semver.md) based on changes made to the EIP's Specification section once its status has changed from `Draft` to `Review`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Once an EIP has moved out of "Draft" status, it MUST use the EIP versioning

MOTIVATION:
EIP specifications often receive increasing modifications as more people review them, which is generally the case as client teams start implementing the specifications and the community gains a better understanding of their interaction with the rest of the protocol. These changes can be difficult to track. In particular, as

RATIONALE:
Making the version available in the EIP's metadata header allows for programmatic parsing of the version number by tooling used in reference tests or by client teams. Currently, the execution-spec-tests repository, which contains consensus tests for Ethereum execution clients, implements a rudimentary EIP version checker: EIP spec tests are


=== EIP-1470 ===
TITLE: Smart Contract Weakness Classification (SWC)
TYPE: Informational 
STATUS: Stagnant
CREATED: 2018-09-18
REQUIRES: 

SUMMARY:
The SWC is a smart contract specific software weakness classification scheme for developers, tool vendors and security practitioners. The SWC is loosely aligned to the terminologies and structure used in the [Common Weakness Enumeration - CWE](https://cwe.mitre.org) scheme while overlaying a wide range of weakness variants that are specific to

SPECIFICATION:
Before discussing the SWC specification it is important to describe the terminology used: - Weakness: A software error or mistake that in the right conditions can by itself or coupled with other weaknesses lead to a vulnerability. - Vulnerability: A weakness or multiple weaknesses which directly or indirectly lead

MOTIVATION:
In the software security industry, it is a widely accepted practice to use a common terminology and to classify security related bugs and errors with a standardized scheme. While this has not stopped vulnerabilities from appearing in software, it has helped communities focusing on web applications, network protocols, IOT


=== EIP-2315 ===
TITLE: Simple Subroutines for the EVM
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-10-17
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0

SUMMARY:
This proposal provides a _complete_, _efficient_, _safe_ and _static_ control-flow facility. It introduces two new opcodes to support calling and returning from subroutines: * `RJUMPSUB relative_offset` -- relative jump to subroutine * `RETURNSUB` -- return to `PC` after most recent `RJUMPSUB`. It depends on the two new opcodes proposed

SPECIFICATION:
### Opcodes #### `RJUMPSUB (0x5f) relative_offset` Transfers control to a subroutine. 1. Decode the `relative_offset` from the immediate data at `PC`. 2. Push the current `PC + 3` to the `return stack`. 3. Set `PC` to `PC + relative_offset`. The `relative_offset` is relative to the current `PC`. The offset

MOTIVATION:
### A complete control-flow facility. Jumps, conditional jumps and subroutines were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine: > We wish to be able to arrange that sequences

RATIONALE:
This is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data – a subroutine is not a contiguous sequence of bytecode, it is a subgraph of the bytecode's control-flow graph. The EVM is a simple state


=== EIP-4788 ===
TITLE: Beacon block root in the EVM
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-02-10
REQUIRES: 1559

SUMMARY:
Commit to the hash tree root of each beacon chain block in the corresponding execution payload header. Store each of these roots in a smart contract.

SPECIFICATION:
| constants | value | |--- |--- | | `FORK_TIMESTAMP` | `1710338135` | | `HISTORY_BUFFER_LENGTH` | `8191` | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | | `BEACON_ROOTS_ADDRESS` | `0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02` | ### Background The high-level idea is that each execution block contains the parent beacon block's root. Even in the event of

MOTIVATION:
Roots of the beacon chain blocks are cryptographic accumulators that allow proofs of arbitrary consensus state. Exposing these roots inside the EVM allows for trust-minimized access to the consensus layer. This functionality supports a wide variety of use cases that improve trust assumptions of staking pools, restaking constructions, smart

RATIONALE:
### Why not repurpose `BLOCKHASH`? The `BLOCKHASH` opcode could be repurposed to provide the beacon root instead of some execution block hash. To minimize code change, avoid breaking changes to smart contracts, and simplify deployment to mainnet, this EIP suggests leaving `BLOCKHASH` alone and adding new functionality with the


=== EIP-3326 ===
TITLE: Wallet Switch Ethereum Chain RPC Method (`wallet_switchEthereumChain`)
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2021-03-04
REQUIRES: 1, 5, 5, ,,  , 6, 9, 5

SUMMARY:
The `wallet_switchEthereumChain` RPC method allows Ethereum applications ("dapps") to request that the wallet switches its active Ethereum chain, if the wallet has a concept thereof. The caller must specify a chain ID. The wallet application may arbitrarily refuse or accept the request. `null` is returned if the active chain

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### `wallet_switchEthereumChain` The method accepts a single object parameter with a `chainId` field. The method returns `null` if the wallet switched

MOTIVATION:
All dapps require the user to interact with one or more Ethereum chains in order to function. Some wallets only supports interacting with one chain at a time. We call this the wallet's "active chain". `wallet_switchEthereumChain` enables dapps to request that the wallet switches its active chain to whichever

RATIONALE:
The purpose `wallet_switchEthereumChain` is to provide dapps with a way of requesting to switch the wallet's active chain, which they would otherwise have to ask the user to do manually. The method accepts a single object parameter to allow for future extensibility at virtually no cost to implementers and


=== EIP-7069 ===
TITLE: Revamped CALL instructions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-05-05
REQUIRES: 1, 5, 0, ,,  , 2, 1, 1, ,,  , 2, 1, 4, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 4, 0

SUMMARY:
Introduce three new call instructions, `EXTCALL`, `EXTDELEGATECALL` and `EXTSTATICCALL`, with simplified semantics. Introduce another instruction, `RETURNDATALOAD` for loading a word from return data into stack. Modify the behavior of `RETURNDATACOPY` instruction executed within EOF formatted code (as defined by [EIP-3540](./eip-3540.md)). The existing `*CALL` instructions remain unchanged. The new instructions

SPECIFICATION:
| Name | Value | Comment | |------|-------|---------| | WARM_STORAGE_READ_COST | 100 | From [EIP-2929](./eip-2929.md) | | COLD_ACCOUNT_ACCESS | 2600 | From [EIP-2929](./eip-2929.md) | | CALL_VALUE_COST | 9000 | | | ACCOUNT_CREATION_COST | 25000 | | | MIN_RETAINED_GAS | 5000 | | | MIN_CALLEE_GAS | 2300 | | We

MOTIVATION:
Observability of gas has been a problem for very long. The system of gas has been (and likely must be) flexible in adapting to changes to both how Ethereum is used as well as changes in underlying hardware. Unfortunately, in many cases compromises or workarounds had to be made

RATIONALE:
### Removing gas selectability One major change from the original `CALL` series of instructions is that the caller has no control over the amount of gas passed in as part of the call. The number of cases where such a feature is essential are probably better served by direct


=== EIP-5757 ===
TITLE: Process for Approving External Resources
TYPE: Meta 
STATUS: Final
CREATED: 2022-09-30
REQUIRES: 1

SUMMARY:
Ethereum improvement proposals (EIPs) occasionally link to resources external to this repository. This document sets out the requirements for origins that may be linked to, and the process for approving a new origin.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Definitions - **Link**: Any method of referring to a resource, including: markdown links, anchor tags (`<a>`), images, citations of

RATIONALE:
### Unique Identifiers If it is impossible to uniquely identify a version of a resource, it becomes impractical to track changes, which makes it difficult to ensure immutability. ### Availability If it is possible to implement a standard without a linked resource, then the linked resource is unnecessary. If


=== EIP-3788 ===
TITLE: Strict enforcement of chainId
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-09-02
REQUIRES: 155

SUMMARY:
Reject transactions that do not explicitly have the same chainId as the node's configuration.

SPECIFICATION:
As of the fork block `N`, consider transactions with a `chaindId = 0` to be invalid. Such that transactions are verified based on the nodes configuration. Eg: ``` if (node.cfg.chainId != tx.chainId) { // Reject transaction } ```

MOTIVATION:
Per [EIP-155](./eip-155.md) a transaction with a `chainId = 0` is considered to be a valid transaction. This was a feature to offer developers the ability to submit replayable transactions across different chains. With the rise of evm compatible chains, many of which use forks, or packages from popular Ethereum

RATIONALE:
The configuration set by the node is the main source of truth, and thus should be explicitly used when deciding how to filter out a transaction. This check should exist in two places, as a filter on the JSON-RPC (eg: `eth_sendTransaction`), and strictly enforced on the EVM during transaction


=== EIP-5792 ===
TITLE: Wallet Call API
TYPE: Standards Track Interface
STATUS: Review
CREATED: 2022-10-17
REQUIRES: 

SUMMARY:
Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls. Applications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional,

SPECIFICATION:
Four new JSON-RPC methods are added: three are for handling batches of onchain calls, and one is for querying support for wallet capabilities, such as to make better use of the three batching methods. Apps may begin using these first three methods immediately, falling back to `eth_sendTransaction` and `eth_getTransactionReceipt`

MOTIVATION:
The current methods used to send transactions from the user wallet and check their status are `eth_sendTransaction` and `eth_getTransactionReceipt`. The current methods used to send transactions from the user wallet and check their status do not meet modern developer demands and cannot accommodate new transaction formats. Even the name–-

RATIONALE:
### On Naming We considered modifying `eth_sendTransaction` to add support for these new capabilities, but the method is ultimately an artifact of when nodes were used to sign transactions. We decided it is better to move forward with `wallet_`-namespaced methods that better describe what they are used for. We


=== EIP-2035 ===
TITLE: Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-16
REQUIRES: 

SUMMARY:
It is part of the State Rent roadmap. This particular change prepares Ethereum for introduction of the block proofs (current understanding is that they can be introuced without a hard fork). The introduction of the block proofs allows any Ethereum node that wishes to receive them, to process transactions

SPECIFICATION:
Not very formal at the moment, but will be formalised with more research and prototyping. Gas of operations `SLOAD` and `SSTORE` increases by `X` gas when the storage slots accessed (read by `SLOAD` or written by `SSTORE`) were not previously accessed (by another `SLOAD` or `SSTORE`) during the same

MOTIVATION:
There is [empirical analysis](https://github.com/holiman/vmstats/blob/master/README.md) showing that `SLOAD` opcode is currently underpriced in terms of execution latency it adds to the block processing. The hypothesis is that it is due to the latency of the database accesses. In the same analysis, `SSTORE` is not considered, because its effect on the

RATIONALE:
[EIP-1884](./eip-1884.md) seeks to increase the gas cost of `SLOAD` but using a different justification (latency of the execution as described in the Motivation). This EIP is likely to increase the cost of `SLOAD` by a larger amount, therefore partially (because EIP-1884 also proposed other increases) supersedes EIP-1884. [EIP-2028](./eip-2028.md) describes


=== EIP-2029 ===
TITLE: State Rent A - State counters contract
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-15
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces a place in the Ethereum state where various state counters can be stored. At this point, the most important counter is the total number of transactions happened, and this counter will be used to populate the nonces

SPECIFICATION:
Prior to the block A, a contract is deployed with the following code: `0x60 0x20 0x60 0x00 0x80 0x80 0x35 0x54 0x90 0x52 0xF3`, which corresponds to this assembly: `PUSH1 32 PUSH1 0 DUP1 DUP1 CALLDATALOAD SLOAD SWAP1 MSTORE RETURN` Call to this contract accepts one 32-byte argument, `x`,

MOTIVATION:
Ethereum currently does not have a special place in the state for tracking state counters such as number of transactions or number of accounts.

RATIONALE:
Two alternative solutions were considered so far: 1. Extending the structure of the Ethereum state to introduce more fields, and hence change the way the state root is constructed. The main downside of this approach is the impact on the software what is currently coupled with the particular way


=== EIP-6888 ===
TITLE: Arithmetic verification at EVM level
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-04-16
REQUIRES: 

SUMMARY:
This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Starting from `BLOCK_TIMESTAMP >= HARDFORK_TIMESTAMP` ### Constants | Constant | Type | Value | |

MOTIVATION:
The importance of math checks in smart contract projects is very clear. It was an OpenZeppelin library and then incorporated in Solidity's default behavior. Bringing this to EVM level can combine both gas efficiency and safety.

RATIONALE:
EVM uses two's complement for negative numbers. The opcodes listed above triggers one or two flags depending if they are used for signed and unsigned numbers. The conditions described for each opcode is made with implementation friendliness in mind. The only exception is EXP as it is hard to


=== EIP-7783 ===
TITLE: Add Controlled Gas Limit Increase Strategy
TYPE: Informational 
STATUS: Draft
CREATED: 2024-10-06
REQUIRES: 


=== EIP-3238 ===
TITLE: Difficulty Bomb Delay to Q2/2022
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-01-25
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting eleven million blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 11_000_000) if block.number >= FORK_BLOCK_NUMBER else block.number

MOTIVATION:
Even after the Ethereum 2.0 mainnet launch, Ethash proof-of-work mining on the legacy chain should be feasible. It should allow miners sealing new blocks every 13~15 seconds on average for another ten months and allow both Ethereum 1.x and Ethereum 2.0 developers to conclude the merge.

RATIONALE:
This will delay the ice age by another ~26 million seconds (approximately ~9.89 months), so the chain would be back at ~30 second block times in Q2/2022. Hopefully, by then the Eth1-to-Eth2 merge will be concluded and the ice age fulfilled its task.


=== EIP-1014 ===
TITLE: Skinny CREATE2
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-04-20
REQUIRES: 

SPECIFICATION:
Adds a new opcode (`CREATE2`) at `0xf5`, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically to `CREATE` (`0xf0`), except using `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]` instead of the usual sender-and-nonce-hash as the address where the contract is initialized at. The `CREATE2` has the

MOTIVATION:
Allows interactions to (actually or counterfactually in channels) be made with addresses that do not exist yet on-chain but can be relied on to only possibly eventually contain code that has been created by a particular piece of init code. Important for state-channel use cases that involve counterfactual interactions

RATIONALE:
#### Address formula * Ensures that addresses created with this scheme cannot collide with addresses created using the traditional `keccak256(rlp([sender, nonce]))` formula, as `0xff` can only be a starting byte for RLP for data many petabytes long. * Ensures that the hash preimage has a fixed size, #### Gas


=== EIP-2657 ===
TITLE: Ephemeral Testnet Yolo
TYPE: Meta 
STATUS: Stagnant
CREATED: 2020-04-19
REQUIRES: 

SUMMARY:
The specification for Ephemeral Testnet Yolo. Clients who wish to sync need to implement the following features into their client. It is for testing basic infrastructure and will be nuked.


=== EIP-7756 ===
TITLE: EOF/EVM Trace Specification
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2024-08-13
REQUIRES: 3, 1, 5, 5, ,,  , 4, 7, 5, 0

SUMMARY:
Updates the [EIP-3155](./eip-3155.md) JSON tracing specification to support EOF features.

SPECIFICATION:
To promote clarity and provide a cohesive specification, the entire tracing specification will be presented with alterations in-line rather than as a set of diffs on top of EIP-3155. Differences will be highlighted in the Backwards Compatibility section. The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",

MOTIVATION:
EIP-3155 defined a tracing standard for Legacy EVM operations. However, the EVM Object Format ([EIP-7692](./eip-7692.md)) adds a number of features that need to be reflected in debugging traces. The use of these traces has also moved out from state testing, including live block tracing and differential fuzzing, increasing the

RATIONALE:
This EIP is an extension of the EIP-3155 tracing features that has been in use for years. Rather than dramatically re-boot the feature, the information was added to the existing traces. A "mini" trace was contemplated to allow for tracing to be included in tools such as `t8n` and


=== EIP-7686 ===
TITLE: Linear EVM memory limits
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-15
REQUIRES: 

SUMMARY:
Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of

SPECIFICATION:
Change `memory_cost` from: ```python memory_size_word = (memory_byte_size + 31) / 32 memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word) ``` To: ```python memory_size_word = (memory_byte_size + 31) / 32 memory_cost = 3 * memory_size_word ``` Additionally, if a memory expansion would lead to `memory_byte_size` strictly exceeding

MOTIVATION:
Today, memory pricing rules are complicated: we have the quadratic cost for expanding memory as well as the 63/64 rule for how much gas can go into a child call. This also makes it extremely hard to calculate a maximum possible amount of memory required to process a given

RATIONALE:
With this EIP, there is a simple EVM implementation that can process an N-gas call using an N-byte bytearray as memory: allocate all bytes to the current context, when doing a child call use the remaining memory starting from the position `memory_byte_size` for the child call's memory, and so


=== EIP-7523 ===
TITLE: Empty accounts deprecation
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2023-09-19
REQUIRES: 161

SUMMARY:
This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. An empty account is an account with has **no code** and **zero nonce** and **zero

MOTIVATION:
The possibility of empty accounts is a historical artifact of the early history of Ethereum. The only networks that have ever been capable of containing them are Ethereum Mainnet, the deprecated testnet Ropsten, Etheruem Classic Mainnet and various Ethereum Classic testnets. All remaining empty accounts on Mainnet were cleared

RATIONALE:
This EIP was drafted to be the simplest possible way of eliminating the long term technical debt imposed by empty accounts. The Merge was chosen as a natural easily identifiable cutoff point. Alternative approaches include: - Using an earlier cutoff point, such as block `14049881`. - Identifying a wider


=== EIP-2566 ===
TITLE: Human Readable Parameters for Contract Function Execution
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-03-23
REQUIRES: 

SUMMARY:
When a dapp prompts a user to execute a smart contract function via a ProviderWallet, confirmation screens displayed in the ProviderWallet layer cannot display the human readable details of the function to be called and the arguments to be passed. This is because the Ethereum RPC method used for

SPECIFICATION:
This EIP proposes increasing the set of Ethereum RPC methods to include a new method - `eth_sendTransactionToContractFunction`. This method parallels `eth_sendTransaction` with the only difference being the inclusion of the contract function's `abi` field. Parameters 1. `Object` - The transaction object * `from`: `DATA`, 20 Bytes - The address

MOTIVATION:
### ProviderWallet Definition ProviderWallets like Metamask and Geth are hybrid software that combine an Ethereum API provider with an Ethereum wallet. This allows them to sign transactions on behalf of their users and also broadcast those signed transactions to the Ethereum network. ProviderWallets are used for both convenience and

RATIONALE:
This EIP's proposed `eth_sendTransactionToContractFunction` method is intended to parallel `eth_sendTransaction` as much as possible since both methods result in the same behaviour when executing a contract function. The newly introduced `abi` field is an element of the contract's ABI that corresponds to the intended function. The `data` field is


=== EIP-7545 ===
TITLE: Verkle proof verification precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-10-13
REQUIRES: 

SUMMARY:
This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A precompiled contract is added at address `0x21`, wrapping the stateless ethereum proof verification function.

MOTIVATION:
The proposed proof systems for stateless Ethereum require an upgrade to many tools and applications, that need a simple path to keep their proving systems up-to-date, without having to develop and deploy new proving libraries each time another proof format must be supported.

RATIONALE:
Stateless Ethereum relies on proofs using advanced mathematical concepts and tools from a fast-moving area of cryptography. As a result, a soft-fork approach is currently favored in the choice of the proof format: proofs are going to be distributed outside of consensus, and in the future, stateless clients will


=== EIP-658 ===
TITLE: Embedding transaction status code in receipts
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-06-30
REQUIRES: 140

SUMMARY:
This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.

SPECIFICATION:
For blocks where block.number >= BYZANTIUM_FORK_BLKNUM, the intermediate state root is replaced by a status code, 0 indicating failure (due to any operation that can cause the transaction or top-level call to revert) and 1 indicating success.

MOTIVATION:
With the introduction of the REVERT opcode in EIP140, it is no longer possible for users to assume that a transaction failed iff it consumed all gas. As a result, there is no clear mechanism for callers to determine whether a transaction succeeded and the state changes contained in

RATIONALE:
This constitutes a minimal possible change that permits fetching the success/failure state of transactions, preserving existing capabilities with minimum disruption or additional work for Metropolis.


=== EIP-6953 ===
TITLE: Network Upgrade Activation Triggers
TYPE: Informational 
STATUS: Final
CREATED: 2023-04-28
REQUIRES: 2, 9, 8, 2, ,,  , 3, 6, 7, 5, ,,  , 6, 1, 2, 2

SUMMARY:
This EIP outlines the various network upgrade activation triggers used on Ethereum over time, from the proof-of-work era to the first post-merge network upgrade, Shanghai/Capella, across both the execution and consensus layers.

SPECIFICATION:
### Proof-of-Work Network Upgrades During the proof-of-work era, network upgrades on Ethereum were triggered based on specific block numbers. The following upgrades followed this pattern: | Upgrade Name | Activation Block Number | |--------------------|-------------------------| | Frontier | `1` | | Frontier Thawing | `200000` | | Homestead | `1150000`

MOTIVATION:
This EIP aims to provide users and developers with a single source of truth for understanding the various upgrade activation patterns used throughout Ethereum's history. It does not aim to be a comprehensive, ongoing record, of upgrades and their activations mechanism. Readers should assume that future upgrades use the

RATIONALE:
### Blocks and Epochs Blocks and epochs serve as natural trigger points for upgrades, as they represent the levels at which state transitions occur on Ethereum. ### Terminal Total Difficulty For the Terminal Total Difficulty mechanism, the rationale can be found in [EIP-3675](./eip-3675.md). ### Timestamps Due to the possibility


=== EIP-7623 ===
TITLE: Increase calldata cost
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-02-13
REQUIRES: 

SUMMARY:
The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB. This EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users. This is achieved by

SPECIFICATION:
| Parameter | Value | | - | - | | `STANDARD_TOKEN_COST` | `4` | | `TOTAL_COST_FLOOR_PER_TOKEN` | `10` | Let `tokens_in_calldata = zero_bytes_in_calldata + nonzero_bytes_in_calldata * 4`. Let `isContractCreation` be a boolean indicating the respective event. The current formula for determining the gas used per transaction, typically described

MOTIVATION:
The block gas limit has not been increased since [EIP-1559](./eip-1559.md), while the average size of blocks has continuously increased due to the growing number of rollups posting data to Ethereum. Moreover, calldata costs have remained unchanged since [EIP-2028](./eip-2028). [EIP-4844](./eip-4844.md) introduces blobs as a preferred method for data availability (DA).

RATIONALE:
The current maximum EL payload size is approximately 1.79 MB (`30_000_000/16`). It is possible to create payloads filled with zero bytes that expand to 7.15 MB. However, since blocks are typically compressed with Snappy at the P2P layer, zero-byte-heavy EL payloads generally compress to under 1.79 MB. The implementation


=== EIP-4863 ===
TITLE: Beacon chain push withdrawals
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-28
REQUIRES: 

SUMMARY:
Introduce a new [EIP-2718 transaction type](./eip-2718.md) to support validator withdrawals that are "pushed" from the beacon chain to the EVM. Add block validations to ensure the withdrawal transactions are sound with respect to withdrawal processing on the beacon chain.

SPECIFICATION:
| constants | value | units |--- |--- |--- | `FORK_TIMESTAMP` | TBD | | `WITHDRAWAL_TX_TYPE` | `0x3` | byte Beginning with the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** introduce the following extensions to transaction processing and block validation: ### New transaction type Define a new [EIP-2718](./eip-2718.md) transaction type

MOTIVATION:
This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM. The architecture is "push"-based, rather than "pull"-based, where withdrawals are required to be processed in the execution block as soon as they are dequeued from the beacon chain. This approach is

RATIONALE:
### Push vs pull approach This push approach gives validators a small subsidy with respect to processing, in lieu of needing to buy gas via normal EVM processing that would be required for a pull-based approach. This style also happens automatically when the requisite conditions are met on the


=== EIP-3338 ===
TITLE: Limit account nonce to 2^52
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-07
REQUIRES: 

SUMMARY:
Limit account nonce to be between `0` and `2^52`.

SPECIFICATION:
If `block.number >= FORK_BLOCK` introduce two new restrictions: 1. Consider any transaction invalid, where the nonce exceeds `2^52`. 2. The `CREATE` instruction to abort with an exceptional halt, where the account nonce is `2^52`.

MOTIVATION:
Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way. Additionally it could prove beneficial to transaction formats, where some improvements

RATIONALE:
1. It is unlikely for any nonce to reach or exceed the proposed limit. If one would want to reach that limit via external transactions, it would cost at least `21000 * (2^64-1) = 387_381_625_547_900_583_915_000` gas. 2. It must be noted that in the past, in the Morden testnet,


=== EIP-7790 ===
TITLE: Controlled Gas Limit Increase Guidelines
TYPE: Informational 
STATUS: Draft
CREATED: 2024-10-18
REQUIRES: 7783


=== EIP-3337 ===
TITLE: Frame pointer support for memory load and store operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-06
REQUIRES: 3336

SUMMARY:
This EIP introduces four new opcodes, `MLOADFP`, `MSTOREFP`, `GETFP` and `SETFP` that allow for more efficient memory access offset by a user-controlled quantity called the "frame pointer". This permits compilers to more efficiently offload ephemeral data such as local variables to memory instead of the EVM's evaluation stack, which

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. ### Frame pointer A new EVM internal state variable called the "frame pointer" is introduced. This is a signed integer that starts

MOTIVATION:
In most commonly used VMs, ephemeral data such as local variables, function arguments, and return addresses is stored in a region of memory called the stack. In contrast to the EVM's evaluation stack, this area of memory is randomly accessible, and thus can store an arbitrary amount of data,

RATIONALE:
### Cost of new opcodes The cost of the new opcodes `MLOADFP` and `MSTOREFP` reflects the cost of `MLOAD` and `MSTORE`. They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost. The cost of the new opcodes `SETFP` and `GETFP` is


=== EIP-4803 ===
TITLE: Limit transaction gas to a maximum of 2^63-1
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-02-02
REQUIRES: 

SUMMARY:
Limit transaction gas to be between `0` and `2^63-1`.

SPECIFICATION:
Introduce one new restriction retroactively from genesis: any transaction is invalid and not includeable in a block, where the gas limit exceeds `2^63-1`.

MOTIVATION:
The gas limit field in the transaction is specified to be an arbitrary long unsigned integer, but various clients put limits on this value. This EIP brings a reasonable limit into consensus.

RATIONALE:
### `2^63-1` vs `2^64-1` `2^63-1` is chosen because it allows representing the gas value as a signed integer, and so the out of gas check can be done as a simple "less than zero" check after subtraction. ### Consider `2^31-1` An alternative is considering a lower limit, because this


=== EIP-3300 ===
TITLE: Phase out refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-26
REQUIRES: 

SUMMARY:
This EIP would define a block when the `SSTORE` and `SELFDESTRUCT` refunds would begin to diminish. The refund would step linearly downward, eroding the implicit value of such refunds at an accelerating pace.

SPECIFICATION:
Parameters: * `FORK_BLOCK_NUM`: EIP-3300 activation block * `REFUND_DECAY_STEP`: 1 gas * `REFUND_DECAY_FREQUENCY`: 100 blocks Computed: * `REFUND_DECAY`: `REFUND_DECAY_STEP * ceil((block.number + 1 - FORK_BLOCK_NUM) / REFUND_DECAY_FREQUENCY)` On the block this EIP activates, and again every `REFUND_DECAY_FREQUENCY` blocks, all gas refunds, including `SELFDESTRUCT` and `SSTORE` would diminish by `REFUND_DECAY_STEP`, until

MOTIVATION:
Refunds increase block elasticity, so the block gas target can exceed the number established by miners by up to 2x. This can cause hesitancy for miners to increase the block gas target. Refunds, tokenized or not, are valuable to their holders, especially during congestion. If refunds must be removed,

RATIONALE:
Persisted refunds would become worthless before they fall below their activation cost. Once the refunds are worthless, they can be removed by another hard fork without waiting for 0. The rate of diminishing specified would currently require (24000-5000) * 100 = 1,900,000 blocks for `SELFDESTRUCT` and (15000-5000) * 100


=== EIP-140 ===
TITLE: REVERT instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-06
REQUIRES: 

SUMMARY:
The `REVERT` instruction will stop execution, roll back all state changes done so far and provide a pointer to a memory section, which can be interpreted as an error code or message. While doing so, it will not consume all the remaining gas.

SPECIFICATION:
On blocks with `block.number >= BYZANTIUM_FORK_BLKNUM`, the `REVERT` instruction is introduced at `0xfd`. It expects two stack items, the top item is the `memory_offset` followed by `memory_length`. It does not produce any stack elements because it stops execution. The semantics of `REVERT` with respect to memory and memory cost

MOTIVATION:
Currently this is not possible. There are two practical ways to revert a transaction from within a contract: running out of gas or executing an invalid instruction. Both of these options will consume all remaining gas. Additionally, reverting an EVM execution means that all changes, including LOGs, are lost


=== EIP-2593 ===
TITLE: Escalator fee market change for ETH 1.0 chain
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-03-13
REQUIRES: 

SUMMARY:
Based on [The Agoric Papers](https://agoric.com/papers/incentive-engineering-for-computational-resource-management/full-text/). Each transaction would have the option of providing parameters that specify an "escalating" bid, creating a time-based auction for validators to include that transaction. This creates highly efficient price discovery, where the price will always immediately fall to the highest bid price, which is

SPECIFICATION:
**Client-Wide Parameters** * `INITIAL_FORK_BLKNUM`: TBD **Transaction Parameters** The transaction `gasPrice` parameter is now optional, and if excluded can be replaced by these parameters instead: * `START_PRICE`: The lowest price that the user would like to pay for the transaction. * `START_TIME`: The first time that this transaction is valid

MOTIVATION:
Ethereum currently prices transaction fees using a simple first-price auction, which leads to well documented inefficiencies (some of which are documented in [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md)) when users are trying to estimate what price will get a transaction included in a block, especially during times of price volatility and full blocks. EIP


=== EIP-2539 ===
TITLE: BLS12-377 curve operations
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2020-02-26
REQUIRES: 1, 1, 0, 9, ,,  , 2, 0, 4, 6

SUMMARY:
This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary to *efficiently* perform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and

SPECIFICATION:
Curve parameters: BLS12-377 curve is fully defined by the following set of parameters (coefficient `A=0` for all BLS12 curves): ``` Base field modulus = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001 B coefficient = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 Main subgroup order = 0x12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001 Extension tower: Fp2 construction: Fp quadratic non-residue = 0x01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508bffffffffffc Fp6/Fp12 construction: Fp2 cubic non-residue c0

MOTIVATION:
Motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security. In addition it allows efficient one-time recursive proof aggregations, e.g. proofs about

RATIONALE:
Motivation section covers a total motivation to have operations over BLS12-377 curve available. We also extend a rationale for move specific fine points. ### Multiexponentiation as a separate call Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger


=== EIP-1682 ===
TITLE: Storage Rent
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-11-10
REQUIRES: 

SUMMARY:
This EIP describes a scheme to charge for data in state, and 'archive' data which is no longer being paid for. It also describes how resurrection of 'archived' data happens.

SPECIFICATION:
The cost of storing an account over time is called `rent`. The amount of `rent` due depends on the size of the account. The `ether` that is paid for `rent` is destroyed. The `rent` is deducted whenever an account is touched. `rent` can be paid from the account's regular

MOTIVATION:
The Ethereum blockchain in its current form is not sustainable because it grows indefinitely. This is true of any blockchain, but Ethereum grows faster than most chains. Many implementation strategies to slow down growth exist. A common strategy is 'state pruning' which discards historical state, keeping only the active

RATIONALE:
### Why do we need a separate rent balance? Accounts need a separate rent balance because some contracts are non-payable, i.e. they reject regular value transfers. Such contracts might not be able to keep themselves alive, but users of those contracts can keep them alive by paying rent for


=== EIP-7723 ===
TITLE: Network Upgrade Inclusion Stages
TYPE: Meta 
STATUS: Review
CREATED: 2024-06-12
REQUIRES: 

SUMMARY:
Define the stages that Core EIPs go through in the process of planning network upgrades: `Proposed for Inclusion`, `Considered for Inclusion`, `Scheduled for Inclusion`, `Declined for Inclusion` and `Included`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All EIP statuses defined in this EIP only apply within the context of a single

MOTIVATION:
This EIP proposes definitions for the various stages EIPs go through when planning network upgrades. Specifically, these are: `Proposed for Inclusion`, `Considered for Inclusion`, `Scheduled for Inclusion`, `Declined for Inclusion` and `Included`. It also provides context and guidelines around when and how EIPs should be moved from one stage

RATIONALE:
Formalizing the `Proposed for Inclusion`, `Considered for Inclusion`, `Scheduled for Inclusion`, `Declined for Inclusion` and `Included` stages provides better legibility to both Ethereum protocol maintainers and the community at large. The specification tries to minimize steps which **MUST** be followed to align with Ethereum's "rough consensus" governance model. Assuming


=== EIP-5806 ===
TITLE: Delegate transaction
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2022-10-20
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters - `FORK_BLKNUM` = `TBD` - `TX_TYPE` = TBD, > 0x03 ([EIP-4844](./eip-4844.md)) As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is

MOTIVATION:
EOA are the most widely used type of account, yet their ability to perform operations is limited to deploying contracts and sending "call" transactions. It is currently not possible for an EOA to execute arbitrary code, which greatly limits the interactions users can have with the blockchain. Account abstraction

RATIONALE:
EOAs are the most widely used type of wallet. This EIP would drastically expand the ability of EOAs to interact with smart contracts by using the pre-existing and well-understood delegation mechanism introduced in [EIP-7](./eip-7.md) and without adding new complexity to the EVM.


=== EIP-1051 ===
TITLE: Overflow checking for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.

SPECIFICATION:
Two new flags are added to the EVM state: overflow (`ovf`) and signed overflow (`sovf`). The `ovf` flag is set in the following circumstances: - When an `ADD` (`0x01`) opcode, with both inputs treated as unsigned integers, produces an ideal output in excess of 2^256 - 1. - When

MOTIVATION:
The correct functioning of many contracts today is dependent on detecting and preventing overflow of arithmetic operations. Since the EVM operates on mod 2^256 integers and provides no built-in overflow detection or prevention, this requires manual checks on every arithmetic operation. In the interests of facilitating efficient and secure

RATIONALE:
Any change to implement overflow protection needs to preserve behaviour of existing contracts, which precludes many changes to the arithmetic operations themselves. One option would be to provide an opcode that enables overflow protection, causing a throw or revert if an overflow happens. However, this limits the manner in


=== EIP-3855 ===
TITLE: PUSH0 instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-02-19
REQUIRES: 

SUMMARY:
Introduce the `PUSH0` (`0x5f`) instruction, which pushes the constant value 0 onto the stack.

SPECIFICATION:
The instruction `PUSH0` is introduced at `0x5f`. It has no immediate data, pops no items from the stack, and places a single item with the value 0 onto the stack. The cost of this instruction is 2 gas (aka `base`).

MOTIVATION:
Many instructions expect offsets as inputs, which in a number of cases are zero. A good example is the return data parameters of `CALLs`, which are set to zeroes in case the contract prefers using `RETURNDATA*`. This is only one example, but there are many other reasons why a

RATIONALE:
### Gas cost The `base` gas cost is used for instructions which place constant values onto the stack, such as `ADDRESS`, `ORIGIN`, and so forth. ### Opcode `0x5f` means it is in a "contiguous" space with the rest of the `PUSH` implementations and potentially could share the implementation.


=== EIP-3529 ===
TITLE: Reduction in refunds
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-04-22
REQUIRES: 2, 2, 0, 0, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `MAX_REFUND_QUOTIENT` | 5 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. 1. Remove the `SELFDESTRUCT` refund. 2. Replace `SSTORE_CLEARS_SCHEDULE` (as defined in [EIP-2200](./eip-2200.md)) with `SSTORE_RESET_GAS + ACCESS_LIST_STORAGE_KEY_COST` (4,800

MOTIVATION:
Gas refunds for `SSTORE` and `SELFDESTRUCT` were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, the benefits of this technique have proven to be far lower than anticipated, and gas refunds have

RATIONALE:
In [EIP-2200](./eip-2200.md#specification), three cases for refunds were introduced: 1. If the original value is nonzero, and the new value is zero, add `SSTORE_CLEARS_SCHEDULE` (currently 15,000) gas to the refund counter 2. If the original value is zero, the current value is nonzero, and the new value is zero, add


=== EIP-7716 ===
TITLE: Anti-correlation attestation penalties
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-25
REQUIRES: 

SUMMARY:
The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with

SPECIFICATION:
| Parameter | Value | | - | - | | `PENALTY_ADJUSTMENT_FACTOR` | `4096` | | `MAX_PENALTY_FACTOR` | `4` | Add a variable `NET_EXCESS_PENALTIES` to the beacon state. Let `penalty_factor` be determined through ``` min( (non_attesting_balance * PENALTY_ADJUSTMENT_FACTOR) // (NET_EXCESS_PENALTIES * total_active_balance + 1), MAX_PENALTY_FACTOR ) ``` Let `NET_EXCESS_PENALTIES`

MOTIVATION:
As of now, during times of usual network operation, there are no economic incentives to diversify node operations through using multiple different nodes, geographical locations, clients, ISP providers, etc., except for reducing the risk of penalties affecting all validators simultaneously, thereby limiting the impact to only a fraction of

RATIONALE:
### PENALTY_ADJUSTMENT_FACTOR This variable impacts the sensitivity of the `NET_EXCESS_PENALTIES`. Given stable participation, the `penalty_factor` is one. If participation decreases, the `penalty_factor` will temporarily increase above one until `net_excess_penalties` catches up. If participation increases, the `penalty_factor` will temporarily be zero until `net_excess_penalties` catches up. The `PENALTY_ADJUSTMENT_FACTOR` regulates how fast


=== EIP-7702 ===
TITLE: Set EOA account code
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-05-07
REQUIRES: 2, ,,  , 1, 6, 1, ,,  , 1, 0, 5, 2, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0, ,,  , 3, 5, 4, 1, ,,  , 3, 6, 0, 7, ,,  , 4, 8, 4, 4

SUMMARY:
Add a new transaction type that adds a list of `[chain_id, address, nonce, y_parity, r, s]` authorization tuples. For each tuple, write a delegation designator `(0xef0100 ++ address)` to the signing account's code. All code executing operations must load the code pointed to by the designator.

SPECIFICATION:
### Parameters | Parameter | Value | | ------------------------ | ------- | | `SET_CODE_TX_TYPE` | `0x04` | | `MAGIC` | `0x05` | | `PER_AUTH_BASE_COST` | `12500` | | `PER_EMPTY_ACCOUNT_COST` | `25000` | ### Set Code Transaction We introduce a new [EIP-2718](./eip-2718.md) transaction, "set code transaction", where the `TransactionType` is

MOTIVATION:
There is a lot of interest in adding short-term functionality improvements to EOAs, increasing the usability of applications and in some cases allowing improved security. Three particular applications include: * **Batching**: allowing multiple operations from the same user in one atomic transaction. One common example is an [ERC-20](./eip-20.md) approval

RATIONALE:
### Cost of Delegation The `PER_AUTH_BASE_COST` is the cost to process the authorization tuple and set the delegation destination. We are able to compute a fair cost for this operation by reviewing its impact on the system: * ferry 101 bytes of calldata = `101 * non-zero cost (16)


=== EIP-7637 ===
TITLE: Optimize EOA EXTCODEHASH
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-02-26
REQUIRES: 1052

SUMMARY:
This proposal is an optimization for [EIP-1052](./eip-1052.md), For addresses with a balance, but without code, the codehash should still be `0x`. When an address `add.code == 0x` and `add.balance != 0`, `add.codehash==0` is required instead of `add.codehash==keccak256("")`

SPECIFICATION:
The behaviour of `EXTCODEHASH` is changed in the following way: 1. When calling `EXTCODEHASH`, the codehash of the address with balance but no code is still `0x`

MOTIVATION:
EIP-1052 was proposed to save gas fees. However, due to some flaws in the set specifications, in actual applications, due to safety concerns, they will not actually be used. In order for EIP-1052 to be truly useful, it should be optimized. If someone uses it based on the proposal

RATIONALE:
EIP-1052 In order to include the function of `BALANCE`, let the `EXTCODEHASH` of the address without balance be `0x`, and the `EXTCODEHASH` of the address with balance be `keccak256("")`. The contract address can be calculated in advance. Whether it is `CREATE` or `CREATE2`, it is possible that the contract


=== EIP-7701 ===
TITLE: Native Account Abstraction with EOF
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-01
REQUIRES: 3540

SUMMARY:
This proposal describes a slight variation of the Native Account Abstraction design fully described in RIP-7560. This version's difference compared to the original proposal is in relying on features of "EVM Object Format" to distinguish between validation and execution code sections.

SPECIFICATION:
### Constants | Name | Value | |------------|-------| | AA_TX_TYPE | TBD | ### New Transaction Type A new [EIP-2718](./eip-2718) transaction with type `AA_TX_TYPE` is introduced. Transactions of this type are referred to as "AA transactions". The contents of such transactions are fully described in RIP-7560. ### System-level code

MOTIVATION:
Talking about Full Native Account Abstraction, the fundamental idea any solution has to address is a mechanism for a Smart Contract Account to separate its validation and execution code sections. RIP-7560 is build on the current Ethereum contract structure, and therefore has little choice but to rely on using

RATIONALE:
### ABI encoding for system frames' input and output data Using an ABI encoding format for data provided by the protocol itself does represent an abstraction levels violation, however it is a relatively safe one and any alternative solution would require some trade-offs. The validation section of a Smart


=== EIP-3076 ===
TITLE: Slashing Protection Interchange Format
TYPE: Standards Track Interface
STATUS: Last Call
CREATED: 2020-10-27
REQUIRES: 

SUMMARY:
A standard format for transferring a key's signing history allows validators to easily switch between clients without the risk of signing conflicting messages. While a common keystore format provides part of the solution, it does not contain any information about a key's signing history. For a validator moving their

SPECIFICATION:
### JSON Schema A valid interchange file is one that adheres to the following JSON schema, and is interpreted according to the [Conditions](#conditions). ```json { "title": "Signing history", "description": "This schema provides a record of the blocks and attestations signed by a set of validators", "type": "object", "properties": {

MOTIVATION:
The proof of stake (PoS) protocol penalises validators for voting in ways that could result in two different versions of the chain being finalised. These types of penalties are called slashings. For a validator following the protocol correctly, there is, in principle, no risk of being slashed. However, changing

RATIONALE:
### Supporting Different Strategies The interchange format is designed to be flexible enough to support the full variety of slashing protection strategies that clients may implement, which may be categorised into two main types: 1. **Complete**: a database containing every message signed by each validator. 2. **Minimal**: a database


=== EIP-1890 ===
TITLE: Commitment to Sustainable Ecosystem Funding
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-03-31
REQUIRES: 

SUMMARY:
A mechanism that allows specification of two parameters, a beneficiary address and a per-block reward denominated in wei, that allows a portion of block rewards to be captured for the purpose of ecosystem funding. Both values are set to zero.

SPECIFICATION:
Two new constants are introduced: BENEFICIARY_ADDRESS, an Address, and DEVFUND_BLOCK_REWARD, an amount denominated in wei. Both are set to zero. Beginning with block ISTANBUL_BLOCK_HEIGHT, DEVFUND_BLOCK_REWARD wei is added to the balance of BENEFICIARY_ADDRESS at each block. We may optionally add another constant, DECAY_FACTOR, which specifies a linear or exponenential

MOTIVATION:
In order for Ethereum to succeed, it needs talented, motivated researchers and developers to continue to develop and maintain the platform. Those talented researchers and developers deserve to be paid fairly for their work. At present there is no mechanism in the Ethereum ecosystem that rewards R&D teams fairly

RATIONALE:
We believe that the technical design of this EIP is straightforward. The social rationale is explained in [this article](https://medium.com/gitcoin/funding-open-source-in-the-blockchain-era-8ded753bf05f).


=== EIP-5345 ===
TITLE: Silent Signing Extension for JSON-RPC
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-07-26
REQUIRES: 

SUMMARY:
Mobile applications supporting lots of transactions might become a source of bad user experience due to uncontrolled switching between the wallet's and application's UI. By this proposal, we would like to introduce the means to sign and send wallet transactions without the need for user participation. This feature can

SPECIFICATION:
To remedy the situation, we'd like to introduce new RPC methods for the ethereum JSON-RPC. Those methods help enable wallets to implement the Silent Signing feature. ### Silent Signing User Flow The Silent Signing process has the following structure: 1. First, the application requests the wallet to use Silent

MOTIVATION:
Some blockchain applications interact with a blockchain much more frequently than others. It is especially true for gaming applications having their own sidechains. Interrupting the gaming process and switching to the wallet to perform a transaction drastically affect the user experience.

RATIONALE:
Games and Metaverse applications imply lots of cases when the user interacts with the wallet, switching to it and approving transactions. This switching aspect might interfere with gaming per se and create a bad user experience. That is why such applications can benefit if the wallets can support the


=== EIP-2242 ===
TITLE: Transaction Postdata
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-08-16
REQUIRES: 

SUMMARY:
A paradigm shift in how blockchains are used has been seen recently in Eth 2.0, with the rise of [_Execution Environments_](https://notes.ethereum.org/w1Pn2iMmSTqCmVUTGV4T5A?view) (EEs), and [_stateless clients_](https://ethresear.ch/t/the-stateless-client-concept/172). This shift involves blockchains serving as a secure data availability and arbitration layer, _i.e._, they provide a globally-accepted source of available data, and process

SPECIFICATION:
We propose a consensus modification, beginning at `FORK_BLKNUM`: An additional optional field, `postdata`, is added to transactions. Serialized transactions now have the format: ``` "from": bytes20, "to": bytes20, "startGas": uint256, "gasPrice": uint256, "value": uint256, "data": bytes, "nonce": uint256, ["postdata": bytes], ``` with witnesses signing over the [RLP encoding](https://github.com/ethereum/wiki/wiki/RLP) of

MOTIVATION:
While [EIP-2028](./eip-2028.md) provides a reduction in gas cost of calldata, and is a step in the right direction of encouraging use of history rather than state, the EVM does not actually need to see all data that is posted on-chain. Following the principle of "don't pay for what you

RATIONALE:
The changes proposed are as minimal and non-disruptive to the existing EVM and transaction format as possible while also supporting possible [future extensions](https://ethresear.ch/t/multi-threaded-data-availability-on-eth-1/5899) through a version code.


=== EIP-7549 ===
TITLE: Move committee index outside Attestation
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-11-01
REQUIRES: 

SUMMARY:
Move the committee `index` field outside of the signed Attestation message to allow aggregation of equal consensus votes.

SPECIFICATION:
### Execution layer This requires no changes to the Execution Layer. ### Consensus layer - Set `index` field from `AttestationData` to fixed value of zero - Move committee indexing data to the outter `Attestation` container with `committee_bits` - Increase the capacity of `aggregation_bits` to all committees in a slot

MOTIVATION:
This proposal aims to make Casper FFG clients more efficient by reducing the average number of pairings needed to verify consensus rules. While all types of clients can benefit from this EIP, ZK circuits proving Casper FFG consensus are likely to have the most impact. On a beacon chain

RATIONALE:
### Deprecation strategy The `index` field in `AttestationData` can be deprecated by: 1. Removing the field 2. Preserving the field and setting it to be zero 3. Changing the field type to Optional (from [EIP-7495](./eip-7495.md) StableContainer) This EIP chooses the second option to not complicate the inclusion of `AttesterSlashing`


=== EIP-2997 ===
TITLE: IMPERSONATECALL Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-24
REQUIRES: 

SUMMARY:
Add a new opcode, `IMPERSONATECALL` at `0xf6`, which is similar in idea to `CALL (0xF1)`, except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.

SPECIFICATION:
`IMPERSONATECALL`: `0xf6`, takes 7 operands: - `gas`: the amount of gas the code may use in order to execute; - `to`: the destination address whose code is to be executed; - `in_offset`: the offset into memory of the input; - `in_size`: the size of the input in bytes; -

MOTIVATION:
This proposal enables native multi-user wallets (wallets that serve multiple users) that can be commanded by EIP-712 based messages and therefore enable meta-transactions. Multi-user wallets also enable the aggregation of transfer operations in batches similar to rollups, but maintaining the same address space as normal onchain transactions, so the

RATIONALE:
Even if `IMPERSONATECALL` requires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn't not compensate increasing the complexity of the implementation. We use the zeros32 field to base address derivation in a pre-image of similar size than CREATE2 and


=== EIP-7667 ===
TITLE: Raise gas costs of hash functions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Raise the gas costs of opcodes and precompiles that involve hash functions.

SPECIFICATION:
| Parameter | Previous value | New value | | - | - | - | | `KECCAK_BASE_COST` | 30 | 300 | | `KECCAK_WORD_COST` | 6 | 60 | | `SHA256_BASE_COST` | 60 | 300 | | `SHA256_WORD_COST` | 12 | 60 | | `RIPEMD_BASE_COST` | 600 |

MOTIVATION:
Gas costs for hash function opcodes and precompiles were originally set based on the time that it takes to execute them on a regular CPU. Since then, however, there has emerged another equally important execution substrate that the EVM is executed on: zero knowledge proof (ZK-SNARK) systems. By that

RATIONALE:
The above increases the gas costs of all opcodes and precompiles that can be used to require large amounts of hashing in the EVM. All hashing costs are increased to 300 per hash plus 60 per word (or kept the same if they are already higher than this). '"


=== EIP-627 ===
TITLE: Whisper Specification
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-05-05
REQUIRES: 

SUMMARY:
This EIP describes the format of Whisper messages within the ÐΞVp2p Wire Protocol. This EIP should substitute the [existing specification](https://github.com/ethereum/wiki/wiki/Whisper-Wire-Protocol). More detailed documentation on Whisper could be found [here](https://github.com/ethereum/go-ethereum/wiki/Whisper).

SPECIFICATION:
All Whisper messages sent as ÐΞVp2p Wire Protocol packets should be RLP-encoded arrays of data containing two objects: integer packet code followed by another object (whose type depends on the packet code). If Whisper node does not support a particular packet code, it should just ignore the packet without

MOTIVATION:
It is necessary to specify the standard for Whisper messages in order to ensure forward compatibility of different Whisper clients.

RATIONALE:
Packet codes 0x00 and 0x01 are already used in all Whisper versions. Packet code 0x02 will be necessary for the future development of Whisper. It will provide possiblitity to adjust the PoW requirement in real time. It is better to allow the network to govern itself, rather than hardcode


=== EIP-101 ===
TITLE: Serenity Currency and Crypto Abstraction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2015-11-15
REQUIRES: 

SPECIFICATION:
1. Accounts now have only two fields in their RLP encoding: **code** and **storage**. 2. Ether is no longer stored in account objects directly; instead, at address `0`, we premine a contract which contains all ether holdings. The `eth.getBalance` command in web3 is remapped appropriately. 3. `msg.value` no longer

RATIONALE:
This allows for a large increase in generality, particularly in a few areas: 1. Cryptographic algorithms used to secure accounts (we could reasonably say that Ethereum is quantum-safe, as one is perfectly free to secure one's account with Lamport signatures). The nonce-incrementing approach is now also open to revision


=== EIP-1930 ===
TITLE: CALLs with strict gas semantic. Revert if not enough gas available.
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-10
REQUIRES: 

SUMMARY:
The current CALL, DELEGATE_CALL, STATIC_CALL opcode do not enforce the gas being sent, they simply consider the gas value as a maximum. This pose serious problem for applications that require the call to be executed with a precise amount of gas. This is for example the case for meta-transaction

SPECIFICATION:
There are 2 possibilities a) one is to add opcode variant that have a stricter gas semantic b) The other is to consider a specific gas value range (one that have never been used before) to have strict gas semantic, while leaving other values as before Here are the

RATIONALE:
Currently the gas specified as part of these opcodes is simply a maximum value. And due to the behavior of [EIP-150](./eip-150.md) it is possible for an external call to be given less gas than intended (less than the gas specified as part of the CALL) while the rest of


=== EIP-7516 ===
TITLE: BLOBBASEFEE instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-09-11
REQUIRES: 3, 1, 9, 8, ,,  , 4, 8, 4, 4

SUMMARY:
Add a `BLOBBASEFEE (0x4a)` instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical to [EIP-3198](./eip-3198.md) (`BASEFEE` opcode) except that it returns the blob base-fee as per [EIP-4844](./eip-4844.md).

SPECIFICATION:
Add a `BLOBBASEFEE` instruction with opcode `0x4a`, with gas cost `2`. | Op | Input | Output | Cost | |------|-------|--------|------| | 0x4a | 0 | 1 | 2 | `BLOBBASEFEE` returns the result of the `get_blob_gasprice(header) -> int` function as defined in [EIP-4844 §Gas accounting](./eip-4844.md#gas-accounting).

MOTIVATION:
The intended use case would be for contracts to get the value of the blob base-fee. This feature enables blob-data users to programmatically account for the blob gas price, eg: - Allow rollup contracts to trustlessly account for blob data usage costs. - Blob gas futures can be implemented

RATIONALE:
### Gas cost The value of the blob base-fee is needed to process data-blob transactions. That means its value is already available before running the EVM code. The instruction does not add extra complexity and additional read/write operations, hence the choice of `2` gas cost. This is also identical


=== EIP-3046 ===
TITLE: Adds `baseFee` to `eth_getUncleByBlockNumberAndIndex`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getUncleByBlockNumberAndIndex` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getUncleByBlockNumberAndIndex` #### Description Returns information about an uncle specified by block number and uncle index position Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-7519 ===
TITLE: Atomic Storage Operations SCREDIT and SDEBIT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-09-16
REQUIRES: 2, 2, 0, 0, ,,  , 2, 9, 2, 9

SUMMARY:
Two new opcodes that atomically mutate smart contract storage are proposed: SCREDIT, which increments a storage slot by a specified value, and SDEBIT, which decrements a storage slot by a specified value. Overflow and underflow errors are enforced, reverting when an unsigned 256-bit integer would overflow or underflow.

SPECIFICATION:
Two operations to atomically increment and decrement a storage will be introduced at `0xTBD`. Each operation takes two stack arguments and has no immediate arguments. Gas schedule will be the same as SSTORE. | Mnemonic | Op | Input | Output | |-----------|-----------|-------|--------| | `SCREDIT` | `0xTBD` | `2`

MOTIVATION:
There has been a large amount of energy around parallel EVMs across multiple chains, however there is a lack of parallel primitives within the EVM to support any model other than optimistic concurrency control (OCC). By adding concurrent increment and decrement operations more advanced parallel environments can be introduced

RATIONALE:
The primary consideration when choosing between alternatives is that the primary intended audiences is token contracts and other asset-tracking contracts combined with a desire to ship the minimum necessary changes to enable that use case. General concurrency controls is not a goal of this EIP. ### Enforcing Overflow Semantics


=== EIP-3416 ===
TITLE: Median Gas Premium
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-18
REQUIRES: 

SUMMARY:
There is a base fee per gas in protocol, which can move up or down by a maximum of 1/8 in each block. The base fee per gas is adjusted by the protocol to target an average gas usage per block instead of an absolute gas usage per block.

SPECIFICATION:
### Definitions This is a classic fork without a long migration time. * `FORK_BLOCK_NUMBER`: TBD. Block number at or after which EIP-3416 transactions are valid. * `GAS_TARGET_MAX_CHANGE`: `1 // 1024`. * `BLOCK_GAS_USED`: total gas consumed by transaction included in the block. * `PARENT_GAS_USED`: same as `BLOCK_GAS_USED` for parent block.

MOTIVATION:
We target the following goals: * Gas prices spikes are mathematically smoothed out. EIP1559 does not seems to really tackle gas premium volatility and UX. * Maintain gas price preference, i.e. transaction senders willing to pay extra in fees will be rewarded with early preferential inclusion in the blocks,


=== EIP-5081 ===
TITLE: Expirable Trainsaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-05-06
REQUIRES: 1, 5, 5, ,,  , 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
This EIP adds a new transaction type of that includes expiration with a blocknum.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters - `FORK_BLKNUM` = `TBD` - `CHAIN_ID` = `TBD` - `TX_TYPE` = TBD, > 0x02 ([EIP-1559](./eip-1559.md)) As of `FORK_BLOCK_NUMBER`,

MOTIVATION:
When a user sends a transaction `tx0` with a low gas price, sometimes it might not be high enough to be executed. A common resolution is for the user to submit the transaction again with the same nonce and higher gas price. That previous `tx0` can theoretically be included

RATIONALE:
TODO


=== EIP-6465 ===
TITLE: SSZ withdrawals root
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-08
REQUIRES: 2, 7, 1, 8, ,,  , 4, 8, 9, 5, ,,  , 6, 4, 0, 4

SUMMARY:
This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated

MOTIVATION:
While the consensus `ExecutionPayloadHeader` and the execution block header map to each other conceptually, they are encoded differently. This EIP aims to align the encoding of the `withdrawals_root`, taking advantage of the more modern SSZ format. This brings several advantages: 1. **Reducing complexity:** The proposed design reduces the number

RATIONALE:
This change was originally a candidate for inclusion in Shanghai, but was postponed to accelerate the rollout of withdrawals. ### Why typed withdrawal envelopes? The RLPx serialization layer may not be aware of the fork schedule and the block timestamp when withdrawals are exchanged. The typed withdrawal envelope assists


=== EIP-7713 ===
TITLE: Box type for EIP-712 messages
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2024-05-23
REQUIRES: 712

SUMMARY:
This EIP defines a new type `box` for use in [EIP-712](./eip-712.md) messages. A `box` value is a value of an arbitrary struct type whose underlying type is encapsulated and hidden from the outer struct but transparent and type-checkable by the wallet, and thus able to be fully inspected by

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. EIP-712 is extended as follows: ### Typed structured data A struct type may contain a

MOTIVATION:
EIP-712 signatures have become a widely used primitive for users to express and authorize intents off-chain. Wide-ranging applications are able to define parameterized messages for users to sign in their wallet through a general-purpose interface that clearly surfaces the type, parameters, and domain of authorization. This crucially applies to

RATIONALE:
TBD <!-- TODO -->


=== EIP-7645 ===
TITLE: Alias ORIGIN to SENDER
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-03
REQUIRES: 

SUMMARY:
This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. This EIP proposes the alteration of the behavior of the ORIGIN opcode within the Ethereum

MOTIVATION:
The ORIGIN opcode in Ethereum returns the address of the account that started the transaction chain, differing from the SENDER (or CALLER) opcode, which returns the address of the direct caller. The use of ORIGIN has been discouraged and deemed deprecated since mid-2016 due to the security problems it

RATIONALE:
The rationale behind aliasing ORIGIN to SENDER is to: Facilitate Account Abstraction: Elegantly nullify a universal barrier to account abstraction, enabling more flexible and powerful account models in Ethereum. Enhance Security: Eliminate the security vulnerabilities associated with differentiating between the original transaction initiator and the immediate caller. Clean up


=== EIP-3534 ===
TITLE: Restricted Chain Context Type Transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-20
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new EIP-2718 transaction type with the format `0x4 || rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`. This proposed `chainContext` element adds a constraint on the validity of a transaction to a chain segment meeting the referenced value(s). Four contexts are defined

SPECIFICATION:
### Parameters - `FORK_BLOCK_NUMBER` `TBD` - `TRANSACTION_TYPE_NUMBER` `0x4`. See EIP-2718. As of `FORK_BLOCK_NUMBER`, a new EIP-2718 transaction is introduced with `TransactionType` `TRANSACTION_TYPE_NUMBER`. The EIP-2718 `TransactionPayload` for this transaction is `rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`. The EIP-2718 `ReceiptPayload` for this transaction is `rlp([status,

MOTIVATION:
Establish a protocol-based mechanism with which transactions are able to articulate constraints on eligible chain contexts. Generally, these constraints give the consumer (the transactor) an ability to express requirements about the transaction's relationship to blockchain data and its provenance. - Restrict transaction applicability to a chain context that is

RATIONALE:
### Subclasses Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP. Their specification definitions allow arbitrary mutual (`AND`) combinations. This design is intended to form a proposal which offers a concrete set of specifics while doing so with


=== EIP-7377 ===
TITLE: Migration Transaction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-21
REQUIRES: 1, 7, 0, ,,  , 1, 5, 5, 9, ,,  , 2, 2, 0, 0, ,,  , 2, 7, 1, 8

SUMMARY:
Introduce a new [EIP-2718](./eip-2718.md) transaction type with the format `0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])` which sets the sending account's `code` field in the state trie to the `code` value at `codeAddr` and applies the storage tuples to the sender's

SPECIFICATION:
At the fork block `X`, introduce the migration transaction type. ### Migration Transaction #### Definition | field | type | |------------------------|-----------| | `chainId` | `uint256` | | `nonce` | `uint64` | | `maxFeePerGas` | `uint256` | | `maxPriorityFeePerGas` | `uint256` | | `gasLimit` | `uint64` | | `codeAddr` |

MOTIVATION:
Smart contract wallets have long been touted as the solution to Ethereum's user experience woes. As early as 2015, there were proposals for allowing smart contracts to originate transactions in hopes that new users would flock to smart contract wallets to store their assets. So far, only a fraction

RATIONALE:
### No `to` address field This transaction is only good for one-time use to migrate an EOA to a smart contract. It is designed to immediately call the deployed contract, which is at the sender's address, after deployment to allow the sender to do any kind of further processing.


=== EIP-1193 ===
TITLE: Ethereum Provider JavaScript API
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2018-06-30
REQUIRES: 1, 5, 5, ,,  , 6, 9, 5

SUMMARY:
A common convention in the Ethereum web application ("dapp") ecosystem is for key management software ("wallets") to expose their API via a JavaScript object in the web page. This object is called "the Provider". Historically, Provider implementations have exhibited conflicting interfaces and behaviors between wallets. This EIP formalizes an

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). > Comments like this are non-normative. ### Definitions _This section is non-normative._ - Provider - A JavaScript object made available to

RATIONALE:
The purpose of a Provider is to _provide_ a consumer with access to Ethereum. In general, a Provider must enable an Ethereum web application to do two things: - Make Ethereum RPC requests - Respond to state changes in the Provider's Ethereum chain, Client, and Wallet The Provider API


=== EIP-7742 ===
TITLE: Uncouple blob count between CL and EL
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-07-12
REQUIRES: 4844

SUMMARY:
Update blob maximum and target verification from [EIP-4844](./eip-4844.md). The execution layer no longer verifies the blob maximum and receives the target dynamically from the consensus layer.

SPECIFICATION:
### Block structure and validity Upon activation of this EIP, execution clients **MUST** extend the header schema with an additional 64-bit field: the `target_blobs_per_block`. This value is set to the current target blob count. The Engine API is modified along with this EIP to provide the `target_blobs_per_block` with each

MOTIVATION:
Following EIP-4844, the execution layer (EL) maintains a hard-coded blob target value and blob maximum value. Given the relationship of the EL and the consensus layer (CL) node software, the verification of the blob maximum is redundant so it can be removed entirely without any change in security. The

RATIONALE:
### Why not have the CL also compute the blob base fee and remove any notion of blob counts from EL processing? Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack. The CL


=== EIP-6466 ===
TITLE: SSZ receipts
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-08
REQUIRES: 6, 5, 8, ,,  , 2, 7, 1, 8, ,,  , 6, 4, 0, 4, ,,  , 7, 7, 0, 2

SUMMARY:
This EIP defines a migration process of [EIP-2718](./eip-2718.md) Recursive-Length Prefix (RLP) receipts to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md)

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated

MOTIVATION:
RLP receipts have a number of shortcomings: 1. **Limited proving support:** Due to receipt data being linearly hashed as part of the `receipts_root` Merkle-Patricia Trie (MPT), it is not possible to efficiently proof individual parts of receipts, such as logs. Requiring the full receipt data to be present can

RATIONALE:
Switching to a single, unified and forward compatible receipt format within execution blocks reduces implementation complexity for client applications and smart contracts. Individual chunks of receipt data can now be verified, simplifying implementation of bridges. Light clients can now efficiently verify a receipt's `from`, `gas_used`, and `authorities`, which previously


=== EIP-1829 ===
TITLE: Precompile for Elliptic Curve Linear Combinations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-03-06
REQUIRES: 

SUMMARY:
A precompile that takes a curve and computes a linear combination of curve points.

SPECIFICATION:
Given integers `m, α` and `β`, scalars `s_i`, and curve points `A_i` construct the elliptic curve ``` y² = x³ + α ⋅ x + β mod m ``` and compute the following ``` C = s₀ ⋅ A₀ + s₁ ⋅ A₁ + ⋯ + s_n ⋅ A_n

RATIONALE:
**Generic Field and Curve.** Many important optimizations are independent of the field and curve used. Some missed specific optimizations are: * Reductions specific to the binary structure of the field prime. * Precomputation of Montgomery factors. * Precomputation of multiples of certain popular points like the generator. * Special


=== EIP-3091 ===
TITLE: Block Explorer API Routes
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-11-02
REQUIRES: 

SUMMARY:
This proposal brings standardization between block explorers API routes when linking transactions, blocks, accounts and tokens.

SPECIFICATION:
Block explorers will route their webpages accordingly for the following data: ### Blocks `<BLOCK_EXPLORER_URL>/block/<BLOCK_HASH_OR_HEIGHT>` ### Transactions `<BLOCK_EXPLORER_URL>/tx/<TX_HASH>` ### Accounts `<BLOCK_EXPLORER_URL>/address/<ACCOUNT_ADDRESS>` ### Tokens `<BLOCK_EXPLORER_URL>/token/<TOKEN_ADDRESS>`

MOTIVATION:
Currently wallets and dapps link transactions and accounts to block explorer web pages but as chain diversity and layer two solutions grow it becomes harder to maintain a consistent user experience. Adding new chains or layer two solutions becomes harder given these endpoints are inconsistent. Standardizing the API routes

RATIONALE:
The particular paths used in this proposal are chosen to be compatible with the majority of existing block explorers.


=== EIP-7709 ===
TITLE: Read BLOCKHASH from storage and update cost
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-18
REQUIRES: 2935

SUMMARY:
Update the `BLOCKHASH (0x40)` opcode to read and serve from the system contract storage and charge the **additional** (cold or warm) storage costs.

SPECIFICATION:
| Parameter | Value | | ------------------------- | ------ | | `FORK_TIMESTAMP` | TBD | | `HISTORY_STORAGE_ADDRESS` | TBD | | `BLOCKHASH_SERVE_WINDOW` | `256` | The `BLOCKHASH` opcode semantics remains the same as before. From the `fork_block` (defined as `fork_block.timestamp >= FORK_TIMESTAMP and fork_block.parent.timestamp < FORK_TIMESTAMP`), the `BLOCKHASH` instruction

MOTIVATION:
The `BLOCKHASH (0x40)` opcode currently assumes that the client has knowledge of the previous blocks, which in Verkle [EIP-6800](./eip-6800.md) would prevent stateless execution. However with [EIP-2935](./eip-2935.md) blockhashes can be retrieved and served from its system contract storage which allows Verkle blocks to include a storage access witness for stateless

RATIONALE:
* The reason behind the updated gas cost is to match the real operation, which is equivalent to an `SLOAD`. * The [EIP-2935](./eip-2935.md) system contract execution charges (and accesses) are not applied to keep the gas low and to keep things simple for clients which choose to resolve `BLOCKHASH`


=== EIP-1283 ===
TITLE: Net gas metering for SSTORE without dirty maps
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
This EIP proposes net gas metering changes for `SSTORE` opcode, enabling new usages for contract storage, and reducing excessive gas costs where it doesn't match how most implementation works. This acts as an alternative for EIP-1087, where it tries to be friendlier to implementations that use different optimization strategies

SPECIFICATION:
Definitions of terms are as below: * *Storage slot's original value*: This is the value of the storage if a reversion happens on the *current transaction*. * *Storage slot's current value*: This is the value of the storage before SSTORE operation happens. * *Storage slot's new value*: This is

MOTIVATION:
This EIP proposes a way for gas metering on SSTORE (as an alternative for EIP-1087 and EIP-1153), using information that is more universally available to most implementations, and require as little change in implementation structures as possible. * *Storage slot's original value*. * *Storage slot's current value*. * Refund

RATIONALE:
This EIP mostly achieves what a transient storage tries to do (EIP-1087 and EIP-1153), but without the complexity of introducing the concept of "dirty maps", or an extra storage struct. * We don't suffer from the optimization limitation of EIP-1087. EIP-1087 requires keeping a dirty map for storage changes,


=== EIP-145 ===
TITLE: Bitwise shifting instructions in EVM
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.

SPECIFICATION:
The following instructions are introduced: ### `0x1b`: `SHL` (shift left) The `SHL` instruction (shift left) pops 2 values from the stack, first `arg1` and then `arg2`, and pushes on the stack `arg2` shifted to the left by `arg1` number of bits. The result is equal to ``` (arg2 *

MOTIVATION:
EVM is lacking bitwise shifting operators, but supports other logical and arithmetic operators. Shift operations can be implemented via arithmetic operators, but that has a higher cost and requires more processing time from the host. Implementing `SHL` and `SHR` using arithmetic cost each 35 gas, while the proposed instructions

RATIONALE:
Instruction operands were chosen to fit the more natural use case of shifting a value already on the stack. This means the operand order is swapped compared to most arithmetic instructions.


=== EIP-649 ===
TITLE: Metropolis Difficulty Bomb Delay and Block Reward Reduction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-06-21
REQUIRES: 

SUMMARY:
Starting with `BYZANTIUM_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 3 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 3 ETH, uncle

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 3_000_000) if block.number >= BYZANTIUM_FORK_BLKNUM else block.number #### Adjust Block, Uncle, and Nephew rewards To

MOTIVATION:
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another one and a half years. With the delay of the ice age, there is a desire to not suddenly also

RATIONALE:
This will delay the ice age by 42 million seconds (approximately 1.4 years), so the chain would be back at 30 second block times at the end of 2018. An alternate proposal was to add special rules to the difficulty calculation to effectively _pause_ the difficulty between different blocks.


=== EIP-2378 ===
TITLE: EIPs Eligible for Inclusion
TYPE: Meta 
STATUS: Stagnant
CREATED: 2019-11-13
REQUIRES: 

SUMMARY:
The pipeline for Core EIPs, per the EIP-Centric upgrade model, is as follows. ``` [ DRAFT ] -> [ ELLIGLE FOR INCLUSION ] -> [ IMPLEMENTATION ] -> [ TESTING ] -> [ ACCEPTED ] -> [ DEPLOYED ] ``` This EIP documents all EIPs marked as **Eligible For

SPECIFICATION:
| EIP | Title | Pipeline Status | Date of Initial Decision | REF | | -------- | ----------------------------------------------------- | -------- | ---------- | ---- | | EIP-663 | Unlimited SWAP and DUP instructions | ELIGIBLE | 2019-11-01 | [🔗](https://github.com/ethereum/pm/blob/master/All%20Core%20Devs%20Meetings/Meeting%2074.md) | | EIP-1057 | ProgPoW, a Programmatic Proof-of-Work |

MOTIVATION:
Development of clear specifications and pull requests to existing Ethereum Clients is a large investment of time and resources. The state of *Eligible for Inclusion* is a signal from the Ethereum Core Developers to an EIP Author validiating the idea behind an EIP and confirms investing their time further

RATIONALE:
**EIP Number** **Title** **Pipeline Status** : Show the current status in the context of the EIP centric model. The list is sorted by furthest along in the process. **Date of Initial Decision** : Date of the initial decision for Eligibility for Inclusion **REF** : Link to the decision on


=== EIP-1013 ===
TITLE: Hardfork Meta: Constantinople
TYPE: Meta 
STATUS: Final
CREATED: 2018-04-20
REQUIRES: 1, 4, 5, ,,  , 6, 0, 9, ,,  , 1, 0, 1, 4, ,,  , 1, 0, 5, 2, ,,  , 1, 2, 3, 4, ,,  , 1, 2, 8, 3

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Constantinople.

SPECIFICATION:
- Codename: Constantinople - Aliases: Metropolis/Constantinople, Metropolis part 2 - Activation: - `Block >= 7_280_000` on the Ethereum Mainnet - `Block >= 4,230,000` on the Ropsten testnet - `Block >= 9_200_000` on the Kovan testnet - `Block >= 3_660_663` on the Rinkeby testnet - Included EIPs: - [EIP-145](./eip-145.md): Bitwise


=== EIP-1679 ===
TITLE: Hardfork Meta: Istanbul
TYPE: Meta 
STATUS: Final
CREATED: 2019-01-04
REQUIRES: 1, 5, 2, ,,  , 1, 1, 0, 8, ,,  , 1, 3, 4, 4, ,,  , 1, 7, 1, 6, ,,  , 1, 8, 8, 4, ,,  , 2, 0, 2, 8, ,,  , 2, 2, 0, 0

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Istanbul.

SPECIFICATION:
- Codename: Istanbul ### Activation - `Block >= 9,069,000` on the Ethereum Mainnet - `Block >= 6,485,846` on the Ropsten testnet - `Block >= 14,111,141` on the Kovan testnet - `Block >= 5,435,345` on the Rinkeby testnet - `Block >= 1,561,651` on the Görli testnet ### Included EIPs -


=== EIP-2256 ===
TITLE: wallet_getOwnedAssets JSON-RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-08-29
REQUIRES: 5, 5, ,,  , 1, 5, 5, ,,  , 1, 4, 7, 4

SUMMARY:
There is no standardized way for a dApp to request a list of owned assets from a user. Now, each dApp needs to keep a list of all the popular or existing assets and check the user's balance against the blockchain, for each of these assets. This leads to

SPECIFICATION:
New JSON-RPC method to be added to web3 browsers: `wallet_getOwnedAssets`. This method is for dApp-wallet communication and only targets the assets that have already been whitelisted by the wallet, for the user account. **Arguments:** - type `address`, Ethereum address that owns the assets - options object, optional: - `chainId`

MOTIVATION:
There are financial dApps that require a list of owned assets from a user, for various purposes - calculating taxes, selecting customized payment options, etc. Each of these dApps are now forced to keep a list of popular assets (smart contract addresses, ABIs) and retrieve the user's data from

RATIONALE:
In order to avoid duplication of effort for dApps that require keeping a list of all or popular assets and to provide optimal UX, the `wallet_getOwnedAssets` JSON-RPC method is proposed. The `chainId` and `types` optional parameters enable dApps to provide options in order to restrict the selection list that


=== EIP-4736 ===
TITLE: Consensus Layer Withdrawal Protection
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-01-30
REQUIRES: 

SUMMARY:
If a consensus layer mnemonic phrase is compromised, it is impossible for the consensus layer network to differentiate the legitimate holder of the key from an illegitimate holder. However, there are signals that can be considered in a wider sense without changing core Ethereum consensus. This proposal outlines ways

SPECIFICATION:
The Consensus Layer `BLSToExecutionChange` operation has the following fields: * Validator index * Current withdrawal BLS public key * Proposed execution layer withdrawal address * Signature by withdrawal private key over the prior fields This proposal describes OPTIONAL and RECOMMENDED mechanisms which a client beacon node MAY implement, and

MOTIVATION:
The consensus layer `BLSToExecutionChange` message is secure for a single user who has certainty their keys and mnemonic have not been compromised. However, as validator withdrawals on the consensus layer are not possible until the Capella hard fork, no user can have absolute certainty that their keys are not

RATIONALE:
This proposal is intended to protect legitimate validator mnemonic holders where it was knowingly or unknowingly compromised. As there is no safe way to transfer ownership of a validator without exiting, it can safely be assumed that all validator holders intend to set to a withdrawal address they specify.


=== EIP-1895 ===
TITLE: Support for an Elliptic Curve Cycle
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-03-31
REQUIRES: 

SUMMARY:
Adds supports for the following operations through precompiles: * `ecadd` on MNT4 * `ecmul` on MNT4 * `ecpairing` on MNT4

SPECIFICATION:
### The curve The proposed cycle has been introduced in [Scalable Zero Knowledge via Cycles of Elliptic Curves](https://eprint.iacr.org/2014/595.pdf). ### MNT4 definition The groups `G_1` and `G_2` are cyclic groups of prime order : ```. q = 475922286169261325753349249653048451545124878552823515553267735739164647307408490559963137 ``` `G_1` is defined over the field `F_p` of prime order :

MOTIVATION:
Elliptic curve is the basic block of recursive SNARKs (ie: verifying a SNARK inside a SNARK) and this addresses the issue of scalable zero-knowledge. More generally this addresses partly the scalability issue as SNARKs verification are constant time in the size of the circuit being verified. More concretely, today

RATIONALE:
The curve has 80 bits of security (whereas MNT6 has 120 bits) which might not be considered enough for critical security level, (for instance transferring several billions), but enough for others. If it turns out this is not enough security for adoption, there is another option : another cycle


=== EIP-7819 ===
TITLE: Create delegate
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-18
REQUIRES: 7, 6, 9, 2, ,,  , 7, 7, 0, 2

SUMMARY:
Introduce a new EVM instruction to [EOF](./eip-7692.md) that allows smart contracts to create (and update) delegation accounts that match [EIP-7702](./eip-7702.md)'s design. These accounts can be used similarly to [ERC-1167](./eip-1167.md) clones, with significant advantages.

SPECIFICATION:
A new instruction (`CREATE_DELEGATE`) is added to EOF at `0xf6`. This instruction is NOT added to legacy EVM. ### Behavior Executing this instruction does the following: 1. deduct `EMPTY_ACCOUNT_COST` gas 2. halt if the current frame is in `static-mode` 3. pop `salt`, `target` from the operand stack 4. calculate

MOTIVATION:
Many on-chain applications involve creating multiple instances of the same code at different locations. These applications often rely on clones, or proxies, to reduce deployment costs. Clones, such as the one described in ERC-1167 are minimal pieces of code that contain the target address directly in the code. That

RATIONALE:
### Gas cost The execution of the `CREATE_DELEGATE` instruction involves fewer moving pieces than what EIP-7702 gas costs account for: - there is no signature recovery - there is no dedicated calldata that must be accounted for that is not already paid for at the transaction level - there


=== EIP-5988 ===
TITLE: Add Poseidon hash function precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-11-15
REQUIRES: 

SUMMARY:
This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Parameters | Constant | Value | | ----------------------------- | ----- | | `FORK_BLKNUM` | `TBD` | | `GAS_COST` | `TBD`

MOTIVATION:
[Poseidon](../assets/eip-5988/papers/poseidon_paper.pdf) is an arithmetic hash function that is designed to be efficient for Zero-Knowledge Proof Systems. Ethereum adopts a rollup centric roadmap and hence must adopt facilities for L2s to be able to communicate with the EVM in an optimal manner. ZK-Rollups have particular needs for cryptographic hash functions

RATIONALE:
TODO: Add rationale TODO: Add rationale for gas cost e.g. benchmark and computation cost estimation.


=== EIP-7591 ===
TITLE: BLS signed transactions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-01-10
REQUIRES: 

SUMMARY:
This EIP introduces a new [EIP-2718](./eip-2718.md) transaction type that is signed with BLS signatures.

SPECIFICATION:
BLS_TX_TYPE = Bytes1(0x04) ### Transaction Type The transaction type will have the following format: ``` [chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, sender, signature] ``` with `sender` being the BLS public key of an account with address `address = [0:20](keccak256(sender))`. The signature value `signature` is calculated by

MOTIVATION:
The BLS signature scheme allows for easy aggregation and verification of aggregated signatures. If a substantial number of transactions on mainnet were BLS signed transactions, we can aggregate signatures in a block and batch-verify them. This will reduce growth of the chain history.

RATIONALE:
Removing the ECDSA signature from a transaction saves 65 bytes. The BLS public key is 48 bytes, the aggregated signature is 96 bytes. Thus we save `-96 + (65-48)* #transactions` bytes per block. With ~7000 blocks per day, 1.000.000 transactions per day, the average block contains roughly 150 transactions.


=== EIP-7833 ===
TITLE: Scheduled function calls
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-06
REQUIRES: 

SUMMARY:
Ethereum's smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers—like MEV attacks—can prevent timely execution. To address these challenges, this Ethereum

SPECIFICATION:
Adding bot-like behavior to an EVM function is achieved by recursively scheduling a call to the same function in the next block. We propose introducing a new EVM opcode, OFFERCALL, which, as the name implies, offers ETH to be burnt to the block producer of the next block in

RATIONALE:
The rationale behind this Ethereum Improvement Proposal (EIP) stems from the need to enhance the reliability and fairness of smart contract execution on the Ethereum network. While Ethereum’s smart contracts allow for a high degree of programmability and automation, the execution of these contracts often depends on external triggers,


=== EIP-7685 ===
TITLE: General purpose execution layer requests
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-04-14
REQUIRES: 

SUMMARY:
This proposal defines a general purpose framework for storing contract-triggered requests. It extends the execution header with a single field to store the request information. Requests are later on exposed to the consensus layer, which then processes each one.

SPECIFICATION:
### Execution Layer #### Requests A `requests` object consists of a `request_type` prepended to an opaque byte array `request_data`. The `request_data` contains zero or more encoded request objects. ``` requests = request_type ++ request_data ``` Each request type will defines its own `requests` object with its own `request_data` format.

MOTIVATION:
The proliferation of smart contract controlled validators has caused there to be a demand for additional EL triggered behaviors. By allowing these systems to delegate administrative operations to their governing smart contracts, they can avoid intermediaries needing to step in and ensure certain operations occur. This creates a safer

RATIONALE:
### Opaque byte array rather than an RLP array By having the bytes of `request_data` array from second byte on be opaque bytes, rather than an RLP (or other encoding) list, we can support different encoding formats for the request payload in the future such as SSZ, LEB128, or


=== EIP-2926 ===
TITLE: Chunk-Based Code Merkleization
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-08-25
REQUIRES: 1, 6, 1, ,,  , 1, 7, 0, ,,  , 2, 5, 8, 4

SUMMARY:
Code merkleization, along with binarification of the trie and gas cost bump of state accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of

SPECIFICATION:
This specification assumes that [EIP-2584](./eip-2584.md) is deployed, and the merkleization rules and gas costs are proposed accordingly. What follows is structured to have two sections: 1. How a given contract code is split into chunks and then merkleized 2. How to merkleize all existing contract codes during a hardfork

MOTIVATION:
Bytecode is currently the [second contributor](https://github.com/mandrigin/ethereum-mainnet-bin-tries-data) to block witness size, after the proof hashes. Transitioning the trie from hexary to binary reduces the hash section of the witness by 3x, thereby making code the first contributor. By breaking contract code into chunks and committing to those chunks in a

RATIONALE:
### Hexary vs binary trie The Ethereum mainnet state is encoded as of now in a hexary Merkle Patricia Tree. As part of the Eth1x roadmap, a transition to a [binary trie](https://ethresear.ch/t/binary-trie-format/7621) has been [investigated](https://medium.com/@mandrigin/stateless-ethereum-binary-tries-experiment-b2c035497768) with the goal of reducing witness sizes. Because code chunks are also stored in


=== EIP-7761 ===
TITLE: HASCODE instruction
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-09-01
REQUIRES: 3, 5, 4, 0, ,,  , 7, 6, 9, 2

SUMMARY:
Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing an `HASCODE` instruction.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLKNUM` | tbd | | `GAS_COLD_ACCOUNT_ACCESS` | Defined as `2600` in the [Ethereum Execution Layer Specs](https://github.com/ethereum/execution-specs/blob/fcd12750edd4443a91f138728689a1d0a503a7c1/src/ethereum/cancun/vm/gas.py#L64) | | `GAS_WARM_ACCESS` | Defined as `100` in the [Ethereum Execution Layer Specs](https://github.com/ethereum/execution-specs/blob/fcd12750edd4443a91f138728689a1d0a503a7c1/src/ethereum/cancun/vm/gas.py#L65) | We introduce a new EOFv1 instruction

MOTIVATION:
EOFv1 as scoped in [EIP-7692](./eip-7692.md) removes code introspection capabilities from the EVM, including the `EXTCODESIZE` instruction (in [EIP-3540](./eip-3540.md)). This makes it hard for [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) standard contracts to be implemented, as they rely on discovering whether a token's `safeTransfer` call target was an EOA or a contract account:

RATIONALE:
### Alternative solutions There have been other solutions proposed to alleviate the problems related to lack of code introspection required for ERC-721 and ERC-1155 standards: 1. Extra status code for `EXT*CALL` instruction - allowing to discriminate a result coming from calling an EOA 2. Extra argument for `EXT*CALL` (a


=== EIP-3541 ===
TITLE: Reject new contract code starting with the 0xEF byte
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-03-16
REQUIRES: 

SUMMARY:
Disallow new code starting with the `0xEF` byte to be deployed. Code already existing in the account trie starting with `0xEF` byte is not affected semantically by this change.

SPECIFICATION:
After `block.number == HF_BLOCK` new contract creation (via create transaction, `CREATE` or `CREATE2` instructions) results in an exceptional abort if the _code_'s first byte is `0xEF`. ### Remarks The *initcode* is the code executed in the context of the *create* transaction, `CREATE`, or `CREATE2` instructions. The *initcode* returns *code*

MOTIVATION:
Contracts conforming to the EVM Object Format (EOF) are going to be validated at deploy time. In order to guarantee that every EOF-formatted contract in the state is valid, we need to prevent already deployed (and not validated) contracts from being recognized as such format. This will be achieved

RATIONALE:
The `0xEF` byte was chosen because it resembles **E**xecutable **F**ormat. Contracts using unassigned opcodes are generally understood to be at risk of changing semantics. Hence using the unassigned `0xEF` should have lesser effects, than choosing an assigned opcode, such as `0xFD` (`REVERT`), `0xFE` (`INVALID)`, or `0xFF` (`SELFDESTRUCT`). Arguably while


=== EIP-608 ===
TITLE: Hardfork Meta: Tangerine Whistle
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 5, 0, ,,  , 7, 7, 9

SUMMARY:
This specifies the changes included in the hard fork named Tangerine Whistle (EIP 150).

SPECIFICATION:
- Codename: Tangerine Whistle - Aliases: EIP 150, Anti-DoS - Activation: - Block >= 2,463,000 on Mainnet - Included EIPs: - [EIP-150](./eip-150.md) (Gas cost changes for IO-heavy operations)


=== EIP-3675 ===
TITLE: Upgrade consensus to Proof-of-Stake
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-22
REQUIRES: 2124

SUMMARY:
This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented in [EIP-2982](./eip-2982.md). Full specification of the beacon chain can be found in the `ethereum/consensus-specs` repository. This document specifies

SPECIFICATION:
### Definitions * **PoW block**: Block that is built and verified by the existing proof-of-work mechanism. In other words, a block of the Ethereum network before the consensus upgrade. * **PoS block**: Block that is built and verified by the new proof-of-stake mechanism. * **Terminal PoW block**: A PoW

MOTIVATION:
The beacon chain network has been up and running since December 2020. Neither safety nor liveness failures were detected during this period of time. This long period of running without failure demonstrates the sustainability of the beacon chain system and its readiness to become a security provider for the

RATIONALE:
The changes specified in this EIP target a minimal requisite set of consensus and client software modifications to safely replace the existing proof-of-work consensus algorithm with the new proof-of-stake consensus represented by the already in-production beacon chain. This EIP was designed to minimize the complexity of hot-swapping the live


=== EIP-1380 ===
TITLE: Reduced gas cost for call to self
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-31
REQUIRES: 150

SUMMARY:
Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then decrease the cost of `CALL`, `DELEGATECALL`, `CALLCODE` and `STATICCALL` from 700 to 40, if and only if, the destination address of the call equals to the address of the caller.

MOTIVATION:
The current gas cost of 700 for all call types (`CALL`, `DELEGATECALL`, `CALLCODE` and `STATICCALL`) does not take into account that a call to a contract itself does not need to perform additional I/O operations, because the current contract code has already been loaded into memory. Reducing the call-to-self

RATIONALE:
EIP150 has increased the cost of these instructions from 40 to 700 to more fairly charge for loading new contracts from disk, e.g. to reflect the I/O charge more closely. By assuming that 660 is the cost of loading a contract from disk, one can assume that the original


=== EIP-5793 ===
TITLE: eth/68 - Add tx type to tx announcement
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-10-18
REQUIRES: 2, 4, 6, 4, ,,  , 2, 4, 8, 1, ,,  , 4, 9, 3, 8

SUMMARY:
The Ethereum Wire Protocol defines request and response messages for exchanging data between clients. The `NewPooledTransactionHashes` message announces transactions available in the node. This EIP extends this announcement message such that beside the transaction hashes, the node sends the transaction types and their sizes (as defined in [EIP-2718](./eip-2718.md)) as

SPECIFICATION:
Modify the `NewPooledTransactionHashes (0x08)` message: * **(eth/67)**: `[hash_0: B_32, hash_1: B_32, ...]` * **(eth/68)**: `[types: B, [size_0: P, size_1: P, ...], [hash_0: B_32, hash_1: B_32, ...]]` The new `types` element refers to the transaction types of the announced hashes. Note the transaction types are packed as a 'byte array'

MOTIVATION:
The `NewPooledTransactionHashes` message announces transaction hashes, allowing the peer to selectively fetch transactions it does not yet have. [EIP-4844](./eip-4844.md) introduces a new transaction type for blob transactions. Since these blob transactions are large, naively broadcasting them to `sqrt(peers)` could significantly increase bandwidth requirements. Adding the transaction type and the

RATIONALE:
This change will make the `eth` protocol future-proof for new transaction types that might not be relevant for all nodes. It gives the receiving node better control over the data it fetches from the peer as well as allow throttling the download of specific types. The `types` message element


=== EIP-155 ===
TITLE: Simple replay attack protection
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-14
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM` and `CHAIN_ID` is available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements `(nonce, gasprice, startgas, to, value, data)`, you **SHOULD** hash nine rlp encoded elements `(nonce, gasprice, startgas, to, value, data, chainid,

RATIONALE:
This would provide a way to send transactions that work on Ethereum without working on ETC or the Morden testnet. ETC is encouraged to adopt this EIP but replacing `CHAIN_ID` with a different value, and all future testnets, consortium chains and alt-etherea are encouraged to adopt this EIP replacing


=== EIP-2045 ===
TITLE: Particle gas costs for EVM opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-17
REQUIRES: 

SUMMARY:
According to recent benchmarks, EVM opcodes for computation (`ADD`, `SUB`, `MUL`, etc.) are generally overpriced relative to opcodes for storage I/O (`SLOAD`, `SSTORE`, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5,

SPECIFICATION:
A new gas counter `particlesUsed` is added to the EVM, in addition to the existing gas counter `gasUsed`. The unit 1 gas is equal to 10000 particles (`PARTICLES_PER_GAS`). The `particlesUsed` counter is only increased for opcodes priced in particles (i.e. opcodes that cost less than 1 gas). If increasing

MOTIVATION:
The transaction capacity of an Ethereum block is determined by the gas cost of transactions relative to the block gas limit. One way to boost the transaction capacity is to raise the block gas limit. Unfortunately, raising the block gas limit would also increase the rate of state growth,

RATIONALE:
Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept of `particles` need not be exposed to Ethereum users nor most contract authors, but only to EVM implementers


=== EIP-7610 ===
TITLE: Revert creation in case of non-empty storage
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2024-02-02
REQUIRES: 

SUMMARY:
This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. If a contract creation is attempted due to a creation transaction, the `CREATE` opcode, the

RATIONALE:
EIP-684 defines two conditions for contract deployment: the destination address must have zero nonce and zero code length. Unfortunately, this is not sufficient. Before [EIP-161](./eip-161.md) was applied, the nonce of a newly deployed contract remained set to zero. Therefore, it was entirely possible to create a contract with a


=== EIP-2786 ===
TITLE: Ethereum Provider Connect/Disconnect Events
TYPE: Standards Track Interface
STATUS: Withdrawn
CREATED: 2020-07-15
REQUIRES: 2700

SUMMARY:
The Provider is said to be “connected” when it can service RPC requests to at least one chain. The Provider is said to be “disconnected” when it cannot service RPC requests to any chain at all. When the Provider switches from a "connected" state to a "disconnected" state, it

SPECIFICATION:
### Definitions #### Connected The Provider is considered `connected` when it is able to service RPC requests to at least one chain. #### Disconnected The Provider is considered `disconnected` when it is unable to service RPC requests to any chain. ### Events #### `connect` The Provider **MUST** emit a

MOTIVATION:
When an application is hooked up to an Ethereum provider, there is value in having the application be alerted of connect/disconnect events that may occur so the application can appropriately inform the user of the situation. It is left up to the application to decide whether to listen in

RATIONALE:
This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn’t a lot of room for improving things such as by having a connect/disconnect event per chain.


=== EIP-7748 ===
TITLE: State conversion to Verkle Tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-07-23
REQUIRES: 7612

SUMMARY:
This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants | Parameter | value | Description | | ---------------------------- | ----- | --------------------------------------------------------------

MOTIVATION:
The accounts state is too large to wait for transactions to organically move all of them to the VKT through the Overlay Tree. Thus, we need a strategy to convert all the state within a reasonable time. The state conversion completion allows removing the Overlay Tree abstraction introduced in

RATIONALE:
### State conversion step position in block execution Performing the conversion step before the block txs execution has some benefits: - If the state conversion step is done after txs execution, there's a possibility that txs execution writes overlap with converted key-values, having to care about them becoming stale


=== EIP-1681 ===
TITLE: Temporal Replay Protection
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-01-08
REQUIRES: 

SPECIFICATION:
The roll-out would be performed in two phases, `X` (hardfork), and `Y` (softfork). At block `X`, - Add an optional field `valid-until` to the RLP-encoded transaction, defined as a `uint64` (same as `nonce`). - If the field is present in transaction `t`, then - `t` is only eligible for

MOTIVATION:
There are a couple of different motivators for introducing a timebased transaction validity. - If any form of dust-account clearing is introduced, e.g. (https://github.com/ethereum/EIPs/issues/168), it will be necessary to introduce a replay protection, such as https://github.com/ethereum/EIPs/issues/169 . Having temporal replay protection removes the need to change nonce-behaviour in the

RATIONALE:
### Rationale for this EIP For the dust-account clearing usecase, - This change is much less invasive in the consensus engine. - No need to maintain a consensus-field of 'highest-known-nonce' or cap the number of transactions from a sender in a block. - Only touches the transaction validation part


=== EIP-3298 ===
TITLE: Removal of refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-02-26
REQUIRES: 

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. Do not apply the `refund`. The description above is sufficient to describe the change, but for the sake of clarity we enumerate

MOTIVATION:
Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It

RATIONALE:
A full removal of refunds is the simplest way to solve the issues with refunds; any gains from partial retention of the refund mechanism are not worth the complexity that that would leave remaining in the Ethereum protocol.


=== EIP-607 ===
TITLE: Hardfork Meta: Spurious Dragon
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 5, 5, ,,  , 1, 6, 0, ,,  , 1, 6, 1, ,,  , 1, 7, 0, ,,  , 6, 0, 8

SUMMARY:
This specifies the changes included in the hard fork named Spurious Dragon.

SPECIFICATION:
- Codename: Spurious Dragon - Aliases: State-clearing - Activation: - Block >= 2,675,000 on Mainnet - Block >= 1,885,000 on Morden - Included EIPs: - [EIP-155](./eip-155.md) (Simple replay attack protection) - [EIP-160](./eip-160.md) (EXP cost increase) - [EIP-161](./eip-161.md) (State trie clearing) - [EIP-170](./eip-170.md) (Contract code size limit)


=== EIP-6493 ===
TITLE: SSZ transaction signature scheme
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-02-24
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 6

SUMMARY:
This EIP defines a signature scheme for native [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md) encoded transactions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Transaction signature scheme Native SSZ transactions are based on the `TransactionPayload` and `Transaction` types

MOTIVATION:
[EIP-6404](./eip-6404.md) introduces SSZ transactions by converting from RLP transactions. Defining a signature scheme for native SSZ transactions further reduces required conversions and unlocks the forward compatibility benefits of SSZ [`StableContainer`](./eip-7495.md).

RATIONALE:
The SSZ signature scheme reduces hashing overhead and ensures that `tx_hash` commitments are available on-chain. It also provides a flexible basis for future transaction functionality.


=== EIP-3756 ===
TITLE: Gas Limit Cap
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-08-21
REQUIRES: 

SUMMARY:
Set an in-protocol cap for the gas limit of 30,000,000.

SPECIFICATION:
As of the fork block `N`, consider blocks with a `gas_limit` greater than `30,000,000` invalid.

MOTIVATION:
A high gas limit increases pressure on the network. In the benign case, it increases the size of the state and history faster than we can sustain. In the malicious case, it amplifies the devastation of certain denial-of-service attacks.

RATIONALE:
### Why Cap the Gas Limit The gas limit is currently under the control of block proposers. They have the ability to increase the gas limit to whatever value they desire. This allows them to bypass the EIP and All Core Devs processes in protocol decisions that may negatively


=== EIP-7480 ===
TITLE: EOF - Data section access instructions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-08-11
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Four new instructions are introduced, that allow to read EOF container's data section: `DATALOAD` loads 32-byte word to stack, `DATALOADN` loads 32-byte word to stack where the word is addressed by a static immediate argument, `DATASIZE` loads data section size and `DATACOPY` copies a segment of data section to

SPECIFICATION:
We introduce four new instructions on the same block number [EIP-3540](./eip-3540.md) is activated on: 1. `DATALOAD` (0xd0) 2. `DATALOADN` (0xd1) 3. `DATASIZE` (0xd2) 4. `DATACOPY` (0xd3) If the code is legacy bytecode, all of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*) If

MOTIVATION:
Clear separation between code and data is one of the main features of EOF1. Data section may contain anything, e.g. compiler's metadata, but to make it useful for smart contracts, EVM has to have instructions that allow to read from data section. Previously existing instructions for bytecode inspection (`CODECOPY`,

RATIONALE:
### Zero-padding on out of bounds access Existing instructions for reading other kinds of data implicitly pad with zeroes on out of bounds access, with the only exception of return data copying. It is beneficial to avoid exceptional failures, because compilers can employ optimizations like removing a code that


=== EIP-7199 ===
TITLE: Linter Scope
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2023-06-20
REQUIRES: 

SUMMARY:
Currently in practice EIP linter tools (EIPW, for example) will block a Pull Request for lint errors even if that lint errors was not introduced in that Pull Request. This EIP make it explicit that lint errors for untouched lines shall be considered ignoreable except for status change.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. In an update to an EIP, A Pull Request SHOULD NOT be required to fix linter errors in untouched lines

RATIONALE:
This policy allows micro contributions for anyone who just want to fix a typo or change a section of a section in a large EIP.


=== EIP-1087 ===
TITLE: Net gas metering for SSTORE operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-17
REQUIRES: 

SUMMARY:
This EIP proposes a change to how gas is charged for EVM `SSTORE` operations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.

SPECIFICATION:
The following changes are made to the EVM: - A 'dirty map' for each transaction is maintained, tracking all storage slots in all contracts that have been modified in the current transaction. The dirty map is scoped in the same manner as updates to storage, meaning that changes to

MOTIVATION:
Presently, `SSTORE` (`0x55`) operations are charged as follows: - 20,000 gas to set a slot from 0 to non-0 - 5,000 gas for any other change - A 10,000 gas refund when a slot is set from non-0 to 0. Refunds are applied at the end of the transaction.

RATIONALE:
We believe the proposed mechanism represents the simplest way to reduce storage gas costs in situations where they do not reflect the actual costs borne by nodes. Several alternative designs were considered and dismissed: - Charging a flat 200 gas for `SSTORE` operations, and an additional 19800 / 4800


=== EIP-2488 ===
TITLE: Deprecate the CALLCODE opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-12-20
REQUIRES: 7

SUMMARY:
Deprecate `CALLCODE` in a *somewhat* backwards compatible way, by making it always return failure.

SPECIFICATION:
If `block.number >= FORK_BLOCK`, the `CALLCODE` (`0xf2`) instruction always returns `0`, which signals failure.

MOTIVATION:
`CALLCODE` was part of the Frontier release of Ethereum. In the first few weeks/months it became clear that it cannot accomplish its intended design goal. This was rectified with introducing `DELEGATECALL` ([EIP-7](./eip-7.md)) in the Homestead update (early 2016). `CALLCODE` became never utilized, but it still puts a burden on

RATIONALE:
It would be possible just to remove the opcode and exceptionally abort if it is encountered. However, by returning failure, the contract has a chance to act on it and potentially recover.


=== EIP-7639 ===
TITLE: eth/70 - Cease serving history before PoS
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2024-02-13
REQUIRES: 

SUMMARY:
Execution layer clients will no longer request or respond to p2p queries about block data before the Paris upgrade.

SPECIFICATION:
Add a new `eth` protocol capability with version `70`. Clients connected on this version must not make or respond to p2p queries about block bodies or receipts before block 15537393. The affected protocol messages are: - `GetBlockBodies (0x05)` - `BlockBodies (0x06)` - `GetReceipts (0x0f)` - `Receipts (0x10)`

MOTIVATION:
As of 2024, historical data in clients has grown to around 500 GB. Nearly 400 GB of that is from block data before PoS was activated in the Paris upgrade. Long term, Ethereum plans to bound the amount of data nodes must store. This EIP proposes the first steps

RATIONALE:
### Only Pre-PoS data One might ask why the distinction between pre and post PoS data is made in this EIP. The simple answer is that the at the moment of the merge, the block structure changed substantially. Although execution layer client software today continues on with block data


=== EIP-4 ===
TITLE: EIP Classification
TYPE: Meta 
STATUS: Final
CREATED: 2015-11-17
REQUIRES: 


=== EIP-698 ===
TITLE: OPCODE 0x46 BLOCKREWARD
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-08-28
REQUIRES: 

SUMMARY:
In the EVM, the 0x40 opcodes are reserved for `Block Information`. Currently reserved opcodes are: * `0X40 BLOCKHASH` * `0X41 COINBASE` * `0X42 TIMESTAMP` * `0X43 NUMBER` * `0X44 DIFFICULTY` * `0X45 GASLIMIT` This EIP would add an additional opcode, `0x46 BLOCKREWARD`, which would return the block reward for

SPECIFICATION:
After block `n` all clients should process opcode `0x46` as follows: * Value: `0x46` * Mnemonic: `BLOCKREWARD` * δ:` 0` nothing removed from stack * α:`1` block reward added to stack * Description: `Get the block's reward emission` * GasCost: `G<sub>base</sub>` Where:`µ'<sub>s</sub>[0] ≡ I<sub>HR</sub>`

MOTIVATION:
Per EIP-649 ( #669 ) periodic block reward reductions/variance are now planned in the roadmap, however, this EIP is consensus system agnostic and is most useful in decentralized pool operations and for any contract that benefits from knowing a block reward payout(i.e. Merge mined tokens)

RATIONALE:
### Contract Mining Pools For distributed consensus systems(staking pools and mining pools) ad hoc groups combine resources in order to reduce variance in payouts. Broadly, pool operations function by allowing a collective of miners / stakers to verify their contribution to solving PoW or staking share by periodically submitting


=== EIP-3584 ===
TITLE: Block Access List
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-05-22
REQUIRES: 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
[EIP-2929](./eip-2929.md)/[EIP-2930](./eip-2930.md) centers around normalizing the (low) gas costs of data/storage accesses made by a transaction as well as providing for (and encouraging) a new transaction type format: ``` 0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS]) ``` that makes upfront `access_list` declarations, where `access_list`

SPECIFICATION:
A block `access_list` represents: ``` Set [ AccessedAddress, List [AccessedStorageKeys] , Set [ AccessedInBlockTransactionNumber, List [ AccessedStorageKeys ]] ] ``` A **canonical** construction of such an `access_list` is specified as below. ### Canonical Block Access List An `access_list` is defined to be comprised of many `access_list_entry` elements: ``` access_list

MOTIVATION:
Motivation for collating the *transaction* `access_list`s for all the transactions in a **block**’s `access_list` is to have an *access index* of the block with following benefits: 1. Block execution/validation optimizations/parallelization/cache warm-up by enabling construction of *a partial order* for access and hence execution (hint: *chains* in this *poset* can

RATIONALE:
### Sorting of canonical `access_list` It is specified to be sorted in lexicographic ordering or integer sorting wherever applicable and specified. Sorting with respect to access time was considered but didn't seem to provide any additional benefit at the cost of adding implementation complexity and bookkeeping. ### `AccessListRoot` `AccessListRoot`


=== EIP-2228 ===
TITLE: Canonicalize the name of network ID 1 and chain ID 1
TYPE: Informational 
STATUS: Final
CREATED: 2019-08-04
REQUIRES: 

SUMMARY:
The name for the Ethereum network with network ID 1 and chain ID 1 shall be Ethereum Mainnet or just Mainnet. This is a proper noun. This standard specifies the name for this network and provides reference examples in an effort to standardize the word choice and provide a

SPECIFICATION:
The network name for network ID 1 and chain ID 1 shall be Ethereum Mainnet, or just Mainnet if the context is known to be discussing Ethereum networks. This IS a proper noun. Several examples are given below which differentiate between usage of the name of the network versus

MOTIVATION:
The Ethereum network with network ID 1 and chain ID 1 is referenced using several conflicting names across EIPs, client implementations, and information published on the internet at large. In several locations, even documents written by the same author use inconsistent names to refer to the Ethereum network with

RATIONALE:
Choosing common word use promotes interoperability of implementations and increases customer awareness. Also, it adds a sense of professionalism when customers see the same word and word styling (i.e. capitalization of letters) across different implementations. Anybody that has travelled to certain countries and seen an "IPhone [sic]" repair store


=== EIP-2014 ===
TITLE: Extended State Oracle
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-10
REQUIRES: 140

SUMMARY:
Introduce a new system contract with an extensible interface following the [Contract ABI Encoding] to access extended data sets, such as chain identifiers, block hashes, etc. This allows Ethereum contract languages to interact with this contract as if it were a regular contract and not needing any language support.

SPECIFICATION:
A new system contract ("precompile") is introduced at address `0x0000000000000000000000000000000000000009` called ESO (Extended State Oracle). It can be queried using `CALL` or `STATICCALL` and follows the [Contract ABI Encoding] for the inputs and outputs. Using elementary types in the ABI encoding is encouraged to keep complexity low. In the

MOTIVATION:
Over the past couple of years several proposals were made to extend the EVM with more data. Some examples include extended access to block hashes ([EIP-210]) and chain identifiers ([EIP-1344]). Adding them as EVM opcodes seems to be using the scarce opcode space for relatively less frequently used features,

RATIONALE:
TBA


=== EIP-609 ===
TITLE: Hardfork Meta: Byzantium
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 1, 0, 0, ,,  , 1, 4, 0, ,,  , 1, 9, 6, ,,  , 1, 9, 7, ,,  , 1, 9, 8, ,,  , 2, 1, 1, ,,  , 2, 1, 4, ,,  , 6, 0, 7, ,,  , 6, 4, 9, ,,  , 6, 5, 8

SUMMARY:
This specifies the changes included in the hard fork named Byzantium.

SPECIFICATION:
- Codename: Byzantium - Aliases: Metropolis/Byzantium, Metropolis part 1 - Activation: - Block >= 4,370,000 on Mainnet - Block >= 1,700,000 on Ropsten testnet - Included EIPs: - [EIP-100](./eip-100.md) (Change difficulty adjustment to target mean block time including uncles) - [EIP-140](./eip-140.md) (REVERT instruction in the Ethereum Virtual Machine) -


=== EIP-2696 ===
TITLE: JavaScript `request` method RPC transport
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2020-06-04
REQUIRES: 

SUMMARY:
This standard provides the description of an object that is made available to JavaScript applications which they can use to communicate with the Ethereum blockchain through. This standard only describes the transport mechanism, it does not specify the payloads that are valid nor does it specify how the client

SPECIFICATION:
### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Interface TypeScript interface definition: ```ts interface RequestArguments { readonly method: string; readonly params?: readonly unknown[] | object; }

MOTIVATION:
When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime. Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or

RATIONALE:
While this standard is perhaps not the greatest mechanism for communicating between an application and a blockchain, it is closely aligned with established practices within the community so migration from existing systems to this one should be relatively easy. Most communication is currently done via JSON-RPC, so aligning with


=== EIP-1872 ===
TITLE: Ethereum Network Upgrade Windows
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-03-25
REQUIRES: 

SUMMARY:
Four different weeks, spaced roughly evenly throughout the year, are targeted for network upgrades to be launched. Regular network upgrades should announce their intention to launch in a particular window early in their process and choose a block number four to six weeks prior to that window. If a

SPECIFICATION:
Scheduling is defined for three categories of network upgrades. First are `Roadmap` network upgrades that include deliberate protocol improvements. Next are `Priority` network updates, where there are technical reasons that necessitate a prompt protocol change but these reasons do not present a systemic risk to the protocol or the

MOTIVATION:
The aim of this EIP is to provide some level of regularity and predictability to the Ethereum network upgrade/hard fork process. This will allow service providers such as exchanges and node operators a predictable framework to schedule activities around. This also provides a framework to regularize the delivery of

RATIONALE:
The rationale for defining launch windows is to give business running Ethereum infrastructure a predictable schedule for when upgrades may or may not occur. Knowing when a upgrade is not going to occur gives the businesses a clear time frame within which to perform internal upgrades free from external


=== EIP-3607 ===
TITLE: Reject transactions from senders with deployed code
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-06-10
REQUIRES: 

SUMMARY:
Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated `2**80` computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this

SPECIFICATION:
Any transaction where `tx.sender` has a `CODEHASH != EMPTYCODEHASH` MUST be rejected as invalid, where `EMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`. The invalid transaction MUST be rejected by the client and not be included in a block. A block containing such a transaction MUST be considered invalid.

MOTIVATION:
### Generating address collisions By creating keys for `2**80` EOAs and simulating the deployment of `2**80` contracts from these EOAs (one each), one expects to find about one collision where an EOA has the same address as one contract. This very simple form of the attack requires the storage

RATIONALE:
We note that it was always the expected that a contract account's behaviour is constrained by the code in that contract -- which means that the account's funds should not suddenly be spendable by some private key. It was just implicitly assumed in the past that a 160 bit


=== EIP-7692 ===
TITLE: EVM Object Format (EOFv1) Meta
TYPE: Meta 
STATUS: Review
CREATED: 2024-04-17
REQUIRES: 6, 6, 3, ,,  , 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 4, 7, 5, 0, ,,  , 5, 4, 5, 0, ,,  , 6, 2, 0, 6, ,,  , 7, 0, 6, 9, ,,  , 7, 4, 8, 0, ,,  , 7, 6, 2, 0, ,,  , 7, 6, 9, 8

SUMMARY:
This Meta EIP lists the EIPs which belong to the EVM Object Format (EOF) proposal, in its first version (EOFv1), also known as the "Mega EOF".

SPECIFICATION:
### EIPs Included - [EIP-3540](./eip-3540.md): EOF - EVM Object Format v1 - [EIP-3670](./eip-3670.md): EOF - Code Validation - [EIP-4200](./eip-4200.md): EOF - Static relative jumps - [EIP-4750](./eip-4750.md): EOF - Functions - [EIP-5450](./eip-5450.md): EOF - Stack Validation - [EIP-6206](./eip-6206.md): EOF - JUMPF and non-returning functions - [EIP-7480](./eip-7480.md): EOF - Data section

RATIONALE:
Refer to the individual EIPs.


=== EIP-1015 ===
TITLE: Configurable On Chain Issuance
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-20
REQUIRES: 


=== EIP-150 ===
TITLE: Gas cost changes for IO-heavy operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-09-24
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, then: - Increase the gas cost of EXTCODESIZE to 700 (from 20). - Increase the base gas cost of EXTCODECOPY to 700 (from 20). - Increase the gas cost of BALANCE to 400 (from 20). - Increase the gas cost of SLOAD to 200 (from

RATIONALE:
Recent denial-of-service attacks have shown that opcodes that read the state tree are under-priced relative to other opcodes. There are software changes that have been made, are being made and can be made in order to mitigate the situation; however, the fact will remain that such opcodes will be


=== EIP-2458 ===
TITLE: Updates and Updated-by Header
TYPE: Informational 
STATUS: Withdrawn
CREATED: 2020-01-06
REQUIRES: 

SUMMARY:
EIP headers `updates` and `updated-by` are used for updating `active` EIPs. This is to make the improvement process of EIPs more modular, and have updates to existing `active` EIPs receive similar exposures to EIPs which replace existing `final` EIPs.

SPECIFICATION:
### `updated-by` `updated-by` is reserved for EIPs in `active` status. For an EIP in status `active`, updates to that EIP, which update the header `updated`, should be started by opening a new EIP to start vetting for that update. When an `active` EIP receives a new entry to header

MOTIVATION:
Currently, EIP1 specifies EIP headers: `updated`, `replaces`, and `superseded-by`. Headers `replaces` and `superseded-by` indicates when an entire EIP is being replaced by another EIP, indicating when an EIP is now historical, and is updated by a new standard. The header `updated` indicates the date an EIP has received an

RATIONALE:
`updates` and `updated-by` apply only to EIPs in `active` status as updates to EIPs in `final` status are already handled by EIP headers `superseded-by` and `replaces`. The syntax should align with previous EIP header syntax, as this EIP is not updating syntax, simply adding header options.


=== EIP-5 ===
TITLE: Gas Usage for `RETURN` and `CALL*`
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-22
REQUIRES: 

SUMMARY:
This EIP makes it possible to call functions that return strings and other dynamically-sized arrays. Currently, when another contract / function is called from inside the Ethereum Virtual Machine, the size of the output has to be specified in advance. It is of course possible to give a larger

SPECIFICATION:
The gas and memory semantics for `CALL`, `CALLCODE` and `DELEGATECALL` (called later as `CALL*`) are changed in the following way (`CREATE` does not write to memory and is thus unaffected): Suppose the arguments to `CALL*` are `gas, address, value, input_start, input_size, output_start, output_size`, then, at the beginning of the

MOTIVATION:
In general, it is good practise to reserve a certain memory area for the output of a call, because letting a subroutine write to arbitrary areas in memory might be dangerous. On the other hand, it is often hard to know the output size of a call prior to

RATIONALE:
This way of dealing with the problem requires a minimal change to the Ethereum Virtual Machine. Other means of achieving a similar goal would have changed the opcodes themselves or the number of their arguments. Another possibility would have been to only change the gas mechanics if `output_size` is


=== EIP-689 ===
TITLE: Address Collision of Contract Address Causes Exceptional Halt
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-08-15
REQUIRES: 

SUMMARY:
Some test cases in the consensus test suite try to deploy a contract at an address already with nonempty code. Although such cases can virtually never happen on the main network before the Constantinople fork block, the test cases detected discrepancies in clients' behavior. Currently, the Yellow Paper says

SPECIFICATION:
If `block.number >= 0`, when a contract creation is on an account with non-zero nonce or non-empty code, the creation fails as if init code execution resulted in an exceptional halt. This applies to contract creation triggered by a contract creation transaction and by CREATE instruction.

MOTIVATION:
This EIP has no practical relevance to the main net history, but simplifies testing and reasoning. This EIP has no effects after Constantinople fork because [EIP-86](./eip-86.md) contains the changes proposed in this EIP. Even before the Constantinople fork, this EIP has no practical relevance because the change is visible

RATIONALE:
It seems impractical to implement never-used features just for passing tests. Client implementations will be simpler with this EIP.


=== EIP-141 ===
TITLE: Designated invalid EVM instruction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-09
REQUIRES: 

SUMMARY:
An instruction is designated to remain as an invalid instruction.

SPECIFICATION:
The opcode `0xfe` is the `INVALID` instruction. It can be used to abort the execution (i.e. duplicates as an `ABORT` instruction).

MOTIVATION:
The invalid instruction can be used as a distinct reason to abort execution.


=== EIP-7441 ===
TITLE: Upgrade block proposer election to Whisk
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-09-01
REQUIRES: 

SUMMARY:
Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.

SPECIFICATION:
### Execution layer This requires no changes to the Execution Layer. ### Consensus layer The protocol can be summarized in the following concurrent steps: - Validators register a tracker and unique commitment on their first proposal after the fork - At the start of a shuffling phase a list

MOTIVATION:
The beacon chain currently elects the next 32 block proposers at the beginning of each epoch. The results of this election are public and everyone gets to learn the identity of those future block proposers. This information leak enables attackers to launch DoS attacks against each proposer sequentially in

RATIONALE:
### Fields per validator Whisk requires having one tracker `(rG,krG)` and one unique commitment `kG` per validator. Both are updated only once on a validator's first proposal after the fork. Trackers are registered with a randomized base `(rG,krG)` to make it harder for adversaries to track them through shuffling


=== EIP-7251 ===
TITLE: Increase the MAX_EFFECTIVE_BALANCE
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-06-28
REQUIRES: 7, 0, 0, 2, ,,  , 7, 6, 8, 5

SUMMARY:
Increases the constant `MAX_EFFECTIVE_BALANCE`, while keeping the minimum staking balance `32 ETH`. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.

SPECIFICATION:
### Constants #### Execution layer | Name | Value | Comment | | - | - | - | | `CONSOLIDATION_REQUEST_TYPE` | `0x02` | The [EIP-7685](./eip-7685.md) type prefix for consolidation request | | `CONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS` | `0x00431F263cE400f4455c2dCf564e53007Ca4bbBb` | Where to call and store relevant details about consolidation request mechanism |

MOTIVATION:
As of October 3, 2023, there are currently over 830,000 validators participating in the consensus layer. The size of this set continues to grow due, in part, to the `MAX_EFFECTIVE_BALANCE`, which limits the stake of a single validator to `32 ETH`. This leads to large amounts of "redundant validators",

RATIONALE:
This EIP aims to reduce the total number of validators without changing anything about the economic security of the protocol. It provides a mechanism by which large node operators who control significant amounts of stake can consolidate into fewer validators. We analyze the reasoning behind each of the core


=== EIP-7775 ===
TITLE: BURN opcode
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-09-30
REQUIRES: 

SUMMARY:
This proposal introduces a `BURN` opcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Behaviour The `BURN` opcode `(0xFC)` is introduced with the following behavior: 1. Pops one

MOTIVATION:
The motivation for this proposal is to provide a standardized and efficient way to burn native ether directly within the EVM. Historically, contracts such as the BeaconDepositContract have "burned" ether by making it irrecoverable from the given address. This approach can lead to confusion and potential misuse. By introducing

RATIONALE:
The introduction of the `BURN` opcode helps clean up a piece of weird semantics in the Ethereum. Historically, burning native ether involved sending them to an address from which they could not be recovered, such as the zero address or a contract with no withdrawal functionality. This method is


=== EIP-2031 ===
TITLE: State Rent B - Net transaction counter
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-15
REQUIRES: 2029

SUMMARY:
It is part of the State Rent roadmap. This particular change makes any Ethereum transaction increment the transaction counter, which is a special storage slot in the *State counter contract*. This counter will be used to populate the nonces of newly created non-contract accounts. This way of populating nonce

SPECIFICATION:
A new field, with the location 0 (that means it resides in the storage slot 0 in the state counter contract, and can be read by calling that contract with argument being 32 zero bytes), is added to the state counter contract. It will eventually contain `txCount`, the total

MOTIVATION:
Ethereum currently does not have a special place in the state for tracking number of transactions.

RATIONALE:
Two main alternatives were proposed for the replay protection of the accounts that were evicted by subsequently brought back by sending ether to them: 1. Temporal replay protection. The nonce of the new accounts (and those brought back) is still zero, but a new `valid-until` field is introduced, making


=== EIP-2831 ===
TITLE: Transaction Replacement Message Type
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-07-26
REQUIRES: 1193

SUMMARY:
The current communication between providers and consumers of providers are fundamentally broken in the event that a transaction in the mempool has been superseded by a newer transactions. Providers currently have no way of communicating a transaction replacement, and consumers are required to poll block by block for the

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Definitions _This section is non-normative._ - Provider - A JavaScript object made available to a consumer, that provides access to

MOTIVATION:
Exert from EIP-1193 > A common convention in the Ethereum web application ("dapp") ecosystem is for key management software ("wallets") to expose their API via a JavaScript object in the web page. This object is called "the Provider". Many ingenious developments have been made by wallet developers to improve

RATIONALE:
The implementation was chosen to help the ease of implementation for both providers and dapp developers. Since `ProviderMessage` is widely used by dapp developers already it means that the implementation path would be as trivial as adding and additional `if` clause to their existing message listener. This also provides


=== EIP-3978 ===
TITLE: Gas refunds on reverts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-09-16
REQUIRES: 2929

SUMMARY:
For reverted state modification operations, keep access cost, but refund modification cost.

SPECIFICATION:
For each callframe, track `revert_gas_refund`, initially 0. The set of operations that modify `revert_gas_refund` are: - SSTORE - LOG0, LOG1, LOG2, LOG3, LOG4 - CALL - CREATE, CREATE2 - SELFDESTRUCT They increase `revert_gas_refund` as follows: ```javascript call.revert_gas_refund += operation.gas - WARM_STORAGE_READ_COST ``` And in case of revert let's use

MOTIVATION:
Reverting a transaction, or any of its sub-calls, drops any state modifications that happened inside. But now, users are being charged for the dropped modifications as if they persisted. Since [EIP-3298](./eip-3298.md), the gas refund mechanism works for storage restores only inside the same transaction. But on revert, the gas

RATIONALE:
Gas should reflect the cost of use. The revert cost reflects the cost of access during execution, but not the cost of modification.


=== EIP-2 ===
TITLE: Homestead Hard-fork Changes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-15
REQUIRES: 


=== EIP-1459 ===
TITLE: Node Discovery via DNS
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2018-09-26
REQUIRES: 778

SUMMARY:
This document describes a scheme for authenticated, updateable Ethereum node lists retrievable via DNS.

SPECIFICATION:
A 'node list' is a list of 'node records' [as defined by EIP-778](./eip-778.md) of arbitrary length. Lists may refer to other lists using links. The entire list is signed using a secp256k1 private key. The corresponding public key must be known to the client in order to verify the

MOTIVATION:
Many Ethereum clients contain hard-coded bootstrap node lists. Updating those lists requires a software update. The current lists are small, giving the client little choice of initial entry point into the Ethereum network. We would like to maintain larger node lists containing hundreds of nodes, and update them regularly.

RATIONALE:
### Why DNS? We have chosen DNS as the distribution medium because it is always available, even under restrictive network conditions. The protocol provides low latency and answers to DNS queries can be cached by intermediate resolvers. No custom server software is needed. Node lists can be deployed to


=== EIP-2938 ===
TITLE: Account Abstraction
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-04
REQUIRES: 2718

SUMMARY:
**See also: [https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020](https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020) and the links therein for historical work and motivation.** Transaction validity, as of Muir Glacier, is defined rigidly by the protocol: ECDSA signature, a simple nonce, and account balance. Account abstraction extends the validity conditions of transactions with the execution of arbitrary EVM bytecode (with some

SPECIFICATION:
### Single Tenant After `FORK_BLOCK`, the following changes will be recognized by the protocol. #### Constants | Constant | Value | | - | - | | **`AA_ENTRY_POINT`** | `0xffffffffffffffffffffffffffffffffffffffff` | | **`AA_TX_TYPE`** | `2` | | **`FORK_BLOCK`** | TBD | | **`AA_BASE_GAS_COST`** | 15000 | #### New Transaction

MOTIVATION:
The existing limitations preclude innovation in a number of important areas, particularly: 1. Smart contract wallets that use signature verification other than ECDSA (eg. Schnorr, BLS, post-quantum...) 2. Smart contract wallets that include features such as multisig verification or social recovery, reducing the highly prevalent risk of funds being

RATIONALE:
The core problem in an account abstraction setup is always that miners and network nodes need to be able to verify that a transaction that they attempt to include, or rebroadcast, will actually pay a fee. Currently, this is fairly simple, because a transaction is guaranteed to be includable


=== EIP-7643 ===
TITLE: History accumulator for pre-PoS data
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-02-29
REQUIRES: 

SUMMARY:
Defines an SSZ object for accumulating all pre-PoS data and commit to the historical hashes accumulator's root `0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701`.

SPECIFICATION:
### Historical Hashes Accumulator The historical hashes accumulator commits to the set of pre-merge headers and their associated total difficulty. The format for this data is defined as: ```python EPOCH_SIZE = 8192 # blocks MAX_HISTORICAL_EPOCHS = 2048 # An individual record for a historical header. HeaderRecord = Container[block_hash: bytes32,

MOTIVATION:
There are two main uses we consider for the historical hashes accumulator: * for users who wish to download the pre-PoS data for the execution chain and verify it without executing each block, they may simply compute each block hash, accumulate the epoch records, and then compare the local

RATIONALE:
### Inclusion of total difficulty The total difficulty allowed so that clients may return the value for specific JSON-RPC methods which support it. It is also useful for verifying the TTD of the final proof-of-work block.


=== EIP-5450 ===
TITLE: EOF - Stack Validation
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-08-12
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 4, 2, 0, 0, ,,  , 4, 7, 5, 0

SUMMARY:
Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.

SPECIFICATION:
### Code validation *Remark:* We rely on the notions of *operand stack* and *type section* as defined by [EIP-4750](./eip-4750.md). Each code section is validated independently. #### Instructions validation In the first validation phase defined in [EIP-3670](./eip-3670.md) (and extended by [EIP-4200](./eip-4200.md) and [EIP-4750](./eip-4750.md)) instructions are inspected independently to check if

MOTIVATION:
The current EVM performs a number of validity checks for each executed instruction, such as checking for instruction being defined, stack overflow and underflow, and enough amount of gas remaining. This EIP minimizes the number of such checks required at run-time by verifying that no exceptional conditions can happen

RATIONALE:
### Properties of validated code Any code section validated according to operand stack validation has the following properties: 1. There are no unreachable instructions 2. There are no instructions reachable only via backwards jump 3. Operand stack underflow cannot happen. 4. Operand stack overflow can only happen at `CALLF`


=== EIP-4345 ===
TITLE: Difficulty Bomb Delay to June 2022
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-10-05
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 10_700_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
Targeting for The Merge to occur before June 2022. If it is not ready by then, the bomb can be delayed further.

RATIONALE:
The following script predicts a ~0.1 second delay to block time by June 2022 and a ~0.5 second delay by July 2022. This gives reason to address because the effect will be seen, but not so much urgency we don't have space to work around if needed. ```python def


=== EIP-7 ===
TITLE: DELEGATECALL
TYPE: Standards Track Core
STATUS: Final
CREATED: 2015-11-15
REQUIRES: 

SPECIFICATION:
`DELEGATECALL`: `0xf4`, takes 6 operands: - `gas`: the amount of gas the code may use in order to execute; - `to`: the destination address whose code is to be executed; - `in_offset`: the offset into memory of the input; - `in_size`: the size of the input in bytes; -

RATIONALE:
Propagating the sender and value from the parent scope to the child scope makes it much easier for a contract to store another address as a mutable source of code and ''pass through'' calls to it, as the child code would execute in essentially the same environment (except for


=== EIP-615 ===
TITLE: Subroutines and Static Jumps for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2016-12-10
REQUIRES: 

SUMMARY:
EVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine—including the compilers—are sufficiently performant to reduce the need for precompiles and otherwise meet the network's long-term demands.

SPECIFICATION:
### Dependencies > **[EIP-1702](./eip-1702.md). Generalized Account Versioning Scheme.** This proposal needs a versioning scheme to allow for its bytecode (and eventually eWasm bytecode) to be deployed with existing bytecode on the same blockchain. ### Proposal We propose to deprecate two existing instructions—`JUMP` and `JUMPI`—and propose new instructions to support

MOTIVATION:
Currently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack. Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs. So dynamic jumps cannot be avoided, yet they obscure

RATIONALE:
This design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment. It was also informed by the lead author's previous work implementing Java and Scheme interpreters. As such there was very little room for alternative designs. As


=== EIP-5069 ===
TITLE: EIP Editor Handbook
TYPE: Meta 
STATUS: Living
CREATED: 2022-05-02
REQUIRES: 1


=== EIP-3143 ===
TITLE: Increase block rewards to 5 ETH
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-12-01
REQUIRES: 

SUMMARY:
Starting with `FORK_BLKNUM` block rewards will be increased to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Adjust Block, Uncle, and Nephew rewards Adjust the block reward to `new_block_reward`, where new_block_reward = 5_000_000_000_000_000_000 if block.number >= FORK_BLKNUM else block.reward (5E18 wei, or 5,000,000,000,000,000,000 wei, or 5 ETH). Analogue, if an uncle is included in a block for `block.number >= FORK_BLKNUM` such that `block.number - uncle.number

MOTIVATION:
Currently, the transaction fees (tx fees) portion of the mining rewards makes up a significant portion of the total rewards per block, at times almost exceeded the block reward of 2 ETH. This have resulted in situations where at times of low tx fees, POW miners decide to point

RATIONALE:
A 5 ETH base reward was chosen as a middle ground between wanting to prevent too high of an inflation rate (10.4% per annum for the first year at 5 ETH per block) and converting as many POW miners as possible into POS validators by making it easier to


=== EIP-3403 ===
TITLE: Partial removal of refunds
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-16
REQUIRES: 

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `SSTORE_REFUND_GAS` | 19000 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. 1. Remove the `SELFDESTRUCT` refund. 2. Remove the `SSTORE` refund in all cases except for one specific

MOTIVATION:
Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice "good state hygiene", clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It

RATIONALE:
Preserving refunds in the `new = original = 0 != current` case ensures that a few key use cases that deserve favorable gas cost treatment continue to receive favorable gas cost treatment, particularly: * Anti-reentrancy locks (typically flipped from 0 to 1 right before a child call begins, and


=== EIP-7684 ===
TITLE: Return deposits for distinct credentials
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-04-12
REQUIRES: 

SUMMARY:
Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.

SPECIFICATION:
### Consensus Layer The configuration values and mechanics of the specification can be found in the [Consensus Layer specs](https://github.com/ethereum/consensus-specs/blob/2360756c8c19c0f7b0e91135f5bbcddecdf0a835/specs/_features/eip9999/beacon_chain.md). A sketch of the resulting changes to the consensus layer is included below. - Modify `apply_deposit` to queue for withdrawal deposits with distinct execution withdrawal credentials - Modify `get_expected_withdrawals` to

MOTIVATION:
Some staking operations feature two distinct entities, one operating the validating key, and one funding the deposit. The funding entity delegates control of the stake operation but must retain ultimate control of funds. If the funding entity naively submits a single deposit with the full stake amount and the

RATIONALE:
### Persist pending withdrawals Rejected deposits from block at slot N can not be withdrawn in block N due to a cyclic dependency. An execution client must know the full list of withdrawals before constructing a payload for slot N. After [EIP-6110](./eip-6110.md), a consensus client must know the full


=== EIP-1702 ===
TITLE: Generalized Account Versioning Scheme
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-12-30
REQUIRES: 

SUMMARY:
This defines a method of hard forking while maintaining the exact functionality of existing account by allowing multiple versions of the virtual machines to execute in the same block. This is also useful to define future account state structures when we introduce the on-chain WebAssembly virtual machine.

SPECIFICATION:
### Account State Re-define account state stored in the world state trie to have 5 items: `nonce`, `balance`, `storageRoot`, `codeHash`, and `version`. The newly added field `version` is a 256-bit **scalar**. We use the definition of "scalar" from Yellow Paper. Note that this is the same type as `nonce`

MOTIVATION:
By allowing account versioning, we can execute different virtual machine for contracts created at different times. This allows breaking features to be implemented while making sure existing contracts work as expected. Note that this specification might not apply to all hard forks. We have emergency hard forks in the

RATIONALE:
This introduces account versioning via a new RLP item in account state. The design above gets account versioning by making the contract *family* always have the same version. In this way, versions are only needed to be provided by contract creation transaction, and there is no restrictions on formats


=== EIP-7706 ===
TITLE: Separate gas type for calldata
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-13
REQUIRES: 1, 5, 5, 9, ,,  , 4, 8, 4, 4

SUMMARY:
Add a new type of gas for transaction calldata. Add a new transaction type that provides `max_basefee` and `priority_fee` as a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.

SPECIFICATION:
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Parameters * `FORK_BLKNUM` = `TBD` * `NEW_TX_TYPE` = `TBD` * `CALLDATA_GAS_PER_TOKEN` = `4` * `TOKENS_PER_NONZERO_BYTE` = `4` * `CALLDATA_GAS_LIMIT_RATIO` =

MOTIVATION:
A major argument against raising the Ethereum gas limit, making calldata cheaper, or increasing the [EIP-4844](./eip-4844.md) blob count before technologies like PeerDAS become available, is that the theoretical maximum size of an Ethereum block is already too large, and we cannot afford to increase it further. However, there is

RATIONALE:
### Conversion of all gas-related mechanics into vectors This allows the same logic that is used for handling gas to handle all three types of gas. As a result, it's arguably a net simplification of protocol gas handling logic, despite the fact that the total number of gas types


=== EIP-1109 ===
TITLE: PRECOMPILEDCALL opcode (Remove CALL costs for precompiled contracts)
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-22
REQUIRES: 

SUMMARY:
This EIP tries to resolve the problem of high gas consumption when calling precompiled contracts with a small gas cost. Using this opcode for calling precompiled contracts allows to define precompiled contracts whose effective cost it is less than 700.

SPECIFICATION:
If `block.number >= XXXXX`, define a new opcode named `PRECOMPILEDCALL` with code value `0xfb`. The gas cost of the OPCODE is 2 (Gbase) plus the Specific gas cost defined for each specific precompiled smart contract. The OPCODE takes 5 words from the stack and returns 1 word to the

MOTIVATION:
Each precompiled contract has an already defined cost for calling it. It does not make sense to add the implicit extra gas cost of the CALL opcode. As an example, SHA256 precompiled contract costs 60 and ECADD costs 500 (proposed to costs only 50 in [EIP-1108](./eip-1108.md) . When a

RATIONALE:
There was a first proposal for removing the gast consts for the `CALL`, but it looks that it's easier to implement and test a new opcode just for that. The code is just the next opcode available after the `STATICCALL` opcode.


=== EIP-4444 ===
TITLE: Bound Historical Data in Execution Clients
TYPE: Standards Track Networking
STATUS: Stagnant
CREATED: 2021-11-02
REQUIRES: 

SUMMARY:
Clients must stop serving historical headers, bodies, and receipts older than one year on the p2p layer. Clients may locally prune this historical data.

SPECIFICATION:
| Parameter | Value | Description | | - | - | - | | `HISTORY_PRUNE_EPOCHS` | 82125 | A year in beacon chain epochs | Clients SHOULD NOT serve headers, block bodies, and receipts that are older than `HISTORY_PRUNE_EPOCHS` epochs on the p2p network. Clients MAY locally prune

MOTIVATION:
Historical blocks and receipts currently occupy more than 400GB of disk space (and growing!). Therefore, to validate the chain, users must typically have a 1TB disk. Historical data is not necessary for validating new blocks, so once a client has synced the tip of the chain, historical data is

RATIONALE:
This proposal forces clients to stop serving old historical data over p2p. We make this explicit to force clients to seek historical data from other sources, instead of relying on the optional behavior of some clients which would result in quality degradation. ### Why a year? This proposal sets


=== EIP-2583 ===
TITLE: Penalty for account trie misses
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-21
REQUIRES: 

SUMMARY:
This EIP adds a gas penalty for accesses to the account trie, where the address being looked up does not exist. Non-existing accounts can be used in DoS attacks, since they bypass cache mechanisms, thus creating a large discrepancy between 'normal' mode of execution and 'worst-case' execution of an

SPECIFICATION:
We define the constant `penalty` as `TBD` (suggested `2000` gas). For opcodes which access the account trie, whenever the operation is invoked targeting an `address` which does not exist in the trie, then `penalty` gas is deducted from the available `gas`. ### Detailed specification These are the opcodes which

MOTIVATION:
As the ethereum trie becomes more and more saturated, the number of disk lookups that a node is required to do in order to access a piece of state increases too. This means that checking e.g. `EXTCODEHASH` of an account at block `5` was _inherently_ a cheaper operation that

RATIONALE:
With this scheme, we could continue to price these operations based on the 'normal' usage, but gain protection from attacks that try to maximize disk lookups/cache misses. This EIP does not modify anything regarding storage trie accesses, which might be relevant for a future EIP. However, there are a


=== EIP-234 ===
TITLE: Add `blockHash` to JSON-RPC filter options.
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-03-24
REQUIRES: 1474

SUMMARY:
This addition would allow clients to fetch logs for specific blocks, whether those blocks were in the current main chain or not. This resolves some issues that make it difficult/expensive to author robust clients due to the nature of chain reorgs, unreliable network connections and the result set not

SPECIFICATION:
The filter options used by `eth_newFilter` would have an additional optional parameter named `blockHash` whose value is a single block hash. The Ethereum node responding to the request would either send back an error if the block hash was not found or it would return the results matching the

RATIONALE:
A client (dApp) who needs reliable notification of both log additions (on new blocks) and log removals (on chain reorgs) cannot achieve this while relying solely on subscriptions and filters. This is because a combination of a network or remote node failure during a reorg can result in the


=== EIP-7801 ===
TITLE: etha - Sharded Blocks Subprotocol
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2024-10-30
REQUIRES: 7642

SUMMARY:
This EIP proposes the creation of a new subprotocol, `etha`, enabling Ethereum nodes to communicate available block spans via a bitmask. Each bit represents a 100_000-block span within each 1_000_000 block range of chain history. Nodes use this bitmask to signal stored spans and commit to storing future spans

SPECIFICATION:
### Subprotocol Handshake - Introduce a new subprotocol named `etha`. - Define the handshake message for the `etha` subprotocol as follows: - Handshake packet: `[version: P, networkid: P, blockhash: B_32, genesis: B_32, forkid, blockBitmask]` - `blockBitmask` is a 10-bit bitmask, with each bit representing a 100_000-block range per 1_000_000

MOTIVATION:
With [EIP-4444](./eip-4444.md), nodes may prune historical data while others continue serving it. Determining data availability by connecting and requesting blocks is inefficient consuming unnexessary bandwidth. This EIP addresses this inefficiency by enabling nodes to shard chain history into 100_000 block segments and signal availability via a bitmask. By introducing

RATIONALE:
The bitmask approach provides a flexible means to represent and retain block data while committing to future spans. This mechanism aligns with the pruning proposed in EIP-4444, while ensuring that historical and future data spans remain available across the network. A similar bitlist approach is already used in the


=== EIP-4200 ===
TITLE: EOF - Static relative jumps
TYPE: Standards Track Core
STATUS: Review
CREATED: 2021-07-16
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Three new EVM jump instructions are introduced (`RJUMP`, `RJUMPI` and `RJUMPV`) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.

SPECIFICATION:
We introduce three new instructions on the same block number [EIP-3540](./eip-3540.md) is activated on: 1. `RJUMP` (0xe0) - relative jump 2. `RJUMPI` (0xe1) - conditional relative jump 3. `RJUMPV` (0xe2) - relative jump via jump table If the code is legacy bytecode, all of these instructions result in an

MOTIVATION:
A recurring discussion topic is that EVM only has a mechanism for dynamic jumps. They provide a very flexible architecture with only 2 (!) instructions. This flexibility comes at a cost however: it makes analysis of code more complicated and it also (partially) resulted in the need to have

RATIONALE:
### Relative addressing We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code like `PUSHn PC ADD JUMPI`. We do not


=== EIP-2542 ===
TITLE: New opcodes TXGASLIMIT and CALLGASLIMIT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-02-29
REQUIRES: 

SUMMARY:
Currently, there is an existing opcode `0x45 GASLIMIT` that provides access to the block gas limit. While this information may be useful in some cases, it is probably not a value that smart contract developers may be concerned about. The opcode `0x5a GAS` provides the remaining gas, not the

SPECIFICATION:
If block.number >= TBD, add three new opcodes: TXGASLIMIT: 0x5c Pushes the gas limit of the entire transaction onto the stack. This is a value of the 'startgas' parameter signed by the externally owned account. Gas costs: 2 (same as `GASLIMIT`) CALLGASLIMIT: 0x5d Pushes the gas limit of the

MOTIVATION:
As concepts of relaying, meta-transactions, gas fees, and account abstraction gain popularity, it becomes critical for some contracts to be able to track gas expenditure with absolute precision. Without access to this data on an EVM level, such contracts resort to approximation, mimicking EVM logic on-chain, and some use-cases

RATIONALE:
Consider a solidity smart contract that wants to know how much gas the entire transaction or a part of it had consumed. It is not entirely possible with the current EVM. With proposed changes, using a pseudo-Solidity syntax, this information would be easily available: ``` function keepTrackOfGas(string memory message,


=== EIP-7650 ===
TITLE: Programmable access lists
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-10
REQUIRES: 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new precompiled contract named `prefetch`, which accepts an `accessList`. The `accessList` specifies a list of addresses and local storage keys; these addresses and local storage keys are added into the `accessed_addresses` and `accessed_storage_keys` global sets (introduced in [EIP-2929](./eip-2929.md)). Similar to [EIP-2930](./eip-2930.md), prefetching data through this precompile

SPECIFICATION:
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Parameters | Constant | Value | | ----------------------------- | ----- | | `FORK_BLOCK_NUMBER` | `TBD` | | `PREFETCH_PRECOMPILE_ADDRESS` | `TBD`

MOTIVATION:
The primary goal of this EIP is to enhance EIP-2930 by enabling contracts to add access lists programmatically. The advantage of implementing this precompile within a contract is the sustained reduction in gas costs for data access operations, leveraging the concurrent computing and IOs that most nodes have.

RATIONALE:
### Charging less for accesses in the access list Similar to EIP-2930, we encourage contract developers to use the `prefetch` precompile as much as possible, especially assuming the nodes have some decent concurrent capabilities (e.g., some cores and IO bandwidth). ### Allowing duplicates Similar to EIP-2930, we allow duplicates


=== EIP-197 ===
TITLE: Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-06
REQUIRES: 

SUMMARY:
This EIP suggests to add precompiled contracts for a pairing function on a specific pairing-friendly elliptic curve. This can in turn be combined with [EIP-196](./eip-196.md) to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because

SPECIFICATION:
For blocks where `block.number >= BYZANTIUM_FORK_BLKNUM`, add a precompiled contracts for a bilinear function on groups on the elliptic curve "alt_bn128". We will define the precompiled contract in terms of a discrete logarithm. The discrete logarithm is of course assumed to be hard to compute, but we will give

MOTIVATION:
Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of

RATIONALE:
The specific curve `alt_bn128` was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts. The feature of adding curve and


=== EIP-6789 ===
TITLE: Rename gas to mana
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2023-03-27
REQUIRES: 

SUMMARY:
This EIP suggests renaming `gas` to `mana`, as proposed by Vitalik Buterin in 2015.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The core term `gas` MUST be renamed to `mana`. The following opcodes MUST be renamed:

MOTIVATION:
The underlying motivation for reviving Vitalik's original proposal from 2015 is that we have finally arrived at the age of Proof-of-Stake, and given the roadmap ahead (i.e. "The Surge", "The Scourge", "The Verge", "The Purge", and "The Splurge"), I consider this moment as the last opportunity to make such

RATIONALE:
- `mana` reflects the increased environmental friendliness of Proof-of-Stake; - `mana` is generally understood to be ephemeral and non-transferable, which better represents the concept of `gas`; and - `mana` is generally portrayed as renewable, while (natural) `gas` is non-renewable.


=== EIP-3030 ===
TITLE: BLS Remote Signer HTTP API
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-09-30
REQUIRES: 

SUMMARY:
A [validator](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/validator.md) client contributes to the consensus of the Eth2 blockchain by signing proposals and attestations of blocks, using a BLS private key which must be available to this client at all times. The BLS remote signer API is designed to be consumed by validator clients, looking for a

SPECIFICATION:
### `GET /upcheck` _**Responses**_ Success | <br> --- | --- Code | `200` Content | `{"status": "OK"}` --- ### `GET /keys` Returns the identifiers of the keys available to the signer. _**Responses**_ Success | <br> --- | --- Code | `200` Content | `{"keys": "[identifier]"}` --- ### `POST /sign/:identifier`

MOTIVATION:
Eth2 utilizes [BLS12-381](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/) signatures. Consensus on the eth2 Blockchain is achieved via the proposal and attestation of blocks from validator clients, using a BLS private key (_signing_ key) which must be available each time a message is signed: that is, at least once every epoch (6.4 minutes), during a

RATIONALE:
### UNIX philosophy: Simple API This API specification contains only three methods: one for **status**, one for **listing the available keys**, and one to **produce a signature**. There are no methods for authentication, key management, nor transport encryption. The following subsections discuss aspects to be considered by the client


=== EIP-7503 ===
TITLE: Zero-Knowledge Wormholes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-08-14
REQUIRES: 

SUMMARY:
While researching on privacy solutions and applications of ZKP, we discovered a technique, by which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, and later build a ZK proof showing that some amount of tokens reside in an account that are unspendable,

SPECIFICATION:
In Elliptic-Curve based digital signatures, normally there is a secret scalar $s$, from which a public-key is calculated (By multiplying the generator point with the scalar: $s \times G$). An Ethereum EOA-address is the keccak hash of a public-key. Also, the funds in an Ethereum address might be spendable

RATIONALE:
Cryptocurrency mixers like TornadoCash can successfully obfuscate Ethereum transactions, but it's easy for the governments to ban usage of them. Anybody who has interactions with a mixer contract, whether the sender or receiver, can get marked. However this EIP tries to minimize the privacy leakage of the senders, by


=== EIP-2464 ===
TITLE: eth/65: transaction announcements and retrievals
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-01-13
REQUIRES: 2364

SUMMARY:
This EIP introduces three additional message types into the `eth` protocol (releasing a new version, `eth/65`): `NewPooledTransactionHashes (0x08)` to announce a set of transactions without their content; `GetPooledTransactions (0x09)` to request a batch of transactions by their announced hash; and `PooledTransactions (0x0a)` to reply to a transaction request. This

SPECIFICATION:
Add three new message types to the `eth` protocol: * `NewPooledTransactionHashes (0x08): [hash_0: B_32, hash_1: B_32, ...]` * Specify one or more transactions that have appeared in the network and which have **not yet been included in a block**. To be maximally helpful, nodes should inform peers of all

MOTIVATION:
The `eth` network protocol has two ways to propagate a newly mined block: it can be broadcast to a peer in its entirety (via `NewBlock (0x07)` in `eth/64` and prior or it can be announced only (via `NewBlockHashes (0x01)`). This duality allows nodes to do the high-bandwidth broadcasting (10s-100s

RATIONALE:
**Q: Why limit `GetPooledTransactions (0x09)` to retrieving items from the pool?** Apart from the transaction pool, transactions in Ethereum are always bundled together by the hundreds in block bodies and existing network retrievals honor this data layout. Allowing direct access to individual transactions in the database has no actionable


=== EIP-7587 ===
TITLE: Reserve Precompile Address Range for RIPs
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-21
REQUIRES: 

SUMMARY:
This EIP reserves precompile ranges to ensure there are no conflicts with those used by the Rollup Improvement Proposal (RIP) process.

SPECIFICATION:
The address range between `0x0000000000000000000000000000000000000100` and `0x00000000000000000000000000000000000001ff` is reserved for use by the RIP process.

MOTIVATION:
As L2s begin to deploy RIPs, it is necessary to reserve an address range for use by the RIP process so as to ensure there are no conflicts between precompile addresses used by RIPs and EIPs.

RATIONALE:
By reserving an address range for RIPs, it allows the RIP process to maintain its own registry of precompiles that are not (necessarily) deployed on L1 mainnet, the EIP process is freed from having to maintain a registry of RIP precompiles while still having 255 addresses for its own


=== EIP-6110 ===
TITLE: Supply validator deposits on chain
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-12-09
REQUIRES: 7685

SUMMARY:
Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (or `eth1data`) voting from the Consensus Layer. Validator deposits list supplied in a block is obtained by parsing deposit contract log events

SPECIFICATION:
### Execution Layer #### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | *TBD* | Mainnet | |`DEPOSIT_REQUEST_TYPE` | `b'0'` | The [EIP-7685](./eip-7685.md) request type byte for deposit operation | #### Configuration | Name | Value | Comment | | -

MOTIVATION:
Validator deposits are a core component of the proof-of-stake consensus mechanism. This EIP allows for an in-protocol mechanism of deposit processing on the Consensus Layer and eliminates the proposer voting mechanism utilized currently. This proposed mechanism relaxes safety assumptions and reduces complexity of client software design, contributing to the

RATIONALE:
### `index` field The `index` field may appear unnecessary but it is important information for deposit processing flow on the Consensus Layer. ### Not limiting the size of deposit operations list The list is unbounded because of negligible data complexity and absence of potential DoS vectors. See [Security Considerations](#security-considerations)


=== EIP-6988 ===
TITLE: Elected block proposer has not been slashed
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-05-04
REQUIRES: 

SUMMARY:
Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.

SPECIFICATION:
Specification of the proposed change can be found in [`/_features/eip6988/beacon-chain.md`](https://github.com/ethereum/consensus-specs/blob/0ad3972725e7c22e8edf3bab2dd7730acbe3c272/specs/_features/eip6988/beacon-chain.md).

MOTIVATION:
A block proposed by a slashed validator is rejected by the corresponding validity check in the [`phase0/process_block_header`](https://github.com/ethereum/consensus-specs/blob/3115d1140b23dd4c9c23fbd9e2428186cf816bde/specs/phase0/beacon-chain.md#block-header) function as defined in the consensus layer specification. At the same time the definition of the [`phase0/compute_proposer_index`](https://github.com/ethereum/consensus-specs/blob/3115d1140b23dd4c9c23fbd9e2428186cf816bde/specs/phase0/beacon-chain.md#compute_proposer_index) allows for a slashed validator to be elected as a proposer. This contradiction effectively leads

RATIONALE:
### Modifying `get_beacon_proposer_index` This function is modified to read a proposer index from a beacon state if a slot of a latest block header is the same as the `state.slot`. This modification is done to make the function return correct proposer index in the case when the proposer of


=== EIP-6780 ===
TITLE: SELFDESTRUCT only in same transaction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-03-25
REQUIRES: 2, 6, 8, 1, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 2, 9

SUMMARY:
This EIP changes the functionality of the `SELFDESTRUCT` opcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved when `SELFDESTRUCT` is called in the same transaction a contract was created.

SPECIFICATION:
The behaviour of `SELFDESTRUCT` is changed in the following way: 1. When `SELFDESTRUCT` is executed in a transaction that is not the same as the contract calling `SELFDESTRUCT` was created: - The current execution frame halts. - `SELFDESTRUCT` does not delete any data (including storage keys, code, or the

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root

RATIONALE:
Getting rid of the `SELFDESTRUCT` opcode has been considered in the past, and there are currently no strong reasons to use it. This EIP implements a behavior that will attempt to leave some common uses of `SELFDESTRUCT` working, while reducing the complexity of the change on EVM implementations that


=== EIP-2159 ===
TITLE: Common Prometheus Metrics Names for Clients
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-07-01
REQUIRES: 

SUMMARY:
Many Ethereum clients expose a range of metrics in a format compatible with Prometheus to allow operators to monitor the client's behaviour and performance and raise alerts if the chain isn't progressing or there are other indications of errors. While the majority of these metrics are highly client-specific, reporting

SPECIFICATION:
The table below defines metrics which may be captured by Ethereum clients which expose metrics to Prometheus. Clients may expose additional metrics however these should not use the `ethereum_` prefix. | Name | Metric type | Definition | JSON-RPC Equivalent | |----------------------------------|-------------|-------------------------------------------------------------------|---------------------------------------------------------------------| | ethereum_blockchain_height | Gauge | The current

MOTIVATION:
Using common names and meanings for metrics which apply to all clients allows node operators to monitor clusters of nodes using heterogeneous clients using a single dashboard and alerting configuration. Currently there are no agreed names or meanings, leaving client developers to invent their own making it difficult to

RATIONALE:
The defined metrics are independent of Ethereum client implementation but provide sufficient information to create an overview dashboard to support monitoring a group of Ethereum nodes. There is a similar, though more prescriptive, specification for beacon chain client metrics. The specific details of how to expose the metrics has


=== EIP-6206 ===
TITLE: EOF - JUMPF and non-returning functions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-12-21
REQUIRES: 4, 7, 5, 0, ,,  , 5, 4, 5, 0

SUMMARY:
This EIP allows for tail call optimizations in EOF functions ([EIP-4750](./eip-4750.md)) by introducing a new instruction `JUMPF`, which jumps to a code section without adding a new return stack frame. Additionally the format of the type sections is extended to allow declaring sections as non-returning, with simplified stack validation

SPECIFICATION:
### Type section changes We define a non-returning section as one that cannot return control to its caller section. Type section `outputs` field contains a special value `0x80` when corresponding code section is non-returning. See [Non-returning status validation](#non-returning-status-validation) below for validation details. The first code section MUST have 0

MOTIVATION:
It is common for functions to make a call at the end of the routine only to then return. `JUMPF` optimizes this behavior by changing code sections without needing to update the return stack. Knowing at validation time that a function will never return control allows for `JUMPF` to

RATIONALE:
### Allowing `JUMPF` to section with less outputs An alternative rule for `JUMPF` stack validation could require the target section's outputs to be exactly equal to the current section's outputs. Under such rule, a particular target section (a shared "helper" piece of code) would only "match" sections (requiring some


=== EIP-3 ===
TITLE: Addition of CALLDEPTH opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2015-11-19
REQUIRES: 


=== EIP-7266 ===
TITLE: Remove BLAKE2 compression precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-03
REQUIRES: 

SUMMARY:
This EIP removes the [`blake2f`](./eip-152.md) (`0x09`) precompile by changing the precompile behaviour to result in an exceptional abort.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. All `CALL`, `CALLCODE`, `DELEGATECALL`, and `STATICCALL` invocations to the `blake2f` precompile address `0x09` MUST result

MOTIVATION:
[EIP-152](./eip-152.md) has never capitalised on a real-world use case. This fact is clearly reflected in the number of times the address `0x09` has been invoked (numbers from the date this EIP was created): - The most recent call took place on 6 October 2022. - Since its gone live

RATIONALE:
The EVM should be optimised for simplicity and future-proofness. The original Yellow Paper states: _these are so-called 'precompiled' contracts, meant as a preliminary piece of architecture that may later become native extensions_. Considering that no use cases have been realised in the last 3.5 years, we can conclude that


=== EIP-2681 ===
TITLE: Limit account nonce to 2^64-1
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-04-25
REQUIRES: 

SUMMARY:
Limit account nonce to be between `0` and `2^64-1`.

SPECIFICATION:
Introduce two new restrictions retroactively from genesis: 1. Consider any transaction invalid, where the nonce exceeds or equals to `2^64-1`. 2. The `CREATE` and `CREATE2` instructions' execution ends with the result `0` pushed on stack, where the account nonce is `2^64-1`. Gas for initcode execution is not deducted in

MOTIVATION:
Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way. Additionally it could prove beneficial to transaction formats, where some improvements

RATIONALE:
1. It is unlikely for any nonce to reach or exceed the proposed limit. If one would want to reach that limit via external transactions, it would cost at least `21000 * (2^64-1) = 387_381_625_547_900_583_915_000` gas. 2. It must be noted that in the past, in the Morden testnet,


=== EIP-6 ===
TITLE: Renaming SUICIDE opcode
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2015-11-22
REQUIRES: 

SUMMARY:
The solution proposed in this EIP is to change the name of the `SUICIDE` opcode in Ethereum programming languages with `SELFDESTRUCT`. ### Motivation Mental health is a very real issue for many people and small notions can make a difference. Those dealing with loss or depression would benefit from

MOTIVATION:
Mental health is a very real issue for many people and small notions can make a difference. Those dealing with loss or depression would benefit from not seeing the word suicide in our programming languages. By some estimates, 350 million people worldwide suffer from depression. The semantics of Ethereum's


=== EIP-1588 ===
TITLE: Hardfork Meta: Ethereum ProgPoW
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-11-16
REQUIRES: 1057

SUMMARY:
This meta-EIP specifies the changes included in the alternative Ethereum hardfork named Ethereum ProgPoW.

SPECIFICATION:
- Codename: Ethereum ProgPoW - Aliases: N/A - Activation: - `Block >= 7280000` on the Ethereum mainnet - Included EIPs: - [EIP-1057](./eip-1057.md): ProgPoW, a Programmatic Proof-of-Work


=== EIP-7612 ===
TITLE: Verkle state transition via an overlay tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-01-25
REQUIRES: 4, 7, 6, 2, ,,  , 6, 8, 0, 0, ,,  , 7, 5, 4, 5

SUMMARY:
This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT “laid over” the hexary MPT. The historical MPT state is

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants | Parameter | value | Description | | ----------- | ----- | --------------------------------------------

MOTIVATION:
The Ethereum state is growing, and VKTs offer a good mitigation strategy to stem this growth and enable weak statelessness. Owing to the difficulty of translating contracts with large storage while they are being accessed, proposals for migrating the current MPT state are complex and will require client teams

RATIONALE:
This approach doesn't convert the state, which is left to a subsequent EIP. This is meant as a stopgap in case we decide to push the conversion itself to a later time. It has the advantage of simplicity, which means that the Verge fork could happen at the same


=== EIP-152 ===
TITLE: Add BLAKE2 compression function `F` precompile
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-04
REQUIRES: 

SUMMARY:
This EIP introduces a new precompiled contract which implements the compression function `F` used in the BLAKE2 cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and Zcash, as well as introducing more flexible cryptographic hash primitives to the EVM.

SPECIFICATION:
We propose adding a precompiled contract at address `0x09` wrapping the [BLAKE2 `F` compression function](https://tools.ietf.org/html/rfc7693#section-3.2). The precompile requires 6 inputs tightly encoded, taking exactly 213 bytes, as explained below. The encoded inputs are corresponding to the ones specified in the [BLAKE2 RFC Section 3.2](https://tools.ietf.org/html/rfc7693#section-3.2): - `rounds` - the number

MOTIVATION:
Besides being a useful cryptographic hash function and SHA3 finalist, BLAKE2 allows for efficient verification of the Equihash PoW used in Zcash, making a BTC Relay - style SPV client possible on Ethereum. A single verification of an Equihash PoW verification requires 512 iterations of the hash function, making

RATIONALE:
BLAKE2 is an excellent candidate for precompilation. BLAKE2 is heavily optimized for modern 64-bit CPUs, specifically utilizing 24 and 63-bit rotations to allow parallelism through SIMD instructions and little-endian arithmetic. These characteristics provide exceptional speed on native CPUs: 3.08 cycles per byte, or 1 gibibyte per second on an


=== EIP-2069 ===
TITLE: Recommendation for using YAML ABI in ERCs/EIPs
TYPE: Informational 
STATUS: Stagnant
CREATED: 2017-02-11
REQUIRES: 

SPECIFICATION:
The [Standard Contract ABI] is usually represented as a JSON object. This works well and several tools – including compilers and clients – support it to handle data encoding. One shortcoming of the JSON description is its inability to contain comments. To counter this, we suggest the use of

MOTIVATION:
In the past, most ERCs/EIPs included an ABI description purely as a Solidity contract and/or interface. This has several drawbacks: - Prefers a single language over others and could hinder the development of new languages. - Locks the specification to a certain version of the Solidity language. - Allows

RATIONALE:
The aim was to chose a representation which is well supported by tools and supports comments. While inventing a more concise description language seems like a good idea, it felt as an unnecessary layer of complexity.


=== EIP-6046 ===
TITLE: Replace SELFDESTRUCT with DEACTIVATE
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-11-25
REQUIRES: 2, 6, 8, 1, ,,  , 2, 9, 2, 9, ,,  , 3, 5, 2, 9

SUMMARY:
Change `SELFDESTRUCT` to not delete all storage keys, and to use a special value in the account nonce to signal *deactivated* accounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction to `DEACTIVATE`.

SPECIFICATION:
1. Change the rules introduced by [EIP-2681](./eip-2681.md) such that regular nonce increase is bound by `2^64-2` instead of `2^64-1`. This applies from genesis. 2. The behaviour of `SELFDESTRUCT` is changed such that: - Does not delete any storage keys and also leave the account in place. - Transfer the

MOTIVATION:
The `SELFDESTRUCT` instruction currently has a fixed price, but is unbounded in terms of how many storage/account changes it performs (it needs to delete all keys). This has been an outstanding concern for some time. Furthermore, with *Verkle trees*, accounts will be organised differently: account properties, including storage, will

RATIONALE:
There have been various proposals of removing `SELFDESTRUCT` and many would just outright remove the deletion capability. This breaks certain usage patterns, which the *deactivation* option leaves intact, albeit with minor changes. This only affects *newly* deployed code, and not existing one. All the proposals would leave data in


=== EIP-7691 ===
TITLE: Blob throughput increase
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-04-17
REQUIRES: 

SUMMARY:
Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.

SPECIFICATION:
### Parameters | Constant | Value | |------------------------------------------|---------------------| | `MAX_BLOBS_PER_BLOCK_ELECTRA` | `9` | | `TARGET_BLOBS_PER_BLOCK_ELECTRA` | `6` | | `MAX_BLOB_GAS_PER_BLOCK` | `1179648` | | `TARGET_BLOB_GAS_PER_BLOCK` | `786432` | | `BLOB_BASE_FEE_UPDATE_FRACTION_ELECTRA` | `5007716` | `MAX_BLOBS_PER_BLOCK_ELECTRA` and `TARGET_BLOBS_PER_BLOCK_ELECTRA` are consumed by the consensus layer clients, and starting at `PECTRA_FORK_EPOCH` replace the

MOTIVATION:
Ethereum, with its rollup centric roadmap, scales by relying on L2. Since the Dencun fork, the blob gas target and maximum was set to 3/6 respectively. The blob gas limit was arrived at based on a series of big block tests performed on the Ethereum mainnet network as well

RATIONALE:
### Simplicity The EIP aims to minimize the amount of testing and implementation effort from the perspective of the client teams, to allow for more resources to be allocated to peerDAS and other scaling research. While this EIP may not achieve the new optimal blob limit, it offers a


=== EIP-3455 ===
TITLE: SUDO Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-01
REQUIRES: 

SUMMARY:
A new opcode, `SUDO`, is introduced with the same parameters as `CALL`, plus another parameter to specify the sender address.

SPECIFICATION:
Adds a new opcode (`SUDO`) at `0xf8`. `SUDO` pops 8 parameters from the stack. Besides the sender parameter, the parameters shall match `CALL`. 1. Gas: Integer; Maximum gas allowance for message call, safely using current gas counter if the counter is lower 2. Sender: Address, truncated to lower 40

MOTIVATION:
There are many use cases for being able to set the sender. Many tokens are stuck irretrievably because nobody has the key for the owner address. In particular, at address zero there is approximately 17 billion USD in tokens and ether, according to etherscan. With `SUDO`, anyone could free

RATIONALE:
The `GAS` parameter is first so that callers can tediously compute how much of their remaining gas to send at the last possible moment. The remaining parameters inherited from `CALL` are in the same order, with sender inserted between.


=== EIP-7666 ===
TITLE: EVM-ify the identity precompile
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.

SPECIFICATION:
| Parameter | Value | | - | - | | `IDENTITY_PRECOMPILE_ADDRESS` | `0x0000....0004` | | `EVM_CODE` | `0x365f5f37365ff3` | At the start of the block in which this fork activates, set the code of `IDENTITY_PRECOMPILE_ADDRESS` to `EVM_CODE`. Starting from and including that block, `IDENTITY_PRECOMPILE_ADDRESS` should no longer be

MOTIVATION:
Ethereum today has a large number of precompiles. Nearly half of these precompiles are not seeing significant use, and are contributing to ongoing maintenance cost and risk of consensus bugs, as well as increased development effort for new Ethereum client implementations, including ZK-EVMs and implementations in formal-verification-friendly languages. This

RATIONALE:
The given `EVM_CODE` corresponds to ``` CALLDATASIZE PUSH0 PUSH0 CALLDATACOPY CALLDATASIZE PUSH0 RETURN ``` Which copies calldata into memory, and then returns the same memory slice. This is thus a minimally disruptive change to Ethereum that preserves functionality, and accomplishes the goal of reducing the number of precompiles by


=== EIP-2930 ===
TITLE: Optional access lists
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-08-29
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 2, 9

SUMMARY:
We introduce a new [EIP-2718](./eip-2718.md) transaction type, with the format `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])`. The `accessList` specifies a list of addresses and storage keys; these addresses and storage keys are added into the `accessed_addresses` and `accessed_storage_keys` global sets (introduced in

SPECIFICATION:
### Definitions **`TransactionType`** `1`. See [EIP-2718](./eip-2718.md) **`ChainId`** The transaction only valid on networks with this `chainID`. **`YParity`** The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature. ### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | 12244000 |

MOTIVATION:
This EIP serves two functions: 1. Mitigates contract breakage risks introduced by [EIP-2929](./eip-2929.md), as transactions could pre-specify and pre-pay for the accounts and storage slots that the transaction plans to access; as a result, in the actual execution, the SLOAD and EXT* opcodes would only cost 100 gas: low

RATIONALE:
### Charging less for accesses in the access list This is done to encourage transactions to use the access list as much as possible, and because processing transactions is easier when their storage reads are predictable (because clients can pre-load the data from databases and/or ask for witnesses at


=== EIP-3690 ===
TITLE: EOF - JUMPDEST Table
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-06-23
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0

SUMMARY:
Introduce a section in the EOF format ([EIP-3540](./eip-3540.md)) for storing the list of `JUMPDEST`s, validate the correctness of this list at the time of contract creation, and remove the need for `JUMPDEST`-analysis at execution time. In EOF contracts, the `JUMPDEST` instruction is not needed anymore and becomes invalid. Legacy

SPECIFICATION:
This feature is introduced on the very same block [EIP-3540](./eip-3540.md) is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps. *Remark:* We rely on the notation of *initcode*, *code* and *creation* as defined by [EIP-3540](./eip-3540.md), and extend validation rules of [EIP-3670](./eip-3670.md). ### EOF container changes

MOTIVATION:
Currently existing contracts require no validation of correctness, but every time they are executed, a list must be built containing all the valid jump-destinations. This is an overhead which can be avoided, albeit the effect of the overhead depends on the client implementation. With the structure provided by EIP-3540

RATIONALE:
### Jumpdests section is bounded The length of the `jumpdests` section is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any valid `jumpdests` section may not be more larger than 0x3000. ### Delta encoding


=== EIP-908 ===
TITLE: Reward clients for a sustainable network
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-03-01
REQUIRES: 

SUMMARY:
The tragedy of the commons is a phenomenon that is well known in many sectors, most notably in regard to sustainability. It involves the over-utilization of shared finite resources, which detriments all participants and stakeholders involved (which in the case of a global public good can be everyone, including

SPECIFICATION:
Add a new field to each block called `PrevBlockVerifications`, which is an arbitrary, unlimited size byte array. When a client verifies that a previous block is [valid](https://ethereum.github.io/yellowpaper/paper.pdf#subsubsection.4.3.2), the client appends a user agent to PrevBlockVerifications via an opcode in a transaction, PREV_BLOCK_VERIF. The user agent is a vector with

MOTIVATION:
Currently there is a lack of incentives for anyone to run a full node, while joining a mining pool is not really economical if one has to purchase a mining rig (several GPUs) now, since there is unlikely to be a return on investment by the time that Ethereum

RATIONALE:
### A rough qualitative analysis of fees As of May 4 2018, there are [16428 nodes](https://web.archive.org/web/20180504051128/https://ethernodes.org/network/1). Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented,


=== EIP-3198 ===
TITLE: BASEFEE opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-01-13
REQUIRES: 1559

SUMMARY:
Add a `BASEFEE (0x48)` that returns the value of the base fee of the current block it is executing in.

SPECIFICATION:
Add a `BASEFEE` opcode at `(0x48)`, with gas cost `G_base`. | Op | Input | Output | Cost | |:----: |:-----: |:------: |:----: | | 0x48 | 0 | 1 | 2 |

MOTIVATION:
The intended use case would be for contracts to get the value of the base fee. This feature would enable or improve existing use cases, such as: - Contracts that need to set bounties for anyone to "poke" them with a transaction could set the bounty to be `BASEFEE

RATIONALE:
### Gas cost The value of the base fee is needed to process transactions. That means it's value is already available before running the EVM code. The opcode does not add extra complexity and additional read/write operations, hence the choice of `G_base` gas cost.


=== EIP-4750 ===
TITLE: EOF - Functions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2022-01-10
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 5, 4, 5, 0

SUMMARY:
Introduce the ability to have several code sections in EOF-formatted ([EIP-3540](./eip-3540.md)) bytecode, each one representing a separate subroutine/function. Two new opcodes,`CALLF` and `RETF`, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.

SPECIFICATION:
### Type Section The type section of EOF containers must adhere to following requirements: 1. The section is comprised of a list of metadata where the metadata index in the type section corresponds to a code section index. Therefore, the type section size MUST be `n * 4` bytes,

MOTIVATION:
Currently, in the EVM everything is a dynamic jump. Languages like Solidity generate most jumps in a static manner (i.e. the destination is pushed to the stack right before, `PUSHn .. JUMP`). Unfortunately however this cannot be used by most EVM interpreters, because of added requirement of validation/analysis. This

RATIONALE:
### `RETF` in the top frame ends execution vs exceptionally halts vs is not allowed during validation Alternative logic for `RETF` in the top frame could be to allow it during code validation and make it either: - end execution if the return stack is emptied by the `RETF`


=== EIP-3860 ===
TITLE: Limit and meter initcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-16
REQUIRES: 170

SUMMARY:
We extend [EIP-170](./eip-170.md) by introducing a maximum size limit for `initcode` (`MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152`). Furthermore, we introduce a charge of `2` gas for every 32-byte chunk of `initcode` to represent the cost of jumpdest-analysis. Lastly, the size limit results in the nice-to-have property that EVM

SPECIFICATION:
### Parameters | Constant | Value | | -------------------- | ------------------- | | `INITCODE_WORD_COST` | `2` | | `MAX_INITCODE_SIZE` | `2 * MAX_CODE_SIZE` | Where `MAX_CODE_SIZE` is defined by [EIP-170](./eip-170.md) as `24576`. We define `initcode_cost(initcode)` to equal `INITCODE_WORD_COST * ceil(len(initcode) / 32)`. ### Rules 1. If length of transaction

MOTIVATION:
During contract creation the client has to perform jumpdest-analysis on the `initcode` prior to execution. The work performed scales linearly with the size of the `initcode`. This work currently is not metered, nor is there a protocol enforced upper bound for the size. There are three costs charged today:

RATIONALE:
### Gas cost constant The value of `INITCODE_WORD_COST` is selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance of `KECCAK256` hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU. | EVM


=== EIP-7823 ===
TITLE: Set upper bounds for MODEXP
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-11
REQUIRES: 198

SUMMARY:
Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.

SPECIFICATION:
Recap from [EIP-198](./eip-198.md): > At address `0x00……05`, add a precompile that expects input in the following format: > > `<length_of_BASE> <length_of_EXPONENT> <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>` We introduce an upper bound to the inputs of the precompile, each of the length inputs (`length_of_BASE`, `length_of_EXPONENT` and `length_of_MODULUS`) MUST be less than

MOTIVATION:
The MODEXP precompile has been a source of numerous consensus bugs. Many of them were due to specifically crafted cases using impractical input lengths. Its pricing function is also quite complex given its nature of unbounded inputs. While we don't suggest to rework the pricing function, it may be

RATIONALE:
### Limit This upper bound allows the existing use cases of MODEXP: 1. RSA verification with up to 8192 bit keys. Commonly used ones are 1024/2048/4196 bits. 2. Elliptic curve related use cases are usually less than 384 bits. ### EVMMAX Replacing the precompile with EVM code using an


=== EIP-2844 ===
TITLE: Add DID related methods to the JSON-RPC
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-08-01
REQUIRES: 

SUMMARY:
This EIP describes three new methods to add to the JSON-RPC that enables wallets to support *Decentralized Identifiers* (DIDs) as well as *JSON Object Signing and Encryption* (JOSE). These standards enables wallets to support data decryption as well as authenticated data, both in standard formats using JOSE. With these

SPECIFICATION:
Three new JSON-RPC methods are specified under the new `did_*` prefix. ### Auth Authenticate the current rpc connection to the DID methods. Prompt the user to give permission to the current connection to access the user DID and the given `paths`. ##### Method: `did_authenticate` ##### Params: * `nonce` -

MOTIVATION:
There has been one main previous effort ([#130](https://github.com/ethereum/EIPs/issues/130), [#1098](https://github.com/ethereum/EIPs/pull/1098)) to add decryption to Ethereum wallets in a standard way. This previous approach used a non standard way to encode and represent data encrypted using `x25519-xsalsa20-poly1305`. While this approach does provide a functional way to add encryption support to wallets,

RATIONALE:
This EIP chooses to rely on DIDs and JOSE since there is already support for these standards in many places, by current systems and new systems. By using DIDs and JOSE wallet implementers can also choose which signing and encryption algorithms that they want to support, since these formats


=== EIP-6690 ===
TITLE: EVM Modular Arithmetic Extensions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-03-15
REQUIRES: 

SUMMARY:
This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1

SPECIFICATION:
### Constants | Name | Value | Description | | ---- | ---- | ---- | | `COST_SETMODX_BASE` | 1 | static cost component for the `SETMODX` opcode | | `COST_STOREX_BASE` | 1 | static cost for the `STOREX` opcode | | `COST_LOADX_BASE` | 1 | static cost for

MOTIVATION:
Current opcodes for modular arithmetic only support values up to 256 bits wide. In addition, they are permissive and accept any representable value for the inputs. Many cryptographic operations are heavily-bottlenecked by modular arithmetic. To expand the range of cryptographic primitives that can be implemented efficiently as EVM contracts,

RATIONALE:
### Separation of EVM Memory and EVMMAX Virtual Register Space It is assumed that optimized implementations will not store values in EVM-compatible big-endian serialization format, but instead convert them to an internal working representation. The costs in the spec explicitly reflect the choice of Montgomery form as an optimal


=== EIP-5593 ===
TITLE: Restrict Ethereum Provider API Injection
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-09-05
REQUIRES: 1193

SUMMARY:
Historically the web platform has had a notion of “powerful” APIs like those defined in W3C's Geolocation specification and W3C's Mediastreams specification, which are subject to additional security restrictions such as those defined by W3C's secure contexts specification. Since the Ethereum Provider APIs allow dApp websites to request access

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### Restrictions for providers The provider objects, e.g. `window.ethereum`, are expected to only inject the Ethereum Provider APIs in secure

MOTIVATION:
Wallets are oftentimes maintaining security and safety of users' funds that can be equivalent to large portions of money. For this reason, it's a good idea to restrict access to the Ethereum Provider APIs to align it with other powerful APIs on the web platform. This will assist in

RATIONALE:
By limiting the capabilities of where the Ethereum Provider APIs are being injected we can reduce the surface area of where attacks can be executed. Given the sensitivity of data that's passed to the Ethereum Provider APIs some basic levels of authentication and confidentiality should be met in order


=== EIP-4396 ===
TITLE: Time-Aware Base Fee Calculation
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-10-28
REQUIRES: 

SUMMARY:
This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle,

SPECIFICATION:
Using the pseudocode language of [EIP-1559](./eip-1559.md), the updated base fee calculation becomes: ```python ... BASE_FEE_MAX_CHANGE_DENOMINATOR = 8 BLOCK_TIME_TARGET = 12 MAX_GAS_TARGET_PERCENT = 95 class World(ABC): def validate_block(self, block: Block) -> None: parent_gas_limit = self.parent(block).gas_limit parent_block_time = self.parent(block).timestamp - self.parent(self.parent(block)).timestamp parent_base_gas_target = parent_gas_limit // ELASTICITY_MULTIPLIER parent_adjusted_gas_target = min(parent_base_gas_target * parent_block_time

MOTIVATION:
The current base fee calculation chooses the gas usage of a block as the signal to determine whether demand for block space is too low (indicating that the base fee should be lowered) or too high (indicating that the base fee should be increased). While simple, this choice of

RATIONALE:
### Mechanism The proposed new base fee calculation only adjusts the block gas target by scaling it with the block time, capped at a maximum percent of the overall block gas limit: #### Current Base Fee Calculation ![](../assets/eip-4396/old_formula.png) #### Proposed Base Fee Calculation ![](../assets/eip-4396/new_formula.png) This new calculation thus targets


=== EIP-1355 ===
TITLE: Ethash 1a
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-08-26
REQUIRES: 

SPECIFICATION:
1. Define hash function `fnv1a()` as ```python def fnv1a(v1, v2): return ((v1 ^ v2) * FNV1A_PRIME) % 2**32 ``` where `FNV1A_PRIME` is 16777499 or 16777639. 2. Change the hash function that determines the DAG item index in Ethash algorithm from `fnv()` to new `fnv1a()`. In [Main Loop](https://github.com/ethereum/wiki/wiki/Ethash#main-loop) change ```python

MOTIVATION:
Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.

RATIONALE:
The usual argument for decentralization and network security. Unless programmable, an ASIC is hardwired to perform sequential operations in a given order. fnv1a changes the order in which an exclusive-or and a multiply are applied, effectively disabling the current wave of ASICS. A second objective is minimize ethash changes


=== EIP-868 ===
TITLE: Node Discovery v4 ENR Extension
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2018-02-02
REQUIRES: 8, ,,  , 7, 7, 8


=== EIP-7825 ===
TITLE: Transaction Gas Limit Cap
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-23
REQUIRES: 

SUMMARY:
This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 30 million gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the Gas

SPECIFICATION:
### Gas Cap - Enforce a protocol-level maximum of **30 million gas** for any single transaction. - This cap applies regardless of the block gas limit set by miners or validators. - Transactions specifying gas limits higher than 30 million gas will be rejected with an appropriate error code

MOTIVATION:
Currently, transactions can theoretically consume up to the entire block gas limit, which poses several risks: 1. **DoS Attacks**: A single transaction consuming most or all of the block gas can result in uneven load distribution and impact network stability. 2. **State Bloat Risks**: High-gas transactions often result in

RATIONALE:
### Why 30 Million? The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space


=== EIP-858 ===
TITLE: Reduce block reward and delay difficulty bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-01-29
REQUIRES: 

SUMMARY:
The current public Ethereum network has a hashrate that corresponds to a tremendous level of energy consumption. As this energy consumption has a correlated environmental cost the network participants have an ethical obligation to ensure this cost is not higher than necessary. At this time, the most direct way

SPECIFICATION:
Delay difficulty bomb by 2,000,000 blocks Adjust block, uncle, and nephew rewards to reflect a new block reward of 1 ETH.

MOTIVATION:
The current public Ethereum network has a hashrate of 296 TH/s. This hashrate corresponds to a power usage of roughly [1 TW](../assets/eip-858/calculations.md) and yearly energy consumption of 8.8 TWh (roughly 0.04% of [total](https://en.wikipedia.org/wiki/List_of_countries_by_electricity_consumption) global electricity consumption). A future switch to full Proof of Stake will solve this issue entirely.

RATIONALE:
This will delay the difficulty bomb by roughly a year. The difficulty bomb remains a community supported mechanism to aid a future transition to POS. The network hashrate provides security by reducing the likelihood that an adversary could mount a 51% attack. A static block reward means that factors


=== EIP-107 ===
TITLE: safe "eth_sendTransaction" authorization via html popup
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2016-06-05
REQUIRES: 

SUMMARY:
This draft EIP describes the details of an authorization method that if provided by rpc enabled ethereum nodes would allow regular websites to send transactions (via ```eth_sendTransaction```) without the need to enable CORS. Instead, user would be asked to confirm the transaction via an html popup. Every read only

SPECIFICATION:
In order for the mechanism to work, the node needs to serve an html file via http at the url \<node url\>/authorization.html This file will then be used by the dapp in 2 different modes (invisible iframe and popup window). The invisible iframe will be embedded in the dapp

MOTIVATION:
Currently, if a user navigates to a dapp running on a website using her/his everyday browser, the dapp will by default have no access to the rpc api for security reasons. The user will have to enable CORS for the website's domain in order for the dapp to work.

RATIONALE:
The design for that proposal was chosen for its simplicity and security. A previous idea was to use an oauth-like protocol in order for the user to accept or deny a transaction request. It would have required deeper code change in the node and some geth contributors argues that


=== EIP-3085 ===
TITLE: wallet_addEthereumChain RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-11-01
REQUIRES: 155

SUMMARY:
This EIP adds a wallet-namespaced RPC method: `wallet_addEtherereumChain`, providing a standard interface for adding chains to Ethereum wallets.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal defines a new RPC method, `wallet_addEthereumChain`. ### `wallet_addEthereumChain` The `wallet_addEthereumChain` method is used to suggest to the wallet

RATIONALE:
The design of `wallet_addEthereumChain` is deliberately ignorant of what it means to "add" a chain to a wallet. The meaning of "adding" a chain to a wallet depends on the wallet implementation. When calling the method, specifying the `chainId` will always be necessary, since in the universe of Ethereum


=== EIP-7732 ===
TITLE: Enshrined Proposer-Builder Separation
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-06-28
REQUIRES: 

SUMMARY:
This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being a *builder*) and a new duty (submitting *payload timeliness attestations*) to Ethereum validators.

SPECIFICATION:
### Execution Layer No changes are required. ### Consensus Layer The full consensus changes can be found in the consensus-specs Github repository. They are split between: - [Beacon Chain](https://github.com/ethereum/consensus-specs/blob/8f8ab03acf1656c54f3a81ef18878f853a1cc4c6/specs/_features/eip7732/beacon-chain.md) changes. - [Fork choice](https://github.com/ethereum/consensus-specs/blob/8f8ab03acf1656c54f3a81ef18878f853a1cc4c6/specs/_features/eip7732/fork-choice.md) changes. - [P2P](https://github.com/ethereum/consensus-specs/blob/8f8ab03acf1656c54f3a81ef18878f853a1cc4c6/specs/_features/eip7732/p2p-interface.md) changes. - [Honest validator guide](https://github.com/ethereum/consensus-specs/blob/8f8ab03acf1656c54f3a81ef18878f853a1cc4c6/specs/_features/eip7732/validator.md) changes. - A new [honest builder](https://github.com/ethereum/consensus-specs/blob/8f8ab03acf1656c54f3a81ef18878f853a1cc4c6/specs/_features/eip7732/builder.md) guide. -

MOTIVATION:
This EIP solves a different set of unrelated important problems. - An overwhelming majority of beacon block proposers outsource the construction of the execution payload within their blocks to a third party (henceforth called a *builder*). In order to do so, they request the hash tree root (HTR) of

RATIONALE:
### Staked builders Being a builder is a new attribution of validators. As such builders are staked in the beacon chain. This allows for in-protocol trustless enforcement of the builder's payment to the proposer. Alternatively, payment could be enforced in the Execution Layer (EL) at the cost of adding


=== EIP-758 ===
TITLE: Subscriptions and filters for completed transactions
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2017-11-09
REQUIRES: 1474

SUMMARY:
When a new transaction is submitted successfully to an Ethereum node, the node responds with the transaction's hash. If the transaction involved the execution of a contract function that returns data, the data is discarded. If the return data is state-dependent, which is common, there is no straightforward way

SPECIFICATION:
### Subscription A caller who wants to be notified when transactions of theirs complete sends an `eth_subscribe` RPC request with the first parameter `"completedTransaction"`: ```json {"jsonrpc": "2.0", "id": 1, "method": "eth_subscribe", "params": ["completedTransaction", filter]} ``` The `filter` parameter is a dictionary containing 3 optional named arguments: `from`, `to`, and

MOTIVATION:
External callers presently have no way of accessing return data from Ethereum, if the function was executed via `eth_sendTransaction` or `eth_sendRawTransaction` RPC request. Access to function return data is in many cases a desirable feature. Making return data available to external callers also addresses the inconsistency between internal callers,

RATIONALE:
[EIP-658](./eip-658.md) originally proposed adding return data to transaction receipts. However, return data is not charged for (as it is not stored on the blockchain), so adding it to transaction receipts could result in DoS and spam opportunities. Instead, a simple Boolean `status` field was added to transaction receipts. This


=== EIP-6873 ===
TITLE: Preimage retention
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-14
REQUIRES: 

SUMMARY:
Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Let `T_p` be the timestamp of the fork preceding the verge, and `T_v` the timestamp

RATIONALE:
Switching to verkle trees require a complete rehashing of all tree keys. Most execution clients store all keys hashed, without their preimages, which as the time of print take up 70GB on mainnet. In order to make these preimages available to everyone, the following course of action are available


=== EIP-2364 ===
TITLE: eth/64: forkid-extended protocol handshake
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2019-11-08
REQUIRES: 2124

SUMMARY:
This EIP specifies the inclusion of the `forkid`, originally defined in [(EIP-2124)](./eip-2124.md), as a new field in the Ethereum wire protocol (`eth`) handshake. This change is implemented as a new version of the wire protocol, `eth/64`.

SPECIFICATION:
- Implement `forkid` generation and validation per [EIP-2124](./eip-2124.md). - Advertise a new `eth` protocol capability (version) at `eth/64`. - The old `eth/63` protocol should still be kept alive side-by-side, until `eth/64` is sufficiently adopted by implementors. - Redefine `Status (0x00)` for `eth/64` to add a trailing `forkid` field: -

MOTIVATION:
The [`forkid` (EIP-2124)](./eip-2124.md) was designed to permit two Ethereum nodes to quickly and cheaply decide if they are compatible or not, not only at a genesis/networking level, but also from the perspective of the currently passed network updates (i.e. forks). [EIP-2124](./eip-2124.md) only defines how the `forkid` is calculated and

RATIONALE:
The specification is tiny since most parts are already specified in EIP-2124. `eth/63` is not specified as an EIP, but is maintained in the [ethereum/devp2p](https://github.com/ethereum/devp2p) Github repository. ### EIP-2124 mentions advertising the `forkid` in the discovery protocol too. How does that compare to advertising in the `eth` protocol? Why


=== EIP-1571 ===
TITLE: EthereumStratum/2.0.0
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-11-09
REQUIRES: 

SUMMARY:
This draft contains the guidelines to define a new standard for the Stratum protocol used by Ethereum miners to communicate with mining pool servers. ### Conventions The key words `MUST`, `MUST NOT`, `REQUIRED`, `SHALL`, `SHALL NOT`, `SHOULD`, `SHOULD NOT`, `RECOMMENDED`, `MAY`, and `OPTIONAL` in this document are to be

SPECIFICATION:
The Stratum protocol is an instance of [JSON-RPC-2.0](https://www.jsonrpc.org/specification). The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of a `session`. A session starts at the moment a client opens a TCP connection to the server till the moment either

RATIONALE:
Ethereum does not have an official Stratum implementation yet. It officially supports only getWork which requires miners to constantly pool the work provider. Only recently go-ethereum have implemented a [push mechanism](https://github.com/ethereum/go-ethereum/pull/17347) to notify clients for mining work, but whereas the vast majority of miners do not run a node,


=== EIP-3220 ===
TITLE: Crosschain Identifier Specification
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-21
REQUIRES: 

SUMMARY:
The crosschain-id is a 32 byte hex string and with some bytes extracted from blockchain hash and some manually defined to characterize a blockchain. We also propose a registration and lookup service to retrieve blockchain metadata from the crosschain-id.

SPECIFICATION:
### Definition of a 32 byte crosschain id | Name | Size(bytes) | Description | |---------------|-------------|-------------| | Truncated Block Hash | 16 | This is the block hash of the genesis block or the block hash of of the block immediate prior to the fork for a fork of

MOTIVATION:
With the success of Bitcoin and Ethereum, various blockchains such as EOS, Ripple, Litecoin, Besu, Wanchain and the like have been developed and are growing at a fast pace. There are also other private and consortium blockchains such as Hyperledger Fabric, Hyperledger Besu, Stellar, Corda, Quorum that only allow

RATIONALE:
We have considered various alternative specifications such as using a random unique hex string to represent a blockchain. The drawback of this method is that the random id can not be used to verify a blockchain's intrinsic identity such as the blockhash of the genesis block. A second alternative


=== EIP-7569 ===
TITLE: Hardfork Meta - Dencun
TYPE: Meta 
STATUS: Final
CREATED: 2023-12-01
REQUIRES: 1, 1, 5, 3, ,,  , 4, 7, 8, 8, ,,  , 4, 8, 4, 4, ,,  , 5, 6, 5, 6, ,,  , 6, 7, 8, 0, ,,  , 7, 0, 4, 4, ,,  , 7, 0, 4, 5, ,,  , 7, 5, 1, 4, ,,  , 7, 5, 1, 6, ,,  , 7, 5, 6, 8

SUMMARY:
This Meta EIP lists the EIPs included in the Dencun network upgrade across both Ethereum's execution and consensus layers.

SPECIFICATION:
### Included EIPs * [EIP-1153](./eip-1153.md): Transient storage opcodes * [EIP-4788](./eip-4788.md): Beacon block root in the EVM * [EIP-4844](./eip-4844.md): Shard Blob Transactions * [EIP-5656](./eip-5656.md): MCOPY - Memory copying instruction * [EIP-6780](./eip-6780.md): SELFDESTRUCT only in same transaction * [EIP-7044](./eip-7044.md): Perpetually Valid Signed Voluntary Exits * [EIP-7045](./eip-7045.md): Increase Max Attestation Inclusion Slot

RATIONALE:
This Meta EIP provides a global view of all changes included in the Dencun network upgrade, as well as links to full specification.


=== EIP-3044 ===
TITLE: Adds `baseFee` to `eth_getBlockByNumber`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getBlockByNumber` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getBlockByNumber` #### Description Returns information about a block specified by number. Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-712 ===
TITLE: Typed structured data hashing and signing
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-09-12
REQUIRES: 1, 5, 5, ,,  , 1, 9, 1

SUMMARY:
This is a standard for hashing and signing of typed structured data as opposed to just bytestrings. It includes a * theoretical framework for correctness of encoding functions, * specification of structured data similar to and compatible with Solidity structs, * safe hashing algorithm for instances of those structures,

SPECIFICATION:
The set of signable messages is extended from transactions and bytestrings `𝕋 ∪ 𝔹⁸ⁿ` to also include structured data `𝕊`. The new set of signable messages is thus `𝕋 ∪ 𝔹⁸ⁿ ∪ 𝕊`. They are encoded to bytestrings suitable for hashing and signing as follows: * `encode(transaction : 𝕋)

MOTIVATION:
Signing data is a solved problem if all we care about are bytestrings. Unfortunately in the real world we care about complex meaningful messages. Hashing structured data is non-trivial and errors result in loss of the security properties of the system. As such, the adage "don't roll your own

RATIONALE:
The `encode` function is extended with a new case for the new types. The first byte of the encoding distinguishes the cases. For the same reason it is not safe to start immediately with the domain separator or a `typeHash`. While hard, it may be possible to construct a


=== EIP-7657 ===
TITLE: Sync committee slashings
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-21
REQUIRES: 

SUMMARY:
This EIP defines a slashing condition for malicious [sync committee messages](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/validator.md#containers).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### State transition checks Note: This still allows having contradictions between attestations/proposals and sync committee

MOTIVATION:
A dishonest supermajority of sync committee members is able to convince applications relying on Ethereum's [light client sync protocol](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md) to assume a non-canonical finalized header, and to potentially take over the sync authority for future `SyncCommitteePeriod`. By signing a malicious beacon block root, a malicious (but valid!) `LightClientUpdate` message

RATIONALE:
### What's the use case? Without a slashing, the light client sync protocol is somewhat limited. While wallet applications may benefit from it (the risk being, that incorrect data is displayed) and new beacon nodes may use it for accelerating chain synchronization, other interesting use cases such as bridges,


=== EIP-1716 ===
TITLE: Hardfork Meta: Petersburg
TYPE: Meta 
STATUS: Final
CREATED: 2019-01-21
REQUIRES: 1, 0, 1, 3, ,,  , 1, 2, 8, 3

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork that removes [EIP-1283](./eip-1283.md) from [Constantinople](./eip-1013.md).

SPECIFICATION:
- Codename: Petersburg - Aliases: St. Petersfork, Peter's Fork, Constantinople Fix - Activation: - `Block >= 7_280_000` on the Ethereum Mainnet - `Block >= 4_939_394` on the Ropsten testnet - `Block >= 10_255_201` on the Kovan testnet - `Block >= 4_321_234` on the Rinkeby testnet - `Block >= 0`


=== EIP-7547 ===
TITLE: Inclusion lists
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-10-24
REQUIRES: 

SUMMARY:
Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.

SPECIFICATION:
### Constants | Name | Value | | - | - | | `MAX_TRANSACTIONS_PER_INCLUSION_LIST` | `2**4 = 16` | | `MAX_GAS_PER_INCLUSION_LIST` | `2**21` | | `MIN_SLOTS_FOR_INCLUSION_LIST_REQUEST` | `1` | #### Reference Objects ``` class InclusionListSummaryEntry(Container): address: ExecutionAddress gas_limit: uint64 ``` ``` class InclusionListSummary(Container) slot: Slot proposer_index: ValidatorIndex summary: List[InclusionListSummaryEntry,

MOTIVATION:
Since the merge, validators have started outsourcing almost all block production to a specialized set of builders who compete to extract the most MEV (this is commonly referred to as Proposer-Builder Separation). As of October 2023, nearly 95% of blocks are built by builders rather than the proposer. While

RATIONALE:
We consider a few design decisions present in this EIP. 1. `ReducedSummary` versus `Summary` - The original proposal tries to improve data efficiency by using a `ReducedSummary` and a `Rebuilder`. This allows the full summary to be reconstructed. - This adds a lot of complexity to the spec, so


=== EIP-6475 ===
TITLE: SSZ Optional
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-02-09
REQUIRES: 

SUMMARY:
This EIP introduces a new [Simple Serialize (SSZ) type](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/ssz/simple-serialize.md) to represent `Optional[T]` values.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Type definition `Optional[T]` is defined as a type that can represent: - A value

MOTIVATION:
Optional values are currently only representable in SSZ using workarounds. Adding proper support provides these benefits: 1. **Better readability:** SSZ structures with optional values can be represented with idiomatic types of the underlying programming language, e.g., `Optional[T]` in Python, making them easier to interact with. 2. **Compact serialization:** SSZ

RATIONALE:
### Why not `Union[None, T]`? `Union[None, T]` leaves ambiguity about the intention whether the type may be extended in the future, i.e., `Union[None, T, U]`. Furthermore, SSZ Union types are currently not used in any final Ethereum specification and do not have a finalized design themselves. If the only


=== EIP-2200 ===
TITLE: Structured Definitions for Net Gas Metering
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-07-18
REQUIRES: 

SUMMARY:
This EIP provides a structured definition of net gas metering changes for `SSTORE` opcode, enabling new usages for contract storage, and reducing excessive gas costs where it doesn’t match how most implementation works. This is a combination of [EIP-1283] and [EIP-1706].

SPECIFICATION:
Define variables `SLOAD_GAS`, `SSTORE_SET_GAS`, `SSTORE_RESET_GAS` and `SSTORE_CLEARS_SCHEDULE`. The old and new values for those variables are: * `SLOAD_GAS`: changed from `200` to `800`. * `SSTORE_SET_GAS`: `20000`, not changed. * `SSTORE_RESET_GAS`: `5000`, not changed. * `SSTORE_CLEARS_SCHEDULE`: `15000`, not changed. Change the definition of EIP-1283 using those variables. The new specification,

MOTIVATION:
This EIP proposes a way for gas metering on `SSTORE`, using information that is more universally available to most implementations, and require as little change in implementation structures as possible. * Storage slot’s original value. * Storage slot’s current value. * Refund counter. Usages that benefits from this EIP’s

RATIONALE:
This EIP mostly achieves what a transient storage tries to do ([EIP-1087] and [EIP-1153]), but without the complexity of introducing the concept of "dirty maps", or an extra storage struct. * We don't suffer from the optimization limitation of EIP-1087. EIP-1087 requires keeping a dirty map for storage changes,


=== EIP-7749 ===
TITLE: Add wallet_signIntendedValidatorData method
TYPE: Standards Track Interface
STATUS: Draft
CREATED: 2024-06-21
REQUIRES: 1, 9, 1, ,,  , 7, 1, 2

SUMMARY:
This EIP introduces a new JSON-RPC method, `wallet_signIntendedValidatorData`, which allows signing data with an intended validator address using [ERC-191](./eip-191.md) version 0x00 with this format: ```bash 0x19 <0x00> <intended validator address> <data to sign> ```

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `wallet_signIntendedValidatorData` MUST calculate an Ethereum signature using `sign(keccak256("\x19\x00<signature validator address><data to sign>"))`. This method

MOTIVATION:
Currently, signing messages relies heavily on ERC-191 version 0x45 (`eth_sign`) and [EIP-712](./eip-712.md) (`eth_signTypedData`). While EIP-712 provides a more structured approach, it is often seen as complex. On the other hand, ERC-191 version 0x45 is widely used but poses significant phishing risks due to the lack of data parsing. ERC-191

RATIONALE:
The `wallet_signIntendedValidatorData` method aims to bridge the gap between the simplicity of ERC-191 version 0x45 and the structured approach of EIP-712. By specifying the intended validator address, it reduces phishing risks and provides a more secure signing method for smart contract accounts and other use cases requiring a specific


=== EIP-2718 ===
TITLE: Typed Transaction Envelope
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-06-13
REQUIRES: 

SUMMARY:
`TransactionType || TransactionPayload` is a valid transaction and `TransactionType || ReceiptPayload` is a valid transaction receipt where `TransactionType` identifies the format of the transaction and `*Payload` is the transaction/receipt contents, which are defined in future EIPs.

SPECIFICATION:
### Definitions * `||` is the byte/byte-array concatenation operator. ### Transactions As of `FORK_BLOCK_NUMBER`, the transaction root in the block header **MUST** be the root hash of `patriciaTrie(rlp(Index) => Transaction)` where: * `Index` is the index in the block of this transaction * `Transaction` is either `TransactionType || TransactionPayload`

MOTIVATION:
In the past, when we have wanted to add new transaction types we have had to ensure they were backward compatible with all other transactions, meaning that you could differentiate them based only on the encoded payload, and it was not possible to have a transaction that matched both

RATIONALE:
### TransactionType only goes up to 0x7f For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit. This also prevents us from colliding with legacy transaction types, which always start


=== EIP-1186 ===
TITLE: RPC-Method to get Merkle Proofs - eth_getProof
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-06-24
REQUIRES: 1474

SUMMARY:
Ethereum uses a [Merkle Tree](https://github.com/ethereum/wiki/wiki/Patricia-Tree) to store the state of accounts and their storage. This allows verification of each value by simply creating a Merkle Proof. But currently, the standard RPC-Interface does not give you access to these proofs. This EIP suggests an additional RPC-Method, which creates Merkle Proofs

SPECIFICATION:
As Part of the eth-Module, an additional Method called `eth_getProof` should be defined as follows: #### eth_getProof Returns the account- and storage-values of the specified account including the Merkle-proof. ##### Parameters 1. `DATA`, 20 Bytes - address of the account. 2. `ARRAY`, 32 Bytes - array of storage-keys which

MOTIVATION:
In order to create a MerkleProof access to the full state db is required. The current RPC-Methods allow an application to access single values (`eth_getBalance`,`eth_getTransactionCount`,`eth_getStorageAt`,`eth_getCode`), but it is impossible to read the data needed for a MerkleProof through the standard RPC-Interface. (There are implementations using leveldb and accessing the

RATIONALE:
This one Method actually returns 3 different important data points: 1. The 4 fields of an account-object as specified in the yellow paper `[nonce, balance, storageHash, codeHash ]`, which allows storing a hash of the account-object in order to keep track of changes. 2. The MerkleProof for the account


=== EIP-4881 ===
TITLE: Deposit Contract Snapshot Interface
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2021-01-29
REQUIRES: 

SUMMARY:
This EIP defines a standard format for transmitting the deposit contract Merkle tree in a compressed form during weak subjectivity sync. This allows newly syncing consensus clients to reconstruct the deposit tree much faster than downloading all historical deposits. The format proposed also allows clients to prune deposits that

SPECIFICATION:
Consensus clients MAY continue to implement the deposit Merkle tree however they choose. However, when transmitting the tree to newly syncing nodes, clients MUST use the following format: ```python class DepositTreeSnapshot: finalized: List[Hash32, DEPOSIT_CONTRACT_DEPTH] deposit_root: Hash32 deposit_count: uint64 execution_block_hash: Hash32 execution_block_height: uint64 ``` Where `finalized` is a variable-length list

MOTIVATION:
To reconstruct the deposit Merkle tree, most client implementations require beacon nodes to download and store every deposit log since the launch of the deposit contract. However, this approach requires beacon nodes to store far more deposits than necessary to participate in consensus. Additionally, this leads to increased sync

RATIONALE:
The format in this specification was chosen to achieve several goals simultaneously: 1. Enable reconstruction of the deposit contract Merkle tree without requiring full nodes to store all historical contract logs 2. Avoid requiring consensus nodes to retain more deposits than necessary to fully participate in consensus 3. Simplicity


=== EIP-2584 ===
TITLE: Trie format transition with overlay trees
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-04-03
REQUIRES: 

SUMMARY:
This EIP describes a four phase process to complete the conversion. * In the first phase, all new state writes are made to an overlay binary trie, while the hexary trie is being converted to binary. The block format is changed to have two storage roots: the root of

SPECIFICATION:
This specification follows the notation introduced by the [Yellow Paper](https://ethereum.github.io/yellowpaper). Prior to reading it is advisable to be familiar with the Yellow Paper. ### Binary tries This EIP assumes that a binary trie is defined like the MPT, except that: * The series of bytes in I₀ is seen

MOTIVATION:
There is a long running interest in switching the state trie from a hexary format to a binary format, for reasons pertaining to proof and storage sizes. The conversion process poses a catch-up issue, caused by the sheer size of the full state: it can not be translated in

RATIONALE:
Methods that have been discussed until now include a "stop the world" approach, in which the chain is stopped for the significant amount of time that is required by the conversion, and a "copy on write" approach, in which branches are converted upon being accessed. The approach suggested here


=== EIP-6968 ===
TITLE: Contract Secured Revenue on an EVM based L2
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-05-01
REQUIRES: 


=== EIP-606 ===
TITLE: Hardfork Meta: Homestead
TYPE: Meta 
STATUS: Final
CREATED: 2017-04-23
REQUIRES: 2, ,,  , 7, ,,  , 8

SUMMARY:
This specifies the changes included in the hard fork named Homestead.

SPECIFICATION:
- Codename: Homestead - Activation: - Block >= 1,150,000 on Mainnet - Block >= 494,000 on Morden - Block >= 0 on future testnets - Included EIPs: - [EIP-2](./eip-2.md) (Homestead Hard-fork Changes) - [EIP-7](./eip-7.md) (DELEGATECALL) - [EIP-8](./eip-8.md) (Networking layer: devp2p Forward Compatibility Requirements for Homestead)


=== EIP-3155 ===
TITLE: EVM trace specification
TYPE: Standards Track Interface
STATUS: Review
CREATED: 2020-12-07
REQUIRES: 

SUMMARY:
Introduce a new JSON standard for EVM traces during execution of state tests.

SPECIFICATION:
Clients should be able to execute simple transactions as well as code and return traces. In the following, we will call this client CUT (client under test) and use go-ethereum's `evm` binary for code examples. ### Datatypes | Type | Explanation | Example | |------------|----------------------------------------------------------------|---------------------| | Number | Plain

MOTIVATION:
The Ethereum Virtual Machine executes all smart contract code on ethereum. In order to debug smart contracts and state tests better, a common format was introduced to log every execution step of the EVM. This format was implemented by Go-Ethereum, Parity-Ethereum, Nethermind and Besu. Since the common format was

RATIONALE:
This EIP is largely based on the previous non-official documentation for EVM tracing. It tries to cover as many corner cases as possible to enable true client compatibility. The datatypes and if a field is optional is chosen to be as compatible with current implementations as possible.


=== EIP-7705 ===
TITLE: NONREENTRANT and REENTRANT opcodes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-09
REQUIRES: 

SUMMARY:
Add two opcodes, `NONREENTRANT` and `REENTRANT`, which set and clear a contract's reentrancy status. After invoking `NONREENTRANT`, a contract cannot be `CALL`ed (or `STATICCALL`ed, or `DELEGATECALL`ed) until `REENTRANT` is invoked.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Two new opcodes are introduced, `NONREENTRANT` (0xF6) and `REENTRANT` (0xF7), which set and clear a

MOTIVATION:
Reentrancy attacks account for a substantial portion of user funds stolen on EVM chains, including the famous "DAO hack". However, due to the cost of preventing against reentrancy attacks in application code, developers often opt-out of reentrancy protection. This cost has come down with the advent of transient storage

RATIONALE:
The computational cost of pushing the current value to the call stack (for handling reverts) is accounted for in the overhead cost of the `*CALL` opcodes. An alternative design could be considered which only introduces one opcode. This opcode, `NONREENTRANT`, would take a single stack item and set the


=== EIP-3041 ===
TITLE: Adds `baseFee` to `eth_getBlockByHash`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-13
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getBlockByHash` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getBlockByHash` #### Description Returns information about a block specified by hash. Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on or after the [EIP-1559](./eip-1559.md) fork

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-6404 ===
TITLE: SSZ transactions
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-01-30
REQUIRES: 1, 5, 5, ,,  , 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4, ,,  , 5, 7, 9, 3, ,,  , 7, 4, 9, 5, ,,  , 7, 7, 0, 2

SUMMARY:
This EIP defines a migration process of [EIP-2718](./eip-2718.md) Recursive-Length Prefix (RLP) transactions to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Existing definitions Definitions from existing specifications that are used throughout this document are replicated

MOTIVATION:
RLP transactions have a number of shortcomings: 1. **Linear hashing:** The signing hash (`sig_hash`) and unique identifier (`tx_hash`) of an RLP transaction are computed by linear keccak256 hashes across its serialization. Even if only partial data is of interest, linear hashes require the full transaction data to be present,

RATIONALE:
Switching to a single, unified and forward compatible transaction format within execution blocks reduces implementation complexity for client applications and smart contracts. Future use cases such as transaction inclusion proofs or submitting individual verifiable chunks of calldata to a smart contract become easier to implement with SSZ. Various protocol


=== EIP-2481 ===
TITLE: eth/66 request identifier
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-01-17
REQUIRES: 2464

SUMMARY:
The `eth` protocol defines various request and response commands that are used to exchange data between Ethereum nodes. For example, to ask a peer node for a specific set of headers, a node sends it the [`GetBlockHeaders`](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md#getblockheaders-0x03) command. *Citing from the [`GetBlockHeaders` spec definition](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md#getblockheaders-0x03):* >`[block: {P, B_32}, maxHeaders: P,

SPECIFICATION:
Change the following message types in the `eth` protocol: * `GetBlockHeaders (0x03)` * **Current (eth/65):** `[block: {P, B_32}, maxHeaders: P, skip: P, reverse: P in {0, 1}]` * **Then (eth/66)**: `[request_id: P, [block: {P, B_32}, maxHeaders: P, skip: P, reverse: P in {0, 1}]]` * `BlockHeaders (0x04)` * **Current

MOTIVATION:
The lack of request identifiers in the request / response paris of the `eth` protocol puts unnecessary burden of code complexity into every Ethereum client. It also makes the communication slightly less efficient. Another argument can be made that the addition of request identifiers makes the protocol more aligned

RATIONALE:
**Q: The efficiency gains might encourage clients to flood their peers with too many simultaneous requests** Peers can always throttle or disconnect if they don't feel treated well. This is the same as today. **Q: If `les` already defines the commands like this, why not just use the `les`


=== EIP-5027 ===
TITLE: Remove the limit on contract code size
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-21
REQUIRES: 1, 7, 0, ,,  , 2, 9, 2, 9, ,,  , 2, 9, 3, 0

SUMMARY:
Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.

SPECIFICATION:
### Parameters | Constant | Value | | ------------------------- | ---------------- | | `FORK_BLKNUM` | TBD | | `CODE_SIZE_UNIT` | 24576 | | `COLD_ACCOUNT_CODE_ACCESS_COST_PER_UNIT` | 2600 | | `CREATE_DATA_GAS` | 200 | If `block.number >= FORK_BLKNUM`, the contract creation initialization can return data with any length, but the contract-related

MOTIVATION:
The motivation is to remove the limit on the code size so that users can deploy a large-code contract without worrying about splitting the contract into several sub-contracts. With the dramatic growth of dApplications, the functionalities of smart contracts are becoming more and more complicated, and thus, the sizes

RATIONALE:
### Gas Metering The goal is to measure the CPU/IO cost of the contract read/write operations reusing existing gas metering so that the resources will not be abused. - For code-size-related opcodes (`CODESIZE`/`EXTCODESIZE`), we would expect the client to implement a mapping from the hash of code to the


=== EIP-1010 ===
TITLE: Uniformity Between 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B and 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-18
REQUIRES: 

SUMMARY:
As of the date of this EIP, the difference in balance between address `0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B` and address `0x15E55EF43efA8348dDaeAa455F16C43B64917e3c` is far from equitable or uniform, with the former having more than 365,000 ether more than the latter. The distribution of ether between these two addresses must be improved in order to

SPECIFICATION:
The balance of `0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B` will be decreased by 100,000 ether. The balance of `0x15E55EF43efA8348dDaeAa455F16C43B64917e3c` will be increased by 100,000 ether. No net change in the amount of extant ether will occur unless at the time of implementation the former address does not contain sufficient ether for such a deduction.

MOTIVATION:
This proposal is necessary because the Ethereum protocol does not allow the owner of an address which does not own an equitable amount of ether to claim their share of ether from an address which owns a dangerously centralized quantity. Rather than proposing an overly complicated generic mechanism for

RATIONALE:
The value 100,000 was chosen after careful technically sound analysis of various economic theories developed over the past century. In spite of the fact that it is a convenient round number, it is actually the exact output of a complex statistical process iterated to determine the optimal distribution of


=== EIP-196 ===
TITLE: Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-02
REQUIRES: 

SUMMARY:
This EIP suggests to add precompiled contracts for addition and scalar multiplication on a specific pairing-friendly elliptic curve. This can in turn be combined with [EIP-197](./eip-197.md) to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users

SPECIFICATION:
If `block.number >= BYZANTIUM_FORK_BLKNUM`, add precompiled contracts for point addition (ADD) and scalar multiplication (MUL) on the elliptic curve "alt_bn128". Address of ADD: 0x6 Address for MUL: 0x7 The curve is defined by: ``` Y^2 = X^3 + 3 over the field F_p with p = 21888242871839275222246405745257275088696311157297823662689037894645226208583 ``` ###

MOTIVATION:
Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of

RATIONALE:
The specific curve `alt_bn128` was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts. The feature of adding curve and


=== EIP-3779 ===
TITLE: Safer Control Flow for the EVM
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-08-30
REQUIRES: 

SUMMARY:
We define a safe EVM contract as one that cannot encounter an exceptional halting state. In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset. This EIP specifies validity rules to ensure that: > Valid contracts will not halt with an exception unless

SPECIFICATION:
### Validity > In theory, theory and practice are the same. In practice, they're not. -- Albert Einstein We define a _safe_ EVM contract as one that cannot encounter an exceptional halting state. We validate _safety_ at initialization time to the extent practical. #### *Exceptional Halting States* The *execution*

MOTIVATION:
### Safety For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state. From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain. Unsafe code can attempt to overflow stack, underflow stack, execute invalid

RATIONALE:
Demanding *static* destinations for all jumps means that all jump destinations can be validated at initialization time, not runtime. Bounding the stack pointers catches all `data stack` and non-recursive`return stack` overflows. Requiring a consistently aligned`data stack` prevents stack underflow. It can also catch such errors as misaligned stacks due


=== EIP-1559 ===
TITLE: Fee market change for ETH 1.0 chain
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-04-13
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 3, 0

SUMMARY:
We introduce a new [EIP-2718](./eip-2718.md) transaction type, with the format `0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`. There is a base fee per gas in protocol, which can move up or down each block according to a formula which is a function

SPECIFICATION:
Block validity is defined in the reference implementation below. The `GASPRICE` (`0x3a`) opcode **MUST** return the `effective_gas_price` as defined in the reference implementation below. As of `FORK_BLOCK_NUMBER`, a new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` 2. The intrinsic cost of the new transaction is inherited from [EIP-2930](./eip-2930.md), specifically `21000

MOTIVATION:
Ethereum historically priced transaction fees using a simple auction mechanism, where users send transactions with bids ("gasprices") and miners choose transactions with the highest bids, and transactions that get included pay the bid that they specify. This leads to several large sources of inefficiency: * **Mismatch between volatility of


=== EIP-4760 ===
TITLE: SELFDESTRUCT bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP renames the `SELFDESCRUCT` opcode to `SENDALL`, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller. In order to give apps more warning even if their developers are completely unaware of the EIP process, this version will

SPECIFICATION:
### Constants | Name | Value | Comment | |------|-------|---------| | `OLD_SELFDESTRUCT_COST` | 5000 | Current gas cost of `SELFDESTRUCT` opcode | | `HARD_FORK_BLOCK` | TBD | (Shanghai HF block height) | | `DOUBLING_SLOTS` | `2**16` | (Time for gas price to double, ca. 9 days) | | `DOUBLINGS_BEFORE_SENDALL`

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root

RATIONALE:
The idea behind this EIP is to disable `SELFDESTRUCT` in a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However,


=== EIP-7762 ===
TITLE: Increase MIN_BASE_FEE_PER_BLOB_GAS
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-08-31
REQUIRES: 4844

SUMMARY:
This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob basefee spike.

SPECIFICATION:
### `MIN_BASE_FEE_PER_BLOB_GAS` Increase The main specification change introduced by this EIP is setting MIN_BASE_FEE_PER_BLOB_GAS to 2**25: ```diff + MIN_BASE_FEE_PER_BLOB_GAS = 2**25 - MIN_BASE_FEE_PER_BLOB_GAS = 1 ``` ### `excess_blob_gas` Reset To avoid a blob basefee spike, the `calc_excess_blob_gas` is modified to reset `excess_blob_gas` to 0 at the fork. To detect

MOTIVATION:
When scoping 4844, the thinking was that blobs would only enter price discovery once, relatively quickly after the blob rollout; however, this has not been the case. In fact, blobs have entered price discovery several times, and the frequency of price discovery events is likely to increase in the

RATIONALE:
The current MIN_BASE_FEE_PER_BLOB_GAS is 1 wei. This is many orders of magnitude lower than the prevailing price of blobs when blobs enter price discovery. Whenever demand for blobs exceeds supply, blobs enter price discovery, but traversing the 8 orders of magnitude between 1 wei and the point where elasticity


=== EIP-7807 ===
TITLE: SSZ execution blocks
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-28
REQUIRES: 6, 4, 0, 4, ,,  , 6, 4, 6, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 7, 0, 6, ,,  , 7, 7, 9, 9

SUMMARY:
This EIP defines a migration process of execution blocks to [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md).

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### `ExecutionBlockHeader` container Execution blocks are represented as a single, normalized SSZ container. The definition

MOTIVATION:
With [EIP-6404](./eip-6404.md) SSZ transactions, [EIP-6466](./eip-6466.md) SSZ receipts, and [EIP-6465](./eip-6465.md) SSZ withdrawals, all Merkle-Patricia Trie (MPT) besides the state trie are converted to SSZ. This enables the surrounding data structure, in this case, the execution block itself, to also convert to SSZ, achieving a unified block representation across both Consensus

RATIONALE:
In the initial draft, only the requests hash and block hash are changed to be SSZ `hash_tree_root()` based. No Consensus Layer changes are required. ### Future - With SSZ `Log`, the withdrawals mechanism and validator requests could be redefined to be based on logs (similar to deposits, originally, but


=== EIP-1767 ===
TITLE: GraphQL interface to Ethereum node data
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-02-14
REQUIRES: 

SUMMARY:
This EIP specifies a GraphQL schema for accessing data stored on an Ethereum node. It aims to provide a complete replacement to the read-only information exposed via the present JSON-RPC interface, while improving on usability, consistency, efficiency, and future-proofing.

SPECIFICATION:
### Node API Compatible nodes MUST provide a GraphQL endpoint available over HTTP. This SHOULD be offered on port 8547 by default. The path to the GraphQL endpoint SHOULD be '/graphql'. Compatible nodes MAY offer a GraphiQL interactive query explorer on the root path ('/'). ### Schema The GraphQL

MOTIVATION:
The current JSON-RPC interface for Ethereum nodes has a number of shortcomings. It's informally and incompletely specified in areas, which has led to incompatibilities around issues such as representation of empty byte strings ("" vs "0x" vs "0x0"), and it has to make educated guesses about the data a

RATIONALE:
Ethereum nodes have been moving away from providing read-write functionality such as transaction and message signing, and from other services such as code compilation, in favor of a more 'unix-like' approach where each task is performed by a dedicated process. We have thus specified a core set of types


=== EIP-1985 ===
TITLE: Sane limits for certain EVM parameters
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-01
REQUIRES: 

SUMMARY:
Introduce an explicit value range for certain EVM parameters (such as gas limit, block number, block timestamp, size field when returning/copying data within EVM). Some of these already have an implicit value range due to various (practical) reasons.

SPECIFICATION:
If `block.number >= {FORK_BLOCK}`, the following value ranges are introduced. They restrict the results (i.e. values pushed to the stack) of the instructions listed below. 1. *gas*, *gas limit*, *block gas limit* is a range between `0` and `0x7fffffffffffffff` (`2**63 - 1`, `9223372036854775807`). It affects the following instructions: -

MOTIVATION:
Having such an explicit value range can help in creating compatible client implementations, in certain cases it can also offer minor speed improvements, and can reduce the effort needed to create consensus critical test cases by eliminating unrealistic edge cases.

RATIONALE:
These limits have been: - proposed by [EVMC] - implemented partially by certain clients, such as [Aleth], [geth], [Parity] and [ethereumjs] - allowed by certain test cases in the [Ethereum testing suite] - and implicitly also allowed by certain assumptions, such as due to gas limits some of these


=== EIP-1344 ===
TITLE: ChainID opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-08-22
REQUIRES: 155

SUMMARY:
This EIP adds an opcode that returns the current chain's EIP-155 unique identifier.

SPECIFICATION:
Adds a new opcode `CHAINID` at 0x46, which uses 0 stack arguments. It pushes the current chain ID onto the stack. Chain ID is a 256-bit value. The operation costs `G_base` to execute. The value of the current chain ID is obtained from the chain ID configuration, which should

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md).

RATIONALE:
The current approach proposed by EIP-712 is to specify the chain ID at compile time. Using this approach will result in problems after a hardfork, as well as human error that may lead to loss of funds or replay attacks on signed messages. By adding the proposed opcode it


=== EIP-7708 ===
TITLE: ETH transfers emit a log
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-17
REQUIRES: 

SUMMARY:
All ETH-transfers, including transactions, `CALL` and `SELFDESTRUCT` emit a log.

SPECIFICATION:
### Parameters * `MAGIC`: `TBD` ### Functionality Whenever (i) a nonzero-value `CALL`, (ii) a nonzero-value-transferring `SELFDESTRUCT`, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i) `MAGIC`, (ii) the sender address, (iii) the recipient address. The log data is a big-endian

MOTIVATION:
Logs are often used to track when balance changes of assets on Ethereum. Logs work for [ERC-20](./eip-20.md) tokens, but they do not work for ETH. ETH transfers from EOAs can be read from the transaction list in the block, but ETH transfers from smart contract wallets are not automatically

RATIONALE:
This is the simplest possible implementation that ensures that all ETH transfers are implemented in some kind of record that can be easily accessed through making RPC calls into a node, or through asking for a Merkle branch that is hashed into the block root. The log type is


=== EIP-7773 ===
TITLE: Hardfork Meta - Amsterdam
TYPE: Meta 
STATUS: Draft
CREATED: 2024-09-26
REQUIRES: 7, 6, 0, 7, ,,  , 7, 7, 2, 3

SUMMARY:
This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Amsterdam network upgrade.

SPECIFICATION:
Definitions for `Scheduled for Inclusion`, `Considered for Inclusion` and `Proposed for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion ### Considered for Inclusion * [EIP-4762](./eip-4762.md): Statelessness gas cost changes * [EIP-6800](./eip-6800.md): Ethereum state using a unified verkle tree * [EIP-6873](./eip-6873.md): Preimage retention * [EIP-7545](./eip-7545.md): Verkle proof

RATIONALE:
This Meta EIP provides a global view of all changes included in the Amsterdam network upgrade, as well as links to full specification.


=== EIP-4573 ===
TITLE: Procedures for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-12-16
REQUIRES: 2, 3, 1, 5, ,,  , 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 3, 7, 7, 9, ,,  , 4, 2, 0, 0

SUMMARY:
Five EVM instructions are introduced to define, call, and return from named EVM _procedures_ and access their _call frames_ in memory - `ENTERPROC`, `LEAVEPROC`, `CALLPROC`, `RETURNPROC`, and `FRAMEADDRESS`.

SPECIFICATION:
### Instructions #### ENTERPROC (0x??) dest_section: uint8, dest_offset: uint8, n_inputs: uint16, n_outputs: uint16, n_locals: uint16 ``` frame_stack.push(FP) FP -= n_locals * 32 PC +- <length of immediates> ``` Marks the entry point to a procedure * at offset `dest_offset` from the beginning of the `dest_section`. * taking `n_inputs` arguments

MOTIVATION:
Currently, Ethereum bytecode has no syntactic structure, and _subroutines_ have no defined interfaces. We propose to add _procedures_ -- delimited blocks of code that can be entered only by calling into them via defined interfaces. Also, the EVM currently has no automatic management of memory for _procedures_. So we

RATIONALE:
There is actually not much new here. It amounts to [EIP-615](./eip-615.md), refined and refactored into bite-sized pieces, along lines common to other machines. This proposal uses the [EIP-2315](./eip-2315.md) return stack to manage calls and returns, and steals ideas from [EIP-615](./eip-615.md), [EIP-3336](./eip-3336.md), and [EIP-4200](./eip-4200.md). `ENTERPROC` corresponds to `BEGINSUB` from EIP-615.


=== EIP-7664 ===
TITLE: Access-Key opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2024-03-27
REQUIRES: 1, 1, 5, 3, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 4, 4

SUMMARY:
This EIP introduces a new opcode to inspect the access-list keys of the executing address.

SPECIFICATION:
### Parameters | Constant | Value | |----------------------------|--------| | `ACCESS_KEY_OPCODE_GAS` | `3` | | `ACCESS_KEY_OPCODE_BYTE` | `0x4B` | ### Opcode We add an instruction `ACCESS_KEY` (with opcode `ACCESS_KEY_OPCODE_BYTE`) which pops `index` from the top of the stack as big-endian `uint256`, and pushes `tx.access_list[address][index]` back on the stack, if `address`

MOTIVATION:
This EIP serves as a substitute of top-level-call detection to enable a smart-contract to enforce static declaration of attributes. Previously, application-layer contracts, against common advice from account-abstraction proponents, used to rely on the `tx.origin` to enforce a top-level call, such that the contract inputs are encoded as transaction input.

RATIONALE:
### Static analysis of transactions Static declaration of contract-inputs enables advanced layer-two constructions and block-building techniques: data is available without EVM introspection, and contracts can reliably tell if the executing transaction declared critical properties to the block builder and verifying nodes. Static-declaration of contract inputs is now independent of


=== EIP-7688 ===
TITLE: Forward compatible consensus data structures
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-04-15
REQUIRES: 6, 1, 1, 0, ,,  , 7, 0, 0, 2, ,,  , 7, 2, 5, 1, ,,  , 7, 4, 9, 5, ,,  , 7, 5, 4, 9, ,,  , 7, 5, 6, 9

SUMMARY:
This EIP defines the changes needed to adopt `StableContainer` from [EIP-7495](./eip-7495.md) in consensus data structures.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Conversion procedure For each converted data structure, a new fork agnostic `StableContainer` type `B`

MOTIVATION:
Ethereum's consensus data structures make heavy use of [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ef434e87165e9a4c82a99f54ffd4974ae113f732/ssz/simple-serialize.md) `Container`, which defines how they are serialized and merkleized. The merkleization scheme allows application implementations to verify that individual fields (and partial fields) have not been tampered with. This is useful, for example, in smart contracts of decentralized

RATIONALE:
### Best timing? Applying this EIP breaks `hash_tree_root` and Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by a `Container` reaching a new power of


=== EIP-1959 ===
TITLE: New Opcode to check if a chainID is part of the history of chainIDs
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-20
REQUIRES: 155

SUMMARY:
This EIP adds an opcode that returns whether the specific number passed in has been a valid chainID (EIP-155 unique identifier) in the history of the chain (including the current chainID).

SPECIFICATION:
Adds a new opcode ```VALID_CHAINID``` at 0x46, which uses 1 stack argument : a 32 bytes value that represent the chainID to test. It will push ```0x1``` onto the stack if the uint256 value is part of the history (since genesis) of chainIDs of that chain, ```0x0``` otherwise. The

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md). [EIP-1344](./eip-1344.md) is attempting to solve this by giving smart contract

RATIONALE:
The only approach available today is to specify the chain ID at compile time. Using this approach will result in problems after a contentious hardfork as the contract can't accept message signed with a new chainID. The approach proposed by EIP-1344 is to give access to the latest chainID.


=== EIP-665 ===
TITLE: Add precompiled contract for Ed25519 signature verification
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-03-25
REQUIRES: 

SUMMARY:
Verification of Ed25519 cryptographic signatures is obviously possible in EVM bytecode. However, the gas cost will be very high, and computationally expensive, as such tight, wide word operations intensive code as required for Ed25519 is not a good fit for the EVM bytecode model. The addition of a native

SPECIFICATION:
If `block.number >= CONSTANTINOPLE_FORK_BLKNUM`, add a precompiled contract for Ed25519 signature verification (`ED25519VFY`). The proposal adds a new precompiled function `ED25519VFY` with the following input and output. `ED25519VFY` takes as **input 128 octets**: 1. **message**: the 32-octet message that was signed 2. **public key**: the 32-octet Ed25519 public key

MOTIVATION:
Ed25519 and Ed448 (that is, EdDSA using Curve25519 or Curve448) are IETF recommendations ([RFC7748](https://tools.ietf.org/html/rfc7748)) with some attractive properties: * Ed25519 is intended to operate at around the 128-bit security level and Ed448 at around the 224-bit security level * EdDSA uses small public keys (32 or 57 octets) and

RATIONALE:
The proposed `ED25519VFY` function takes the signer public key as a call parameter, as with Ed25519, I don't believe it is possible to derive the signers public key from the signature and message alone. The proposed `ED25519VFY` function uses a zero return value to indicate success, since this allows


=== EIP-2025 ===
TITLE: Block Rewards Proposal for funding Eth1.x
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2019-04-20
REQUIRES: 1890

SUMMARY:
This EIP extends the mechanism established in EIP-1890 to add `0.0055 ETH` to the block reward for a specific distribution period of `3,100,000 BLOCKS`(≈ 18 months). The `RECIPIENT_ADDRESS` is set to a smart contract with hardcoded denominations that distributes incoming ETH to a set of addresses for the purpose

SPECIFICATION:
Two constants will be introduced: - `REWARD_DURATION_IN_BLOCKS`, which specifies the number of blocks after `ISTANBUL_BLOCK_HEIGHT` when the reward collection will terminate (i.e., at block `ISTANBUL_BLOCK_HEIGHT + REWARD_DURATION_IN_BLOCKS`) - `BENEFICIARY_ADDRESSES`, a list of tuples containing the address and the amount to be transferred to this address per block. These amounts

MOTIVATION:
The context for this proposal came from attending the [Core Dev Eth1.X Meeting](https://www.youtube.com/watch?v=Au1Qll-86v0) in Berlin. Development is needed to move Eth1.X forward, and I observed that a lack of funding is the primary barrier to this work. This work can only be effectively conducted by working groups forming around

RATIONALE:
There has been great public debate concerning EIP-1890, and one of the primary concerns is that it is difficult to evaluate the proposal without more complete information on how funds would be raised, how they would be administered, and how they would be used. There is a need for


=== EIP-6913 ===
TITLE: SETCODE instruction
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2023-04-20
REQUIRES: 

SUMMARY:
Introduce the `SETCODE` (`0xfc`) instruction, which replaces the code of the executing account from memory.

SPECIFICATION:
When within a read-only execution scope like the recursive kind created by `STATICCALL`, `SETCODE` causes an exceptional abort. When the currently executing code does not equal the code of the executing account, such as can happen inside of `DELEGATECALL` or `CREATE`, `SETCODE` causes an exceptional abort. Otherwise, `SETCODE` consumes

MOTIVATION:
Many contracts are upgradeable in order to facilitate improvement or defer decisions without migrating to a new address. Contracts presently do this in several ways: The oldest method uses `CALL`. The limitation of this method is that internal state must be modifiable by all future implementations. Second, `DELEGATECALL` can

RATIONALE:
The behavior of `CODECOPY`, `CODESIZE`, `EXTCODESIZE`, and `EXTCODECOPY` match the behavior of `DELEGATECALL` and `CREATE`, where it is also possible for executing code to differ from the code of the executing account. The gas cost of `SETCODE` is comparable to `CREATE` but excludes `Gcreate` because no execution context is


=== EIP-7607 ===
TITLE: Hardfork Meta - Fusaka
TYPE: Meta 
STATUS: Draft
CREATED: 2024-02-01
REQUIRES: 7600

SUMMARY:
This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Fulu/Osaka network upgrade.

SPECIFICATION:
Definitions for `Scheduled for Inclusion`, `Considered for Inclusion` and `Proposed for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion * [EIP-7594](./eip-7594.md): PeerDAS - Peer Data Availability Sampling * EOF EIPs listed as part of [EIP-7692](./eip-7692.md), namely: * [EIP-663](./eip-663.md): SWAPN, DUPN and EXCHANGE instructions * [EIP-3540](./eip-3540.md): EOF

RATIONALE:
This Meta EIP provides a global view of all changes included in the Fusaka network upgrade, as well as links to full specification.


=== EIP-1 ===
TITLE: EIP Purpose and Guidelines
TYPE: Meta 
STATUS: Living
CREATED: 2015-10-27
REQUIRES: 


=== EIP-3368 ===
TITLE: Increase block rewards to 3 ETH, with 2 Year Decay to 1 ETH Scheduled
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-12
REQUIRES: 

SUMMARY:
Set the block reward to 3 ETH and then decrease it slightly every block for 4,724,000 blocks (approximately 2 years) until it reaches 1 ETH.

SPECIFICATION:
Adjust block, uncle, and nephew rewards ### Constants * `TRANSITION_START_BLOCK_NUMBER: TBD` * `TRANSITION_DURATION: 4_724_000` (about two years) * `TRANSITION_END_BLOCK_NUMBER: FORK_BLOCK_NUMBER + TRANSITION_DURATION` * `STARTING_REWARD: 3_000_000_000_000_000_000` * `ENDING_REWARD: 1_000_000_000_000_000_000` * `REWARD_DELTA: STARTING_REWARD - ENDING_REWARD` ### Block Reward ```py if block.number >= TRANSITION_END_BLOCK_NUMBER: block_reward = ENDING_REWARD elif block.number = TRANSITION_START_BLOCK_NUMBER: block_reward

MOTIVATION:
A sudden drop in PoW mining rewards could result in a sudden precipitous decrease in mining profitability that may drive miners to auction off their hashrate to the highest bidder while they figure out what to do with their now "worthless" hardware. If enough hashrate is auctioned off in

RATIONALE:
2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort


=== EIP-7698 ===
TITLE: EOF - Creation transaction
TYPE: Standards Track Core
STATUS: Review
CREATED: 2024-04-24
REQUIRES: 3540

SUMMARY:
Creation transactions (i.e. the ones with empty `to`) can be used to deploy EOF contracts by providing EOF initcontainer concatenated with `calldata` for initcontainer execution in transaction's `data`. Initcontainer execution is similar to its execution during `EOFCREATE` instruction, ending with `RETURNCONTRACT` instruction. New account address calculation is based on

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `EOF_MAGIC` | Defined as `0xEF00` in [EIP-3540](./eip-3540.md) | | `MAX_CODE_SIZE` | Defined as `24576` in [EIP-170](./eip-170.md) | In case a creation transaction (transaction with empty `to`) has `data` starting with `EOF_MAGIC`, `data` is interpreted as a

MOTIVATION:
Creation transaction is one if the three ways alongside creation instructions provided by legacy EVM to deploy new code. Given that legacy creation instructions (`CREATE` and `CREATE2`) are not allowed to deploy EOF code, supporting EOF in creation transactions is the only way to get the first EOF on-chain.

RATIONALE:
### Irregular state change to deploy Creator Contract Originally it was proposed to deploy the first EOF contract via irregular state change. This contract would execute `TXCREATE` instruction and could be used then as an entry point to deploy any other EOF code. This would also require an introduction


=== EIP-7778 ===
TITLE: Prevent Block Gas Smuggling
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-01
REQUIRES: 


=== EIP-663 ===
TITLE: SWAPN, DUPN and EXCHANGE instructions
TYPE: Standards Track Core
STATUS: Review
CREATED: 2017-07-03
REQUIRES: 3, 5, 4, 0, ,,  , 5, 4, 5, 0

SUMMARY:
Currently, `SWAP*` and `DUP*` instructions are limited to a stack depth of 16. Introduce three new instructions, `SWAPN`, `DUPN` and `EXCHANGE` which lift this limitation and allow accessing the stack at higher depths.

SPECIFICATION:
We introduce three new instructions: 1. `DUPN` (`0xe6`) 2. `SWAPN` (`0xe7`) 3. `EXCHANGE` (`0xe8`) If the code is legacy bytecode, any of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*) If the code is valid EOF1, the following rules apply: 1. The instructions

MOTIVATION:
While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a "stack to memory elevation" in a compiler. This can result in complex and inefficient code. Furthermore, implementing

RATIONALE:
### EOF-only Since this instruction depends on an immediate argument encoding, it can only be enabled within EOF. In legacy bytecode that encoding could contradict jumpdest-analysis. ### Size of immediate argument For `DUPN` and `SWAPN` a 16-bit size was considered to accommodate the full stack space of 1024 items,


=== EIP-2027 ===
TITLE: State Rent C - Net contract size accounting
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-05-14
REQUIRES: 

SUMMARY:
This is part of the State Rent roadmap. This particular change introduces initial, net accounting of the number of the contract storage slots. Though not very useful on its own, it makes it possible to introduce gross accounting of the number of storage slots, which is useful for number

SPECIFICATION:
Each contract (account with `codeHash` field not equal to 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, which the hash of the empty code) gets a new uint64 field, called `storagesize`. On and after block `C`, the semantics of the operation `SSTORE` (`location`, `value`) changes as follows: - If previous value of the [`location`] is 0,

MOTIVATION:
Ethereum currently does not track the number of contract storage slots at all, and producing such number given the downloaded state cannot be done in constant *O(1)* time.

RATIONALE:
A mechanism for estimation of contract storage size has been proposed [here](https://medium.com/@akhounov/estimation-approximate-of-the-size-of-contracst-in-ethereum-4642fe92d6fe). But it does have a big drawback of introducing a lot of complexity into the consensus (in the form of estimation algorithm, which has quite a few edge cases to cater for different sizes of the storage).


=== EIP-7543 ===
TITLE: EVM arbitrary precision decimal math
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-10-22
REQUIRES: 

SUMMARY:
This EIP adds *arbitrary precision decimal float* OPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for

SPECIFICATION:
### Decimal A decimal is defined as c * 10^q where c and q are int256. Notationwise: a = ac * 10^aq b = bc * 10^bq etc. ### OPCODE defs 0xd0 DECADD a+b -> c : (ac, aq, bc, bq, precision) -> (cc, cq) 0xd1 DECNEG -a ->

MOTIVATION:
Currently, to take a power, a^b, of non integer values, requires vast amounts of Solidity code. The simplest task in trading e.g. is to convert volatilities from yearly to daily, which involves taking the 16th root. Giving users/devs the same ability that scientific calculators have allows for the creation

RATIONALE:
### gas All the above OPCODEs are deterministic, hence the gas cost can be determined. At the same time, the calculations are complex and depend on the input. It is crucial to have accurate gas costs to avoid energy attacks on nodes. To this end, the underlying uint256 lib


=== EIP-198 ===
TITLE: Big integer modular exponentiation
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-01-30
REQUIRES: 


=== EIP-6049 ===
TITLE: Deprecate SELFDESTRUCT
TYPE: Meta 
STATUS: Final
CREATED: 2022-11-27
REQUIRES: 

SUMMARY:
This EIP deprecates the `SELFDESTRUCT` opcode and warns against its use. A breaking change to this functionality is likely to come in the future.

SPECIFICATION:
Documentation of the `SELFDESTRUCT` opcode is updated to warn against its use and to note that a breaking change may be forthcoming.

MOTIVATION:
Discussions about how to change `SELFDESTRUCT` are ongoing. But there is a strong consensus that *something* will change.

RATIONALE:
As time goes on, the cost of doing something increases, because any change to `SELFDESTRUCT` will be a breaking change. The Ethereum Blog and other official sources have not provided any warning to developers about a potential forthcoming change.


=== EIP-1474 ===
TITLE: Remote procedure call specification
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-10-02
REQUIRES: 

SUMMARY:
Nodes created by the current generation of Ethereum clients expose inconsistent and incompatible remote procedure call (RPC) methods because no formal Ethereum RPC specification exists. This proposal standardizes such a specification to provide developers with a predictable Ethereum RPC interface regardless of underlying node implementation.

SPECIFICATION:
### Concepts #### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). #### JSON-RPC Communication with Ethereum nodes is accomplished using [JSON-RPC](https://www.jsonrpc.org/specification), a stateless, lightweight [remote procedure call](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol

RATIONALE:
Much of Ethereum's effectiveness as an enterprise-grade application platform depends on its ability to provide a reliable and predictable developer experience. Nodes created by the current generation of Ethereum clients expose RPC endpoints with differing method signatures; this forces applications to work around method inconsistencies to maintain compatibility with


=== EIP-3045 ===
TITLE: Adds `baseFee` to `eth_getUncleByBlockHashAndIndex`
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2020-10-14
REQUIRES: 1, 4, 7, 4, ,,  , 1, 5, 5, 9

SUMMARY:
Adds `baseFee` property to the `eth_getUncleByBlockHashAndIndex` JSON-RPC request `result` object. This property will contain the value of the base fee for any block after the EIP-1559 fork.

SPECIFICATION:
### `eth_getUncleByBlockHashAndIndex` #### Description Returns information about an uncle specified by block hash and uncle index position Every block returned by this endpoint whose block number is before the [EIP-1559](./eip-1559.md) fork block **MUST NOT** include a `baseFee` field. Every block returned by this endpoint whose block number is on

MOTIVATION:
[EIP-1559](./eip-1559.md) introduces a base fee per gas in protocol. This value is maintained under consensus as a new field in the block header structure. Users may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.

RATIONALE:
The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated. For backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.


=== EIP-7329 ===
TITLE: ERC/EIP Repository split
TYPE: Meta 
STATUS: Final
CREATED: 2023-07-13
REQUIRES: 1

SUMMARY:
Describes the motivation and rational for splitting the EIP repositories into an EIP repository, targeting core ethereum changes and an ERC repository, targeting application layer specifications.

SPECIFICATION:
This specification only details with the initial mechanism of the split. The particulars of how each repository will govern itself is out of scope for this EIP, as it is the motivating point of this EIP that the divergent needs of the community will require highly divergent methods. 1.

MOTIVATION:
Long ago when the EIPs repository was created, there was a vision of a single home for all standards related to Ethereum. The community was small and most people were interacting at every level of the ecosystem. It made sense to combine application standards with core consensus changes. Since

RATIONALE:
There are two major communities served by the EIP process that are highly divergent and very differentiated in their needs. Let's consider the impact of specification ambiguity, the impacts are different based on the community. The core protocol community has a low tolerance for difference of implementation and a


=== EIP-7830 ===
TITLE: Contract size limit increase for EOF
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-11-29
REQUIRES: 1, 7, 0, ,,  , 3, 5, 4, 0, ,,  , 3, 8, 6, 0

SUMMARY:
Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.

SPECIFICATION:
[EIP-170](./eip-170.md) specifies `MAX_CODE_SIZE` as 24576 bytes, and [EIP-3860](./eip-3860.md) specifies `MAX_INITCODE_SIZE` as `2 * MAX_CODE_SIZE` (49152 bytes). <!-- TODO: if profiling analysis shows we need to charge more for EOF analysis, this is where we can specify it. Either globally or for 0xef00 contracs --> Starting `FORK_BLOCK`, for EOF initcode/code

MOTIVATION:
The contract size limit was introduced as a measure against DoS attacks. `JUMPDEST`-analysis is required for legacy contracts, and many of the algorithms performing it are not linear and/or have unknown unknowns. This is one of the reasons for the hesitance of a limit increase. For contract developers the

RATIONALE:
The 64 KiB limit is over 2x of existing limit, while it is not a significant increase, it is the realistic increase given the limitations of initcode. In EOF deployment the to-be-deployed code is stored as a section ("subcontainer"), which has a size limit of 64 KiB, therefore it


=== EIP-2972 ===
TITLE: Wrapped Legacy Transactions
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-09-12
REQUIRES: 1, 5, 5, ,,  , 2, 7, 1, 8

SUMMARY:
Introduces two new [EIP-2718](./eip-2718.md) transactions that are signature compatible with legacy transactions and can be automatically upgraded by any client. * `0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))` * `0x01 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))`

SPECIFICATION:
### Definitions * `||` is the byte/byte-array concatenation operator. * `yParity` is the parity (0 for even, 1 for odd) of the `y` value of the curve point for which `r` is the `x` value in the secp256k1 signing process. ### Transactions As of `FORK_BLOCK_NUMBER`, `0x00 || ssz.serialize(yParity, r,

MOTIVATION:
We would like to eventually deprecate legacy transactions so we no longer have to retain code in the networking and signer layer that deals with them. However, we also want to ensure that signatures for transactions that were generated prior to that deprecation are still valid and funds don't

RATIONALE:
### Signature doesn't include transaction type as first signature byte These transaction types are explicitly designed to be signature compatible with legacy transactions, which means we cannot change the data being signed. See Security Considerations section for more details. ### Two transaction types instead of one With the introduction


=== EIP-616 ===
TITLE: SIMD Operations for the EVM
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-04-25
REQUIRES: 


=== EIP-6963 ===
TITLE: Multi Injected Provider Discovery
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2023-05-01
REQUIRES: 1193

SUMMARY:
An alternative discovery mechanism to `window.ethereum` for [EIP-1193](./eip-1193.md) providers which supports discovering multiple injected Wallet Providers in a web page using Javascript's `window` events.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [RFC-2119]. ### Definitions Wallet Provider: A user agent that manages keys and facilitates transactions with Ethereum. Decentralized Application (DApp): A web page

MOTIVATION:
Currently, Wallet Provider that offer browser extensions must inject their Ethereum providers ([EIP-1193](./eip-1193.md)) into the same window object `window.ethereum`; however, this creates conflicts for users that may install more than one browser extension. Browser extensions are loaded in the web page in an unpredictable and unstable order, resulting in

RATIONALE:
The previous proposal introduced mechanisms that relied on a single, mutable window object that could be overwritten by multiple parties. We opted for an event-based approach to avoid the race conditions, the namespace collisions, and the potential for "pollution" attacks on a shared mutable object; the event-based orchestration creates


=== EIP-3709 ===
TITLE: Remove Support for Type 1 Transactions
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2021-08-07
REQUIRES: 1559

SUMMARY:
Since both `TransactionType` 1 and 2 contain `access_list`, we propose the removal of offering `TransactionType` 1 from wallets and providers, instead the transaction will be converted to `TransactionType` 2 to make use of the new gas properties introduced by [EIP-1559](./eip-1559.md).

SPECIFICATION:
For wallets and providers, if a user submits a transaction for signing with where `TransactionType == 0x1`, the developer should upgrade the transaction to meet the criteria of transaction of type 2. The following fields need to be changed, or amended: - `access_list`: Nothing changes and it should remain

MOTIVATION:
[EIP-2930](./eip-2930.md) was introduced as the first `TransactionType`, type 1, with the intention of adding `access_list` to the `TransactionPayload`. [EIP-1559](./eip-1559.md) introduced the second `TransactionType` 2, which is represented as `rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`. The intention behind EIP-1559 was to enhance the user

RATIONALE:
Improve the user experience for submitting transactions, and move away from legacy style transactions.


=== EIP-2003 ===
TITLE: EVMC modules for implementations of precompiled contracts
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-05-09
REQUIRES: 1352

SUMMARY:
[EVMC] specifies a generic API for Ethereum execution engines. This EIP specifies a way of providing implementations of Ethereum precompiled contracts using the [EVMC VM API].

SPECIFICATION:
For the complete [EVMC] specification visit the [EVMC documentation] first. This EIP is based on and is compatible with EVMC ABI version 6. The EVMC module with implementations of precompiled contracts SHOULD: 1. Advertise the [`EVMC_CAPABILITY_PRECOMPILES`] capability in the [`get_capabilities()`] method. 2. Implement the [`execute()`] method in the following

RATIONALE:
It is very unlikely that any precompile will need to access or modify a contract state. Not requiring the Client to implement the EVMC Host interface removes the big portion of work needed for full EVMC integration.


=== EIP-1011 ===
TITLE: Hybrid Casper FFG
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-04-20
REQUIRES: 

SUMMARY:
This EIP specifies a hybrid PoW/PoS consensus model for Ethereum main net. Existing PoW mechanics are used for new block creation, and a novel PoS mechanism called Casper the Friendly Finality Gadget (FFG) is layered on top using a smart contract. Through the use of Ether deposits, slashing conditions,

SPECIFICATION:
#### Deploying Casper Contract If `block.number == HYBRID_CASPER_FORK_BLKNUM`, then when processing the block before processing any transactions: * set the code of `MSG_HASHER_ADDR` to `MSG_HASHER_CODE` * set the code of `PURITY_CHECKER_ADDR` to `PURITY_CHECKER_CODE` * set the code of `CASPER_ADDR` to `CASPER_CODE` * set balance of `CASPER_ADDR` to `CASPER_BALANCE` Then

MOTIVATION:
Transitioning the Ethereum network from PoW to PoS has been on the roadmap and in the [Yellow Paper](https://github.com/ethereum/yellowpaper) since the launch of the protocol. Although effective in coming to a decentralized consensus, PoW consumes an incredible amount of energy, has no economic finality, and has no effective strategy in

RATIONALE:
Naive PoS specifications and implementations have existed since early blockchain days, but most are vulnerable to serious attacks and do not hold up under crypto-economic analysis. Casper FFG solves problems such as "Nothing at Stake" and "Long Range Attacks" through requiring validators to post slashable deposits and through defining


=== EIP-233 ===
TITLE: Formal process of hard forks
TYPE: Meta 
STATUS: Stagnant
CREATED: 2017-03-23
REQUIRES: 

SUMMARY:
To describe the formal process of preparing and activating hard forks.

SPECIFICATION:
A Meta EIP should be created and merged as a *Draft* as soon as a new hard fork is planned. This EIP should contain: - the desired codename of the hard fork, - activation block number once decided - a timeline section - an EIPs to include section -

MOTIVATION:
Today discussions about hard forks happen at various forums and sometimes in ad-hoc ways.

RATIONALE:
A meta EIP for coordinating the hard fork should help in visibility and traceability of the scope of changes as well as provide a simple name and/or number for referring to the proposed fork.


=== EIP-747 ===
TITLE: wallet_watchAsset RPC Method
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2018-08-13
REQUIRES: 2, 0, ,,  , 1, 0, 4, 6, ,,  , 1, 1, 9, 3

SUMMARY:
This EIP standardizes a new wallet-scoped RPC method, `wallet_watchAsset`, to allow a client to suggest a token for the user's wallet to track.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. A new RPC method, `wallet_watchAsset` is added. `wallet_watchAsset` requests that a specified asset be listed

MOTIVATION:
Today, one of the major uses of Ethereum wallets is to track users' assets. Without this EIP, each wallet either needs to pre-load a list of approved assets, or users must manually add assets to their wallet. In the first case, wallets are burdened with both the security of

RATIONALE:
Displaying a user's assets is a basic feature that every modern DApp user expects. Most wallets currently either manage their own asset lists, which they store client-side, or they query a centralized API for balances, which reduces decentralization and allows correlating account holders with IP addresses. Additionally, refreshing/polling an


=== EIP-2700 ===
TITLE: JavaScript Provider Event Emitter
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2020-06-05
REQUIRES: 

SUMMARY:
This standard provides the description of an object that is made available to JavaScript applications which they can use to receive notifications from an Ethereum Provider. This standard only describes the notification mechanism, it does not specify the payloads that are valid nor does it specify how the client

SPECIFICATION:
### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). ### Interface ```ts interface EthereumProvider { on(eventName: string, listener: (...params: unknown[]) => void): void removeListener(eventName: string, listener: (...params: unknown[])

MOTIVATION:
When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime. Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or

RATIONALE:
This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn't a lot of room for improving things such as by using a discriminated union object for listener parameters or having a tighter definition of `on`. The specific events are intentionally left out


=== EIP-2929 ===
TITLE: Gas cost increases for state access opcodes
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-09-01
REQUIRES: 

SUMMARY:
Increase the gas cost of `SLOAD` (`0x54`) to 2100, and the `*CALL` opcode family (`0xf1`, `f2`, `f4`, `fA`), `BALANCE` `0x31` and the `EXT*` opcode family (`0x3b`, `0x3c`, `0x3f`) to 2600. Exempts (i) precompiles, and (ii) addresses and storage slots that have already been accessed in the same transaction, which

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `FORK_BLOCK` | 12244000 | | `COLD_SLOAD_COST` | 2100 | | `COLD_ACCOUNT_ACCESS_COST` | 2600 | | `WARM_STORAGE_READ_COST` | 100 | For blocks where `block.number >= FORK_BLOCK`, the following changes apply. When executing a transaction, maintain a set

MOTIVATION:
Generally, the main function of gas costs of opcodes is to be an estimate of the time needed to process that opcode, the goal being for the gas limit to correspond to a limit on the time needed to process a block. However, storage-accessing opcodes (`SLOAD`, as well as

RATIONALE:
### Opcode costs vs charging per byte of witness data The natural alternative path to changing gas costs to reflect witness sizes is to charge per byte of witness data. However, that would take a longer time to implement, hampering the goal of providing short-term security relief. Furthermore, following


=== EIP-4895 ===
TITLE: Beacon chain push withdrawals as operations
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-03-10
REQUIRES: 

SUMMARY:
Introduce a system-level "operation" to support validator withdrawals that are "pushed" from the beacon chain to the EVM. These operations create unconditional balance increases to the specified recipients.

SPECIFICATION:
| constants | value | units |--- |--- |--- | `FORK_TIMESTAMP` | 1681338455 | Beginning with the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** introduce the following extensions to payload validation and processing: ### System-level operation: withdrawal Define a new payload-level object called a `withdrawal` that describes withdrawals that have

MOTIVATION:
This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM. The architecture is "push"-based, rather than "pull"-based, where withdrawals are required to be processed in the execution layer as soon as they are dequeued from the consensus layer. Withdrawals are represented

RATIONALE:
### Why not a new transaction type? This EIP suggests a new type of object -- the "withdrawal operation" -- as it has special semantics different from other existing types of EVM transactions. Operations are initiated by the overall system, rather than originating from end users like typical transactions.


=== EIP-1482 ===
TITLE: Define a maximum block timestamp drift
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-10-09
REQUIRES: 

SUMMARY:
On the basis that both Geth and Parity implement the same timestamp validation requirements, this should be written into the reference specification.

SPECIFICATION:
The yellow paper should define a timestamp as: > A scalar value equal to the output of Unix’s time() at this block’s inception. For the purpose of block validation, it must be greater than the previous block's timestamp, and no more than 15 seconds greater than system time.

MOTIVATION:
There is a lack of clarity about how accurate timestamps in the block header must be. The yellow paper describes the timestamp as > A scalar value equal to the reasonable output of Unix’s time() at this block’s inception This causes [confusion](https://ethereum.stackexchange.com/questions/5924/how-do-ethereum-mining-nodes-maintain-a-time-consistent-with-the-network/5926#5926) about the safe use of the `TIMESTAMP`

RATIONALE:
Both [Geth](https://github.com/ethereum/go-ethereum/blob/4e474c74dc2ac1d26b339c32064d0bac98775e77/consensus/ethash/consensus.go#L45) and [Parity](https://github.com/paritytech/parity-ethereum/blob/73db5dda8c0109bb6bc1392624875078f973be14/ethcore/src/verification/verification.rs#L296-L307) reject blocks with timestamp more than 15 seconds in the future. This establishes a defacto standard, which should be made explicit in the reference specification.


=== EIP-7707 ===
TITLE: Incentivize Access List Provisioning
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-12
REQUIRES: 2930

SUMMARY:
This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.

SPECIFICATION:
We shall update [EIP-2930](./eip-2930.md) parameters: | Constant | Value | | - | - | | `ACCESS_LIST_STORAGE_KEY_COST` | 320 | | `ACCESS_LIST_ADDRESS_COST` | 512 |

MOTIVATION:
While [EIP-2930](./eip-2930.md) introduced `accessLists` as a mechanism for `SLOAD` pre-warming to reduce gas costs by informing the EVM upfront about which storage slots a transaction will access, the practical use is limited and uncommon due to the savings versus penalties involved. In order to break even for each address

RATIONALE:
As stated in the introduction the gas cost benefit analysis does not encourage the users of the chain to provide accessList hints, even though the mechanism is already in protocol (and a call to `eth_createAccessList` will give them, or a wallet the correct list to include). So we propose


=== EIP-3651 ===
TITLE: Warm COINBASE
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-07-12
REQUIRES: 2929

SUMMARY:
The `COINBASE` address shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.

SPECIFICATION:
At the start of transaction execution, `accessed_addresses` shall be initialized to also include the address returned by `COINBASE` (`0x41`).

MOTIVATION:
Direct `COINBASE` payments are becoming increasingly popular because they allow conditional payments, which provide benefits such as implicit cancellation of transactions that would revert. But accessing `COINBASE` is overpriced; the address is initially cold under the access list framework introduced in [EIP-2929](./eip-2929.md). This gas cost mismatch can incentivize alternative

RATIONALE:
The addresses currently initialized warm are the addresses that should already be loaded at the start of transaction validation. The `ORIGIN` address is always loaded to check its balance against the gas limit and the gas price. The `tx.to` address is always loaded to begin execution. The `COINBASE` address


=== EIP-2937 ===
TITLE: SET_INDESTRUCTIBLE opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-04
REQUIRES: 

SPECIFICATION:
Add a transaction-wide global variable `globals.indestructible: Set[Address]` (i.e. a variable that operates the same way as the selfdestructs set), initialized to the empty set. Add a `SET_INDESTRUCTIBLE` opcode at `0xA8`, with gas cost `G_base`, that adds the current `callee` to the `globals.indestructible` set. If in the current execution context

MOTIVATION:
The intended use case would be for contracts to make their first byte of code be the `SET_INDESTRUCTIBLE` opcode if they wish to serve as libraries that guarantee to users that their code will exist unmodified forever. This is useful in account abstraction as well as other contexts. Unlike

RATIONALE:
Alternative proposals to this include: * Simply banning `SELFDESTRUCT` outright. This would be ideal, but has larger backwards compatibility issues. * Using a local variable instead of a global variable. This is problematic because it would be broken by `DELEGATECALL`.


=== EIP-158 ===
TITLE: State clearing
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-16
REQUIRES: 


=== EIP-3520 ===
TITLE: Transaction Destination Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-16
REQUIRES: 3508

SUMMARY:
This EIP introduces the following EVM instruction: `ENTRYPOINT`. This instruction is meant to provide access to the original recipient of the transaction, the `to` address, enabling new ways of introspection to be applied in conjunction with [EIP-3508](./eip-3508.md).

SPECIFICATION:
### ENTRYPOINT (`0x4a`) The `ENTRYPOINT` instruction uses 0 stack arguments and pushes the original `to` member of the transaction onto the stack. The address yielded by the instruction is a 160-bit value padded to 256-bits. The operation costs `G_base` to execute, similarly to `ORIGIN` (`0x32`). The address returned by

MOTIVATION:
It is undeniable that smart contracts are becoming more interconnected than ever. Up until this point, smart contracts have entirely relied on compliant interfaces and introspection to introduce a new step in the call chain of a complex multi-contract interaction. However, this presents a forwards-only approach which limits the

RATIONALE:
### AUTHCALL (`0xf7`) Interaction The [EIP-3074](./eip-3074.md) introduced a new call instruction called `AUTHCALL` (`0xf7`) that will replace a transaction's `ORIGIN` (`0x32`) with the context variable `authorized`. The intention of `AUTHCALL` is to prevent discrimination between smart contracts and EOAs which `ORIGIN` initially facilitated. The `ENTRYPOINT` opcode by itself re-introduces


=== EIP-7495 ===
TITLE: SSZ StableContainer
TYPE: Standards Track Core
STATUS: Review
CREATED: 2023-08-18
REQUIRES: 

SUMMARY:
This EIP introduces two new [Simple Serialize (SSZ) types](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/ssz/simple-serialize.md) to enable forward-compatible containers. A `StableContainer[N]` extends an SSZ `Container` with stable merkleization and forward-compatible serialization even when individual fields are deprecated or new fields are introduced in the future. Furthermore, `Profile[B]` is introduced to support specialized sub-types of `StableContainer[N]`

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. **Note:** In this document, `Optional[T]` exclusively refers to Python's `typing.Optional`. Specifically, `Optional[T]` is NOT an

MOTIVATION:
Stable containers and profiles are currently not representable in SSZ. Adding support provides these benefits: 1. **Stable signatures:** Signing roots derived from a `StableContainer[N]` never change. In the context of Ethereum, this is useful for transaction signatures that are expected to remain valid even when future updates introduce additional

RATIONALE:
### What are the problems solved by `StableContainer[N]`? Current SSZ types are only stable within one version of a specification, i.e., one fork of Ethereum. This is alright for messages pertaining to a specific fork, such as attestations or beacon blocks. However, it is a limitation for messages that


=== EIP-1965 ===
TITLE: Method to check if a chainID is valid at a specific block Number
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-20
REQUIRES: 155

SUMMARY:
This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.

SPECIFICATION:
Adds a new precompile which uses 2 argument : a 32 bytes value that represent the chainID to test and a 32 bytes value representing the blockNumber at which the chainID is tested. It return 0x1 if the chainID is valid at the specific blockNumber, 0x0 otherwise. Note that

MOTIVATION:
[EIP-155](./eip-155.md) proposes to use the chain ID to prevent the replay of transactions between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling off-chain message signatures, especially for Layer 2 signature schemes using [EIP-712](./eip-712.md). [EIP-1344](./eip-1344.md) is attempting to solve this

RATIONALE:
The rationale at EIP-1959 applies here as well too : - An opcode is better than a caching system for past chainID, It is cheaper, safer and do not include gaps. - Direct access to the latest chainID is dangerous since it make it easy for contract to use


=== EIP-7378 ===
TITLE: Add time-weighted averaging to the base fee
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-07-22
REQUIRES: 

SUMMARY:
This EIP proposes a new formula to update the base fee, derived from [EIP-1559](./eip-1559.md). The existing base fee update formula, $$b[i+1]\triangleq b[i] \cdot \left( 1+\frac{1}{8} \cdot \frac{s[i]-s^* }{s^* }\right)$$ only considers the last block size $s[i]$. This mechanism incentivizes proposers to collude with users to manipulate the base fee.

SPECIFICATION:
$s[i]$ is replaced by $s_{\textit{avg}}[i]$, where: $$s_{\textit{avg}}[i] \triangleq \alpha\sum_{k=1}^{\infty} (1-\alpha)^k\cdot s[i-k+1]$$ which simplifies to the recursive form $$s_{\textit{avg}}[i] = \alpha\cdot s[i] + (1-\alpha)\cdot s_{\textit{avg}}[i-1]$$ where $\alpha\in(0, 1)$ is the smoothing factor. A higher smoothing factor means that the average responds more quickly to changes in block size (e.g., if

MOTIVATION:
To reduce bribe motivation when the demand for blockspace is high (see Incentive Considerations section) and to reduce oscillations, thus, having a more stable fee setting mechanism. Proposers use a mechanism described in EIP-1559 to determine which messages to include in a block. This mechanism includes a "base fee":

RATIONALE:
An intuitive option for the Transaction Fee Mechanism (TFM) that adjusts supply and demand economically is *First price auction*, which is well known and studied. Nevertheless, the Ethereum network choice was to use EIP-1559 for the TFM (one stated reason was to try and simplify the fee estimation for


=== EIP-1901 ===
TITLE: Add OpenRPC Service Discovery To JSON-RPC Services
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-02-25
REQUIRES: 

SUMMARY:
### What is this? This is a proposal to add [OpenRPC](https://github.com/open-rpc/spec) support to existing and future JSON-RPC services by adding the method [`rpc.discover`](https://github.com/open-rpc/spec#service-discovery-method) to the projects [JSON-RPC](https://www.jsonrpc.org/specification) APIs, enabling automation and tooling. The OpenRPC Document and generated Documentation that specifies all the methods an EVM-based blockchain should implement can

SPECIFICATION:
### What is OpenRPC? The [OpenRPC](https://github.com/open-rpc/spec) Specification defines a standard, programming language-agnostic interface description for [JSON-RPC 2.0](https://www.jsonrpc.org/specification) APIs, which allows both humans and computers to discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic. When properly defined

MOTIVATION:
Although [EIP-1474](./eip-1474.md) outlines a JSON-RPC specification. Ethereum still lacks a machine-readable JSON-RPC Specification that can be used as the industry standard for tooling. This proposal attempts to standardize such a specification in a way that is versionable, and both human and machine readable. Ethereum clients can expose RPC endpoints

RATIONALE:
### Why would we do this? Services need to figure out how to talk to each other. If we really want to build the next generation of automation, then having up to date libraries, documented APIs, and modern tools are going to provide easy discovery, on-boarding, and enable end


=== EIP-779 ===
TITLE: Hardfork Meta: DAO Fork
TYPE: Meta 
STATUS: Final
CREATED: 2017-11-26
REQUIRES: 606

SUMMARY:
This documents the changes included in the hard fork named "DAO Fork". Unlike other hard forks, the DAO Fork did not change the protocol; all EVM opcodes, transaction format, block structure, and so on remained the same. Rather, the DAO Fork was an "irregular state change" that transferred ether

SPECIFICATION:
- Codename: DAO Fork - Activation: - Block == 1,920,000 on Mainnet See references [1] and [2] for the original, full specification. It is summarized here for convenience. At block 1880000, the following accounts are encoded into a list `L`: * The DAO (`0xbb9bc244d798123fde783fcc1c72d3bb8c189413`) * its extraBalance (`0x807640a13483f8ac783c557fcdf27be11ea4ac7a`) *


=== EIP-1276 ===
TITLE: Eliminate Difficulty Bomb and Adjust Block Reward on Constantinople Shift
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-31
REQUIRES: 

SUMMARY:
Starting with `CNSTNTNPL_FORK_BLKNUM` the client will calculate the difficulty without considering the current block number. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Remove Exponential Component of Difficulty Adjustment For the purposes of `calc_difficulty`, simply remove the exponential difficulty adjustment component, `epsilon`, i.e. the `int(2**((block.number // 100000) - 2))`. #### Adjust Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward =

MOTIVATION:
Block time has been played a most important role on blockchain ecosystem, and it is being adjusted by the logic of mining difficulty calculation that is already implemented on the node client as a part of proof-of-work consensus. Last year, average block time rapidly increased due to the wrong

RATIONALE:
This will completely remove the difficulty bomb on difficulty adjustment algorithm without delaying the difficulty bomb again, therefore it is possible to prevent network delay on the beginning of 2019. This EIP-1276 opposes directly the intent of [EIP-1234](./eip-1234.md) which should be also considered in discussions.


=== EIP-7834 ===
TITLE: Separate Metadata Section for EOF
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-12-06
REQUIRES: 3540

SUMMARY:
Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. Extending the format introduced in [EIP-3540](./eip-3540.md), this EIP proposes to add a new OPTIONAL section

MOTIVATION:
It is desirable to include metadata in contract's bytecode for various reasons. For instance, both the Solidity and Vyper compilers by default include the language and compiler version used to compile. Vyper (with 0.4.1) appends an integrity hash to the initcode in CBOR encoding. Solidity additionally includes the IPFS

RATIONALE:
The `metadata_section` in the `body`, as well as the `kind_metadata` and `metadata_size` fields in the `header`, are OPTIONAL. This way, the compilers can avoid additional bytes in the container if they don't want to write any metadata. The `data_section` can change in its size and content during deployment, therefore


=== EIP-999 ===
TITLE: Restore Contract Code at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-04-04
REQUIRES: 

SUMMARY:
The `WalletLibrary` contract was used by the [Parity Wallet](https://www.parity.io/) to reduce gas costs for users deploying multi-signature wallets on the Ethereum blockchain. It contained basic functionality such as confirming or revoking multi-signature transactions for any wallet deployed that depends on this library. The [accidental self-destruction](https://github.com/paritytech/parity/issues/6995) of the library contract

SPECIFICATION:
The self-destructed contract code at [`0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4`](https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code) shall be replaced with a patched version of the [`walletLibrary.sol`](https://github.com/parity-contracts/0x863df6bfa4/blob/master/contracts/walletLibrary.sol) as reviewed, tested, and approved in [parity-contracts/0x863df6bfa4](https://github.com/parity-contracts/0x863df6bfa4): ```json { "object": "606060405234156200000d57fe5b5b6000808054806001018281620000259190620002d9565b916000526020600020900160005b6000909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550506200012081805480602002602001604051908101604052809291908181526020018280548015620000fd57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311620000b2575b505050505060016000620001286401000000000262001d46176401000000009004565b5b5062000330565b600060015411156200013a5760006000fd5b6200015981620001806401000000000262001d71176401000000009004565b620001798383620001c26401000000000262001d9c176401000000009004565b5b5b505050565b60006001541115620001925760006000fd5b80600281905550620001b7620002c16401000000000262001bcf176401000000009004565b6004819055505b5b50565b600060006001541115620001d65760006000fd5b600082111515620001e75760006000fd5b81835110151515620001f95760006000fd5b8251600181905550600090505b8251811015620002b35782818151811015156200021f57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff16600582600101610100811015156200025357fe5b0160005b508190555080600101610105600085848151811015156200027457fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80600101905062000206565b816000819055505b5b505050565b60006201518042811515620002d257fe5b0490505b90565b815481835581811511620003035781836000526020600020918201910162000302919062000308565b5b505050565b6200032d91905b80821115620003295760008160009055506001016200030f565b5090565b90565b611ebf80620003406000396000f300606060405236156100ef576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063173825d91461016d5780632f54bf6e146101a35780634123cb6b146101f157806352375093146102175780635c52c2f51461023d578063659010e71461024f5780637065cb4814610275578063746c9171146102ab578063797af627146102d1578063b20d30a91461030d578063b61d27f61461032d578063b75c7dc61461039c578063ba51a6df146103c0578063c2cf7326146103e0578063c41a360a1461043b578063f00d4b5d1461049b578063f1736d86146104f0575b61016b5b6000341115610168577fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c3334604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b5b565b005b341561017557fe5b6101a1600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610516565b005b34156101ab57fe5b6101d7600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610659565b604051808215151515815260200191505060405180910390f35b34156101f957fe5b610201610691565b6040518082815260200191505060405180910390f35b341561021f57fe5b610227610697565b6040518082815260200191505060405180910390f35b341561024557fe5b61024d61069d565b005b341561025757fe5b61025f6106d7565b6040518082815260200191505060405180910390f35b341561027d57fe5b6102a9600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506106dd565b005b34156102b357fe5b6102bb610829565b6040518082815260200191505060405180910390f35b34156102d957fe5b6102f360048080356000191690602001909190505061082f565b604051808215151515815260200191505060405180910390f35b341561031557fe5b61032b6004808035906020019091905050610dcc565b005b341561033557fe5b61037e600480803573ffffffffffffffffffffffffffffffffffffffff169060200190919080359060200190919080359060200190820180359060200191909192905050610e06565b60405180826000191660001916815260200191505060405180910390f35b34156103a457fe5b6103be60048080356000191690602001909190505061127d565b005b34156103c857fe5b6103de6004808035906020019091905050611392565b005b34156103e857fe5b61042160048080356000191690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190505061141a565b604051808215151515815260200191505060405180910390f35b341561044357fe5b610459600480803590602001909190505061149c565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34156104a357fe5b6104ee600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff169060200190919050506114bf565b005b34156104f857fe5b610500611672565b6040518082815260200191505060405180910390f35b600060003660405180838380828437820191505092505050604051809103902061053f81611678565b156106535761010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561057f57610652565b600160015403600054111561059357610652565b6000600583610100811015156105a557fe5b0160005b5081905550600061010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506105e6611890565b6105ee6119d0565b7f58619076adf5bb0943d100ef88d52d7c3fd691b19d3a9071b555b651fbf418da83604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b5b505050565b6000600061010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541190505b919050565b60015481565b60045481565b6000366040518083838082843782019150509250505060405180910390206106c481611678565b156106d35760006003819055505b5b5b50565b60035481565b60003660405180838380828437820191505092505050604051809103902061070481611678565b156108245761071282610659565b1561071c57610823565b610724611890565b60fa600154101515610739576107386119d0565b5b60fa60015410151561074a57610823565b6001600081548092919060010191905055508173ffffffffffffffffffffffffffffffffffffffff1660056001546101008110151561078557fe5b0160005b508190555060015461010560008473ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507f994a936646fe87ffe4f1e469d3d6aa417d6b855598397f323de5b449f765f0c382604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a15b5b5b5050565b60005481565b600060008261083d81611678565b15610dc45760006101086000866000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415806108c757506000610108600086600019166000191681526020019081526020016000206001015414155b80610906575060006101086000866000191660001916815260200190815260200160002060020180546001816001161561010002031660029004905014155b15610dc25760006101086000866000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415610a5057610a496101086000866000191660001916815260200190815260200160002060010154610108600087600019166000191681526020019081526020016000206002018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610a3f5780601f10610a1457610100808354040283529160200191610a3f565b820191906000526020600020905b815481529060010190602001808311610a2257829003601f168201915b5050505050611b37565b9150610b71565b6101086000856000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166101086000866000191660001916815260200190815260200160002060010154610108600087600019166000191681526020019081526020016000206002016040518082805460018160011615610100020316600290048015610b4a5780601f10610b1f57610100808354040283529160200191610b4a565b820191906000526020600020905b815481529060010190602001808311610b2d57829003601f168201915b505091505060006040518083038185876185025a03f1925050501515610b705760006000fd5b5b7fe3a3a4111a84df27d76b68dc721e65c7711605ea5eee4afd3a9c58195217365c338561010860008860001916600019168152602001908152602001600020600101546101086000896000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661010860008a6000191660001916815260200190815260200160002060020187604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200186600019166000191681526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828103825284818154600181600116156101000203166002900481526020019150805460018160011615610100020316600290048015610d475780601f10610d1c57610100808354040283529160200191610d47565b820191906000526020600020905b815481529060010190602001808311610d2a57829003601f168201915b505097505050505050505060405180910390a16101086000856000191660001916815260200190815260200160002060006000820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff02191690556001820160009055600282016000610db79190611be6565b505060019250610dc3565b5b5b5b5050919050565b600036604051808383808284378201915050925050506040518091039020610df381611678565b15610e0157816002819055505b5b5b5050565b60006000610e1333610659565b1561127357600084849050148015610e305750610e2f85611b51565b5b80610e3d57506001600054145b15610fed5760008673ffffffffffffffffffffffffffffffffffffffff161415610ea457610e9d8585858080601f016020809104026020016040519081016040528093929190818152602001838380828437820191505050505050611b37565b9050610ef3565b8573ffffffffffffffffffffffffffffffffffffffff168585856040518083838082843782019150509250505060006040518083038185876185025a03f1925050501515610ef25760006000fd5b5b7f9738cd1a8777c86b011f7b01d87d484217dc6ab5154a9d41eda5d14af8caf292338688878786604051808773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281038252858582818152602001925080828437820191505097505050505050505060405180910390a1611271565b6000364360405180848480828437820191505082815260200193505050506040518091039020915060006101086000846000191660001916815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16148015611099575060006101086000846000191660001916815260200190815260200160002060010154145b80156110d85750600061010860008460001916600019168152602001908152602001600020600201805460018160011615610100020316600290049050145b1561118f57856101086000846000191660001916815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550846101086000846000191660001916815260200190815260200160002060010181905550838361010860008560001916600019168152602001908152602001600020600201919061118d929190611c2e565b505b6111988261082f565b1515611270577f1733cbb53659d713b79580f79f3f9ff215f78a7c7aa45890f3b89fc5cddfbf328233878988886040518087600019166000191681526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018581526020018473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001806020018281038252848482818152602001925080828437820191505097505050505050505060405180910390a15b5b5b5b5b50949350505050565b60006000600061010560003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054925060008314156112be5761138c565b8260020a9150610106600085600019166000191681526020019081526020016000209050600082826001015416111561138b5780600001600081548092919060010191905055508181600101600082825403925050819055507fc7fb647e59b18047309aa15aad418e5d7ca96d173ad704f1031a2c3d7591734b3385604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182600019166000191681526020019250505060405180910390a15b5b50505050565b6000366040518083838082843782019150509250505060405180910390206113b981611678565b15611415576001548211156113cd57611414565b816000819055506113dc611890565b7facbdb084c721332ac59f9b8e392196c9eb0e4932862da8eb9beaf0dad4f550da826040518082815260200191505060405180910390a15b5b5b5050565b600060006000600061010660008760001916600019168152602001908152602001600020925061010560008673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561147f5760009350611493565b8160020a9050600081846001015416141593505b50505092915050565b6000600560018301610100811015156114b157fe5b0160005b505490505b919050565b60006000366040518083838082843782019150509250505060405180910390206114e881611678565b1561166b576114f683610659565b156115005761166a565b61010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549150600082141561153b5761166a565b611543611890565b8273ffffffffffffffffffffffffffffffffffffffff166005836101008110151561156a57fe5b0160005b5081905550600061010560008673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508161010560008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507fb532073b38c83145e3e5135377a08bf9aab55bc0fd7c1179cd4fb995d2a5159c8484604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019250505060405180910390a15b5b5b50505050565b60025481565b600060006000600061010560003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054925060008314156116bb57611888565b6101066000866000191660001916815260200190815260200160002091506000826000015414156117455760005482600001819055506000826001018190555061010780548091906001016117109190611cae565b826002018190555084610107836002015481548110151561172d57fe5b906000526020600020900160005b5081600019169055505b8260020a90506000818360010154161415611887577fe1c52dc63b719ade82e8bea94cc41a0d5d28e4aaf536adb5e9cccc9ff8c1aeda3386604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182600019166000191681526020019250505060405180910390a16001826000015411151561185e57610107610106600087600019166000191681526020019081526020016000206002015481548110151561180a57fe5b906000526020600020900160005b5060009055610106600086600019166000191681526020019081526020016000206000600082016000905560018201600090556002820160009055505060019350611888565b8160000160008154809291906001900391905055508082600101600082825417925050819055505b5b5b505050919050565b60006000610107805490509150600090505b818110156119bc576101086000610107838154811015156118bf57fe5b906000526020600020900160005b50546000191660001916815260200190815260200160002060006000820160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905560018201600090556002820160006119269190611be6565b505060006001026101078281548110151561193d57fe5b906000526020600020900160005b5054600019161415156119b05761010660006101078381548110151561196d57fe5b906000526020600020900160005b505460001916600019168152602001908152602001600020600060008201600090556001820160009055600282016000905550505b5b8060010190506118a2565b61010760006119cb9190611cda565b5b5050565b6000600190505b600154811015611b33575b60015481108015611a095750600060058261010081101515611a0057fe5b0160005b505414155b15611a1b5780806001019150506119e2565b5b6001600154118015611a4557506000600560015461010081101515611a3d57fe5b0160005b5054145b15611a625760016000815480929190600190039190505550611a1c565b60015481108015611a8b57506000600560015461010081101515611a8257fe5b0160005b505414155b8015611aac5750600060058261010081101515611aa457fe5b0160005b5054145b15611b2e57600560015461010081101515611ac357fe5b0160005b505460058261010081101515611ad957fe5b0160005b508190555080610105600060058461010081101515611af857fe5b0160005b50548152602001908152602001600020819055506000600560015461010081101515611b2457fe5b0160005b50819055505b6119d7565b5b50565b600081516020830184f09050803b15610000575b92915050565b6000611b5c33610659565b15611bc957600454611b6c611bcf565b1115611b89576000600381905550611b82611bcf565b6004819055505b600354826003540110158015611ba55750600254826003540111155b15611bc3578160036000828254019250508190555060019050611bc8565b600090505b5b5b919050565b60006201518042811515611bdf57fe5b0490505b90565b50805460018160011615610100020316600290046000825580601f10611c0c5750611c2b565b601f016020900490600052602060002090810190611c2a9190611cfc565b5b50565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10611c6f57803560ff1916838001178555611c9d565b82800160010185558215611c9d579182015b82811115611c9c578235825591602001919060010190611c81565b5b509050611caa9190611cfc565b5090565b815481835581811511611cd557818360005260206000209182019101611cd49190611d21565b5b505050565b5080546000825590600052602060002090810190611cf89190611d21565b5b50565b611d1e91905b80821115611d1a576000816000905550600101611d02565b5090565b90565b611d4391905b80821115611d3f576000816000905550600101611d27565b5090565b90565b60006001541115611d575760006000fd5b611d6081611d71565b611d6a8383611d9c565b5b5b505050565b60006001541115611d825760006000fd5b80600281905550611d91611bcf565b6004819055505b5b50565b600060006001541115611daf5760006000fd5b600082111515611dbf5760006000fd5b81835110151515611dd05760006000fd5b8251600181905550600090505b8251811015611e85578281815181101515611df457fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1660058260010161010081101515611e2757fe5b0160005b50819055508060010161010560008584815181101515611e4757fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b806001019050611ddd565b816000819055505b5b5050505600a165627a7a7230582016889f0740f073d397f9d00b0d19900fb050b957e3e2942f861085beb9baab180029", "opcodes": "PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH3 0xD JUMPI INVALID JUMPDEST JUMPDEST PUSH1 0x0 DUP1 DUP1 SLOAD DUP1 PUSH1 0x1

MOTIVATION:
This proposal is necessary because the Ethereum protocol does not allow the restoration of self-destructed contracts and there is no other simple way to enable the affected users and companies regaining access to their tokens and Ether. In opposite to previously discussed proposals, this will not change any EVM

RATIONALE:
The design decision to restore the `WalletLibrary` contract code in a single state transition was made after lengthy discussions of [alternate proposals](https://gist.github.com/5chdn/a9bb8617cc8523a030126a3d1c60baf3) that explored different ways to improve the Ethereum protocol to allow contract revivals by adding different built-in contracts. It was eventually concluded that all of these proposals


=== EIP-2015 ===
TITLE: wallet_updateEthereumChain RPC Method
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2019-05-12
REQUIRES: 155

SUMMARY:
This EIP adds a wallet-namespaced RPC endpoint, `wallet_updateEthereumChain`, providing a standard interface for switching chains. The method takes the minimal parameters of `chainId`, `chainName`, `rpcUrl`, `nativeCurrency` and `blockExplorerUrl`.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal adds a method to a wallet's web3 provider API: `wallet_updateEthereumChain`. ### `wallet_updateEthereumChain` The `wallet_updateEthereumChain` method is used to

RATIONALE:
The `wallet_updateEthereumChain` method is designed to be as simple as possible, while still providing the necessary information for a wallet to switch to a new chain. The `chainId` is the only required parameter, as it is the only parameter that is guaranteed to be unique. The `chainName` is included


=== EIP-4747 ===
TITLE: Simplify EIP-161
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-02
REQUIRES: 161

SUMMARY:
Simplify the definition of [EIP-161](./eip-161.md), removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. Retroactively replace EIP-161, starting from its introduction in block 2675000, with the following rules: a. When creating an account, set

MOTIVATION:
EIP-161 is overly complex and has a number of edge cases that are poorly documented and tested. This EIP takes advantage of the complete removal of all remaining empty accounts in block 14049881 (tx `0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d`) to clarify it, and allows implementors to not implement various edge cases that never

RATIONALE:
EIP-161 provides that empty accounts (accounts that have zero nonce, zero balance and no code, but that might have storage) can no longer be created and provides mechanism to remove old empty accounts. The last empty accounts were removed in block 14049881 (tx `0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d`). The complete removal of all


=== EIP-778 ===
TITLE: Ethereum Node Records (ENR)
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2017-11-23
REQUIRES: 


=== EIP-6810 ===
TITLE: Ex Post Facto Cascading Revert
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-01
REQUIRES: 2, 7, 1, 8, ,,  , 2, 9, 2, 9

SUMMARY:
A new transaction type reverts one of a sender's prior transactions, and other transactions dependent on that state, recursively.

SPECIFICATION:
### Parameters A new [EIP-2718](./eip-2718.md) transaction is introduced with `TransactionType` `0x5a`. The [EIP-2718](./eip-2718.md) `TransactionPayload` for this transaction is `rlp([chainId, nonce, revertNonce, budget, signatureYParity, signatureR, signatureS])`. The `signatureYParity, signatureR, signatureS` elements of this transaction represent a secp256k1 signature over `keccak256(0x5a || rlp([chainId, nonce, revertNonce, budget]))`. The [EIP-2718](./eip-2718.md) `ReceiptPayload` for this

MOTIVATION:
While Ethereum has the capability of reversible transactions through smart contracts, instant settlement is the default. But sometimes users make mistakes. Most mistakes are discovered quickly. However, once the transaction is confirmed, it is settled. There are many use cases for reverting settled transactions. Some of the most-common mistakes

RATIONALE:
The transaction must fill the entire block to prevent MEV attacks. While some cascading reverts are highly consequential, others are considerably simpler. The budget ensures the full network cost of the operation is paid. For example, reversing a token transfer to the wrong recipient would be relatively cheap. On


=== EIP-210 ===
TITLE: Blockhash refactoring
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-02-10
REQUIRES: 

SPECIFICATION:
If `block.number == CONSTANTINOPLE_FORK_BLKNUM`, then when processing the block, before processing any transactions set the code of BLOCKHASH_CONTRACT_ADDR to BLOCKHASH_CONTRACT_CODE. If `block.number >= CONSTANTINOPLE_FORK_BLKNUM`, then when processing a block, before processing any transactions execute a call with the parameters: * `SENDER`: SUPER_USER * `GAS`: 1000000 * `TO`: BLOCKHASH_CONTRACT_ADDR *

RATIONALE:
This removes the need for implementations to have an explicit way to look into historical block hashes, simplifying the protocol definition and removing a large component of the "implied state" (information that is technically state but is not part of the state tree) and thereby making the protocol more


=== EIP-2936 ===
TITLE: EXTCLEAR Opcode For SELFDESTRUCTed contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-03
REQUIRES: 

SUMMARY:
Changes `SELFDESTRUCT` (`0xff`) to not clear any storage and adds a new `EXTCLEAR` (`0x5c`) opcode that will clear a specific storage slot for a contract that has previously been self destructed.

SPECIFICATION:
After `FORK_BLOCK_NUM`, a new opcode, `EXTCLEAR`, is enabled at `0x5C` to clear storage for `SELFDESTRUCT`ed contracts. `EXTCLEAR`: * does not push any words onto the stack * pops two words off the stack: the destroyed contract address and a storage address * if the contract exists, charge the same

MOTIVATION:
`SELFDESTRUCT` (`0xFF`) is unnecessarily complex because it clears an unbounded amount of contract storage. It is computationally expensive for nodes to track all of the storage used in every contract in case the contract `SELFDESTRUCT`s. Further, contracts can be re-initialized using `CREATE2` (`0xF5`), and then `SLOAD` (`0x54`) prior storage.

RATIONALE:
`0x5C` is available in the same range as `SSTORE` and `SLOAD`.


=== EIP-2028 ===
TITLE: Transaction data gas cost reduction
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-05-03
REQUIRES: 

SPECIFICATION:
The gas per non-zero byte is reduced from 68 to 16. Gas cost of zero bytes is unchanged.

MOTIVATION:
There are a couple of main benefits to accepting this proposal and lowering gas cost of Calldata On-Chain Scalability: Generally speaking, higher bandwidth of Calldata improves scalability, as more data can fit within a single block. * Layer two scalability: Layer two scaling solutions can improve scalability by moving

RATIONALE:
Roughly speaking, reducing the gas cost of Calldata leads to potentially larger blocks, which increases the network delay associated with data transmission over the network. This is only part of the full network delay, other factors are block processing time (and storage access, as part of it). Increasing network


=== EIP-5003 ===
TITLE: Insert Code into EOAs with AUTHUSURP
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-03-26
REQUIRES: 3, 0, 7, 4, ,,  , 3, 6, 0, 7

SUMMARY:
This EIP introduces a new opcode, `AUTHUSURP`, which deploys code at an [EIP-3074](./eip-3074.md) authorized address. For externally owned accounts (EOAs), together with [EIP-3607](./eip-3607.md), this effectively revokes the original signing key's authority.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. ### Conventions - **`top - N`** - the `N`th most recently pushed value on the EVM stack, where `top -

MOTIVATION:
EOAs currently hold a significant amount of user-controlled value on Ethereum blockchains, but are limited by the protocol in a variety of critical ways. These accounts do not support rotating keys for security, batching to save gas, or sponsored transactions to reduce the need to hold ether yourself. There

RATIONALE:
`AUTHUSURP` does not check the nonce of the `authorized` account because it must work with accounts that have previously sent transactions. When using `AUTHUSURP`, if the initcode were to deploy a zero-length contract, there would be no way to prevent using `AUTHUSURP` again later. The account's code must be


=== EIP-867 ===
TITLE: Standardized Ethereum Recovery Proposals
TYPE: Meta 
STATUS: Stagnant
CREATED: 2018-02-02
REQUIRES: 

SUMMARY:
This proposal identifies a common solution method that can be used to address certain classes of lost funds on the Ethereum blockchain. In particular, it is intended to address cases where there is no disagreement about the right outcome between directly affected parties, enabling timely and low-risk solutions to

SPECIFICATION:
This EIP describes a common format to be used for a subclass of EIPs, referred to as ethereum recovery proposals (ERPs), that propose an irregular state change required to address a fund recovery scenario that cannot be addressed using the standard protocol. Each ERP will reference this EIP will

MOTIVATION:
The issue of fund recovery on the Ethereum blockchain is often controversial. Frozen fund recovery proposals are almost never successful due to the relatively ad-hoc nature of such requests and the subjectivity that is often required to evaluate the merits. This EIP attempts to remove these barriers by providing

RATIONALE:
The primary consideration for the approach described above was to minimize the amount of risk associated with recovery actions that would otherwise not have a viable solution. A secondary consideration was to standardize the format used in the proposals for recovery actions. First, including a verification script guarantees that


=== EIP-2124 ===
TITLE: Fork identifier for chain compatibility checks
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2019-05-03
REQUIRES: 

SUMMARY:
There are many public and private Ethereum networks, but the discovery protocol doesn't differentiate between them. The only way to check if a peer is good or bad (same chain or not), is to establish a TCP/IP connection, wrap it with RLPx cryptography, then execute an `eth` handshake. This

SPECIFICATION:
Each node maintains the following values: - **`FORK_HASH`**: IEEE CRC32 checksum (`[4]byte`) of the genesis hash and fork blocks numbers that already passed. - The fork block numbers are fed into the CRC32 checksum in ascending order. - If multiple forks are applied at the same block, the block

MOTIVATION:
Peer-to-peer networking is messy and hard due to firewalls and network address translation (NAT). Generally only a small fraction of nodes have publicly routed addresses and P2P networks rely mainly on these for forwarding data for everyone else. The best way to maximize the utility of the public nodes

RATIONALE:
##### Why flatten `FORK_HASH` into 4 bytes? Why not share the entire genesis and fork list? Whilst the `eth` devp2p protocol permits arbitrarily much data to be transmitted, the discovery protocol's total space allowance for all ENR entries is 300 bytes. Reducing the `FORK_HASH` into a 4 bytes checksum


=== EIP-3267 ===
TITLE: Giving Ethereum fees to Future Salaries
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-02-13
REQUIRES: 

SUMMARY:
Transfer a part (exact fractions - TBD) of mining/transfer fees + (probably: TBD) some minted ETH to the `DonateETH` contract configured to transfer to `SalaryWithDAO` contract.

SPECIFICATION:
(TBD) `SalaryWithDAO` = `TBD` (`address`) `DefaultDAOInterface` = `TBD` (`address`) `MintPerPeriod` = `TBD` (`uint256`) `TransferFraction` = `TBD` (0..1) `MineFraction` = `TBD` (0..1) [The contract's source](../assets/eip-3267/contracts/README.md) Prior to `FORK_BLOCK_NUMBER`, `SalaryWithDAO` and `DefaultDAOInterface` contracts will be deployed to the network and exist at the above specified addresses. Change the Ethereum clients to

MOTIVATION:
This proposal solves two problems at once: 1. It provides a big amount of "money" to common good producers. That obviously personally benefits common good producers, allowing them to live better human lives, it increases peoples' and organizations' both abilities and incentives to produce common goods. That benefits the

RATIONALE:
The Future Salaries is the _only_ known system of distributing significant funds to common good producers. (Quadratic funding aimed to do a similar thing, but in practice as we see on GitCoin it favors a few developers, ignores project of highly advanced scientific research that is hard to explain


=== EIP-3670 ===
TITLE: EOF - Code Validation
TYPE: Standards Track Core
STATUS: Review
CREATED: 2021-06-23
REQUIRES: 3540

SUMMARY:
Introduce code validation at contract creation time for EOF formatted ([EIP-3540](./eip-3540.md)) contracts. Reject contracts which contain truncated `PUSH`-data or undefined instructions. Legacy bytecode (code which is not EOF formatted) is unaffected by this change.

SPECIFICATION:
This feature is introduced on the same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST be validated according to these rules. 1. Previously deprecated instructions `CALLCODE` (0xf2) and `SELFDESTRUCT` (0xff), as well as instructions deprecated in EIP-3540, are invalid and their opcodes are undefined. (**NOTE** there are more

MOTIVATION:
Currently existing contracts require no validation of correctness and EVM implementations can decide how they handle truncated bytecode or undefined instructions. This change aims to bring code validity into consensus, so that it becomes easier to reason about bytecode. Moreover, EVM implementations may require fewer paths to decide which

RATIONALE:
### Immediate data Allowing implicit zero immediate data for `PUSH` instructions introduces inefficiencies to EVM implementations without any practical use-case (the value of a `PUSH` instruction at the code end cannot be observed by EVM). This EIP requires all immediate bytes to be explicitly present in the code. ###


=== EIP-5283 ===
TITLE: Semaphore for Reentrancy Protection
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-07-17
REQUIRES: 2, 0, ,,  , 1, 2, 8, 3, ,,  , 1, 3, 5, 2

SUMMARY:
This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage,

SPECIFICATION:
Starting from an activation block (TBD) a new precompiled contract `Semaphore` is created at address `0x0A`. When `Semaphore` is called, if the caller address is present more than once in the call stack, the contract behaves as if the first instruction had been a `REVERT`, therefore the CALL returns

MOTIVATION:
The typical smart contract RPG uses a contract storage cell. The algorithm is simple: the code checks that a storage cell is 0 (or any other predefined constant) on entry, aborting if not, and then sets it to 1. After executing the required code, it resets the cell back

RATIONALE:
The address `0x0A` is the next one available within the range defined by [EIP-1352](./eip-1352). ### Sample usage ```solidity pragma solidity ^0.8.0; abstract contract ReentrancyGuard2 { uint8 constant SemaphoreAddress = 0x0A; /** * @dev Prevents a contract from calling itself, directly or indirectly. * Calling a `nonReentrant` function from another


=== EIP-1962 ===
TITLE: EC arithmetic and pairings with runtime definitions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-04-22
REQUIRES: 1109

SUMMARY:
This EIP proposes a new precompile to bring cryptographic functionality desired for privacy and scaling solutions. Functionality of such precompile will require the following: - Implementation the following operations over elliptic curves in the Weierstrass form with curve parameters such as base field, A, B coefficients defined in runtime:

SPECIFICATION:
If `block.number >= XXXXX`, define a set of `10` new precompiles with an addresses `[0x.., 0x.., ...]` and the following functionality. - Addition of points on the curve defined over base field - Multiplication of a point on the curve defined over base field - Multiexponentiation for `N` pairs

MOTIVATION:
- There is a pending proposal to implement base elliptic curve arithmetic is covered by [EIP-1829](./eip-1829.md) and will allow to implement various privacy-preserving protocols with a reasonable gas costs per operation. - Pairings are an important extension for basic arithmetic and so this new precompile is proposed with the

RATIONALE:
Only the largest design decisions will be covered: - While there is no arithmetic over the scalar field (which is modulo size of the main group) of the curve, it's required for gas estimation purposes. - Multiexponentiation is a separate operation due to large cost saving - There are


=== EIP-214 ===
TITLE: New opcode STATICCALL
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
This proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present). Any opcode that attempts to perform such a modification (see below for details) will result in an exception

SPECIFICATION:
Introduce a new `STATIC` flag to the virtual machine. This flag is set to `false` initially. Its value is always copied to sub-calls with an exception for the new opcode below. Opcode: `0xfa`. `STATICCALL` functions equivalently to a `CALL`, except it takes only 6 arguments (the "value" argument is

MOTIVATION:
Currently, there is no restriction about what a called contract can do, as long as the computation can be performed with the amount of gas provided. This poses certain difficulties about smart contract engineers; after a regular call, unless you know the called contract, you cannot make any assumptions

RATIONALE:
This allows contracts to make calls that are clearly non-state-changing, reassuring developers and reviewers that re-entrancy bugs or other problems cannot possibly arise from that particular call; it is a pure function that returns an output and does nothing else. This may also make purely functional HLLs easier to


=== EIP-7804 ===
TITLE: Withdrawal Credential Update Request
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-31
REQUIRES: 

SUMMARY:
This proposal defines a mechanism to allow validators to update their withdrawal credentials using a new execution request type (0x03). The request allows for changing the execution address and the withdrawal credential prefix (0x01 or 0x02).

SPECIFICATION:
### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | *TBD* | Mainnet | ### Configuration | Name | Value | Comment | | - | - | - | | `WITHDRAWAL_CREDENTIALS_UPDATE_REQUEST_PREDEPLOY_ADDRESS` | `0x09Fc772D0857550724b07B850a4323f39112aAaA` | Where to call and store relevant

MOTIVATION:
When the ability to update a validator BLS withdrawal credentials to execution address was introduced in Capella, one of the most common questions was about allowing the withdrawal credential to be changed in the future. Either for security (e.g. credential rotation) or to allow for alternative ways of handling

RATIONALE:
<!-- TODO -->


=== EIP-1295 ===
TITLE: Modify Ethereum PoW Incentive Structure and Delay Difficulty Bomb
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-08-05
REQUIRES: 

SUMMARY:
Starting with CNSTNTNPL_FORK_BLKNUM the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 6 million blocks later than previously specified with the Homestead fork. Furthermore, Uncle rewards will be adjusted and Nephew rewards will be removed to

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 6_000_000) if block.number >= CNSTNTNPL_FORK_BLKNUM else block.number #### Adjust Uncle and Nephew rewards If an

MOTIVATION:
Network scalability and security are at the forefront of risks to the Ethereum protocol. With great strides being made towards on and off chain scalability, the existence of an artificial throughput limiting device in the protocol is not warranted. Removing the risk of reducing throughput through the initialization of

RATIONALE:
The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the growing ecosystem’s security are paramount. At the same time, the ancillary issuance benefits of the Ethereum protocol can be adjusted to reduce the overall issuance profile. Aggressively adjusting Uncle and removing


=== EIP-7799 ===
TITLE: System logs
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-29
REQUIRES: 1, 5, 5, 9, ,,  , 4, 8, 9, 5, ,,  , 6, 4, 6, 6, ,,  , 7, 7, 0, 8

SUMMARY:
This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### System logs list A new list is introduced to track all block level logs

MOTIVATION:
With [EIP-7708](./eip-7708.md) wallets gain the ability to use eth_getLogs to track changes to their ETH balance. However, the ETH balance may change without an explicit transaction, through block production and withdrawals. By having such operations emit block-level system logs, eth_Logs provides a complete picture of ETH balance changes.

RATIONALE:
Together with [EIP-7708](./eip-7708.md) this EIP provides the ability for wallets to compute the exact ETH balance from logs without requiring download of every single block header and all withdrawals. The block reward from priority fees no longer has to be summed up by processing all receipts and can be


=== EIP-6122 ===
TITLE: Forkid checks based on timestamps
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-12-13
REQUIRES: 2124

SUMMARY:
[EIP-2124](./eip-2124.md) proposed a way of identifying nodes on the p2p network based on their chain configuration via the forkid parameter. It allows nodes to cut incompatible nodes off quickly which makes the P2P network more reliable. After the merge, forks are scheduled by block time instead of block number.

SPECIFICATION:
Each node maintains the following values: - **`FORK_HASH`**: IEEE CRC32 checksum (`[4]byte`) of the genesis hash and fork blocks numbers or timestamps that already passed. - The fork block numbers or timestamps are fed into the CRC32 checksum in ascending order. - If multiple forks are applied at the

MOTIVATION:
While in proof-of-work forks were scheduled by block number, the proof-of-stake consensus layer schedules forks by slot number. The slot number is a time based measurement. In order to schedule forks at the same time on the consensus and execution layer, the execution layer is forced to also schedule

RATIONALE:
Shanghai will be scheduled by timestamp thus the forkid calculations need to be updated to work with timestamps and blocks. Since all block number based forks are before time based forks, nodes need to check the block based forks before the time based forks.


=== EIP-4762 ===
TITLE: Statelessness gas cost changes
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.

SPECIFICATION:
### Helper functions ```python def get_storage_slot_tree_keys(storage_key: int) -> [int, int]: if storage_key < (CODE_OFFSET - HEADER_STORAGE_OFFSET): pos = HEADER_STORAGE_OFFSET + storage_key else: pos = MAIN_STORAGE_OFFSET + storage_key return ( pos // 256, pos % 256 ) ``` ### Access events Whenever the state is read, one or more of

MOTIVATION:
The introduction of Verkle trees into Ethereum requires fundamental changes and as a preparation, this EIP is targeting the fork coming right before the verkle tree fork, in order to incentivize Dapp developers to adopt the new storage model, and ample time to adjust to it. It also incentivizes

RATIONALE:
### Gas reform Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design. `WITNESS_CHUNK_COST` is set to charge 6.25 gas per byte for chunks, and `WITNESS_BRANCH_COST` is set to charge ~13,2 gas per byte for branches on


=== EIP-7675 ===
TITLE: Retroactively Included EIPs
TYPE: Meta 
STATUS: Review
CREATED: 2024-04-04
REQUIRES: 2, 6, 8, 1, ,,  , 3, 6, 0, 7, ,,  , 7, 5, 2, 3, ,,  , 7, 6, 1, 0

SUMMARY:
This Meta EIP lists Core EIPs introducing changes to Ethereum's consensus which were activated independently of an Ethereum hard fork due to their backward compatible nature. These EIPs generally introduce constraints to underspecified protocol rules or clarify how certain edge cases should be handled.

SPECIFICATION:
### Retroactively Activated EIPs * [EIP-2681](./eip-2681.md): Limit account nonce to 2^64-1 * [EIP-3607](./eip-3607.md): Reject transactions from senders with deployed code * [EIP-7523](./eip-7523.md): Empty accounts deprecation * [EIP-7610](./eip-7610.md): Revert creation in case of non-empty storage ### Activation All EIPs listed above are considered activated as of Ethereum's genesis block. Note

MOTIVATION:
To maintain consensus across all nodes, backward incompatible changes to Ethereum must be activated synchronously. Given the coordination required for this, changes are usually bundled together in network upgrades. A Meta EIP is typically used to list the changes included in a network upgrade, as well as its activation

RATIONALE:
This Meta EIP provides a global view of all changes included in the Ethereum protocol without an explicit network upgrade, as well as links to full specification.


=== EIP-3554 ===
TITLE: Difficulty Bomb Delay to December 2021
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-05-06
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9,700,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 9_700_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
Targeting for the Shanghai upgrade and/or the Merge to occur before December 2021. Either the bomb can be readjusted at that time, or removed all together.

RATIONALE:
The following script predicts a .1 second delay to blocktime the first week of december and a 1 second delay by the end of the month. This gives reason to address because the effect will be seen, but not so much urgency we don't have space to work around


=== EIP-7736 ===
TITLE: Leaf-level state expiry in verkle trees
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-07-05
REQUIRES: 6800

SUMMARY:
Adds an "update epoch" to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted. A new transaction type with a simple verkle proof pays for the costs of reactivating the extension and suffix nodes,

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Constants |Name|Description|Value| |----|-----------|-----| |`FORK_TIME`|Fork activation time|TBD| |`EPOCH_LENGTH`|Duration of an epoch, in s|15778800 (6 months)|

MOTIVATION:
Previous attempts at implementing state expiry have been stalled by the quickly-increasing complexity, require heavy change in the structure of ethereum (address space extension, oil, multiple trees, ...). This proposal is offering a simpler albeit non-exhaustive approach to state expiry: only removing the leaf nodes and leaving the rest

RATIONALE:
This approach has the benefit of simplicity, over previous proposals for state expiry: * no Address Space Extension (ASE) required * it only uses a single tree instead of multiple, per-epoch trees * smaller resurrection proofs, as only providing the data is necessary to resurrect. * clear gas costs


=== EIP-7594 ===
TITLE: PeerDAS - Peer Data Availability Sampling
TYPE: Standards Track Networking
STATUS: Review
CREATED: 2024-01-12
REQUIRES: 4844

SUMMARY:
PeerDAS (Peer Data Availability Sampling) is a networking protocol that allows beacon nodes to perform data availability sampling (DAS) to ensure that blob data has been made available while downloading only a subset of the data. PeerDAS utilizes gossip for distribution, discovery for finding peers of particular data custody,

SPECIFICATION:
We extend the blobs introduced in EIP-4844 using a one-dimensional erasure coding extension. Each row consists of the blob data combined with its erasure code. It is subdivided into cells, which are the smallest units that can be authenticated with their respective blob's KZG commitments. Each column, associated with

MOTIVATION:
DAS is a method of scaling data availability beyond the levels of [EIP-4844](./eip-4844.md) by not requiring all nodes to download all data while still ensuring that all of the data has been made available. Providing additional data availability helps bring scale to Ethereum users in the context of layer

RATIONALE:
TBD


=== EIP-2387 ===
TITLE: Hardfork Meta: Muir Glacier
TYPE: Meta 
STATUS: Final
CREATED: 2019-11-22
REQUIRES: 1, 6, 7, 9, ,,  , 2, 3, 8, 4

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hard fork named Muir Glacier. This hard fork addresses the impending Ice Age on Ethereum Mainnet and includes a commitment to solving the problems with the ice age more permanently.

SPECIFICATION:
- Codename: Muir Glacier ### Activation - `Block >= 9,200,000` on the Ethereum mainnet - `Block >= 7,117,117` on the Ropsten testnet - `Block >= N/A` on the Kovan testnet - `Block >= N/A` on the Rinkeby testnet - `Block >= N/A` on the Görli testnet ### Included EIPs

MOTIVATION:
Ethereum achieves a consistent block time due to its' difficulty retargeting algorithm. If a block-time is higher than 20 seconds, it reduces the difficulty, and if a block time is lower than 10 seconds, it increases the difficulty. This mechanism reaches typically an equilibrium of around 13-14 seconds. Included

RATIONALE:
I want to address the rationale for the intention of the Iceage and the implementation of the Iceage separately. **The original intentions of the ice age include:** - At the time of upgrades, inhibit unintentional growth of the resulting branching forks leading up to Eth 2.0. * - Encourage


=== EIP-4938 ===
TITLE: eth/67 - Removal of GetNodeData
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2022-03-23
REQUIRES: 2, 4, 6, 4, ,,  , 2, 4, 8, 1

SUMMARY:
The [Ethereum Wire Protocol](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/eth.md) defines request and response messages for exchanging data between clients. The `GetNodeData` request retrieves a set of trie nodes or contract code from the state trie by hash. We propose to remove the `GetNodeData` and `NodeData` messages from the wire protocol.

SPECIFICATION:
Remove the following message types from the `eth` protocol: * `GetNodeData (0x0d)` * **(eth/66)**: `[request_id: P, [hash_0: B_32, hash_1: B_32, ...]]` * `NodeData (0x0e)` * **(eth/66)**: `[request_id: P, [value_0: B, value_1: B, ...]]`

MOTIVATION:
`GetNodeData` and `NodeData` were introduced in protocol version `eth/63` to allow for a sync mode called "fast sync", which downloads the Ethereum state without executing all blocks. The sync algorithm works by requesting all state trie nodes and contract codes by their hash. Serving `GetNodeData` requests requires clients to

RATIONALE:
A replacement for `GetNodeData` is available in the [snap protocol](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md). Specifically, clients can use the [GetByteCodes](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md#getbytecodes-0x04) and [GetTrieNodes](https://github.com/ethereum/devp2p/blob/40ab248bf7e017e83cc9812a4e048446709623e8/caps/snap.md#gettrienodes-0x06) messages instead of `GetNodeData`. The snap protocol can be used to implement the "fast sync" algorithm, though it is recommended to use it for "snap sync".


=== EIP-5022 ===
TITLE: Increase price of SSTORE from zero to non-zero to 40k gas
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-20
REQUIRES: 

SUMMARY:
Increase the price of the SSTORE opcode from `20_000` gas to `40_000` gas when the original slot is zero and the resultant slot is non-zero. ### Motivation The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage

SPECIFICATION:
| Constant | Value | | - | - | | `FORK_BLOCK` | TBD | | `NEW_STORAGE_PRICE` | `40_000` For blocks where `block.number >= FORK_BLOCK`, a new gas schedule applies. Make `SSTORE_SET_GAS`, the price when a slot is set from zero to non-zero, equal `NEW_STORAGE_PRICE`. All other costs remain

MOTIVATION:
The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage slot has not increased. All resources are merged into the same pricing mechanism. If the price for creating new storage slots is fixed, then it needs to

RATIONALE:
### Why not also raise the cost of non-zero to non-zero? Rewriting storage does not affect state growth, which is the main issue this EIP is addressing. Rewriting storage may also be underpriced. Increasing the price of state growth will, at least, incentivize developers to reuse storage instead. ###


=== EIP-2070 ===
TITLE: Hardfork Meta: Berlin
TYPE: Meta 
STATUS: Withdrawn
CREATED: 2019-05-20
REQUIRES: 1679

SUMMARY:
This meta-EIP specifies the changes included in the Ethereum hardfork named Berlin.

SPECIFICATION:
- Codename: Berlin In the current stage of coordination, the changes are tracked and discussed in the [eth1.0-specs](https://github.com/ethereum/eth1.0-specs) repository. For an accurate status please refer to the [`berlin.md`](https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/berlin.md) file.


=== EIP-1240 ===
TITLE: Remove Difficulty Bomb
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2018-07-21
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty without considering the current block number.

SPECIFICATION:
#### Remove Difficulty For the purposes of `calc_difficulty`, if `block.number >= FORK_BLOCK_NUMBER` then change the epsilon component to `0` rather than having it be a function of block number.

MOTIVATION:
The difficulty bomb operates under the assumption that miners decide what code economic participants are running, rather than economic participants deciding for themselves. In reality, miners will mine whatever chain is most profitable and the most profitable chain is the one that economic participants use. If 99% of miners

RATIONALE:
With the difficulty bomb removed, when Casper is released it will be up to economic participants to decide whether they want the features that Casper enables or not. If they do not want Casper, they are free to continue running unpatched clients and participating in the Ethereum network as


=== EIP-7703 ===
TITLE: Increase calldata cost
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-05-07
REQUIRES: 

SUMMARY:
An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.

SPECIFICATION:
* Increase `G_CALLDATAZERO` from 4 to 12. * Increase `G_CALLDATANONZERO` from 16 to 48.

MOTIVATION:
Larger blocks take longer to propagate through the network. In this way, the maximium potential block size is constraining the block gas limit. Therefore, in order to safely increase the block gas limit, the calldata gas must be increased.

RATIONALE:
Tripling the gas cost of calldata reduces the maximimum possible block size by a factor of three.


=== EIP-1057 ===
TITLE: ProgPoW, a Programmatic Proof-of-Work
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-05-02
REQUIRES: 

SUMMARY:
ProgPoW is a proof-of-work algorithm designed to close the efficiency gap available to specialized ASICs. It utilizes almost all parts of commodity hardware (GPUs), and comes pre-tuned for the most common hardware utilized in the Ethereum network. This document presents an overview of the algorithm and examines what it

SPECIFICATION:
ProgPoW can be tuned using the following parameters. The proposed settings have been tuned for a range of existing, commodity GPUs: * `PROGPOW_PERIOD`: Number of blocks before changing the random program * `PROGPOW_LANES`: The number of parallel lanes that coordinate to calculate a single hash instance * `PROGPOW_REGS`: The

MOTIVATION:
Ever since the first bitcoin mining ASIC was released, many new Proof of Work algorithms have been created with the intention of being “ASIC-resistant”. The goal of “ASIC-resistance” is to resist the centralization of PoW mining power such that these coins couldn’t be so easily manipulated by a few


=== EIP-2733 ===
TITLE: Transaction Package
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-06-16
REQUIRES: 2718

SUMMARY:
Introduce a new transaction type which includes a list of transactions that must be executed serially by clients. Execution information (e.g. success, gas_used, etc.) will be propagated forward to the next transaction.

SPECIFICATION:
Introduce a new [EIP-2718](./eip-2718.md) transaction type where `id = 2`. #### Structure ``` struct TransactionPackage { chain_id: u256, children: [ChildPackage], nonce: u64, gas_price: u256, v: u256, r: u256, s: u256 } ``` ##### Hash `keccak256(rlp([2, chain_id, children, nonce, gas_price, v, r, s])` ##### Signature Hash `keccak256(rlp([2, chain_id, children, nonce,

MOTIVATION:
Onboarding new users to Ethereum has been notoriously difficult due to the need for new users to acquire enough ether to pay for their transactions. This hurdle has seen a significant allocation of resources over the years to solve. Today, that solution is meta-transactions. This is, unfortunately, a brittle

RATIONALE:
### Each `Child` has its own signature For simplicity, the author has chosen to require each child package to specify its own signature, even if the signer is the same as the package signer. This choice is made to allow for maximum flexibility, with minimal client changes. This transaction


=== EIP-2803 ===
TITLE: Rich Transactions
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-07-18
REQUIRES: 

SUMMARY:
If a transaction has a `to` of address `x`, then the `data` of the transaction will be treated as EVM bytecode and it will be executed from the context of the `CALLER` of the transaction (aka: the transaction signer).

SPECIFICATION:
A new reserved address is specified at `x`, in the range used for precompiles. When a transaction is sent to this address from an externally owned account, the payload of the transaction is treated as EVM bytecode, and executed with the signer of the transaction as the current account.

MOTIVATION:
Many Ethereum DApps presently require users to approve multiple transactions in order to produce one effect - for example, the common pattern of first approving a contract to spend a token, then calling that contract. This results in a poor user-experience, and complicates the experience of interacting with DApps.

RATIONALE:
The intent of this EIP is for the new precompile to act in all ways possible like a `DELEGATECALL` from an externally owned account. Some changes are required to reflect the fact that the code being executed is not stored on chain, and for special cases such as `SELFDESTRUCT`,


=== EIP-3332 ===
TITLE: MEDGASPRICE Opcode
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-05
REQUIRES: 

SUMMARY:
Adds `MEDGASPRICE (0x46)` opcode that returns the median gas price for the parent block.

SPECIFICATION:
If `block.number >= TBD`, add a new opcode `MEDGASPRICE (0x46)`: Pushes the median gas price of the parent block onto the stack. | Op | Input | Output | Cost | |:----: |:-----: |:------: |:----: | | 0x46 | 0 | 1 | 8 |

MOTIVATION:
With the emergence of rollups as core mechanisms in scaling Ethereum there are a number of common transactions that can be front-run. Optimistic rollups rely on the submission of fraud proofs to maintain the integrity of their systems. As a result actors submitting fraud proofs typically receive a financial

RATIONALE:
Having access to the current gas price economy allows contracts to implement more robust and automated logic surrounding acceptable transaction gas prices. ### Naming note The name `MEDGASPRICE` was chosen because the median gas price of the network can only be calculated from the latest complete block. Thus transactions


=== EIP-3026 ===
TITLE: BW6-761 curve operations
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-10-05
REQUIRES: 2539

SUMMARY:
This precompile adds operations for the BW6-761 curve (from the EY/Inria **Optimized and secure pairing-friendly elliptic curves suitable for one layer proof composition** research paper) as a precompile in a set necessary to *efficiently* perform verification of one-layer composed zkSNARKs proofs. If `block.number >= X` we introduce *seven* separate

SPECIFICATION:
Curve parameters: The BW6-761 `y^2=x^3-1` curve is fully defined by the following set of parameters: ``` Base field modulus = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008b A coefficient = 0x0 B coefficient = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008a Main subgroup order = 0x1ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001 Extension tower: Fp3 construction: (Fp3 = Fp[u]/u^3+4) Fp cubic non-residue = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d000000000087 Twist parameters: Twist

MOTIVATION:
This EIP is based on and tends to replace matter-labs' proposol for significant performance reasons. In most applications, BW6-761 is used as an outer curve to BLS12-377 considered in [EIP-2539](./eip-2539.md). The motivation of this precompile is to allow efficient one-layer composition of SNARK proofs. Currently this is done by

RATIONALE:
Gas costs are based on [EIP-1962](./eip-1962.md) estimation strategy (but do not fully include yet parsing of ABI, decoding and encoding of the result as a byte array). ### Gas estimation strategy Gas cost is derived by taking the average timing of the same operations over different implementations and assuming


=== EIP-161 ===
TITLE: State trie clearing (invariant-preserving alternative)
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-24
REQUIRES: 

SPECIFICATION:
a. Account creation transactions and the `CREATE` operation SHALL, prior to the execution of the initialisation code, **increment** the **nonce** over and above its normal starting value by **one** (for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different). b. Whereas

RATIONALE:
Same as #158 except that several edge cases are avoided since we do not break invariants: - ~~that an account can go from having code and storage to not having code or storage mid-way through the execution of a transaction;~~ [corrected] - that a newly created account cannot be


=== EIP-7782 ===
TITLE: Reduce Slot Time for Lower Peak Bandwidth
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-10-05
REQUIRES: 7, 6, 2, 3, ,,  , 7, 7, 7, 8

SUMMARY:
This EIP suggests decreasing the slot time in Ethereum's Proof-of-Stake (PoS) consensus mechanism from 12 seconds to 8 seconds. The reduction increases the number of slots per unit time, boosting the network's transaction processing capacity by approximately 33%. Unlike directly increasing the gas limit or blob limit; which would

SPECIFICATION:
### Slot Time Reduction - **Change the Slot Time Parameter**: Modify the slot time (`SECONDS_PER_SLOT`) from **12 seconds** to **8 seconds** in the Ethereum consensus specifications. ### Adjustments to Timing Parameters - **Epoch Length**: - **Slots per Epoch**: Maintain the current number of slots per epoch (32 slots). -

MOTIVATION:
### Distributing Bandwidth and Reducing Peak Usage - **Avoiding Peak Bandwidth Increases**: Increasing the gas limit from 30 million to 40 million or the blob limit from 6 to 8 directly raises the size of individual blocks or blobs, leading to higher peak bandwidth requirements that can strain network

RATIONALE:
### Based Rollup Latency - Reducing the slot time from 12 seconds to 8 seconds significantly improves the latency for based-rollup Layer 2 solutions as they are directly effected by L1 latency. ### Throughput Increase Without Raising Peak Bandwidth - **Maintaining Individual Block Sizes**: By keeping block and blob


=== EIP-7658 ===
TITLE: Light client data backfill
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-21
REQUIRES: 

SUMMARY:
This EIP defines a mechanism for syncing [light client data](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md) between beacon nodes.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Containers #### New containers ##### `SyncData` ```python class SyncData(Container): # Sync committee aggregate signature

MOTIVATION:
[Light client data](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/full-node.md) is collected by beacon nodes to assist [light clients](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/light-client.md) to sync with the network. The [sync protocol](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md) defines a mechanism to sync forward in time. However, it cannot be used to sync backward. Collecting light client data is challenging because beacon nodes need to have access

RATIONALE:
### How to rank `SyncAggregate`? The EIP reuses the [`is_better_update`](https://github.com/ethereum/consensus-specs/blob/4afe39822c9ad9747e0f5635cca117c18441ec1b/specs/altair/light-client/sync-protocol.md#is_better_update) function from existing specs. ### How could a backfill protocol use this? Once the data is available in the `BeaconState`, a light client data backfill protocol could be defined that serves, for past periods: 1. A `LightClientUpdate` from requested


=== EIP-160 ===
TITLE: EXP cost increase
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-10-20
REQUIRES: 

SPECIFICATION:
If `block.number >= FORK_BLKNUM`, increase the gas cost of EXP from 10 + 10 per byte in the exponent to 10 + 50 per byte in the exponent. ### Rationale Benchmarks suggest that EXP is currently underpriced by a factor of about 4–8. ### References 1. EIP-160 issue and

RATIONALE:
Benchmarks suggest that EXP is currently underpriced by a factor of about 4–8. ### References 1. EIP-160 issue and discussion: https://github.com/ethereum/EIPs/issues/160


=== EIP-2474 ===
TITLE: Coinbase calls
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-01-19
REQUIRES: 

SUMMARY:
_In proof-of-work blockchains, validators are known as miners._ The validator might want to execute functions directly, without having to sign a transaction. Some examples might be presenting a proof in a contract for an change which also benefits the validator. A notable example would be when a validator want

SPECIFICATION:
The calls to be executed by `block.coinbase` would be included first at block, and would consume normally the gas of block, however they won't pay/cost gas, instead the call logic would pay the validator in other form. Would be valid to execute any calls without a transaction by the

MOTIVATION:
In order to reduce the overhead of calls that don't use `msg.sender` and are being called by validator with `tx.gasPrice = 0`.

RATIONALE:
TBD


=== EIP-1227 ===
TITLE: Defuse Difficulty Bomb and Reset Block Reward
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-18
REQUIRES: 649

SUMMARY:
Starting with `FORK_BLKNUM` the client will calculate the difficulty without the additional exponential component. Furthermore, block rewards will be adjusted to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.

SPECIFICATION:
#### Remove Exponential Component of Difficulty Adjustment For the purposes of `calc_difficulty`, simply remove the exponential difficulty adjustment component, `epsilon`, i.e. the `int(2**((block.number // 100000) - 2))`. #### Reset Block, Uncle, and Nephew rewards To ensure a constant Ether issuance, adjust the block reward to `new_block_reward`, where new_block_reward =

MOTIVATION:
Due to the "difficulty bomb" (also known as the "ice age"), introduced in EIP [#2](./eip-2.md), an artificial exponential increase in difficulty until chain freeze, users may find it much more challenging to remain on the unforked chain after a hard-fork. This is a desirable effect of the ice age

RATIONALE:
This will permanently, without further changes, disable the "ice age." It will also reset the block reward to pre-Byzantium levels. Both of these changes are specified similarly to EIP [#649](./eip-649.md), so they should require only minimal changes from client developers.


=== EIP-4844 ===
TITLE: Shard Blob Transactions
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-02-25
REQUIRES: 1, 5, 5, 9, ,,  , 2, 7, 1, 8, ,,  , 2, 9, 3, 0, ,,  , 4, 8, 9, 5

SUMMARY:
Introduce a new transaction format for "blob-carrying transactions" which contain a large amount of data that cannot be accessed by EVM execution, but whose commitment can be accessed. The format is intended to be fully compatible with the format that will be used in full sharding.

SPECIFICATION:
### Parameters | Constant | Value | | - | - | | `BLOB_TX_TYPE` | `Bytes1(0x03)` | | `BYTES_PER_FIELD_ELEMENT` | `32` | | `FIELD_ELEMENTS_PER_BLOB` | `4096` | | `BLS_MODULUS` | `52435875175126190479447740508185965837690552500527637822603658699938581184513` | | `VERSIONED_HASH_VERSION_KZG` | `Bytes1(0x01)` | | `POINT_EVALUATION_PRECOMPILE_ADDRESS` | `Bytes20(0x0A)` | | `POINT_EVALUATION_PRECOMPILE_GAS` | `50000` | | `MAX_BLOB_GAS_PER_BLOCK`

MOTIVATION:
Rollups are in the short and medium term, and possibly in the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups

RATIONALE:
### On the path to sharding This EIP introduces blob transactions in the same format in which they are expected to exist in the final sharding specification. This provides a temporary but significant scaling relief for rollups by allowing them to initially scale to 0.375 MB per slot, with


=== EIP-86 ===
TITLE: Abstraction of transaction origin and signature
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2017-02-10
REQUIRES: 


=== EIP-2677 ===
TITLE: Limit size of `initcode`
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-05-18
REQUIRES: 

SUMMARY:
Enforce a maximum size limit (`max_initcode_size`) for `initcode`. If the size of `initcode` exceeds `max_initcode_size`, then contract creation fails with an out of gas error. Since [EIP-170](./eip-170.md) was implemented, there has been a size limit of `24576` (`0x6000`) on contract code. We propose to also limit the size of

SPECIFICATION:
There are three situations where this is applicable: * `CREATE`, * `CREATE2`, * creation using a transaction with empty receiver. In all these (and future) cases, the EVM should fail with Out Of Gas error if the code has a length more than `max_initcode_size`.

MOTIVATION:
When a client executes `initcode`, the client has to perform a jumpdest analysis. In some cases, the client also performs a `hash` of the code: * To use as a key in a mapping containing result of a jumpdest analysis * To use for address calculation within `CREATE2`. The

RATIONALE:
TBA


=== EIP-1485 ===
TITLE: TEthashV1
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-11-01
REQUIRES: 

SUMMARY:
This EIP pursue "obsolete current ASIC miners" by modifying PoW algorithm in a very low risk manner and update to latest hash algorithm from deprecated FNV Hash algorithms. Following TEthashV1 algorithm suggests safe transition of PoW algorithms and secure the FNV Algorithm in MIX Parts.

SPECIFICATION:
#### 1. Reference materials on ETHASH FNV0 #### Where FNV Applied on ETHASH - In [ETHASH](https://github.com/ethereum/wiki/wiki/Ethash) , FNV Hash is used on * 1) On data aggregation function, MIX parts. * Ethash Algorithm ``` Header + Nonce | Keccak | **[MIX 0]** --> **[DAG Page]** | | Mixing <--|

MOTIVATION:
Provide original Ethash proof of work verification with minimal set of changes by updating FNV0 algorithm

RATIONALE:
In case of ethash algorithm, it can't prevent ASIC forever. And, current ethash algorithm's FNV function is deprecated. So, It needs to be upgraded and it will make current ethash based ASICs obsolete. And current TETHASHV1 FNV1A implementation is based on most of ethash , which is verified for


=== EIP-2384 ===
TITLE: Muir Glacier Difficulty Bomb Delay
TYPE: Standards Track Core
STATUS: Final
CREATED: 2019-11-20
REQUIRES: 

SUMMARY:
Starting with `MUIR_GLACIER_FORK_BLKNUM` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9 million blocks later than the Homestead fork, which is also 7 million blocks later than the Byzantium fork and 4 million blocks later

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: fake_block_number = max(0, block.number - 9_000_000) if block.number >= MUIR_GLACIER_FORK_BLKNUM else block.number

MOTIVATION:
The difficulty bomb started to become noticeable again on October 5th 2019 at block 8,600,000. Block times have been around 13.1s on average and now as of block 8,900,000 are around 14.3s. This will start to accelerate exponentially every 100,000 blocks. Estimating the added impact from the difficulty bomb

RATIONALE:
This will delay the ice age by 52 million seconds (approximately 611 days), so the chain would be back at 20 second block times around July 2021. It's important to note this pushes the ice age 4,000,000 blocks from ~block 8,800,000 NOT from when this EIP is activated in


=== EIP-2982 ===
TITLE: Serenity Phase 0
TYPE: Informational 
STATUS: Final
CREATED: 2020-09-15
REQUIRES: 

SUMMARY:
This EIP specifies Phase 0 of Serenity (eth2), a multi-phased upgrade to the consensus mechanism for Ethereum mainnet. In Phase 0, the existing PoW chain and mechanics are entirely unaffected, while a PoS chain -- the beacon chain -- is built in parallel to serve as the core of

SPECIFICATION:
Phase 0 is designed to require _no breaking consensus changes_ to existing Ethereum mainnet. Instead, this is the bootstrapping a new PoS consensus that can, once stable, supplant the current PoW consensus. Phase 0 specifications are maintained in a repository independent of this EIP. `SPEC_RELEASE_VERSION` release of the specs

MOTIVATION:
Eth2 aims to fulfill the original vision of Ethereum to support an efficient, global-scale, general-purpose transactional platform while retaining high cryptoeconomic security and decentralization. Today, Ethereum blocks are consistently full due to increasingly high demand for decentralized applications. Ever since the first serious spikes in adoption in 2017 (cryptokitties),

RATIONALE:
### Principles * **Simplicity**: especially since cryptoeconomic proof of stake and quadratic sharding are inherently complex, the protocol should strive for maximum simplicity in its decisions as much as possible. This is important because it (i) minimizes development costs, (ii) reduces risk of unforeseen security issues, and (iii) allows


=== EIP-4758 ===
TITLE: Deactivate SELFDESTRUCT
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-02-03
REQUIRES: 

SUMMARY:
This EIP renames the `SELFDESTRUCT` opcode to `SENDALL`, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.

SPECIFICATION:
* The `SELFDESTRUCT` opcode is renamed to `SENDALL`, and now only immediately moves all ETH in the account to the target; it no longer destroys code or storage or alters the nonce * All refunds related to `SELFDESTRUCT` are removed

MOTIVATION:
The `SELFDESTRUCT` opcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root

RATIONALE:
Getting rid of the `SELFDESTRUCT` opcode has been considered in the past, and there are currently no strong reasons to use it. Disabling it will be a requirement for statelessness.


=== EIP-7542 ===
TITLE: eth/70 - available-blocks-extended protocol
TYPE: Standards Track Networking
STATUS: Withdrawn
CREATED: 2023-10-21
REQUIRES: 7642

SUMMARY:
The purpose of this EIP is to introduce a method that allows an Ethereum node to communicate the range of blocks it has available. By knowing the block range a node can serve, peers can make more informed decisions when choosing whom to request blocks from or whom to

SPECIFICATION:
- Advertise a new `eth` protocol capability (version) at `eth/70`. - The old `eth/69` protocol should still be kept alive side-by-side, until `eth/70` is sufficiently adopted by implementors. - Modify the `Status (0x00)` message for `eth/70` to add an additional `blockRange` field right after the `forkid`: - Current packet

MOTIVATION:
In a first stage of [EIP-4444](./eip-4444.md), some nodes will still need to serve the historical data of the chain and others might be interested in starting to prune it. Currently, nodes need to connect to peers and request specific blocks to determine if a peer has the requested data.

RATIONALE:
Including the available block range in the `eth` handshake allows for immediate understanding of peer capabilities. This can lead to more efficient networking as nodes can prioritize connections based on the data they need. The new message types are introduced to allow nodes to request updated available block range


=== EIP-6811 ===
TITLE: To The Moon—10 Minute Blocks
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-01
REQUIRES: 

SUMMARY:
This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth's solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. * The time between blocks MUST be changed from 12 seconds to 600 seconds (10

MOTIVATION:
It is impossible for today's Ethereum to literally "go to the moon" due to a limitation in the protocol: the block length. Should validators attempt to validate on the surface of the moon, they would find that the ~1.25 second communication delay (caused by the speed of light) might

RATIONALE:
* The block gas limit is multiplied by fifty to compensate for the time between blocks being multiplied by fifty. * The per-block validator reward is also multiplied by fifty to compensate for the time between blocks being multiplied by fifty. * Epochs are changed to be 2 blocks


=== EIP-1352 ===
TITLE: Specify restricted address range for precompiles/system contracts
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-07-27
REQUIRES: 

SUMMARY:
The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts.

SPECIFICATION:
The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts. Due to the extremely low probability (and lack of adequate testing possibilities) no explicit checks should be added to ensure that external transaction signing or the invoking of the `CREATE` instruction can result in a

MOTIVATION:
This will simplify certain future features where unless this is implemented, several exceptions must be specified.

RATIONALE:
N/A


=== EIP-2935 ===
TITLE: Serve historical block hashes from state
TYPE: Standards Track Core
STATUS: Review
CREATED: 2020-09-03
REQUIRES: 

SUMMARY:
Store last `HISTORY_SERVE_WINDOW` historical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact on `BLOCKHASH` resolution mechanism (and hence its range/costs etc).

SPECIFICATION:
| Parameter | Value | | - | - | | `FORK_TIMESTAMP` | TBD | | `BLOCKHASH_SERVE_WINDOW` | `256` | | `HISTORY_SERVE_WINDOW` | `8192` | | `SYSTEM_ADDRESS` | `0xfffffffffffffffffffffffffffffffffffffffe` | | `HISTORY_STORAGE_ADDRESS` | `0x0aae40965e6800cd9b1f4b05ff21581047e3f91e`| This EIP specifies for storing last `HISTORY_SERVE_WINDOW` block hashes in a ring buffer storage of

MOTIVATION:
EVM implicitly assumes the client has the recent block (hashes) at hand. This assumption is not future-proof given the prospect of stateless clients. Including the block hashes in the state will allow bundling these hashes in the witness provided to a stateless client. This is already possible in the

RATIONALE:
Very similar ideas were proposed before. This EIP is a simplification, removing two sources of needless complexity: 1. Having a tree-like structure with multiple layers as opposed to a single list 2. Writing the EIP in EVM code 3. Serial unbounded storage of hashes for a deep access to


=== EIP-2780 ===
TITLE: Reduce intrinsic transaction gas
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-07-11
REQUIRES: 

SUMMARY:
Reduce the intrinsic cost of a transaction from `21,000` to `7,000` gas.

SPECIFICATION:
After `block.number >= FORK_BLOCK`, enforce an intrinsic gas cost of `7,000`.

MOTIVATION:
The current `21,000` gas intrinsic cost of a transaction makes sending ETH very costly, often times prohibitively costly for small amounts (tens of USD). While broad changes to the gas price and first price auction are being considerted in other EIPs (like EIP-1559), substantially reducing the cost of sending

RATIONALE:
The proliferation of calls to DeFi smart-contracts had substantially increased the cost of making transactions, since such calls are usually both time sensitive and involve large sums of money. While the utilization of the chain's capacity by the most valuable transactions is by design, the high cost of sending


=== EIP-2711 ===
TITLE: Sponsored, expiring and batch transactions.
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2020-06-11
REQUIRES: 2718

SUMMARY:
An EIP-2718 transaction with the type number `2` is a new type of transaction that includes support for: 1. **Sponsored Transactions**: an optional additional signature from which the account that will pay for gas (`GAS_PAYER`) can be recovered 2. **Batch Transactions**: multiple transactions from the same sender that will

SPECIFICATION:
### Definitions **`TransactionType`** 2. See [EIP-2718](./eip-2718.md) **`TransactionSubtype`** is either 1, 2, 3, or 4. **`ChainId`** The transaction is valid if this value is `0` or it is included in a block on a chain whose ID is equal to this value. **`ValidUntil`** The transaction is valid if this value

MOTIVATION:
### Sponsored Transactions With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account. Some users don't want to be exposed to the perceived volatility of ETH

RATIONALE:
### One Monolithic EIP This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type. Alternatively, each of the subtypes could be a unique TransactionType. The reason we chose to go with a single EIP with subtypes is because these


=== EIP-7045 ===
TITLE: Increase max attestation inclusion slot
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-05-18
REQUIRES: 

SUMMARY:
Increases max attestation inclusion slot from `attestation.slot + SLOTS_PER_EPOCH` to the last slot of epoch `N+1` where `N` is the epoch containing the attestation slot. This increase is critical to the current LMD-GHOST security analysis as well as the confirmation rule.

SPECIFICATION:
### Constants | Name | Value | Comment | | - | - | - | |`FORK_TIMESTAMP` | *TBD* | Mainnet | ### Execution layer This requires no changes to the Execution Layer. ### Consensus layer Specification changes are built into the Consensus Specs Deneb upgrade. The specification makes

MOTIVATION:
Attestations can currently be included after some minimum delay (`1` slot on mainnet) up until `SLOTS_PER_EPOCH` slots after the slot the attestation was created in. This rolling window of one epoch was decided upon during Phase 0 because the equal inclusion window for any attestation was assessed as "fair".

RATIONALE:
### Extended max inclusion slot As discussed in the Motivation, extending this max inclusion slot to the end of the next epoch is critical for LMD-GHOST security proofs and confirmation rule. ### Removal of `inclusion_delay` consideration for target reward Previously, `get_attestation_participation_flag_indices` would only set the `TIMELY_TARGET_FLAG` (and thus reward


=== EIP-6914 ===
TITLE: Reuse Withdrawn Validator Indices
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2023-04-19
REQUIRES: 

SUMMARY:
Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.

SPECIFICATION:
### Consensus Layer The configuration values and mechanics of the specification can be found in the [Consensus Layer specs](https://github.com/ethereum/consensus-specs/blob/1a38b83e5db8638ee01c9461cccf11e7d8a3ebce/specs/_features/eip6914). Note that validator indices are reused in the event that the validator has been fully withdrawn *and* that the validator has been withdrawable for a sufficient safe period. ### Execution

MOTIVATION:
The beacon chain maintains a list of validators and a separate list of balances associated with each validator. When a new deposit for a new validator occurs, the current mechanism only appends, rather than reusing previously fully withdrawn validator indices. As validators fully withdraw and new validators enter, this

RATIONALE:
The `validators` and `balances` lists are currently appended to each time a new Deposit for a new pubkey comes into the beacon chain. Due to the natural mechanics of stakers entering and leaving consensus over long time spans, these lists, thus the state size, will grow unbounded. Increased state


=== EIP-1108 ===
TITLE: Reduce alt_bn128 precompile gas costs
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-05-21
REQUIRES: 1, 9, 6, ,,  , 1, 9, 7

SUMMARY:
Changes in 2018 to the underlying library used by the official Go reference implementation led to significant performance gains for the `ECADD`, `ECMUL`, and pairing check precompiled contracts on the `alt_bn128` elliptic curve. In the Parity client, field operations used by the precompile algorithms were optimized in 2018, and

SPECIFICATION:
Following is a table with the current gas cost and new gas cost: | Contract | Address | Current Gas Cost | Updated Gas Cost | | ------------- | --------- | ----------------------------- | ------------------- | | `ECADD` | `0x06` | 500<sup>[1]</sup> | 150 | | `ECMUL` | `0x07` |

MOTIVATION:
Recently, the underlying library used by the [official Go reference implementation](https://github.com/ethereum/go-ethereum) to implement the `ECADD` (at address `0x06`), `ECMUL` (at address `0x07`), and pairing check (at address `0x08`) precompiled contracts was shifted to [Cloudflare's bn256 library](https://github.com/cloudflare/bn256). Based on the [initial PR that introduced this change](https://github.com/ethereum/go-ethereum/pull/16203), and corroborated in [a


=== EIP-7514 ===
TITLE: Add Max Epoch Churn Limit
TYPE: Standards Track Core
STATUS: Final
CREATED: 2023-09-07
REQUIRES: 

SUMMARY:
Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.

SPECIFICATION:
### Constants | Name | Value | | ---- | ----- | | `MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT` | 8 | ### Execution layer This requires no changes to the Execution Layer. ### Consensus layer - Add `get_validator_activation_churn_limit` with upper bound `MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT` - Modify `process_registry_updates` to use bounded activation churn limit The full

MOTIVATION:
This proposal aims to mitigate the negative externalities of very high level of total ETH supply staked before a proper solution is implemented. In other words, this proposal accepts the complexities of changing the rewards curve and is meant only to slow down growth. In the event that the

RATIONALE:
### `MAX_PER_EPOCH_CHURN_LIMIT` value Depending on the specific constant selection the churn can _decrease_ at the activation fork epoch. The Beacon chain spec can handle this without issues. During 2023 Q4 (projected Dencun activation) the churn value will range 14-16. The table below compares the projected validator set assuming a


=== EIP-695 ===
TITLE: Create `eth_chainId` method for JSON-RPC
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2017-08-21
REQUIRES: 155

SUMMARY:
The `eth_chainId` method should return a single STRING result for an integer value in hexadecimal format, describing the currently configured `CHAIN_ID` value used for signing replay-protected transactions, introduced by [EIP-155](./eip-155.md).

SPECIFICATION:
### `eth_chainId` Returns the currently configured chain ID, a value used in replay-protected transaction signing as introduced by [EIP-155](./eip-155.md). The chain ID returned should always correspond to the information in the current known head block. This ensures that caller of this RPC method can always use the retrieved information

MOTIVATION:
Currently although we can use `net_version` RPC call to get the current network ID, there's no RPC for querying the chain ID. This makes it impossible to determine the current actual blockchain using the RPC.

RATIONALE:
An ETH/ETC client can accidentally connect to an ETC/ETH RPC endpoint without knowing it unless it tries to sign a transaction or it fetch a transaction that is known to have signed with a chain ID. This has since caused trouble for application developers, such as MetaMask, to add


=== EIP-7039 ===
TITLE: Scheme-Handler Discovery Option for Wallets
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2023-05-15
REQUIRES: 1193

SUMMARY:
This proposal (affectionately known as SHADOW) is an alternative to [EIP-1193](./eip-1193.md) for wallet discovery in web browsers that requires no special permissions. Web pages intending to open a connection to a wallet inject an `iframe` tag pointing at a well-known scheme. Communication between the page and the wallet uses

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Initiating a Connection To initiate a connection to a provider, a web page SHOULD:

MOTIVATION:
Current wallet discovery methods (eg. `window.ethereum`) only support one active wallet at a time, and require browser extensions to request broad permissions to modify web pages. Ideally users should be able to have multiple wallets active, and choose between them at runtime. This not only results in an improved

RATIONALE:
Instead of directly using the `iframe.contentWindow`'s message port, SHADOW transfers a message port in the first message. This allows the `iframe`, in some specific scenarios, to completely hand off communication, so the web page and the provider communicate directly, without any proxying in the `iframe`.


=== EIP-1102 ===
TITLE: Opt-in account exposure
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2018-05-04
REQUIRES: 1474

SUMMARY:
The previous generation of Ethereum-enabled DOM environments follows a pattern of injecting a provider populated with accounts without user consent. This puts users of such environments at risk because malicious websites can use these accounts to view detailed account information and to arbitrarily initiate unwanted transactions on a user's

SPECIFICATION:
### Concepts #### RFC-2119 The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt). #### `eth_requestAccounts` Providers exposed by Ethereum-enabled DOM environments define a new RPC method: `eth_requestAccounts`. Calling this method

RATIONALE:
The pattern of automatic account exposure followed by the previous generation of Ethereum-enabled DOM environments fails to protect user privacy and fails to maintain safe user experience: untrusted websites can both view detailed account information and arbitrarily initiate transactions on a user's behalf. Even though most users may reject


=== EIP-7668 ===
TITLE: Remove bloom filters
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2024-03-31
REQUIRES: 

SUMMARY:
Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.

SPECIFICATION:
The logs bloom of an execution block is now required to be empty (ie. 0 bytes long). The logs bloom of a transaction receipt is now required to be empty (ie. 0 bytes long).

MOTIVATION:
Logs were originally introduced to give applications a way to record information about onchain events, which decentralized applications (dapps) would be able to easily query. Using bloom filters, dapps would be able to quickly go through the history, identify the few blocks that contained logs relative to their application,

RATIONALE:
This is a minimally disruptive way to remove the need to handle blooms from clients. A future EIP can later clean up by removing this field entirely, along with other fields that have been deprecated. Gas costs of LOG are not reduced, because while the externality of polluting the


=== EIP-2976 ===
TITLE: Typed Transactions over Gossip
TYPE: Standards Track Networking
STATUS: Final
CREATED: 2020-09-13
REQUIRES: 2718

SUMMARY:
[Typed Transactions](./eip-2718.md) can be sent over devp2p as `TransactionType || TransactionPayload`. The exact contents of the `TransactionPayload` are defined by the `TransactionType` in future EIPs, and clients may start supporting their gossip without incrementing the devp2p version. If a client receives a `TransactionType` that it doesn't recognize, it **SHOULD**

SPECIFICATION:
All changes specified below apply to all protocol/versions retroactively. ### Definitions * `||` is the byte/byte-array concatenation operator. * `|` is the type union operator. * `DEVP2P_VERSION = TBD` * `Transaction` is either `TypedTransaction` or `LegacyTransaction` * `TypedTransaction` is a byte array containing `TransactionType || TransactionPayload` * `TypedTransactionHash` is

MOTIVATION:
[EIP-2718](./eip-2718.md) introduced new transaction types for blocks (which presents itself in the makeup of a block header's transaction root and receipts root). However, without a mechanism for gossiping these transactions, no one can actually include them in a block. By updating devp2p to support the gossip of Typed Transactions,

RATIONALE:
### Why not specify each transaction type at the protocol layer? We could have chosen to make the protocol aware of the shape of the transaction payloads. The authors felt that it would be too much maintenance burden long term to have every new transaction type require an update


=== EIP-1052 ===
TITLE: EXTCODEHASH opcode
TYPE: Standards Track Core
STATUS: Final
CREATED: 2018-05-02
REQUIRES: 161

SUMMARY:
This EIP specifies a new opcode, which returns the keccak256 hash of a contract's code.

SPECIFICATION:
A new opcode, `EXTCODEHASH`, is introduced, with number `0x3f`. The `EXTCODEHASH` takes one argument from the stack, zeros the first 96 bits and pushes to the stack the keccak256 hash of the code of the account at the address being the remaining 160 bits. In case the account does

MOTIVATION:
Many contracts need to perform checks on a contract's bytecode, but do not necessarily need the bytecode itself. For instance, a contract may want to check if another contract's bytecode is one of a set of permitted implementations, or it may perform analyses on code and whitelist any contract

RATIONALE:
As described in the motivation section, this opcode is widely useful, and saves on wasted gas in many cases. The gas cost is the same as the gas cost for the `BALANCE` opcode because the execution of the `EXTCODEHASH` requires the same account lookup as in `BALANCE`. Only the


=== EIP-5065 ===
TITLE: Instruction for transferring ether
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-04-30
REQUIRES: 2929

SUMMARY:
Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to how `SELFDESTRUCT (0xFF)` transfers ether to the destination without making a call to it.

SPECIFICATION:
Introduce a new instruction, `AIRDROP` (`0xFG`) that transfers ether to the destination without making a call to it. ### Stack input address: the account to send ether to. value: value in wei to send to the account. ### Gas The total gas cost should be the sum of a

MOTIVATION:
From an architectural point of view, execution flow should never be handed over to an untrusted contract. Ethereum currently does not have any ideal way to transfer ether without transferring the flow of execution. People have come up with reentrancy guards and similar solutions to prevent some types of

RATIONALE:
This behavior is already possible by deploying a new contract that does `SELFDESTRUCT (0xFF)` but it is prohibitively expensive. In most scenarios, the contract author only wants to transfer ether rather than transferring control of the execution. ERC20 can be used as a case study for this where most


=== EIP-7642 ===
TITLE: eth/69 - Drop pre-merge fields
TYPE: Standards Track Networking
STATUS: Draft
CREATED: 2024-02-29
REQUIRES: 5793

SUMMARY:
After the merge a few fields (`td`) and messages (`NewBlockHashes`, `NewBlock`) in the networking protocol became obsolete. This EIP modifies the networking messages such that these fields are not sent anymore. Additionally we propose to remove the `Bloom` field from the receipts networking messages.

SPECIFICATION:
Remove the `NewBlockHashes (0x01)` message. Remove the `NewBlock (0x07)` message. Modify the `Status (0x00)` message as follows: - (eth/68): `[version: P, networkid: P, td: P, blockhash: B_32, genesis: B_32, forkid]` - (eth/69): `[version: P, networkid: P, blockhash: B_32, genesis: B_32, forkid]` Modify the encoding for receipts in the `Receipts

MOTIVATION:
We recently discovered that none of the clients store the `Bloom` field of the receipts as it can be recomputed on demand. However the networking spec requires the `Bloom` field to be sent over the network. Thus a syncing node will ask for the Bloom filters for all receipts.

RATIONALE:
After the merge, the `TD` field of the `Status` message became meaningless since the difficulty of post-merge blocks are 0. It could in theory be used to distinguish synced with unsynced nodes, but the same thing can be accomplished with the forkid as well. It is not used in


=== EIP-3521 ===
TITLE: Reduce access list cost
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-04-15
REQUIRES: 2, 0, 2, 8, ,,  , 2, 9, 3, 0

SPECIFICATION:
Treat the first occurrence of `tx.to` in an access list as `calldata` for gas accounting purposes. Do not charge `ACCESS_LIST_ADDRESS_COST` for it. Storage keys underneath the address are unaffected. If `tx.to == nil`, `tx.to` is defined be the derived contract address created by the transaction.

MOTIVATION:
Currently, a transaction must read at least 25 distinct storage slots in `tx.to` before it's more expensive to forego an access list. ``` ACCESS_LIST_ADDRESS_COST + (ACCESS_LIST_STORAGE_KEY_COST + WARM_STORAGE_READ_COST) * x = COLD_SLOAD_COST * x x = 24 ``` EIP-2930 requires the address under which the storage keys reside be


=== EIP-211 ===
TITLE: New opcodes: RETURNDATASIZE and RETURNDATACOPY
TYPE: Standards Track Core
STATUS: Final
CREATED: 2017-02-13
REQUIRES: 

SUMMARY:
Please see summary.

SPECIFICATION:
If `block.number >= BYZANTIUM_FORK_BLKNUM`, add two new opcodes and amend the semantics of any opcode that creates a new call frame (like `CALL`, `CREATE`, `DELEGATECALL`, ...) called call-like opcodes in the following. It is assumed that the EVM (to be more specific: an EVM call frame) has a new

MOTIVATION:
In some situations, it is vital for a function to be able to return data whose length cannot be anticipated before the call. In principle, this can be solved without alterations to the EVM, for example by splitting the call into two calls where the first is used to

RATIONALE:
Other solutions that would allow returning dynamic data were considered, but they all had to deduct the gas from the call opcode and thus were both complicated to implement and specify ([5/8](https://github.com/ethereum/EIPs/issues/8)). Since this proposal is very similar to the way calldata is handled, it fits nicely into the


=== EIP-2970 ===
TITLE: IS_STATIC opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-09-13
REQUIRES: 

SPECIFICATION:
Add a `IS_STATIC (0x4A)` opcode that pushes `1` if the current context is static (ie. the execution is in a `STATICCALL` or a descendant thereof, so state-changing operations are not possible), and `0` if it is not.

MOTIVATION:
The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA's security model) but not state-changing calls.

RATIONALE:
Determining staticness is already possibly using the following hacky technique: make a `CALL` with limited gas, and inside that `CALL` issue one `LOG` and exit. If the context is static, the `CALL` would fail and leave a 0 on the stack; if the context is non-static, the `CALL` would


=== EIP-2666 ===
TITLE: Repricing of precompiles and Keccak256 function
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-05-22
REQUIRES: 1, 3, 5, 2, ,,  , 2, 0, 4, 6, ,,  , 2, 5, 6, 5

SUMMARY:
Costs of many precompiles and built-in functions are invalid at the current state of the clients. This EIP contains a list of changes to the pricing formulas to better reflect underlying computations' structure.

SPECIFICATION:
If `block_number >= X` set the gas cost of the following precompiles and Keccak256 opcode: - SHA256 (precompile `0x02`): `10 + ((len(input) + 8)/64 + 1) * 9` - RIPEMD (precompile `0x03`): `6 + ((len(input) + 8)/64 + 1) * 12` - KECCAK256 (`0x20`): `13 + (len(input)/136 + 1)*15`

MOTIVATION:
Historical pricing for these functions in EVM does not reflect inner structure of the underlying computations (inner structure of the hash functions). - EIP-2046 changes a `STATICCALL (0xfa)` cost to precompile and it may be necessary to adjust costs of some precompiles that *may* have taken old large cost

RATIONALE:
Cost of functions being executed must accurately reflect real CPU time spent on computations, so benchmarking was performed for current precompiles and Keccak256 function to measure running time versus input parameters. ### Detailed summary of repricing approach This EIP relies on two facts: - apriori knowledge of the inner


=== EIP-1418 ===
TITLE: Blockchain Storage Rent Payment
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2018-09-16
REQUIRES: 1559

SUMMARY:
At each block, deduct an amount of value ("rent") from every account based on the quantity of storage used by that account.

SPECIFICATION:
**Updated transaction type** A new transaction type is introduced. Whereas [EIP-1559](./eip-1559.md) introduced warm access for contract state, this new type introduces warm access for contract code. **New state variables (per account)** * **σ[a]_rent** -- an amount of value, in Wei, this is a signed value * **σ[a]_storageWords** -- number

MOTIVATION:
Ethereum is a public utility and we are underpricing the long-term costs of storage. Storage cost can be approximately modeled as bytes × time.


=== EIP-6800 ===
TITLE: Ethereum state using a unified verkle tree
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2023-03-17
REQUIRES: 6780

SUMMARY:
Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. ### Verkle tree definition We define a Verkle tree here by providing the function to

MOTIVATION:
Verkle trees solve a key problem standing in the way of Ethereum being stateless-client-friendly: witness sizes. A witness accessing an account in today’s hexary Patricia tree is, in the average case, close to 3 kB, and in the worst case it may be three times larger. Assuming a worst

RATIONALE:
This implements all of the logic in transitioning to a Verkle tree, and at the same time reforms gas costs, but does so in a minimally disruptive way that does not require simultaneously changing the whole tree structure. Instead, we add a new Verkle tree that starts out empty,


=== EIP-5920 ===
TITLE: PAY opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-03-14
REQUIRES: 2, 9, 2, 9, ,,  , 7, 5, 2, 3

SUMMARY:
This EIP introduces a new opcode, `PAY`, taking two stack parameters, `addr` and `val`, that transfers `val` wei to the address `addr` without calling any of its functions.

SPECIFICATION:
### Constants | Constant | Definition | | -------------------------- | ------------------------- | | `WARM_STORAGE_READ_COST` | [EIP-2929](./eip-2929.md) | | `COLD_ACCOUNT_ACCESS_COST` | [EIP-2929](./eip-2929.md) | | `GAS_NEW_ACCOUNT` | [EELS][gna] | | `GAS_CALL_VALUE` | [EELS][gcv] | [gna]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L52 [gcv]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L53 ### Behavior A new opcode is introduced: `PAY` (`0xf9`), which: - Pops two

MOTIVATION:
Currently, to send ether to an address requires you to call into that address, which transfers execution context to that address, which creates several issues: - First of all, it opens a reentrancy attack vector, as the recipient can call back into the sender. More generally, the recipient can

RATIONALE:
### Argument order The order of arguments mimics that of `CALL`, which pops `addr` before `val`. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, so `PAY` always appears immediately after `COINBASE`.


=== EIP-2327 ===
TITLE: BEGINDATA opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2019-10-28
REQUIRES: 

SUMMARY:
It is common for smart contracts to efficiently store data directly in the contract bytecode. Examples include constructor arguments, constant variables, compiler metadata and the contract runtime during the init phase. Currently, such data is not distinguished from normal bytecode and is still being analysed for `JUMPDEST`s by EVM

SPECIFICATION:
While computing the valid `JUMPDEST`s of a contract, halt analysis once the first `BEGINDATA` is encountered. In other words: A jump to any codelocation equal to or greater than the location of the first `BEGINDATA` causes a `BAD_JUMP_DESTINATION` error. If `BEGINDATA` is encountered during contract execution, it has the

MOTIVATION:
The `BEGINDATA` opcode has been suggested before as part of the EIP `Subroutines and Static Jumps for the EVM` [EIP-615](./eip-615.md) as a way to determine the position of jumptables in contract bytecode. It is here introduced in its own right in order to exclude data from the `JUMPDEST` analysis

RATIONALE:
The byte `0xb6` was chosen to align with [EIP-615](./eip-615.md). The choice to `STOP` if `BEGINDATA` is encountered is somewhat arbitrary. An alternative would be to be to abort the execution with an out-of-gas error.


=== EIP-3436 ===
TITLE: Expanded Clique Block Choice Rule
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2021-03-25
REQUIRES: 225

SUMMARY:
The current specification of Clique allows for multiple competing blocks from producers but does not provide any strategies to pick blocks aside from the current "highest total difficulty" rule. This EIP proposes a four step choice rule of highest total difficulty, shortest chain, most recently in-turn, and lowest hash.

SPECIFICATION:
When a Clique validator is arbitrating the canonical status between two different chain head blocks, they should choose the canonical block with the following ordered priorities. 1. Choose the block with the most total difficulty. 2. Then choose the block with the lowest block number. 3. Then choose the

MOTIVATION:
There has been more than one deadlock in the Goerli multi-client Clique network. The number of active validators was greater than 1/2 of the available validators so a chain halt should not have occurred. The halt was resolved by an inactive validator coming back on line. The state of

RATIONALE:
Two scenarios of a halted chain are known based on the current total difficulty then first observed rule. One of the scenarios is also resistant to the shortest chain rule. For the first scenario where chains of different lengths can halt consider a block with 8 validators, whose addresses


=== EIP-7745 ===
TITLE: Two dimensional log filter data structure
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-07-17
REQUIRES: 

SUMMARY:
Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio. The proposed structure maps all log entries onto a global linear log

SPECIFICATION:
### Terms and definitions - _log value_: either an _address value_ or a _topic value_. Each `LOG` opcode adds one _address value_ and 0..4 _topic values_. A _log value_ is represented by a 32 byte hash which is calculated as `SHA2(address)` or `SHA2(topic)` - _log index_: values are globally

MOTIVATION:
Bloom filters are only useful as long as they are sufficiently sparse. False positive ratio rises rapidly with the number of events per filter and the density of `1` bits in the filter bit vector. In the currently existing bloom filter each log address and topic sets 3 out

RATIONALE:
### Log index space In each block a varying number of _log values_ are emitted. In addition to inefficient search, another drawback of per-block fixed size bloom filters is the varying filter utilization leading to over-utilized filters giving many false positives in some blocks and/or wastefully under-utilized filters in


=== EIP-3322 ===
TITLE: Account gas storage opcodes
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2020-03-04
REQUIRES: 

SUMMARY:
Contracts can persist gas for later transfer to the refund counter. Three opcodes are introduced to read, add to, and use this gas counter.

SPECIFICATION:
Contract accounts gain an unsigned gas refund counter, initially zero. Three new opcodes are introduced to manage this state. * `SELFGAS` (`0x49`): Pushes the current account's gas refund counter onto the stack. Shares gas pricing with `SELFBALANCE`. * `USEGAS` (`0x4a`): Pops `amount` from the stack. The minimum of `amount`

MOTIVATION:
The refund mechanism is currently being used by gas tokens to arbitrage gas price. This brings gas supply elasticity and price stability by moving gas from blocks with less demand to blocks with more demand. Unfortunately this rewards unnecessary state growth. By introducing a superior gas storage mechanism, the

RATIONALE:
By reusing the execution context's refund counter we can reuse its 50% DoS protection, which limits its block elasticity contribution to 2x. The gas costs are based on similar opcodes `SELFBALANCE` and `SSTORE`. Most accounts will store no gas, so the per-account storage overhead should be minimal or even


=== EIP-2565 ===
TITLE: ModExp Gas Cost
TYPE: Standards Track Core
STATUS: Final
CREATED: 2020-03-20
REQUIRES: 198

SUMMARY:
To accurately reflect the real world operational cost of the `ModExp` precompile, this EIP specifies an algorithm for calculating the gas cost. This algorithm approximates the multiplication complexity cost and multiplies that by an approximation of the iterations required to execute the exponentiation.

SPECIFICATION:
As of `FORK_BLOCK_NUMBER`, the gas cost of calling the precompile at address `0x0000000000000000000000000000000000000005` will be calculated as follows: ``` def calculate_multiplication_complexity(base_length, modulus_length): max_length = max(base_length, modulus_length) words = math.ceil(max_length / 8) return words**2 def calculate_iteration_count(exponent_length, exponent): iteration_count = 0 if exponent_length <= 32 and exponent == 0: iteration_count =

MOTIVATION:
Modular exponentiation is a foundational arithmetic operation for many cryptographic functions including signatures, VDFs, SNARKs, accumulators, and more. Unfortunately, the ModExp precompile is currently over-priced, making these operations inefficient and expensive. By reducing the cost of this precompile, these cryptographic functions become more practical, enabling improved security, stronger randomness

RATIONALE:
After benchmarking the ModExp precompile, we discovered that it is ‘overpriced’ relative to other precompiles. We also discovered that the current gas pricing formula could be improved to better estimate the computational complexity of various ModExp input variables. The following changes improve the accuracy of the `ModExp` pricing: ###


=== EIP-3382 ===
TITLE: Hardcoded Block Gas Limit
TYPE: Standards Track Core
STATUS: Withdrawn
CREATED: 2021-03-13
REQUIRES: 

SUMMARY:
Updates the block validation rules such that a block is invalid if the `gas_limit` header field is not equal to `12,500,000`.

SPECIFICATION:
Refer to `gasLimit` as `gasTarget` post EIP-1559. ### Added Consensus Constraint As of `FORK_BLOCK_NUMBER`, the `header.gasLimit` **MUST** be equal to `BLOCK_GAS_LIMIT`, where `BLOCK_GAS_LIMIT` is a hardcoded constant set to `12,500,000`.

MOTIVATION:
Both Ethereum's Proof of Work and Proof of Stake designs assume that block producers are financially rational, but does not assume block producers to be benevolent. There is one exception however, and it is when block producers choose the gas limit of a block where it is assumed that

RATIONALE:
### Keeping gasLimit in Block Headers While it would be possible to remove the `gasLimit` field from block headers, it would change the data structure to be hashed, which could lead to unintended consequences. It is therefore easier to leave the gasLimit as part of block headers. ### Chosen


=== EIP-5749 ===
TITLE: The 'window.evmproviders' object
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2022-10-04
REQUIRES: 1193

SUMMARY:
A Javascript Ethereum Provider interface injection that will allow for the interoperability of multiple browser wallets at the same time. Replacing `window.ethereum` with `window.evmproviders` is a simple solution that will provide multiple benefits including: improving user experience, encouraging innovation in the space, removing race conditions and a 'winner-takes-most' environment

SPECIFICATION:
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. ### `window.evmproviders={}` ```typescript /** * Represents the assets needed to display a wallet */ interface ProviderInfo { /** * A

MOTIVATION:
At present, `window.ethereum` is the prevailing method by which Ethereum-compatible applications interact with injected wallets. This originated with Mist Wallet in 2015 to interact with other applications. With the proliferation of both applications and wallets, `window.ethereum` has unintended negative consequences: - `window.ethereum` only permits one wallet to be injected

RATIONALE:
Standardizing a `ProviderInfo` type allows determining the necessary information to populate a wallet selection popup. This is particularly useful for web3 onboarding libraries such as Web3Modal, Web3React, and Web3Onboard. The name `evmproviders` was chosen to include other EVM-compliant chains. The SVG image format was chosen for its flexibility, lightweight


=== EIP-2294 ===
TITLE: Explicit bound to Chain ID size
TYPE: Informational 
STATUS: Review
CREATED: 2019-09-19
REQUIRES: 155

SUMMARY:
This EIP informationally defines the "Safe Range" and "Max Range" of ChainId based on a few known restrictions such as [EIP-155](./eip-155.md) and major wallet and JsonPRC representation of ChainId.

SPECIFICATION:
We declared the following chainID range 1. (1, 2^31 - 1): "Safe Range", the higher bound is decided by Javascript number 2. (1, MAX_CHAIN_ID); "Max Range", in which `MAX_CHAIN_ID := floor(MAX_UINT64 / 2) - 36 = 9,223,372,036,854,775,771`:

MOTIVATION:
1. We want chainId to be safe across the different components of the ecosystem such as smart contract, wallet, dApp and JsonPRC etc. 2. We want to enable Cross-Chain function call 3. We want to ensure [EIP-712](./eip-712.md) domains have a clear definition of how to pack ChainID. 4. Enable

RATIONALE:
### Beyond "Max Range", the EIP-155 will overflow as discussed below The `MAX_CHAIN_ID` is calculated to avoid overflow when performing uint64 math. For reference, a value of 0 or less is also disallowed. Due to how the calculation for chain ID is performed, the maximum value seen during the


=== EIP-2537 ===
TITLE: Precompile for BLS12-381 curve operations
TYPE: Standards Track Core
STATUS: Review
CREATED: 2020-02-21
REQUIRES: 

SUMMARY:
Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification. Along with the curve arithmetic, multi-scalar-multiplication operations are included to efficiently aggregate public keys or individual signer's signatures during BLS signature verification.

SPECIFICATION:
### Constants | Name | Value | Comment | |---------------------|-------|--------------------| | `FORK_TIMESTAMP` | *TBD* | Mainnet | | BLS12_G1ADD | 0x0b | precompile address | | BLS12_G1MUL | 0x0c | precompile address | | BLS12_G1MSM | 0x0d | precompile address | | BLS12_G2ADD | 0x0e | precompile address |

MOTIVATION:
The motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security.

RATIONALE:
The motivation section covers a total motivation to have operations over the BLS12-381 curves available. We also extend a rationale for more specific fine points. ### MSM as a separate call Explicit separate MSM operation that allows one to save execution time (so gas) by both the algorithm used


=== EIP-7676 ===
TITLE: EOF - Prepare for Address Space Extension
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-04-03
REQUIRES: 3, 5, 4, 0, ,,  , 3, 6, 7, 0, ,,  , 7, 0, 6, 9

SUMMARY:
Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This EIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve bytes need to be zero or an exceptional halt is raised.

SPECIFICATION:
We introduce one new instruction: - `EXTBALANCE` (`tbd`) with arguments `(target_address)`, returning `balance` `EXTBALANCE` will pop one stack item off of the stack, the address of another account or contract. The balance of that account or contract will be pushed onto the stack. If `EXTBALANCE` is invoked with any

MOTIVATION:
There have been proposals to extend Ethereum Addresses from 160 bits to 256, such as one that would use the extra bits for state expiry (such as the ethereum magicians forum topic "Increasing the address size from 20 to 32 bytes"). One issue ground the work to a halt:

RATIONALE:
### New Opcode There is no need to ban the `BALANCE` opcode as it does not cause any problems that would require banning it within an EOF container. Adding a new opcode also allows the existing opcode to behave the same in EOF and legacy code, reducing potential friction


=== EIP-4399 ===
TITLE: Supplant DIFFICULTY opcode with PREVRANDAO
TYPE: Standards Track Core
STATUS: Final
CREATED: 2021-10-30
REQUIRES: 3675

SUMMARY:
This EIP supplants the semantics of the return value of existing `DIFFICULTY (0x44)` opcode and renames the opcode to `PREVRANDAO (0x44)`. The return value of the `DIFFICULTY (0x44)` instruction after this change is the output of the randomness beacon provided by the beacon chain.

SPECIFICATION:
### Definitions * **`TRANSITION_BLOCK`** The definition of this block can be found in the Definitions section of [EIP-3675](./eip-3675.md#definitions). ### Block structure Beginning with `TRANSITION_BLOCK`, client software **MUST** set the value of the `mixHash`, i.e. the field with the number `13` (0-indexed) in a block header, to the latest RANDAO

MOTIVATION:
Applications may benefit from using the randomness accumulated by the beacon chain. Thus, randomness outputs produced by the beacon chain should be accessible in the EVM. At the point of `TRANSITION_BLOCK` of the Proof-of-Stake (PoS) upgrade described in [EIP-3675](./eip-3675.md), the `difficulty` block field **MUST** be `0` thereafter because there

RATIONALE:
### Including RANDAO output in the block header Including a RANDAO output in the block header provides a straightforward method of accessing it from inside of the EVM as block header data is already available in the EVM context. Additionally, this ensures that the execution layer can be fully


=== EIP-100 ===
TITLE: Change difficulty adjustment to target mean block time including uncles
TYPE: Standards Track Core
STATUS: Final
CREATED: 2016-04-28
REQUIRES: 

SPECIFICATION:
Currently, the formula to compute the difficulty of a block includes the following logic: ``` python adj_factor = max(1 - ((timestamp - parent.timestamp) // 10), -99) child_diff = int(max(parent.difficulty + (parent.difficulty // BLOCK_DIFF_FACTOR) * adj_factor, min(parent.difficulty, MIN_DIFF))) ... ``` If `block.number >= BYZANTIUM_FORK_BLKNUM`, we change the first line to

RATIONALE:
This new formula ensures that the difficulty adjustment algorithm targets a constant average rate of blocks produced including uncles, and so ensures a highly predictable issuance rate that cannot be manipulated upward by manipulating the uncle rate. A formula that accounts for the exact number of included uncles: ```


=== EIP-7600 ===
TITLE: Hardfork Meta - Pectra
TYPE: Meta 
STATUS: Review
CREATED: 2024-01-18
REQUIRES: 2, 5, 3, 7, ,,  , 2, 9, 3, 5, ,,  , 6, 1, 1, 0, ,,  , 7, 0, 0, 2, ,,  , 7, 2, 5, 1, ,,  , 7, 5, 4, 9, ,,  , 7, 5, 9, 4, ,,  , 7, 6, 8, 5, ,,  , 7, 7, 0, 2, ,,  , 7, 7, 4, 2

SUMMARY:
This Meta EIP lists the EIPs formally Considered and Scheduled for Inclusion in the Prague/Electra network upgrade.

SPECIFICATION:
Definitions for `Scheduled for Inclusion` and `Considered for Inclusion` can be found in [EIP-7723](./eip-7723.md). ### EIPs Scheduled for Inclusion * [EIP-2537](./eip-2537.md): Precompile for BLS12-381 curve operations * [EIP-2935](./eip-2935.md): Save historical block hashes in state * [EIP-6110](./eip-6110.md): Supply validator deposits on chain * [EIP-7002](./eip-7002.md): Execution layer triggerable exits * [EIP-7251](./eip-7251.md):

RATIONALE:
This Meta EIP provides a global view of all changes included in the Prague/Electra network upgrade, as well as links to full specification.


=== EIP-7609 ===
TITLE: Decrease base cost of TLOAD/TSTORE
TYPE: Standards Track Core
STATUS: Draft
CREATED: 2024-02-01
REQUIRES: 1153

SUMMARY:
Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174. The gas cost for `TLOAD` is proposed to be 5 gas. The gas cost for

MOTIVATION:
[EIP-1153](./eip-1153.md) introduces a new storage region, termed "transient storage". It behaves like storage (word-addressed and persists between call frames), but unlike storage it is wiped at the end of each transaction. During development of EIP-1153, the pricing was set to be the same as warm storage loads and stores.

RATIONALE:
### Gas In benchmarking, `TLOAD` was found to cost a similar amount of CPU time as `MUL`, while `TSTORE` was found to cost about 1.5x that. The values `G_low` and `G_mid` were therefore chosen for `TLOAD` and `TSTORE`, respectively.


=== EIP-6051 ===
TITLE: Private Key Encapsulation
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2022-11-21
REQUIRES: 

SUMMARY:
This EIP proposes a mechanism to encapsulate a private key so that it could be securely relocated to another application without providing the seed. This EIP combines `ECIES` (Elliptic Curve Integrated Encryption Scheme) and optional signature verification under various choices to ensure that the private key is encapsulated for

SPECIFICATION:
### Sender and Recipient We hereby define: - *Sender* as the party who holds in custody the private key to be encapsulated; *Sender Application* as the client-side application that said *Sender* uses to send the encapsulated private key. - *Recipient* as the party who accepts the encapsulated private key,

MOTIVATION:
There are various cases in which we might want to export one of many private keys from a much more secure but less convenient wallet, which is controlled with a seed or passphrase. 1. We might dedicate one of many private keys for messaging purposes, and that private key

RATIONALE:
A critical difference between this [EIP-6051](./eip-6051.md) with [EIP-5630](./eip-5630.md) is that, as the purpose of key encapsulation is to transport a private key securely, the public key from the key recipient should be ephemeral, and mostly used only one-time. While in EIP-5630 settings, the public key of the message recipient


=== EIP-1803 ===
TITLE: Rename opcodes for clarity
TYPE: Standards Track Interface
STATUS: Stagnant
CREATED: 2017-07-28
REQUIRES: 141

SUMMARY:
Rename the `BALANCE`, `SHA3`, `NUMBER`, `GASLIMIT`, `GAS` and `INVALID` opcodes to reflect their true meaning.

SPECIFICATION:
Rename the opcodes as follows: - `BALANCE` (`0x31`) to `EXTBALANCE` to be in line with `EXTCODESIZE`, `EXTCODECOPY` and `EXTCODEHASH` - `SHA3` (`0x20`) to `KECCAK256` - `NUMBER` (`0x43`) to `BLOCKNUMBER` - `GASLIMIT` (`0x45`) to `BLOCKGASLIMIT` to avoid confusion with the gas limit of the transaction - `GAS` (`0x5a`) to `GASLEFT`


=== EIP-6916 ===
TITLE: Automatically Reset Testnet
TYPE: Standards Track Core
STATUS: Last Call
CREATED: 2023-04-10
REQUIRES: 

SUMMARY:
This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.

SPECIFICATION:
The testnet is set to always reset after a predefined time period. The reset means the generation of the next genesis, discarding the old one and starting a new network. This is possible by introducing functions for the genesis generation and the client reset. ### Genesis To connect to

MOTIVATION:
A testnet which automatically resets can provide an alternative environment for short-term testing of applications, validators and also breaking changes in client implementations. It avoids issues of long running testnets which suffer from state bloat, lack of testnet funds or consensus issues. Periodically resetting the network back to genesis

RATIONALE:
Ephemeral testnets with deterministic parameters provide a sustainable alternative to traditional testnets, with the same infrastructure. At each reset, the validator set is cleared, faucets are filled again and the database is kept small. Upon reset the whole state is purged, which, on the one hand keeps the network


=== EIP-5478 ===
TITLE: CREATE2COPY Opcode
TYPE: Standards Track Core
STATUS: Stagnant
CREATED: 2022-08-17
REQUIRES: 1, 0, 1, 4, ,,  , 2, 9, 2, 9

SUMMARY:
Adding a new opcode, `CREATE2COPY`, that is identical to `CREATE2` but with potentially much lower gas cost by accepting an additional argument `existing_contract_address` that already stored the code of the new contract.

SPECIFICATION:
### Parameters | Constant | Value | | ---------------------------- | ---------------- | | `FORK_BLKNUM` | TBD | | `CREATE_DATA_GAS_PER_BYTE` | 200 | | `COLD_ACCOUNT_ACCESS_COST` | 2600 | | `WARM_ACCOUNT_ACCESS_COST` | 100 | If `block.number >= FORK_BLKNUM`, a new opcode is added (`CREATE2COPY`) at `0xf6`, which takes 5 stack arguments:

MOTIVATION:
This EIP aims to reduce the smart contract creation cost of account abstraction (AA) contracts that have identical code. The major cost of creating an AA contract is the contract creation cost, especially data gas. For example, creating an AA contract with 10,000 bytes will consume 2,000,000 data gas.

RATIONALE:
TBD


=== EIP-5133 ===
TITLE: Delaying Difficulty Bomb to mid-September 2022
TYPE: Standards Track Core
STATUS: Final
CREATED: 2022-06-01
REQUIRES: 

SUMMARY:
Starting with `FORK_BLOCK_NUMBER` the client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.

SPECIFICATION:
#### Relax Difficulty with Fake Block Number For the purposes of `calc_difficulty`, simply replace the use of `block.number`, as used in the exponential ice age component, with the formula: ```py fake_block_number = max(0, block.number - 11_400_000) if block.number >= FORK_BLOCK_NUMBER else block.number ```

MOTIVATION:
To avoid network degradation due to a premature activation of the difficulty bomb.

RATIONALE:
The following script predicts the bomb will go off at block 15530314, which is expected to be mined around mid-September. ```python import math def predict_bomb_block(current_difficulty, diff_adjust_coeff, block_adjustment): ''' Predicts the block number at which the difficulty bomb will become noticeable. current_difficulty: the current difficulty diff_adjust_coeff: intuitively, the percent increase


=== EIP-2255 ===
TITLE: Wallet Permissions System
TYPE: Standards Track Interface
STATUS: Final
CREATED: 2019-08-22
REQUIRES: 1193

SUMMARY:
This EIP adds two new wallet-namespaced RPC endpoints, `wallet_getPermissions` and `wallet_requestPermissions`, providing a standard interface for requesting and checking permissions.

SPECIFICATION:
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. This proposal adds two new methods to a wallet's web3 provider API: `wallet_getPermissions` and `wallet_requestPermissions`. ### `wallet_getPermissions` The `wallet_getPermissions` method

MOTIVATION:
Wallets are responsible for mediating interactions between untrusted applications and users' keys through appropriate user consent. Today, wallets always prompt the user for every action. This provides security at the cost of substantial user friction. We believe that a single permissions request can achieve the same level of security

RATIONALE:
While the current model of getting user consent on a per-action basis has high security, there are huge usability gains to be had bo getting more general user consent which can cover broad categories of usage, which can be expressed in a more human-readable way. This pattern has a
